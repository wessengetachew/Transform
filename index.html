
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Primitive Lattice Point Theory</title>
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        :root {
            --bg: #1a1a1a; --bg2: #2d2d2d; --bg3: #3a3a3a; --text: #e0e0e0; --text2: #b0b0b0;
            --border: #4a4a4a; --blue: #0066cc; --purple: #6f42c1; --green: #28a745; --red: #dc3545;
            --yellow: #ffc107; --orange: #fd7e14;
        }
        body.light { --bg: #fff; --bg2: #f8f9fa; --bg3: #e9ecef; --text: #212529; --text2: #495057; --border: #dee2e6; }
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: system-ui; background: var(--bg); color: var(--text); line-height: 1.6; transition: background 0.3s, color 0.3s; }
        .container { max-width: 1400px; margin: 0 auto; padding: 20px; }
        .header { text-align: center; padding: 40px 20px; background: linear-gradient(135deg, var(--blue), var(--purple));
            color: white; border-radius: 12px; margin-bottom: 30px; position: relative; overflow: hidden; }
        .header::before { content: ''; position: absolute; top: -50%; left: -50%; width: 200%; height: 200%;
            background: radial-gradient(circle, rgba(255,255,255,0.1) 0%, transparent 70%); animation: pulse 4s infinite; }
        @keyframes pulse { 0%, 100% { transform: scale(1); } 50% { transform: scale(1.1); } }
        .header h1 { font-size: 2.5rem; margin-bottom: 10px; position: relative; z-index: 1; }
        .header p { position: relative; z-index: 1; }
        .tabs { display: flex; gap: 5px; margin-bottom: 30px; background: var(--bg2); padding: 10px; border-radius: 12px; flex-wrap: wrap; }
        .tab-btn { flex: 1; min-width: 120px; padding: 12px 20px; border: none; background: var(--bg3); color: var(--text);
            cursor: pointer; border-radius: 8px; font-weight: 600; transition: all 0.3s; }
        .tab-btn:hover { background: var(--blue); color: white; transform: translateY(-2px); }
        .tab-btn.active { background: var(--blue); color: white; box-shadow: 0 4px 12px rgba(0,102,204,0.3); }
        .controls button.active { background: var(--purple); }
        select { font-size: 1em; }
        .panel { display: none; animation: fadeIn 0.5s; }
        .panel.active { display: block; }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }
        .section { background: var(--bg2); padding: 30px; border-radius: 12px; margin-bottom: 30px; transition: all 0.3s; }
        .section:hover { box-shadow: 0 4px 20px rgba(0,0,0,0.1); }
        .section h2 { color: var(--blue); margin-bottom: 20px; display: flex; align-items: center; gap: 10px; }
        .help-icon { display: inline-block; width: 20px; height: 20px; background: var(--blue); color: white;
            border-radius: 50%; text-align: center; line-height: 20px; font-size: 12px; cursor: help; }
        .tooltip { position: relative; }
        .tooltip:hover::after { content: attr(data-tip); position: absolute; bottom: 125%; left: 50%;
            transform: translateX(-50%); padding: 8px 12px; background: var(--text); color: var(--bg);
            border-radius: 6px; white-space: nowrap; z-index: 1000; font-size: 12px; }
        .controls { margin: 20px 0; padding: 20px; background: var(--bg3); border-radius: 8px; }
        .controls label { display: block; margin: 10px 0; font-weight: 600; }
        .controls input[type="range"] { width: 100%; }
        .controls button { padding: 10px 20px; background: var(--blue); color: white; border: none;
            border-radius: 6px; cursor: pointer; margin: 5px; transition: all 0.3s; }
        .controls button:hover { background: var(--purple); transform: scale(1.05); }
        .controls button:disabled { background: var(--text2); cursor: not-allowed; transform: none; }
        .stats { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; margin: 20px 0; }
        .stat { background: var(--bg3); padding: 20px; border-radius: 8px; text-align: center; transition: all 0.3s; }
        .stat:hover { transform: translateY(-5px); box-shadow: 0 4px 12px rgba(0,0,0,0.15); }
        .stat .val { font-size: 2rem; font-weight: bold; color: var(--blue); transition: all 0.5s; }
        .stat .lbl { font-size: 0.9rem; color: var(--text2); }
        canvas { border: 2px solid var(--border); border-radius: 8px; display: block; margin: 20px auto; max-width: 100%; }
        #canvas3d, #c3d { width: 100%; height: 800px; cursor: grab; }
        #canvas3d:active, #c3d:active { cursor: grabbing; }
        table { width: 100%; border-collapse: collapse; margin: 20px 0; overflow-x: auto; display: block; }
        th, td { padding: 12px; text-align: left; border-bottom: 1px solid var(--border); }
        th { background: var(--bg3); color: var(--blue); font-weight: 600; position: sticky; top: 0; }
        .btn-fixed { position: fixed; bottom: 20px; padding: 12px 24px; border: none; border-radius: 25px;
            cursor: pointer; font-weight: 600; z-index: 1000; color: white; transition: all 0.3s; }
        .btn-fixed:hover { transform: translateY(-3px); box-shadow: 0 6px 20px rgba(0,0,0,0.3); }
        #darkBtn { right: 20px; background: var(--blue); }
        #helpBtn { right: 140px; background: var(--green); }
        .formula { background: var(--bg3); padding: 20px; border-left: 4px solid var(--blue); border-radius: 8px; margin: 20px 0; }
        .warning { background: #3d3106; color: #ffc107; padding: 15px; border-left: 4px solid var(--yellow); border-radius: 8px; margin: 20px 0; }
        body.light .warning { background: #fff3cd; color: #856404; }
        .loading { display: none; text-align: center; padding: 20px; }
        .loading.active { display: block; }
        .spinner { border: 4px solid var(--border); border-top: 4px solid var(--blue); border-radius: 50%;
            width: 40px; height: 40px; animation: spin 1s linear infinite; margin: 20px auto; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        .compare-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 20px; }
        .compare-item { background: var(--bg3); padding: 15px; border-radius: 8px; }
        .modal { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7);
            z-index: 2000; align-items: center; justify-content: center; }
        .modal.active { display: flex; }
        .modal-content { background: var(--bg); padding: 30px; border-radius: 12px; max-width: 600px; max-height: 80vh;
            overflow-y: auto; position: relative; }
        .modal-close { position: absolute; top: 10px; right: 10px; font-size: 24px; cursor: pointer; color: var(--text2); }
        .export-buttons { display: flex; gap: 10px; flex-wrap: wrap; }
        .data-table-container { max-height: 400px; overflow-y: auto; }
        .point-info-active { background: var(--bg3) !important; border: 2px solid var(--blue); animation: highlightPulse 0.5s ease; }
        @keyframes highlightPulse { 0%, 100% { transform: scale(1); } 50% { transform: scale(1.02); } }
        @media (max-width: 768px) {
            .header h1 { font-size: 1.8rem; }
            .tabs { flex-direction: column; }
            .tab-btn { min-width: 100%; }
            #canvas3d, #c3d { height: 500px; }
            .btn-fixed { padding: 10px 16px; font-size: 14px; }
            #helpBtn { right: 20px; bottom: 70px; }
        }
    </style>
</head>
<body>
    <div class="container">
        <header class="header">
            <h1>Primitive Lattice Point Theory</h1>
            <p>A Computational Framework for Boundary Cancellation Analysis</p>
            <p style="margin-top:10px; font-size:0.9rem">By Wessen Getachew | <a href="https://twitter.com/7dview" style="color:white">@7dview</a></p>
        </header>

        <nav class="tabs">
            <button class="tab-btn active" onclick="showTab('theory')">Theory</button>
            <button class="tab-btn" onclick="showTab('presets')">Presets</button>
            <button class="tab-btn" onclick="showTab('patterns')">Pattern Explorer</button>
            <button class="tab-btn" onclick="showTab('gcdheatmap')">GCD Heatmap</button>
            <button class="tab-btn" onclick="showTab('gcdtable')">GCD Table</button>
            <button class="tab-btn" onclick="showTab('criticalstrip')">Critical Strip</button>
            <button class="tab-btn" onclick="showTab('viz2d')">2D Viz</button>
            <button class="tab-btn" onclick="showTab('viz3d')">3D Viz</button>
            <button class="tab-btn" onclick="showTab('comparison')">Compare</button>
            <button class="tab-btn" onclick="showTab('analysis')">Analysis</button>
            <button class="tab-btn" onclick="showTab('animation')">Animation üé¨</button>
            <button class="tab-btn" onclick="showTab('tools')">Tools</button>
            <button class="tab-btn" onclick="showTab('explore')">Explore More</button>
            <button class="tab-btn" onclick="showTab('export')">Export</button>
            <button class="tab-btn" onclick="showTab('farey')">Farey Sequences</button>
            <button class="tab-btn" onclick="showTab('session')">Save/Load</button>
            <button class="tab-btn" onclick="showTab('derivation')">Derivation</button>
        </nav>
        
        <div id="presets" class="panel">
            <div class="section">
                <h2>Mathematical Presets <span class="help-icon tooltip" data-tip="Pre-configured significant cases">?</span></h2>
                <p>Explore mathematically sit radii, dimensions, and configurations. Each preset demonstrates important number-theoretic properties.</p>
                
                <h3 style="color:var(--blue); margin-top:30px;">Classic Results</h3>
                <div class="compare-grid">
                    <div class="compare-item">
                        <h4 style="color:var(--blue);">Basel Problem (k=2, R=10)</h4>
                        <p style="margin:10px 0;">Density 6/œÄ¬≤ ‚âà 0.6079</p>
                        <p style="font-size:0.9em; color:var(--text2);">Euler's solution to Œ∂(2) = œÄ¬≤/6. Shows fundamental coprime probability.</p>
                        <button onclick="applyPreset('basel')" style="margin-top:10px; padding:8px 16px;">Apply Preset</button>
                    </div>
                    
                    <div class="compare-item">
                        <h4 style="color:var(--blue);">Ap√©ry's Constant (k=3, R=20)</h4>
                        <p style="margin:10px 0;">Œ∂(3) ‚âà 1.202, Density ‚âà 0.832</p>
                        <p style="font-size:0.9em; color:var(--text2);">3D primitive point density. Ap√©ry proved Œ∂(3) is irrational.</p>
                        <button onclick="applyPreset('apery')" style="margin-top:10px; padding:8px 16px;">Apply Preset</button>
                    </div>
                    
                    <div class="compare-item">
                        <h4 style="color:var(--blue);">Gauss Circle (R=100)</h4>
                        <p style="margin:10px 0;">Error Œî(R) = O(R^(2/3))</p>
                        <p style="font-size:0.9em; color:var(--text2);">Classic lattice point problem. Connected to Riemann Hypothesis.</p>
                        <button onclick="applyPreset('gauss')" style="margin-top:10px; padding:8px 16px;">Apply Preset</button>
                    </div>
                </div>
                
                <h3 style="color:var(--green); margin-top:30px;">Special Radii</h3>
                <div class="compare-grid">
                    <div class="compare-item">
                        <h4 style="color:var(--green);">Fibonacci F‚ÇÅ‚ÇÅ (R=89)</h4>
                        <p style="margin:10px 0;">89th Fibonacci number (prime)</p>
                        <p style="font-size:0.9em; color:var(--text2);">Intersection of Fibonacci sequence and primes.</p>
                        <button onclick="applyPreset('fibonacci')" style="margin-top:10px; padding:8px 16px;">Apply Preset</button>
                    </div>
                    
                    <div class="compare-item">
                        <h4 style="color:var(--green);">Mersenne M‚ÇÖ (R=31)</h4>
                        <p style="margin:10px 0;">2‚Åµ - 1 = 31 (prime)</p>
                        <p style="font-size:0.9em; color:var(--text2);">Mersenne prime. Related to perfect numbers.</p>
                        <button onclick="applyPreset('mersenne')" style="margin-top:10px; padding:8px 16px;">Apply Preset</button>
                    </div>
                    
                    <div class="compare-item">
                        <h4 style="color:var(--green);">Perfect Number (R=28)</h4>
                        <p style="margin:10px 0;">28 = 1+2+4+7+14</p>
                        <p style="font-size:0.9em; color:var(--text2);">Second perfect number. Sum of divisors equals 2√ó28.</p>
                        <button onclick="applyPreset('perfect')" style="margin-top:10px; padding:8px 16px;">Apply Preset</button>
                    </div>
                    
                    <div class="compare-item">
                        <h4 style="color:var(--green);">Golden Ratio œÜ (R‚âà161)</h4>
                        <p style="margin:10px 0;">R ‚âà 100œÜ ‚âà 161.8</p>
                        <p style="font-size:0.9em; color:var(--text2);">Golden ratio approximation. Appears in Fibonacci spirals.</p>
                        <button onclick="applyPreset('golden')" style="margin-top:10px; padding:8px 16px;">Apply Preset</button>
                    </div>
                </div>
                
                <h3 style="color:var(--purple); margin-top:30px;">High Dimensions</h3>
                <div class="compare-grid">
                    <div class="compare-item">
                        <h4 style="color:var(--purple);">4D Hypersphere (k=4, R=15)</h4>
                        <p style="margin:10px 0;">Density ‚âà 0.924</p>
                        <p style="font-size:0.9em; color:var(--text2);">Four-dimensional sphere. Most points are primitive.</p>
                        <button onclick="applyPreset('4d')" style="margin-top:10px; padding:8px 16px;">Apply Preset</button>
                    </div>
                    
                    <div class="compare-item">
                        <h4 style="color:var(--purple);">8D E‚Çà Lattice (k=8, R=10)</h4>
                        <p style="margin:10px 0;">Density ‚âà 0.996</p>
                        <p style="font-size:0.9em; color:var(--text2);">Related to E‚Çà exceptional Lie group. Nearly all points primitive.</p>
                        <button onclick="applyPreset('e8')" style="margin-top:10px; padding:8px 16px;">Apply Preset</button>
                    </div>
                    
                    <div class="compare-item">
                        <h4 style="color:var(--purple);">High-D Limit (k=12, R=5)</h4>
                        <p style="margin:10px 0;">Density ‚âà 0.9998</p>
                        <p style="font-size:0.9em; color:var(--text2);">As k‚Üí‚àû, density‚Üí1. Almost all points are primitive.</p>
                        <button onclick="applyPreset('highdim')" style="margin-top:10px; padding:8px 16px;">Apply Preset</button>
                    </div>
                </div>
                
                <h3 style="color:var(--orange); margin-top:30px;">Pattern Exploration</h3>
                <div class="compare-grid">
                    <div class="compare-item">
                        <h4 style="color:var(--orange);">Highly Composite (m=12)</h4>
                        <p style="margin:10px 0;">œÜ(12) = 4, modular patterns</p>
                        <p style="font-size:0.9em; color:var(--text2);">Rich divisor structure (2¬≤√ó3). Patterns mod 12.</p>
                        <button onclick="applyPreset('composite')" style="margin-top:10px; padding:8px 16px;">Apply Preset</button>
                    </div>
                    
                    <div class="compare-item">
                        <h4 style="color:var(--orange);">Prime Field (p=17)</h4>
                        <p style="margin:10px 0;">Forms field ‚Ñ§/17‚Ñ§</p>
                        <p style="font-size:0.9em; color:var(--text2);">All non-zero elements invertible. Field structure.</p>
                        <button onclick="applyPreset('primefield')" style="margin-top:10px; padding:8px 16px;">Apply Preset</button>
                    </div>
                    
                    <div class="compare-item">
                        <h4 style="color:var(--orange);">Power of 2 (R=64)</h4>
                        <p style="margin:10px 0;">64 = 2‚Å∂, binary structure</p>
                        <p style="font-size:0.9em; color:var(--text2);">Pure power of 2. Dyadic patterns visible.</p>
                        <button onclick="applyPreset('power2')" style="margin-top:10px; padding:8px 16px;">Apply Preset</button>
                    </div>
                </div>
            </div>
        </div>

        <div id="theory" class="panel active">
            <div class="section">
                <h2>Abstract</h2>
                <p>We develop a comprehensive study of primitive lattice points in Z^n, generalizing the classical 2-dimensional coprime lattice problem. Using geometric decomposition into primitive rays and the M√∂bius inversion formula, we rigorously derive the asymptotic density of coprime points in any dimension. The framework connects number theory, geometry of numbers, and classical constants like the Riemann zeta function, providing both intuition and formal proofs.</p>
            </div>
            
            <div class="section">
                <h2>Introduction</h2>
                <p>Counting lattice points inside a ball is a classical problem in number theory. Restricting to <i>primitive points</i>, i.e., points with coordinates coprime, leads to deep insights in analytic number theory and the geometry of numbers. In two dimensions, this relates to the Basel problem (Œ∂(2) = œÄ¬≤/6) and visible points from the origin. We extend the problem to arbitrary dimensions, n ‚â• 2, developing both geometric intuition and rigorous algebraic derivation.</p>
            </div>
            
            <div class="section">
                <h2>Primitive Vectors and Rays in Z^n</h2>
                
                <div class="formula">
                    <h3 style="color:var(--blue); margin-bottom:10px;">Definition (Primitive Vector)</h3>
                    <p>A vector <b>v</b> = (a‚ÇÅ, ..., a‚Çô) ‚àà Z^n \ {0} is called <i>primitive</i> if</p>
                    $$\gcd(a_1, \dots, a_n) = 1$$
                </div>
                
                <div class="formula">
                    <h3 style="color:var(--blue); margin-bottom:10px;">Lemma (Unique Ray Decomposition)</h3>
                    <p>Every nonzero lattice point <b>v</b> ‚àà Z^n lies on a unique primitive ray:</p>
                    $$\mathbf{v} = k \mathbf{u}, \quad k \in \mathbb{N}, \ \mathbf{u} \text{ primitive}$$
                </div>
                
                <div class="formula">
                    <h3 style="color:var(--blue); margin-bottom:10px;">Proof</h3>
                    <p>Let d = gcd(a‚ÇÅ, ..., a‚Çô). Then <b>v</b> = d<b>u</b>, where <b>u</b> is primitive. Uniqueness follows from the uniqueness of the gcd.</p>
                    <p style="margin-top:10px; font-style:italic;">Each primitive vector acts as the "gatekeeper" for the entire ray of lattice points extending from the origin.</p>
                </div>
            </div>
            
            <div class="section">
                <h2>Counting Coprime Lattice Points</h2>
                <p>Let C_n(R) denote the number of primitive points inside the n-dimensional ball of radius R:</p>
                <div class="formula">$$C_n(R) = \#\{\mathbf{v} \in \mathbb{Z}^n : \|\mathbf{v}\|_2 \le R, \ \gcd(v_1,\dots,v_n)=1\}$$</div>
                
                <h3>Geometric Consideration</h3>
                <p>For a primitive vector <b>u</b>, the lattice points along its ray are</p>
                <div class="formula">$$\mathbf{v} = k \mathbf{u}, \quad 1 \le k \le \left\lfloor \frac{R}{\|\mathbf{u}\|_2} \right\rfloor$$</div>
                <p>Counting only the first point on each ray yields exactly C_n(R).</p>
                
                <h3>Asymptotic Density</h3>
                <p>The density of primitive points in Z^n equals the probability that n integers are coprime:</p>
                <div class="formula">$$\mathbb{P}(\gcd(a_1,\dots,a_n) = 1) = \frac{1}{\zeta(n)}$$</div>
                <p>Thus, the leading term for C_n(R) is</p>
                <div class="formula">$$C_n(R) \sim \frac{\operatorname{Vol}(B_n(R))}{\zeta(n)}$$</div>
                <p>where</p>
                <div class="formula">$$\operatorname{Vol}(B_n(R)) = \frac{\pi^{n/2}}{\Gamma(n/2+1)} R^n$$</div>
                <p>is the n-dimensional ball volume. The error term arises from the boundary: O(R^(n-1)).</p>
            </div>
            
            <div class="section">
                <h2>Boundary Cancellation Principle</h2>
                <p>The key insight is that non-primitive points (those sharing a common factor d > 1) can be expressed as d¬∑(primitive point). Through M√∂bius inversion, we show that boundary contributions from non-primitive points cancel systematically, leaving only the volume term divided by Œ∂(k).</p>
                <div class="formula">$$N_k(R) = \sum_{d=1}^{R} \mu(d) \cdot |\{(x_1,...,x_k) : \sum x_i^2 \leq (R/d)^2\}|$$</div>
                <p style="margin-top:15px">The M√∂bius function Œº(d) = (-1)^œâ(d) for square-free d (where œâ counts distinct prime factors) ensures alternating cancellation of boundary terms.</p>
            </div>
            
            <div class="section" style="background:linear-gradient(135deg, rgba(0,102,204,0.1), rgba(111,66,193,0.1)); border:3px solid var(--blue);">
                <h2 style="text-align:center; color:var(--blue);">Grand Result</h2>
                <div class="formula" style="font-size:1.2em; text-align:center; padding:20px;">
                    $$C_n(R) = \frac{\operatorname{Vol}(B_n(R))}{\zeta(n)} + O(R^{n-1}), \quad n \ge 2$$
                </div>
                <p style="text-align:center; font-style:italic; margin-top:15px;">This combines geometric intuition, rigorous number theory, and multi-dimensional generalization. It provides a unified framework for analyzing primitive lattice points in any dimension.</p>
            </div>
            
            <div class="section">
                <h2>Special Cases</h2>
                <div class="formula">
                    <p><b>Case n=1:</b> Only primitive points are ¬±1. Œ∂(1) diverges; density is zero.</p>
                </div>
                <div class="formula">
                    <p><b>2D Case (Classical):</b> Density: 1/Œ∂(2) = 6/œÄ¬≤ ‚âà 0.6079. Corresponds to "visible" points in the plane.</p>
                </div>
                <div class="formula">
                    <p><b>3D Case:</b> Density: 1/Œ∂(3) ‚âà 0.832. Visualization: "particles in space," approximately 83% visible from the origin.</p>
                </div>
                <div class="formula">
                    <p><b>High Dimensions:</b> As n ‚Üí ‚àû, Œ∂(n) ‚Üí 1, so almost all points are primitive.</p>
                </div>
            </div>
            
            <div class="section">
                <h2>Geometric Interpretation</h2>
                <ul style="list-style-position: inside; margin-left:20px;">
                    <li>Primitive points correspond to points "visible" from the origin.</li>
                    <li>Non-primitive points are hidden behind their corresponding primitive vector.</li>
                    <li>This generalizes the 2D "light ray" visualization to higher dimensions.</li>
                    <li>Each primitive vector acts as a "gatekeeper" for its entire ray of multiples.</li>
                </ul>
            </div>

            <div class="section">
                <h2>Interactive Explorer <span class="help-icon tooltip" data-tip="Adjust parameters to see predictions">?</span></h2>
                <div class="controls">
                    <label>Dimension k: <span id="tk">3</span></label>
                    <input type="range" id="tks" min="2" max="12" value="3" oninput="updateTheory()">
                    <label>Radius R: <span id="tr">50</span></label>
                    <input type="range" id="trs" min="10" max="200" value="50" step="10" oninput="updateTheory()">
                    <button onclick="exportTheoryData()">Export Data</button>
                </div>
                <div class="stats">
                    <div class="stat"><div class="val" id="sz">1.202</div><div class="lbl">Œ∂(k)</div></div>
                    <div class="stat"><div class="val" id="sp">4186</div><div class="lbl">Predicted N_k(R)</div></div>
                    <div class="stat"><div class="val" id="sd">0.832</div><div class="lbl">Density (1/Œ∂(k))</div></div>
                    <div class="stat"><div class="val" id="svol">523.6</div><div class="lbl">Sphere Volume</div></div>
                </div>
                <div style="background:var(--bg3); padding:10px; border-radius:6px; margin:10px 0; text-align:center;">
                    <p style="font-size:0.9em; color:var(--text2);">
                        <b>Precision:</b> <span id="currentPrecision">6</span> decimal places (k > 6 shows up to 17 decimals)
                    </p>
                </div>
                <div class="data-table-container">
                    <table><thead><tr><th>k</th><th>Œ∂(k)</th><th>1/Œ∂(k)</th><th>V_k (unit sphere)</th></tr></thead><tbody id="tbl"></tbody></table>
                </div>
            </div>
            
            <div class="section">
                <h2>Connections to Classical Problems</h2>
                
                <h3>Basel Problem</h3>
                <div class="formula">
                    <p>The 2D case directly connects to Euler's solution of the Basel problem:</p>
                    $$\zeta(2) = 1 + \frac{1}{4} + \frac{1}{9} + \frac{1}{16} + \cdots = \frac{\pi^2}{6}$$
                    <p style="margin-top:10px;">Thus the density of primitive points in Z¬≤ is exactly 6/œÄ¬≤.</p>
                </div>
                
                <h3>Visible Lattice Points</h3>
                <div class="formula">
                    <p>A lattice point (a, b) is visible from the origin if and only if gcd(a,b) = 1. The number of visible points in a circle of radius R is asymptotically:</p>
                    $$V(R) \sim \frac{6}{\pi^2} \cdot \pi R^2 = \frac{6R^2}{\pi}$$
                </div>
                
                <h3>Farey Sequences</h3>
                <div class="formula">
                    <p>Primitive lattice points in 2D correspond to reduced fractions. The Farey sequence F_n contains all fractions p/q in lowest terms with 0 ‚â§ p ‚â§ q ‚â§ n. The number of terms in F_n is:</p>
                    $$|F_n| = 1 + \sum_{k=1}^{n} \phi(k)$$
                    <p style="margin-top:10px;">where œÜ(k) is Euler's totient function, which counts integers coprime to k.</p>
                </div>
            </div>
            
            <div class="section">
                <h2>Advanced Topics</h2>
                
                <h3>M√∂bius Inversion Formula</h3>
                <div class="formula">
                    <p>The M√∂bius function Œº(n) is defined as:</p>
                    $$\mu(n) = \begin{cases} 
                    1 & \text{if } n = 1 \\
                    (-1)^k & \text{if } n \text{ is a product of } k \text{ distinct primes} \\
                    0 & \text{if } n \text{ has a squared prime factor}
                    \end{cases}$$
                    <p style="margin-top:10px;">The key property for our application:</p>
                    $$\sum_{d|n} \mu(d) = \begin{cases} 1 & \text{if } n=1 \\ 0 & \text{if } n>1 \end{cases}$$
                </div>
                
                <h3>Error Term Analysis</h3>
                <div class="formula">
                    <p>The error term O(R^(n-1)) can be understood as arising from the boundary of the ball. More precisely:</p>
                    $$C_n(R) = \frac{\operatorname{Vol}(B_n(R))}{\zeta(n)} + E_n(R)$$
                    <p style="margin-top:10px;">where |E_n(R)| ‚â§ C ¬∑ R^(n-1) for some constant C depending on n.</p>
                    <p style="margin-top:10px;">This error reflects the discrete nature of the lattice versus the continuous ball boundary.</p>
                </div>
            </div>
        </div>

        <div id="patterns" class="panel">
            <div class="section">
                <h2>Pattern Explorer <span class="help-icon tooltip" data-tip="Discover patterns in primitive lattice points">?</span></h2>
                <p>Explore mathematical patterns and structures within primitive lattice point distributions. Interactive tools reveal modular patterns, density variations, and symmetry properties.</p>
                
                <div class="controls">
                    <label><b>Select Pattern Type:</b></label>
                    <div style="display:grid; grid-template-columns: repeat(auto-fit, minmax(180px, 1fr)); gap:10px; margin:15px 0;">
                        <button id="patternModular" class="active" onclick="setPatternType('modular')" style="padding:12px;">Modular Residue Classes</button>
                        <button id="patternDensity" onclick="setPatternType('density')" style="padding:12px;">Density Distribution</button>
                        <button id="patternAngular" onclick="setPatternType('angular')" style="padding:12px;">Angular Distribution</button>
                        <button id="patternRadial" onclick="setPatternType('radial')" style="padding:12px;">Radial Shells</button>
                    </div>
                    
                    <div id="modularPatternControls">
                        <div style="background:var(--bg3); padding:20px; border-radius:8px; margin:15px 0;">
                            <h3 style="color:var(--blue); margin-bottom:15px;">Modular Arithmetic Patterns</h3>
                            <p style="margin-bottom:15px;">Analyze how primitive points distribute across residue classes modulo m. This reveals deep connections between coprimality and modular arithmetic.</p>
                            
                            <label>Modulus m: <span id="patternModv">7</span></label>
                            <input type="range" id="patternMod" min="2" max="20" value="7" step="1" oninput="updatePatternViz()">
                            
                            <label style="margin-top:15px;">Radius R: <span id="patternRv">30</span></label>
                            <div style="display:flex; gap:10px; align-items:center;">
                                <input type="range" id="patternR" min="10" max="100" value="30" step="5" oninput="document.getElementById('patternRv').textContent=this.value; document.getElementById('patternRInput').value=this.value;" style="flex:1;">
                                <input type="number" id="patternRInput" min="10" max="200" value="30" style="width:80px; padding:8px;" oninput="document.getElementById('patternRv').textContent=this.value; document.getElementById('patternR').value=Math.min(this.value,100);">
                            </div>
                            
                            <div style="margin-top:15px;">
                                <label><input type="checkbox" id="showExpected" checked onchange="updatePatternViz()"> Show Expected Distribution</label>
                            </div>
                        </div>
                        
                        <div style="margin:20px 0;">
                            <button onclick="updatePatternViz()" style="padding:12px 24px;">Compute Pattern</button>
                            <button onclick="exportPatternData()" style="padding:12px 24px;">Export Data</button>
                        </div>
                        
                        <canvas id="patternCanvas" width="1000" height="600" style="max-width:100%;"></canvas>
                        
                        <div class="stats" id="patternStats" style="margin-top:20px;"></div>
                        
                        <div class="formula" style="margin-top:20px;">
                            <p><b>Theoretical Background:</b></p>
                            <p>For modulus m and primitive points with gcd(x,y) = 1, the distribution across residue classes (x+y) mod m reveals patterns related to Euler's totient function œÜ(m). Residue classes coprime to m tend to have higher concentrations of primitive points.</p>
                        </div>
                    </div>
                    
                    <div id="densityPatternControls" style="display:none;">
                        <div style="background:var(--bg3); padding:20px; border-radius:8px; margin:15px 0;">
                            <h3 style="color:var(--blue); margin-bottom:15px;">Density Distribution Analysis</h3>
                            <p style="margin-bottom:15px;">Examine how the density of primitive points varies across different regions of the lattice.</p>
                            
                            <label>Grid Size: <span id="gridSizev">10</span></label>
                            <div style="display:flex; gap:10px; align-items:center; margin-bottom:15px;">
                                <input type="range" id="gridSize" min="5" max="50" value="10" step="1" oninput="updateGridSize()" style="flex:1;">
                                <input type="number" id="gridSizeInput" min="5" max="100" value="10" style="width:100px; padding:8px;" oninput="updateGridSize()">
                            </div>
                            
                            <label style="margin-top:15px;">Max Radius: <span id="densityRv">50</span></label>
                            <div style="display:flex; gap:10px; align-items:center; margin-bottom:15px;">
                                <input type="range" id="densityR" min="20" max="200" value="50" step="5" oninput="updateDensityR()" style="flex:1;">
                                <input type="number" id="densityRInput" min="20" max="500" value="50" step="5" style="width:100px; padding:8px;" oninput="updateDensityR()">
                            </div>
                        </div>
                        
                        <button onclick="updatePatternViz()" style="padding:12px 24px; margin:10px 0;">Compute Density Map</button>
                        
                        <canvas id="densityCanvas" width="800" height="800" style="max-width:100%;"></canvas>
                        
                        <div class="formula" style="margin-top:20px;">
                            <p><b>Observation:</b> Density approaches 1/Œ∂(2) ‚âà 60.79% uniformly as radius increases, confirming the asymptotic formula.</p>
                        </div>
                    </div>
                    
                    <div id="angularPatternControls" style="display:none;">
                        <div style="background:var(--bg3); padding:20px; border-radius:8px; margin:15px 0;">
                            <h3 style="color:var(--blue); margin-bottom:15px;">Angular Distribution</h3>
                            <p style="margin-bottom:15px;">How are primitive points distributed by angle around the origin?</p>
                            
                            <label>Number of Sectors: <span id="numSectorsv">16</span></label>
                            <input type="range" id="numSectors" min="4" max="32" value="16" step="1" oninput="updatePatternViz()">
                            
                            <label style="margin-top:15px;">Radius: <span id="angularRv">40</span></label>
                            <div style="display:flex; gap:10px; align-items:center;">
                                <input type="range" id="angularR" min="10" max="100" value="40" step="5" oninput="document.getElementById('angularRv').textContent=this.value; document.getElementById('angularRInput').value=this.value;" style="flex:1;">
                                <input type="number" id="angularRInput" min="10" max="200" value="40" style="width:80px; padding:8px;" oninput="document.getElementById('angularRv').textContent=this.value; document.getElementById('angularR').value=Math.min(this.value,100);">
                            </div>
                        </div>
                        
                        <button onclick="updatePatternViz()" style="padding:12px 24px; margin:10px 0;">Analyze Angular Distribution</button>
                        
                        <canvas id="angularCanvas" width="1000" height="600" style="max-width:100%;"></canvas>
                        
                        <div class="formula" style="margin-top:20px;">
                            <p><b>Expected Result:</b> For large R, angular distribution should be approximately uniform, with each sector containing roughly (total primitive points) / (number of sectors).</p>
                        </div>
                    </div>
                    
                    <div id="radialPatternControls" style="display:none;">
                        <div style="background:var(--bg3); padding:20px; border-radius:8px; margin:15px 0;">
                            <h3 style="color:var(--blue); margin-bottom:15px;">Radial Shell Analysis</h3>
                            <p style="margin-bottom:15px;">Count primitive points in concentric shells to observe growth patterns.</p>
                            
                            <label>Shell Thickness: <span id="shellThickv">2</span></label>
                            <input type="range" id="shellThick" min="1" max="10" value="2" step="1" oninput="updatePatternViz()">
                            
                            <label style="margin-top:15px;">Maximum Radius: <span id="radialMaxRv">60</span></label>
                            <div style="display:flex; gap:10px; align-items:center;">
                                <input type="range" id="radialMaxR" min="20" max="100" value="60" step="5" oninput="document.getElementById('radialMaxRv').textContent=this.value; document.getElementById('radialMaxRInput').value=this.value;" style="flex:1;">
                                <input type="number" id="radialMaxRInput" min="20" max="200" value="60" style="width:80px; padding:8px;" oninput="document.getElementById('radialMaxRv').textContent=this.value; document.getElementById('radialMaxR').value=Math.min(this.value,100);">
                            </div>
                        </div>
                        
                        <button onclick="updatePatternViz()" style="padding:12px 24px; margin:10px 0;">Compute Radial Distribution</button>
                        
                        <canvas id="radialCanvas" width="1000" height="600" style="max-width:100%;"></canvas>
                        
                        <div class="formula" style="margin-top:20px;">
                            <p><b>Growth Pattern:</b> The number of primitive points in shell [r, r+Œîr] grows approximately as 2œÄrŒîr/Œ∂(2), reflecting the density theorem.</p>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div id="gcdheatmap" class="panel">
            <div class="section">
                <h2>Interactive GCD Heatmap <span class="help-icon tooltip" data-tip="Click on points to see details">?</span></h2>
                <p>Explore GCD patterns in the lattice. Click on any point to see detailed information about its coordinates and GCD value.</p>
                
                <div class="controls">
                    <div style="margin-bottom:10px;">
                        <label><b>Presets:</b></label>
                        <div style="display:flex; gap:8px; flex-wrap:wrap; margin-top:5px;">
                            <button onclick="setGCDHeatmapPreset('small')" style="padding:6px 12px; font-size:0.9em;">Small (R=15)</button>
                            <button onclick="setGCDHeatmapPreset('medium')" style="padding:6px 12px; font-size:0.9em;">Medium (R=30)</button>
                            <button onclick="setGCDHeatmapPreset('large')" style="padding:6px 12px; font-size:0.9em;">Large (R=50)</button>
                            <button onclick="setGCDHeatmapPreset('xlarge')" style="padding:6px 12px; font-size:0.9em;">X-Large (R=100)</button>
                            <button onclick="setGCDHeatmapPreset('huge')" style="padding:6px 12px; font-size:0.9em;">Huge (R=200)</button>
                        </div>
                    </div>
                    
                    <label>Radius: <span id="heatmapRv">25</span></label>
                    <div style="display:flex; gap:10px; align-items:center; margin-bottom:15px;">
                        <input type="range" id="heatmapR" min="5" max="200" value="25" step="1" oninput="updateHeatmapR()" style="flex:1;">
                        <input type="number" id="heatmapRinput" min="5" max="500" value="25" style="width:100px; padding:8px;" oninput="updateHeatmapR()">
                    </div>
                    
                    <div style="background:var(--bg3); padding:15px; border-radius:8px; margin-bottom:15px;">
                        <label style="font-size:1.1em; color:var(--blue); margin-bottom:10px; display:block;"><b>Display Mode:</b></label>
                        <div style="display:grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap:8px;">
                            <button id="heatmapGCD" class="active" onclick="setHeatmapMode('gcd')" style="padding:10px;">By GCD Value</button>
                            <button id="heatmapPrimitive" onclick="setHeatmapMode('primitive')" style="padding:10px;">Primitive Only</button>
                            <button id="heatmapGradient" onclick="setHeatmapMode('gradient')" style="padding:10px;">Distance Gradient</button>
                        </div>
                    </div>
                    
                    <div style="background:var(--bg3); padding:15px; border-radius:8px; margin-bottom:15px;">
                        <label style="font-size:1.1em; color:var(--blue); margin-bottom:10px; display:block;"><b>Filter Options:</b></label>
                        <label style="display:flex; align-items:center; gap:8px; margin:8px 0;">
                            <input type="checkbox" id="filterGCD1" checked onchange="updateGCDHeatmap()"> Show GCD = 1 (Primitive)
                        </label>
                        <label style="display:flex; align-items:center; gap:8px; margin:8px 0;">
                            <input type="checkbox" id="filterGCD2" checked onchange="updateGCDHeatmap()"> Show GCD = 2
                        </label>
                        <label style="display:flex; align-items:center; gap:8px; margin:8px 0;">
                            <input type="checkbox" id="filterGCD3" checked onchange="updateGCDHeatmap()"> Show GCD = 3
                        </label>
                        <label style="display:flex; align-items:center; gap:8px; margin:8px 0;">
                            <input type="checkbox" id="filterGCDOther" checked onchange="updateGCDHeatmap()"> Show GCD > 3
                        </label>
                    </div>
                    
                    <label>Point Size: <span id="heatmapPSv">4</span></label>
                    <input type="range" id="heatmapPS" min="2" max="10" value="4" oninput="updateGCDHeatmap()">
                    
                    <div style="margin-top:15px;">
                        <button onclick="updateGCDHeatmap()">Refresh Heatmap</button>
                        <button onclick="exportCanvas('heatmapCanvas', 'gcd-heatmap')">Export Image</button>
                        <button onclick="exportHeatmapData()">Export Data</button>
                    </div>
                </div>
                
                <canvas id="heatmapCanvas" width="1200" height="1200" style="max-width:100%; cursor:crosshair;"></canvas>
                
                <div id="pointInfo" style="background:var(--bg3); padding:20px; border-radius:8px; margin-top:20px; min-height:100px;">
                    <p style="color:var(--text2); font-style:italic;">Click on a point to see details</p>
                </div>
                
                <div class="stats">
                    <div class="stat"><div class="val" id="heatmapTotal">0</div><div class="lbl">Total Points</div></div>
                    <div class="stat"><div class="val" id="heatmapPrim">0</div><div class="lbl">Primitive (GCD=1)</div></div>
                    <div class="stat"><div class="val" id="heatmapGCD2">0</div><div class="lbl">GCD = 2</div></div>
                    <div class="stat"><div class="val" id="heatmapGCD3">0</div><div class="lbl">GCD = 3</div></div>
                    <div class="stat"><div class="val" id="heatmapGCDOther">0</div><div class="lbl">GCD > 3</div></div>
                </div>
                
                <div class="formula" style="margin-top:20px;">
                    <p><b>GCD Patterns:</b></p>
                    <p>- Points with GCD = d form a scaled copy of the primitive lattice, scaled by factor d</p>
                    <p>- The number of points with GCD = d in radius R is approximately N‚ÇÅ(R/d) where N‚ÇÅ is the primitive count</p>
                    <p>- GCD values reveal the arithmetic structure of the lattice - patterns repeat at each GCD level</p>
                </div>
            </div>
        </div>

        <div id="gcdtable" class="panel">
            <div class="section">
                <h2>Modular Arithmetic Tables <span class="help-icon tooltip" data-tip="Interactive algebraic structure visualization">?</span></h2>
                <p>Explore various algebraic structures and patterns in modular arithmetic. Choose different table types to visualize GCD, addition, multiplication, and structural properties.</p>
                
                <div class="controls">
                    <div style="background:var(--bg3); padding:15px; border-radius:8px; margin-bottom:15px;">
                        <label style="font-size:1.1em; color:var(--blue); margin-bottom:10px; display:block;"><b>Table Type:</b></label>
                        <div style="display:grid; grid-template-columns: repeat(auto-fit, minmax(160px, 1fr)); gap:8px;">
                            <button id="tableTypeGCD" class="active" onclick="setTableType('gcd')" style="padding:10px;">GCD Table</button>
                            <button id="tableTypeAdd" onclick="setTableType('addition')" style="padding:10px;">Addition Mod n</button>
                            <button id="tableTypeMult" onclick="setTableType('multiplication')" style="padding:10px;">Multiplication Mod n</button>
                            <button id="tableTypeZeroDiv" onclick="setTableType('zerodivisors')" style="padding:10px;">Zero Divisors</button>
                            <button id="tableTypeUnits" onclick="setTableType('units')" style="padding:10px;">Units (Invertible)</button>
                            <button id="tableTypeTotient" onclick="setTableType('totient')" style="padding:10px;">Euler's œÜ</button>
                        </div>
                    </div>
                    
                    <div style="margin-bottom:10px;">
                        <label><b>Presets:</b></label>
                        <div style="display:flex; gap:8px; flex-wrap:wrap; margin-top:5px;">
                            <button onclick="setGCDTablePreset('small')" style="padding:6px 12px; font-size:0.9em;">Small (20√ó20)</button>
                            <button onclick="setGCDTablePreset('medium')" style="padding:6px 12px; font-size:0.9em;">Medium (50√ó50)</button>
                            <button onclick="setGCDTablePreset('large')" style="padding:6px 12px; font-size:0.9em;">Large (100√ó100)</button>
                            <button onclick="setGCDTablePreset('xlarge')" style="padding:6px 12px; font-size:0.9em;">X-Large (200√ó200)</button>
                            <button onclick="setGCDTablePreset('huge')" style="padding:6px 12px; font-size:0.9em;">Huge (500√ó500)</button>
                        </div>
                    </div>
                    
                    <label>Grid Size: <span id="gcdTableSizev">30</span></label>
                    <div style="display:flex; gap:10px; align-items:center; margin-bottom:15px;">
                        <input type="range" id="gcdTableSize" min="5" max="500" value="30" step="1" oninput="updateGCDTableSize()" style="flex:1;">
                        <input type="number" id="gcdTableSizeInput" min="5" max="1000" value="30" style="width:100px; padding:8px;" oninput="updateGCDTableSize()">
                    </div>
                    
                    <div style="background:var(--bg3); padding:15px; border-radius:8px; margin-bottom:15px;">
                        <label style="font-size:1.1em; color:var(--blue); margin-bottom:10px; display:block;"><b>Color Scheme:</b></label>
                        <div style="display:grid; grid-template-columns: repeat(auto-fit, minmax(140px, 1fr)); gap:8px;">
                            <button id="gcdTableHeat" class="active" onclick="setGCDTableColor('heat')" style="padding:10px;">Heat Map</button>
                            <button id="gcdTableDiscrete" onclick="setGCDTableColor('discrete')" style="padding:10px;">Discrete Values</button>
                            <button id="gcdTablePrime" onclick="setGCDTableColor('prime')" style="padding:10px;">Prime Powers</button>
                            <button id="gcdTableBinary" onclick="setGCDTableColor('binary')" style="padding:10px;">Binary (Yes/No)</button>
                            <button id="gcdTableRainbow" onclick="setGCDTableColor('rainbow')" style="padding:10px;">Rainbow</button>
                        </div>
                    </div>
                    
                    <div style="background:var(--bg3); padding:15px; border-radius:8px; margin-bottom:15px;">
                        <label style="font-size:1.1em; color:var(--blue); margin-bottom:10px; display:block;"><b>Grid Rotation:</b></label>
                        <div style="display:grid; grid-template-columns: repeat(4, 1fr); gap:8px;">
                            <button id="gcdTableRot0" class="active" onclick="setGCDTableRotation(0)" style="padding:10px;">0¬∞</button>
                            <button id="gcdTableRot90" onclick="setGCDTableRotation(90)" style="padding:10px;">90¬∞</button>
                            <button id="gcdTableRot180" onclick="setGCDTableRotation(180)" style="padding:10px;">180¬∞</button>
                            <button id="gcdTableRot270" onclick="setGCDTableRotation(270)" style="padding:10px;">270¬∞</button>
                        </div>
                        <p style="font-size:0.85em; color:var(--text2); margin-top:8px;">Rotate to view table from different quadrants</p>
                    </div>
                    
                    <label style="display:flex; align-items:center; gap:8px; margin:10px 0;">
                        <input type="checkbox" id="showGCDValues" checked onchange="updateGCDTable()"> Show GCD Values
                    </label>
                    
                    <label style="display:flex; align-items:center; gap:8px; margin:10px 0;">
                        <input type="checkbox" id="highlightDiagonal" checked onchange="updateGCDTable()"> Highlight Diagonal
                    </label>
                    
                    <div style="margin-top:15px;">
                        <button onclick="updateGCDTable()">Refresh Table</button>
                        <button onclick="exportCanvas('gcdTableCanvas', 'gcd-table')">Export Image</button>
                        <button onclick="exportGCDTableData()">Export Data</button>
                    </div>
                </div>
                
                <canvas id="gcdTableCanvas" width="1200" height="1200" style="max-width:100%; cursor:crosshair;"></canvas>
                
                <div id="gcdTableInfo" style="background:var(--bg3); padding:20px; border-radius:8px; margin-top:20px; min-height:100px;">
                    <p style="color:var(--text2); font-style:italic;">Click on a cell to see GCD(row, col) details</p>
                </div>
                
                <div class="formula" id="tableFormula" style="margin-top:20px;">
                    <p><b>Patterns to Observe:</b></p>
                    <p id="tablePatternInfo">Loading...</p>
                    <p style="margin-top:15px; padding:10px; background:var(--bg); border-radius:6px;">
                        <b>About Grid Rotation:</b><br>
                        Rotating the table by 90¬∞ increments reveals different symmetries and patterns:<br>
                        ‚Ä¢ <b>0¬∞:</b> Standard view - rows increase downward, columns increase rightward<br>
                        ‚Ä¢ <b>90¬∞:</b> Rotated clockwise - observe vertical symmetry patterns<br>
                        ‚Ä¢ <b>180¬∞:</b> Upside down - reveals inverse patterns and reflections<br>
                        ‚Ä¢ <b>270¬∞:</b> Rotated counter-clockwise - horizontal symmetry emphasis<br>
                        Perfect for analyzing table structure from all four quadrants!
                    </p>
                </div>
            </div>
        </div>

        <div id="criticalstrip" class="panel">
            <div class="section">
                <h2>Critical Strip & Error Analysis <span class="help-icon tooltip" data-tip="Gauss Circle Problem & RH Connection">?</span></h2>
                <p>Analyzes the error term Œî(R) from the Gauss Circle Problem and its connection to the Riemann Hypothesis. The growth rate of |Œî(R)| is deeply connected to the distribution of zeros of the Riemann zeta function.</p>
                
                <div class="controls">
                    <div style="background:var(--bg3); padding:15px; border-radius:8px; margin-bottom:15px;">
                        <label style="font-size:1.1em; color:var(--blue); margin-bottom:10px; display:block;"><b>Problem Type:</b></label>
                        <div style="display:flex; gap:10px; flex-wrap:wrap;">
                            <button id="criticalAllPoints" class="active" onclick="setCriticalProblem('all')" style="flex:1; min-width:150px; padding:12px;">Gauss Circle (All Points)</button>
                            <button id="criticalPrimitive" onclick="setCriticalProblem('primitive')" style="flex:1; min-width:150px; padding:12px;">Primitive Points Only</button>
                        </div>
                    </div>
                    
                    <div style="background:var(--bg3); padding:15px; border-radius:8px; margin-bottom:15px;">
                        <label style="font-size:1.1em; color:var(--blue); margin-bottom:10px; display:block;"><b>Visualization Type:</b></label>
                        <div style="display:grid; grid-template-columns: repeat(auto-fit, minmax(160px, 1fr)); gap:8px;">
                            <button id="criticalVizError" class="active" onclick="setCriticalViz('error')" style="padding:10px;">Error vs Radius</button>
                            <button id="criticalVizNormalized" onclick="setCriticalViz('normalized')" style="padding:10px;">Œî(R)/R^(1/2)</button>
                            <button id="criticalVizLog" onclick="setCriticalViz('loglog')" style="padding:10px;">Log-Log Plot</button>
                            <button id="criticalVizBounds" onclick="setCriticalViz('bounds')" style="padding:10px;">With Bounds</button>
                        </div>
                    </div>
                    
                    <div style="margin-bottom:10px;">
                        <label><b>Presets:</b></label>
                        <div style="display:flex; gap:8px; flex-wrap:wrap; margin-top:5px;">
                            <button onclick="setCriticalStripPreset('standard')" style="padding:6px 12px; font-size:0.9em;">Standard (R‚â§100)</button>
                            <button onclick="setCriticalStripPreset('detailed')" style="padding:6px 12px; font-size:0.9em;">Detailed (R‚â§200)</button>
                            <button onclick="setCriticalStripPreset('extended')" style="padding:6px 12px; font-size:0.9em;">Extended (R‚â§300)</button>
                        </div>
                    </div>
                    
                    <label>Max Radius: <span id="criticalMaxRv">100</span></label>
                    <div style="display:flex; gap:10px; align-items:center; margin-bottom:15px;">
                        <input type="range" id="criticalMaxR" min="20" max="500" value="100" step="10" oninput="updateCriticalMaxR()" style="flex:1;">
                        <input type="number" id="criticalMaxRinput" min="20" max="1000" value="100" step="10" style="width:100px; padding:8px;" oninput="updateCriticalMaxR()">
                    </div>
                    
                    <label>Step Size: <span id="criticalStepv">1</span></label>
                    <div style="display:flex; gap:10px; align-items:center; margin-bottom:15px;">
                        <input type="range" id="criticalStep" min="1" max="10" value="1" step="1" oninput="updateCriticalStep()" style="flex:1;">
                        <input type="number" id="criticalStepInput" min="1" max="20" value="1" style="width:100px; padding:8px;" oninput="updateCriticalStep()">
                    </div>
                    
                    <div style="background:var(--bg3); padding:15px; border-radius:8px; margin:15px 0;">
                        <label style="font-size:1.1em; color:var(--blue); margin-bottom:10px; display:block;"><b>Display Options:</b></label>
                        <label style="display:flex; align-items:center; gap:8px; margin:8px 0;">
                            <input type="checkbox" id="showZeroLine" checked onchange="updateCriticalStrip()"> Show Zero Line
                        </label>
                        <label style="display:flex; align-items:center; gap:8px; margin:8px 0;">
                            <input type="checkbox" id="showRHBound" checked onchange="updateCriticalStrip()"> Show RH Bound (R^(1/2))
                        </label>
                        <label style="display:flex; align-items:center; gap:8px; margin:8px 0;">
                            <input type="checkbox" id="showClassicalBound" onchange="updateCriticalStrip()"> Show Classical Bound (R^(2/3))
                        </label>
                        <label style="display:flex; align-items:center; gap:8px; margin:8px 0;">
                            <input type="checkbox" id="colorBySign" checked onchange="updateCriticalStrip()"> Color by Error Sign
                        </label>
                    </div>
                    
                    <div style="margin-top:15px;">
                        <button onclick="updateCriticalStrip()">Compute Analysis</button>
                        <button onclick="exportCanvas('criticalCanvas', 'critical-strip')">Export Image</button>
                        <button onclick="exportCriticalData()">Export Data</button>
                    </div>
                </div>
                
                <div class="loading" id="loadCritical"><div class="spinner"></div><p>Computing error analysis...</p></div>
                
                <canvas id="criticalCanvas" width="1400" height="1000" style="max-width:100%; cursor:crosshair;"></canvas>
                
                <div id="criticalPointInfo" style="background:var(--bg3); padding:20px; border-radius:8px; margin-top:20px; min-height:100px;">
                    <p style="color:var(--text2); font-style:italic;">Click on a point to see detailed error information</p>
                </div>
                
                <div class="stats">
                    <div class="stat"><div class="val" id="criticalPoints">0</div><div class="lbl">Data Points</div></div>
                    <div class="stat"><div class="val" id="criticalMaxErr">0</div><div class="lbl">Max |Œî(R)|</div></div>
                    <div class="stat"><div class="val" id="criticalAvgErr">0</div><div class="lbl">Avg |Œî(R)|</div></div>
                    <div class="stat"><div class="val" id="criticalRMSErr">0</div><div class="lbl">RMS Error</div></div>
                    <div class="stat"><div class="val" id="criticalMaxNorm">0</div><div class="lbl">Max |Œî(R)/R^(1/2)|</div></div>
                </div>
                
                <div class="formula" style="margin-top:20px;">
                    <p><b>Gauss Circle Problem:</b></p>
                    <p>Let N(R) = |{(x,y) ‚àà ‚Ñ§¬≤ : x¬≤ + y¬≤ ‚â§ R¬≤}| be the number of lattice points in a circle of radius R.</p>
                    <p style="margin-top:10px;">We have N(R) = œÄR¬≤ + Œî(R), where Œî(R) is the error term.</p>
                    
                    <p style="margin-top:15px;"><b>Connection to Riemann Hypothesis:</b></p>
                    <p>- <b>Known:</b> |Œî(R)| = O(R^(2/3)) (classical result by van der Corput, 1923)</p>
                    <p>- <b>Conjectured (Hardy, 1915):</b> |Œî(R)| = O(R^(1/2 + Œµ)) for any Œµ > 0</p>
                    <p>- <b>If RH is true:</b> This bound is expected to hold, though not yet proven</p>
                    <p>- <b>Lower bound:</b> |Œî(R)| = Œ©(R^(1/4)) (Sierpi≈Ñski, 1906)</p>
                    
                    <p style="margin-top:15px;"><b>For Primitive Points:</b></p>
                    <p>N_prim(R) = œÄR¬≤/Œ∂(2) + Œî_prim(R), with similar error behavior scaled by 1/Œ∂(2) ‚âà 0.608</p>
                    
                    <p style="margin-top:15px;"><b>Key Observations:</b></p>
                    <p>- The error oscillates around zero with increasing amplitude</p>
                    <p>- Normalized error Œî(R)/R^(1/2) should be bounded if RH is true</p>
                    <p>- The oscillation frequency relates to the imaginary parts of zeta zeros</p>
                </div>
            </div>
        </div>

        <div id="viz2d" class="panel">
            <div class="section">
                <h2>2D Lattice Visualization <span class="help-icon tooltip" data-tip="Explore primitive lattice points">?</span></h2>
                <div class="controls">
                    <div style="background: var(--bg3); padding: 15px; border-radius: 8px; margin-bottom: 15px;">
                        <label style="font-size: 1.1em; color: var(--blue); margin-bottom: 10px; display: block;"><b>View Mode:</b></label>
                        <div style="display:flex; gap:10px; flex-wrap:wrap;">
                            <button id="viewPrimitive" class="active" onclick="set2DView('primitive')" style="flex:1; min-width:150px; padding: 12px;">Colored by Mode</button>
                            <button id="viewGauss" onclick="set2DView('gauss')" style="flex:1; min-width:150px; padding: 12px;">Circle Problem (All Points)</button>
                        </div>
                    </div>
                    
                    <div style="background: var(--bg3); padding: 15px; border-radius: 8px; margin-bottom: 15px;">
                        <label style="font-size: 1.1em; color: var(--blue); margin-bottom: 10px; display: block;"><b>Coloring Mode:</b></label>
                        <div style="display:grid; grid-template-columns: repeat(auto-fit, minmax(160px, 1fr)); gap:8px;">
                            <button id="color2DPrimitive" class="active" onclick="set2DColorMode('primitive')" style="padding:10px 12px; font-size:0.85em;">GCD=1 vs GCD>1</button>
                            <button id="color2DGCD" onclick="set2DColorMode('gcd')" style="padding:10px 12px; font-size:0.85em;">By GCD Value</button>
                            <button id="color2DMod" onclick="set2DColorMode('mod')" style="padding:10px 12px; font-size:0.85em;">By Mod m</button>
                            <button id="color2DQuadrant" onclick="set2DColorMode('quadrant')" style="padding:10px 12px; font-size:0.85em;">By Quadrant</button>
                            <button id="color2DAngular" onclick="set2DColorMode('angular')" style="padding:10px 12px; font-size:0.85em;">By Angular Sector</button>
                            <button id="color2DGCDQuad" onclick="set2DColorMode('gcdquad')" style="padding:10px 12px; font-size:0.85em;">GCD √ó Quadrant</button>
                            <button id="color2DGCDMod" onclick="set2DColorMode('gcdmod')" style="padding:10px 12px; font-size:0.85em;">GCD √ó Mod</button>
                        </div>
                        <div id="modControls2D" style="display:none; margin-top:10px;">
                            <label>Modulus m: <span id="mod2Dv">3</span></label>
                            <input type="range" id="mod2D" min="2" max="12" value="3" step="1" oninput="document.getElementById('mod2Dv').textContent=this.value; draw2D()">
                        </div>
                        <div id="sectorControls2D" style="display:none; margin-top:10px;">
                            <label>Angular Sectors: <span id="sectors2Dv">8</span></label>
                            <input type="range" id="sectors2D" min="4" max="16" value="8" step="1" oninput="document.getElementById('sectors2Dv').textContent=this.value; draw2D()">
                        </div>
                    </div>
                    <div style="margin-bottom:10px;">
                        <label><b>Presets:</b></label>
                        <div style="display:flex; gap:8px; flex-wrap:wrap; margin-top:5px;">
                            <button onclick="set2DPreset('small')" style="padding:6px 12px; font-size:0.9em;">Small (R=10)</button>
                            <button onclick="set2DPreset('medium')" style="padding:6px 12px; font-size:0.9em;">Medium (R=50)</button>
                            <button onclick="set2DPreset('large')" style="padding:6px 12px; font-size:0.9em;">Large (R=100)</button>
                            <button onclick="set2DPreset('xlarge')" style="padding:6px 12px; font-size:0.9em;">X-Large (R=200)</button>
                            <button onclick="set2DPreset('huge')" style="padding:6px 12px; font-size:0.9em;">Huge (R=500)</button>
                        </div>
                    </div>
                    <label>Radius: <span id="r2v">20</span></label>
                    <div style="display:flex; gap:10px; align-items:center; margin-bottom:10px;">
                        <input type="range" id="r2" min="1" max="500" value="20" step="1" oninput="update2DRadius(this.value)" style="flex:1;">
                        <input type="number" id="r2input" min="1" max="2000" value="20" style="width:100px; padding:8px;" oninput="update2DRadius(this.value)">
                    </div>
                    
                    <label>Canvas Zoom: <span id="zoom2Dv">100</span>%</label>
                    <input type="range" id="zoom2D" min="50" max="200" value="100" step="5" oninput="update2DZoom()">
                    
                    <label>Point Size: <span id="psv">3</span></label>
                    <input type="range" id="ps" min="1" max="20" value="3" oninput="draw2D()">
                    
                    <div style="background: var(--bg3); padding: 15px; border-radius: 8px; margin: 15px 0;">
                        <label style="font-size: 1.1em; color: var(--blue); margin-bottom: 10px; display: block;"><b>Point Labels:</b></label>
                        <div style="display:grid; grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); gap:8px; margin-bottom:10px;">
                            <button id="label2DNone" class="active" onclick="set2DLabelMode('none')" style="padding:8px; font-size:0.85em;">No Labels</button>
                            <button id="label2DGCD" onclick="set2DLabelMode('gcd')" style="padding:8px; font-size:0.85em;">By GCD</button>
                            <button id="label2DCoords" onclick="set2DLabelMode('coords')" style="padding:8px; font-size:0.85em;">Coordinates</button>
                            <button id="label2DAngle" onclick="set2DLabelMode('angle')" style="padding:8px; font-size:0.85em;">By Angle</button>
                        </div>
                        <div id="labelControls2D" style="display:none;">
                            <label>Label Font Size: <span id="labelSize2Dv">8</span>px</label>
                            <input type="range" id="labelSize2D" min="6" max="16" value="8" step="1" oninput="draw2D()">
                            <label style="margin-top:10px;">Max Points to Label: <span id="maxLabels2Dv">50</span></label>
                            <input type="range" id="maxLabels2D" min="10" max="500" value="50" step="10" oninput="draw2D()">
                            <p style="font-size:0.85em; color:var(--text2); margin-top:8px;">Labels shown for points closest to origin</p>
                        </div>
                    </div>
                    
                    <button onclick="exportCanvas('c2d', '2d-lattice')">Export Image</button>
                    <button onclick="exportPointData2D()">Export Points</button>
                </div>
                <div class="warning" id="warn2d" style="display:none;">
                    Warning: Large radius values may slow performance. Consider using R ‚â§ 200 for smooth rendering.
                </div>
                <div class="loading" id="load2d"><div class="spinner"></div><p>Computing lattice points...</p></div>
                <canvas id="c2d" width="1200" height="1200" style="max-width:100%;"></canvas>
                <div class="stats">
                    <div class="stat"><div class="val" id="p2">0</div><div class="lbl">Primitive Points</div></div>
                    <div class="stat"><div class="val" id="t2">0</div><div class="lbl">Total Points</div></div>
                    <div class="stat"><div class="val" id="d2">0%</div><div class="lbl">Density</div></div>
                    <div class="stat"><div class="val" id="e2">0</div><div class="lbl">|Predicted - Actual|</div></div>
                </div>
            </div>
        </div>

        <div id="viz3d" class="panel">
            <div class="section">
                <h2>3D Lattice Visualization <span class="help-icon tooltip" data-tip="Click and drag to rotate">?</span></h2>
                <div class="controls">
                    <div style="background: var(--bg3); padding: 15px; border-radius: 8px; margin-bottom: 15px;">
                        <label style="font-size: 1.1em; color: var(--blue); margin-bottom: 10px; display: block;"><b>Boundary Shape:</b></label>
                        <div style="display:flex; gap:10px; flex-wrap:wrap;">
                            <button id="shape3DSphere" class="active" onclick="set3DShape('sphere')" style="flex:1; min-width:120px; padding: 12px;">Sphere (x¬≤+y¬≤+z¬≤ ‚â§ R¬≤)</button>
                            <button id="shape3DCube" onclick="set3DShape('cube')" style="flex:1; min-width:120px; padding: 12px;">Cube (|x|,|y|,|z| ‚â§ R)</button>
                        </div>
                    </div>
                    
                    <div style="background: var(--bg3); padding: 15px; border-radius: 8px; margin-bottom: 15px;">
                        <label style="font-size: 1.1em; color: var(--blue); margin-bottom: 10px; display: block;"><b>Coloring Mode:</b></label>
                        <div style="display:grid; grid-template-columns: repeat(auto-fit, minmax(160px, 1fr)); gap:8px;">
                            <button id="colorPrimitive" class="active" onclick="set3DColorMode('primitive')" style="padding:10px 12px; font-size:0.85em;">GCD=1 vs GCD>1</button>
                            <button id="colorGCD" onclick="set3DColorMode('gcd')" style="padding:10px 12px; font-size:0.85em;">By GCD Value</button>
                            <button id="colorMod" onclick="set3DColorMode('mod')" style="padding:10px 12px; font-size:0.85em;">By Mod m</button>
                            <button id="colorOctant" onclick="set3DColorMode('octant')" style="padding:10px 12px; font-size:0.85em;">By Octant</button>
                            <button id="colorDistance" onclick="set3DColorMode('distance')" style="padding:10px 12px; font-size:0.85em;">By Distance</button>
                            <button id="colorGCDOct" onclick="set3DColorMode('gcdoct')" style="padding:10px 12px; font-size:0.85em;">GCD √ó Octant</button>
                            <button id="colorGCDMod" onclick="set3DColorMode('gcdmod')" style="padding:10px 12px; font-size:0.85em;">GCD √ó Mod</button>
                        </div>
                        <div id="modControls3D" style="display:none; margin-top:10px;">
                            <label>Modulus m: <span id="mod3Dv">3</span></label>
                            <input type="range" id="mod3D" min="2" max="12" value="3" step="1" oninput="document.getElementById('mod3Dv').textContent=this.value; draw3D()">
                        </div>
                    </div>
                    
                    <div style="margin-bottom:10px;">
                        <label><b>Presets:</b></label>
                        <div style="display:flex; gap:8px; flex-wrap:wrap; margin-top:5px;">
                            <button onclick="set3DPreset('tiny')" style="padding:6px 12px; font-size:0.9em;">Tiny (R=5)</button>
                            <button onclick="set3DPreset('small')" style="padding:6px 12px; font-size:0.9em;">Small (R=10)</button>
                            <button onclick="set3DPreset('medium')" style="padding:6px 12px; font-size:0.9em;">Medium (R=20)</button>
                            <button onclick="set3DPreset('large')" style="padding:6px 12px; font-size:0.9em;">Large (R=30)</button>
                        </div>
                    </div>
                    <label>Radius: <span id="r3v">10</span></label>
                    <input type="range" id="r3" min="1" max="40" value="10" step="1" oninput="draw3D()">
                    
                    <label>Point Size: <span id="ps3v">0.6</span></label>
                    <input type="range" id="ps3" min="0.2" max="2.0" value="0.6" step="0.1" oninput="draw3D()">
                    
                    <label>Camera Distance (Zoom): <span id="zoom3Dv">86</span></label>
                    <input type="range" id="zoom3D" min="30" max="150" value="86" step="1" oninput="update3DZoom()">
                    
                    <div style="background: var(--bg3); padding: 15px; border-radius: 8px; margin: 15px 0;">
                        <label style="font-size: 1.1em; color: var(--blue); margin-bottom: 10px; display: block;"><b>Point Labels:</b></label>
                        <div style="display:grid; grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); gap:8px; margin-bottom:10px;">
                            <button id="label3DNone" class="active" onclick="set3DLabelMode('none')" style="padding:8px; font-size:0.85em;">No Labels</button>
                            <button id="label3DGCD" onclick="set3DLabelMode('gcd')" style="padding:8px; font-size:0.85em;">By GCD</button>
                            <button id="label3DCoords" onclick="set3DLabelMode('coords')" style="padding:8px; font-size:0.85em;">Coordinates</button>
                        </div>
                        <div id="labelControls3D" style="display:none;">
                            <label>Max Points to Label: <span id="maxLabels3Dv">30</span></label>
                            <input type="range" id="maxLabels3D" min="10" max="200" value="30" step="10" oninput="draw3D()">
                            <p style="font-size:0.85em; color:var(--text2); margin-top:8px;">Labels shown for points closest to origin</p>
                        </div>
                    </div>
                    
                    <button onclick="reset3D()">Reset View</button>
                    <button onclick="toggleRotation()">Auto-Rotate</button>
                    <button onclick="export3DData()">Export Points</button>
                </div>
                <div class="warning" id="warn3d" style="display:none;">
                    Warning: Radius > 30 generates many points and may impact performance.
                </div>
                <div class="loading" id="load3d"><div class="spinner"></div><p>Generating 3D lattice...</p></div>
                <div id="c3d" style="width:100%; height:800px;"></div>
                <div class="stats">
                    <div class="stat"><div class="val" id="p3">0</div><div class="lbl">Primitive Points</div></div>
                    <div class="stat"><div class="val" id="t3">0</div><div class="lbl">Total Points</div></div>
                    <div class="stat"><div class="val" id="d3">0%</div><div class="lbl">Density</div></div>
                    <div class="stat"><div class="val" id="e3">0</div><div class="lbl">Error</div></div>
                </div>
            </div>
        </div>

        <div id="comparison" class="panel">
            <div class="section">
                <h2>Dimension Comparison <span class="help-icon tooltip" data-tip="Compare different dimensions">?</span></h2>
                <p>Compare how primitive lattice point counts change across dimensions for a fixed radius, or analyze how different radii affect each dimension.</p>
                
                <div class="controls">
                    <label>Comparison Mode:</label>
                    <div style="display:flex; gap:10px; margin-bottom:15px; flex-wrap:wrap;">
                        <button id="modeFixed" class="active" onclick="setComparisonMode('fixed')" style="flex:1; min-width:150px;">Fixed Radius</button>
                        <button id="modeMulti" onclick="setComparisonMode('multi')" style="flex:1; min-width:150px;">Multiple Radii</button>
                    </div>
                    
                    <div style="margin-bottom:10px;">
                        <label><b>Presets:</b></label>
                        <div style="display:flex; gap:8px; flex-wrap:wrap; margin-top:5px;">
                            <button onclick="setComparisonPreset('low')" style="padding:6px 12px; font-size:0.9em;">Low Dimensions (2-4)</button>
                            <button onclick="setComparisonPreset('mid')" style="padding:6px 12px; font-size:0.9em;">Mid Dimensions (3-6)</button>
                            <button onclick="setComparisonPreset('high')" style="padding:6px 12px; font-size:0.9em;">High Dimensions (5-10)</button>
                            <button onclick="setComparisonPreset('all')" style="padding:6px 12px; font-size:0.9em;">All Dimensions (2-10)</button>
                            <button onclick="setComparisonPreset('growth')" style="padding:6px 12px; font-size:0.9em;">Growth Analysis</button>
                        </div>
                    </div>
                    
                    <div id="fixedRadiusControls">
                        <label>Radius: <span id="crv">15</span></label>
                        <div style="display:flex; gap:10px; align-items:center; margin-bottom:15px;">
                            <input type="range" id="cr" min="1" max="100" value="15" step="1" oninput="updateComparisonRadius(this.value)" style="flex:1;">
                            <input type="number" id="crinput" min="1" max="200" value="15" style="width:100px; padding:8px;" oninput="updateComparisonRadius(this.value)">
                        </div>
                    </div>
                    
                    <div id="multiRadiusControls" style="display:none;">
                        <label>Radii to compare (comma-separated): </label>
                        <input type="text" id="multiRadii" value="10, 20, 30, 40, 50" style="width:100%; padding:10px; margin-bottom:15px;" oninput="updateComparison()">
                    </div>
                    
                    <div style="margin-bottom:15px;">
                        <p><b>Dimensions to compare:</b></p>
                        <div style="display:grid; grid-template-columns: repeat(auto-fit, minmax(80px, 1fr)); gap:10px; margin-top:10px;">
                            <label style="display:flex; align-items:center; gap:8px;">
                                <input type="checkbox" id="compk2" checked onchange="updateComparison()"> k=2
                            </label>
                            <label style="display:flex; align-items:center; gap:8px;">
                                <input type="checkbox" id="compk3" checked onchange="updateComparison()"> k=3
                            </label>
                            <label style="display:flex; align-items:center; gap:8px;">
                                <input type="checkbox" id="compk4" checked onchange="updateComparison()"> k=4
                            </label>
                            <label style="display:flex; align-items:center; gap:8px;">
                                <input type="checkbox" id="compk5" checked onchange="updateComparison()"> k=5
                            </label>
                            <label style="display:flex; align-items:center; gap:8px;">
                                <input type="checkbox" id="compk6" checked onchange="updateComparison()"> k=6
                            </label>
                            <label style="display:flex; align-items:center; gap:8px;">
                                <input type="checkbox" id="compk7" onchange="updateComparison()"> k=7
                            </label>
                            <label style="display:flex; align-items:center; gap:8px;">
                                <input type="checkbox" id="compk8" onchange="updateComparison()"> k=8
                            </label>
                            <label style="display:flex; align-items:center; gap:8px;">
                                <input type="checkbox" id="compk9" onchange="updateComparison()"> k=9
                            </label>
                            <label style="display:flex; align-items:center; gap:8px;">
                                <input type="checkbox" id="compk10" onchange="updateComparison()"> k=10
                            </label>
                        </div>
                    </div>
                    
                    <div style="margin-bottom:15px;">
                        <p><b>Display options:</b></p>
                        <label style="display:flex; align-items:center; gap:8px; margin:8px 0;">
                            <input type="checkbox" id="showDensity" checked onchange="updateComparison()"> Show Density (1/Œ∂(k))
                        </label>
                        <label style="display:flex; align-items:center; gap:8px; margin:8px 0;">
                            <input type="checkbox" id="showVolume" checked onchange="updateComparison()"> Show Sphere Volume
                        </label>
                        <label style="display:flex; align-items:center; gap:8px; margin:8px 0;">
                            <input type="checkbox" id="showZeta" checked onchange="updateComparison()"> Show Œ∂(k) Values
                        </label>
                        <label style="display:flex; align-items:center; gap:8px; margin:8px 0;">
                            <input type="checkbox" id="showChart" checked onchange="updateComparison()"> Show Comparison Chart
                        </label>
                    </div>
                    
                    <button onclick="updateComparison()">Refresh Comparison</button>
                    <button onclick="exportComparisonData()">Export Data</button>
                    <button onclick="exportComparisonChart()">Export Chart</button>
                </div>
                
                <div class="compare-grid" id="compGrid"></div>
                
                <div id="comparisonChart" style="margin-top:30px;">
                    <canvas id="compChart" width="800" height="400"></canvas>
                </div>
                
                <div class="formula" style="margin-top:20px;">
                    <p><b>Key Observations:</b></p>
                    <p>- As dimension k increases, Œ∂(k) approaches 1, meaning the density 1/Œ∂(k) approaches 100%</p>
                    <p>- Higher dimensions have exponentially more lattice points (grows as R^k)</p>
                    <p>- The ratio of primitive to total points stabilizes at 1/Œ∂(k) for each dimension</p>
                    <p>- Sphere volume grows dramatically with dimension, following the gamma function pattern</p>
                </div>
                
                <div style="margin-top:30px;">
                    <h3 style="color:var(--blue);">Dimensional Scaling Analysis</h3>
                    <p>Explore how the boundary term R^(k-1) becomes negligible compared to the main term R^k as dimension increases.</p>
                    
                    <div class="controls" style="background:var(--bg3); padding:20px; border-radius:8px; margin:20px 0;">
                        <label>Dimension k: <span id="dimScaleK">3</span></label>
                        <input type="range" id="dimScaleKSlider" min="2" max="12" value="3" step="1" oninput="updateDimScale()">
                        
                        <label style="margin-top:15px;">Radius R: <span id="dimScaleR">100</span></label>
                        <input type="range" id="dimScaleRSlider" min="10" max="1000" value="100" step="10" oninput="updateDimScale()">
                    </div>
                    
                    <div class="stats" id="dimScaleStats">
                        <div class="stat"><div class="val" id="mainTerm">1000000</div><div class="lbl">Main Term (R^k)</div></div>
                        <div class="stat"><div class="val" id="boundaryTerm">10000</div><div class="lbl">Boundary Term (R^(k-1))</div></div>
                        <div class="stat"><div class="val" id="relativeError">1.00%</div><div class="lbl">Relative Error</div></div>
                        <div class="stat"><div class="val" id="densityVal">0.8319</div><div class="lbl">Density (1/Œ∂(k))</div></div>
                    </div>
                    
                    <div class="data-table-container" style="margin-top:20px;">
                        <h4 style="margin-bottom:10px;">Dimensional Scaling Table</h4>
                        <table>
                            <thead>
                                <tr>
                                    <th>k</th>
                                    <th>Boundary Geometry</th>
                                    <th>Density 1/Œ∂(k)</th>
                                    <th>Stability</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr><td>2</td><td>Perimeter (R¬π)</td><td>0.6079</td><td>Baseline</td></tr>
                                <tr><td>3</td><td>Surface Area (R¬≤)</td><td>0.8319</td><td>High</td></tr>
                                <tr><td>4</td><td>3D Hypersurface (R¬≥)</td><td>0.9239</td><td>Very High</td></tr>
                                <tr><td>5</td><td>4D Hypersurface (R‚Å¥)</td><td>0.9644</td><td>Extreme</td></tr>
                                <tr><td>6</td><td>5D Hypersurface (R‚Åµ)</td><td>0.9829</td><td>Extreme</td></tr>
                                <tr><td>8</td><td>7D Hypersurface (R‚Å∑)</td><td>0.9959</td><td>Extreme+</td></tr>
                                <tr><td>10</td><td>9D Hypersurface (R‚Åπ)</td><td>0.9990</td><td>Approaching 1</td></tr>
                                <tr><td>12</td><td>11D Hypersurface (R¬π¬π)</td><td>0.9998</td><td>Nearly 1</td></tr>
                            </tbody>
                        </table>
                    </div>
                    
                    <div class="formula" style="margin-top:20px;">
                        <p><b>Key Insight:</b> As k increases, the relative error (Boundary/Main) = R^(k-1)/R^k = 1/R decreases.</p>
                        <p>For fixed R, higher dimensions have proportionally smaller boundary effects, leading to more stable density convergence to 1/Œ∂(k).</p>
                    </div>
                </div>
            </div>
        </div>

        <div id="analysis" class="panel">
            <div class="section">
                <h2>Error Analysis <span class="help-icon tooltip" data-tip="Study O(R^(k-1)) error term for ALL radius values">?</span></h2>
                <p>Visualization of the error term Œî(R) = N(R) - R^k/Œ∂(k) for every single radius value. The chart shows how actual counts differ from predictions.</p>
                <div class="controls">
                    <div style="margin-bottom:10px;">
                        <label><b>Presets:</b></label>
                        <div style="display:flex; gap:8px; flex-wrap:wrap; margin-top:5px;">
                            <button onclick="setAnalysisPreset('quick')" style="padding:6px 12px; font-size:0.9em;">Quick (R‚â§50, all values)</button>
                            <button onclick="setAnalysisPreset('standard')" style="padding:6px 12px; font-size:0.9em;">Standard (R‚â§100, all values)</button>
                            <button onclick="setAnalysisPreset('detailed')" style="padding:6px 12px; font-size:0.9em;">Detailed (R‚â§200, all values)</button>
                            <button onclick="setAnalysisPreset('extended')" style="padding:6px 12px; font-size:0.9em;">Extended (R‚â§500, all values)</button>
                        </div>
                    </div>
                    
                    <label>Dimension k: <span id="analysisKv">2</span></label>
                    <input type="range" id="analysisK" min="2" max="5" value="2" step="1" oninput="document.getElementById('analysisKv').textContent=this.value">
                    
                    <label>Max Radius: <span id="mrv">100</span></label>
                    <div style="display:flex; gap:10px; align-items:center; margin-bottom:10px;">
                        <input type="range" id="mr" min="10" max="500" value="100" step="5" oninput="updateAnalysisRadius(this.value)" style="flex:1;">
                        <input type="number" id="mrinput" min="10" max="1000" value="100" step="5" style="width:100px; padding:8px;" oninput="updateAnalysisRadius(this.value)">
                    </div>
                    
                    <label>Start from Radius: <span id="minrv">1</span></label>
                    <input type="range" id="minr" min="1" max="50" value="1" step="1" oninput="document.getElementById('minrv').textContent=this.value">
                    
                    <div style="background:var(--bg3); padding:15px; border-radius:8px; margin:15px 0;">
                        <p style="color:var(--blue); font-weight:bold; margin-bottom:10px;">Computation Info:</p>
                        <p style="font-size:0.9em; margin-bottom:5px;">- <b>k=2:</b> Exact computation up to R=200, then uses prediction</p>
                        <p style="font-size:0.9em; margin-bottom:5px;">- <b>k=3:</b> Exact computation up to R=40, then uses prediction</p>
                        <p style="font-size:0.9em; margin-bottom:5px;">- <b>k=4:</b> Exact computation up to R=15, then uses prediction</p>
                        <p style="font-size:0.9em;">- <b>k=5:</b> Uses prediction (computational limit)</p>
                        <p style="font-size:0.85em; color:var(--text2); margin-top:10px;">Note: Computes for <b>every single R value</b> (no skipping)</p>
                    </div>
                    
                    <div style="margin-top:20px;">
                        <label style="display:flex; align-items:center; gap:8px; margin:8px 0;">
                            <input type="checkbox" id="showAbsError" checked onchange="runAnalysis()"> Show Absolute Error
                        </label>
                        <label style="display:flex; align-items:center; gap:8px; margin:8px 0;">
                            <input type="checkbox" id="showRelError" checked onchange="runAnalysis()"> Show Relative Error (%)
                        </label>
                        <label style="display:flex; align-items:center; gap:8px; margin:8px 0;">
                            <input type="checkbox" id="showRunningAvg" onchange="runAnalysis()"> Show Running Average
                        </label>
                        <label style="display:flex; align-items:center; gap:8px; margin:8px 0;">
                            <input type="checkbox" id="showBoundary" onchange="runAnalysis()"> Show Theoretical Boundary O(R^(k-1))
                        </label>
                        <label style="display:flex; align-items:center; gap:8px; margin:8px 0;">
                            <input type="checkbox" id="showActualCount" onchange="runAnalysis()"> Show Actual Primitive Count
                        </label>
                    </div>
                    
                    <button onclick="runAnalysis()" style="margin-top:15px;">Compute Analysis</button>
                    <button onclick="exportChartData()">Export Chart Data</button>
                    <button onclick="analyzeSpecificPoint()">Analyze Specific R</button>
                </div>
                <div class="loading" id="loadAnalysis"><div class="spinner"></div><p>Computing error analysis for all R values...</p></div>
                <canvas id="ch" width="1600" height="1000" style="max-width: 100%; cursor:crosshair;"></canvas>
                
                <div id="pointAnalysisResult" style="background:var(--bg3); padding:20px; border-radius:8px; margin-top:20px; min-height:100px;">
                    <p style="color:var(--text2); font-style:italic;">Click on chart points or use "Analyze Specific R" button to see detailed analysis</p>
                </div>
                <div class="formula" style="margin-top: 20px;">
                    <p><b>Error Bound Theory:</b></p>
                    <p>The error term O(R^(k-1)) arises from boundary effects. For k=2, the error is O(R), corresponding to points near the circle boundary. As k increases, the error term becomes relatively smaller compared to the main term R^k.</p>
                    <p style="margin-top:10px;"><b>Relative Error:</b> Shows |Predicted - Actual| / Predicted as a percentage. This decreases as R grows, confirming the asymptotic accuracy.</p>
                    <p style="margin-top:10px;"><b>Running Average:</b> The cumulative average of absolute errors up to each R. Shows convergence behavior.</p>
                    <p style="margin-top:10px;"><b>Boundary Term:</b> The theoretical O(R^(k-1)) term, showing the expected growth rate of the error.</p>
                    <p style="margin-top:15px;"><b>Key Feature:</b> This analysis computes for <b>every single R value</b> from start to max (no skipping), giving you the complete error landscape.</p>
                </div>
                
                <div style="margin-top:30px;">
                    <h3 style="color:var(--blue);">Empirical Validation Table (k=2)</h3>
                    <p>Computational verification of the theoretical predictions for dimension k=2:</p>
                    
                    <div class="data-table-container" style="margin-top:15px;">
                        <table>
                            <thead>
                                <tr>
                                    <th>R</th>
                                    <th>N(R) Actual</th>
                                    <th>R¬≤/Œ∂(2) Predicted</th>
                                    <th>Œî(R) Error</th>
                                    <th>Œî(R)/(R log R)</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr><td>10</td><td>63</td><td>60.79</td><td>2.21</td><td>0.096</td></tr>
                                <tr><td>50</td><td>1,519</td><td>1,519.7</td><td>-0.7</td><td>-0.008</td></tr>
                                <tr><td>100</td><td>6,087</td><td>6,079.3</td><td>7.7</td><td>0.017</td></tr>
                                <tr><td>500</td><td>151,983</td><td>151,982.5</td><td>0.5</td><td>0.0002</td></tr>
                                <tr><td>1000</td><td>607,926</td><td>607,927.0</td><td>-1.0</td><td>-0.0001</td></tr>
                            </tbody>
                        </table>
                    </div>
                    
                    <div class="formula" style="margin-top:15px;">
                        <p><b>Observations:</b></p>
                        <p>- The error Œî(R) oscillates around zero, confirming the prediction is unbiased</p>
                        <p>- The normalized error Œî(R)/(R log R) decreases as R increases</p>
                        <p>- Even at R=1000, the error is less than 0.0002% of the predicted value</p>
                        <p>- This validates the asymptotic formula N(R) = R¬≤/Œ∂(2) + O(R log R) for k=2</p>
                    </div>
                </div>
            </div>
        </div>

        <div id="explore" class="panel">
            <div class="section">
                <h2>Related Mathematical Visualizations</h2>
                <p>Explore the complete collection of interactive number theory and lattice point visualizations by Wessen Getachew. Each project focuses on a specific mathematical concept with deep interactive exploration.</p>
                
                <h3 style="color:var(--blue); margin-top:30px;">Core Lattice & Coprimality Theory</h3>
                <div class="compare-grid">
                    <div class="compare-item">
                        <h4 style="color:var(--blue);">Boundary Cancellation (Main)</h4>
                        <p style="margin:10px 0;">Analysis of arithmetic lattice residues and the M√∂bius inversion principle.</p>
                        <a href="https://wessengetachew.github.io/R/" target="_blank" style="display:inline-block; padding:8px 16px; background:var(--blue); color:white; text-decoration:none; border-radius:6px; margin-top:10px;">Visit Project</a>
                    </div>
                    
                    <div class="compare-item">
                        <h4 style="color:var(--blue);">GCD & 2œÄr</h4>
                        <p style="margin:10px 0;">Complete discovery engine for GCD patterns and boundary cancellation principles.</p>
                        <a href="https://wessengetachew.github.io/GCD/" target="_blank" style="display:inline-block; padding:8px 16px; background:var(--blue); color:white; text-decoration:none; border-radius:6px; margin-top:10px;">Visit Project</a>
                    </div>
                    
                    <div class="compare-item">
                        <h4 style="color:var(--blue);">Finite Fields</h4>
                        <p style="margin:10px 0;">Exploration of finite field structures and modular arithmetic patterns.</p>
                        <a href="https://wessengetachew.github.io/finite/" target="_blank" style="display:inline-block; padding:8px 16px; background:var(--blue); color:white; text-decoration:none; border-radius:6px; margin-top:10px;">Visit Project</a>
                    </div>
                </div>
                
                <h3 style="color:var(--green); margin-top:30px;">Prime Number Visualizations</h3>
                <div class="compare-grid">
                    <div class="compare-item">
                        <h4 style="color:var(--green);">Prime Patterns</h4>
                        <p style="margin:10px 0;">Interactive visualization of prime number distribution and patterns.</p>
                        <a href="https://wessengetachew.github.io/Primes/" target="_blank" style="display:inline-block; padding:8px 16px; background:var(--green); color:white; text-decoration:none; border-radius:6px; margin-top:10px;">Visit Project</a>
                    </div>
                    
                    <div class="compare-item">
                        <h4 style="color:var(--green);">Composite Numbers</h4>
                        <p style="margin:10px 0;">Analysis of composite number structures and factorization patterns.</p>
                        <a href="https://wessengetachew.github.io/Composite/" target="_blank" style="display:inline-block; padding:8px 16px; background:var(--green); color:white; text-decoration:none; border-radius:6px; margin-top:10px;">Visit Project</a>
                    </div>
                    
                    <div class="compare-item">
                        <h4 style="color:var(--green);">Goldbach Conjecture</h4>
                        <p style="margin:10px 0;">Interactive exploration of Goldbach's conjecture and twin prime patterns.</p>
                        <a href="https://wessengetachew.github.io/Goldbach/" target="_blank" style="display:inline-block; padding:8px 16px; background:var(--green); color:white; text-decoration:none; border-radius:6px; margin-top:10px;">Visit Project</a>
                    </div>
                </div>
                
                <h3 style="color:var(--purple); margin-top:30px;">Rational Numbers & Fractions</h3>
                <div class="compare-grid">
                    <div class="compare-item">
                        <h4 style="color:var(--purple);">Farey Sequences</h4>
                        <p style="margin:10px 0;">Visualization of Farey sequences, Ford circles, and Stern-Brocot trees.</p>
                        <a href="https://wessengetachew.github.io/Farey/" target="_blank" style="display:inline-block; padding:8px 16px; background:var(--purple); color:white; text-decoration:none; border-radius:6px; margin-top:10px;">Visit Project</a>
                    </div>
                    
                    <div class="compare-item">
                        <h4 style="color:var(--purple);">Rational Numbers</h4>
                        <p style="margin:10px 0;">Deep dive into rational number theory and continued fractions.</p>
                        <a href="https://wessengetachew.github.io/Rational-/" target="_blank" style="display:inline-block; padding:8px 16px; background:var(--purple); color:white; text-decoration:none; border-radius:6px; margin-top:10px;">Visit Project</a>
                    </div>
                    
                    <div class="compare-item">
                        <h4 style="color:var(--purple);">1/2 Density</h4>
                        <p style="margin:10px 0;">Analysis of half-density phenomena in number theory.</p>
                        <a href="https://wessengetachew.github.io/1-2/" target="_blank" style="display:inline-block; padding:8px 16px; background:var(--purple); color:white; text-decoration:none; border-radius:6px; margin-top:10px;">Visit Project</a>
                    </div>
                </div>
                
                <h3 style="color:var(--orange); margin-top:30px;">Geometric Number Theory</h3>
                <div class="compare-grid">
                    <div class="compare-item">
                        <h4 style="color:var(--orange);">Pythagorean Triples</h4>
                        <p style="margin:10px 0;">Complete analysis of Pythagorean triples and right triangle geometry.</p>
                        <a href="https://wessengetachew.github.io/Pythagorean-/" target="_blank" style="display:inline-block; padding:8px 16px; background:var(--orange); color:white; text-decoration:none; border-radius:6px; margin-top:10px;">Visit Project</a>
                    </div>
                    
                    <div class="compare-item">
                        <h4 style="color:var(--orange);">Ethiopian Multiplication</h4>
                        <p style="margin:10px 0;">Ancient multiplication algorithms and binary number patterns.</p>
                        <a href="https://wessengetachew.github.io/Ethiopian/" target="_blank" style="display:inline-block; padding:8px 16px; background:var(--orange); color:white; text-decoration:none; border-radius:6px; margin-top:10px;">Visit Project</a>
                    </div>
                </div>
                
                <h3 style="color:var(--red); margin-top:30px;">Advanced Topics & Transforms</h3>
                <div class="compare-grid">
                    <div class="compare-item">
                        <h4 style="color:var(--red);">Infinite Moduli</h4>
                        <p style="margin:10px 0;">Exploration of infinite modular arithmetic systems and patterns.</p>
                        <a href="https://wessengetachew.github.io/Infinitemoduli/" target="_blank" style="display:inline-block; padding:8px 16px; background:var(--red); color:white; text-decoration:none; border-radius:6px; margin-top:10px;">Visit Project</a>
                    </div>
                    
                    <div class="compare-item">
                        <h4 style="color:var(--red);">Transform Analysis</h4>
                        <p style="margin:10px 0;">Mathematical transforms and their applications to number theory.</p>
                        <a href="https://wessengetachew.github.io/Transform/" target="_blank" style="display:inline-block; padding:8px 16px; background:var(--red); color:white; text-decoration:none; border-radius:6px; margin-top:10px;">Visit Project</a>
                    </div>
                    
                    <div class="compare-item">
                        <h4 style="color:var(--red);">Phase Visualization</h4>
                        <p style="margin:10px 0;">Phase space analysis of arithmetic functions and sequences.</p>
                        <a href="https://wessengetachew.github.io/Phase/" target="_blank" style="display:inline-block; padding:8px 16px; background:var(--red); color:white; text-decoration:none; border-radius:6px; margin-top:10px;">Visit Project</a>
                    </div>
                    
                    <div class="compare-item">
                        <h4 style="color:var(--red);">Gemini Patterns</h4>
                        <p style="margin:10px 0;">Twin and dual structures in number theory.</p>
                        <a href="https://wessengetachew.github.io/Gemini/" target="_blank" style="display:inline-block; padding:8px 16px; background:var(--red); color:white; text-decoration:none; border-radius:6px; margin-top:10px;">Visit Project</a>
                    </div>
                    
                    <div class="compare-item">
                        <h4 style="color:var(--red);">Rebuild Framework</h4>
                        <p style="margin:10px 0;">Reconstruction and synthesis of mathematical structures.</p>
                        <a href="https://wessengetachew.github.io/Rebuild/" target="_blank" style="display:inline-block; padding:8px 16px; background:var(--red); color:white; text-decoration:none; border-radius:6px; margin-top:10px;">Visit Project</a>
                    </div>
                </div>
                
                <div class="formula" style="margin-top:40px; background:linear-gradient(135deg, rgba(0,102,204,0.1), rgba(111,66,193,0.1)); border-left:4px solid var(--blue);">
                    <h3 style="color:var(--blue);">About These Projects</h3>
                    <p>All visualizations are created by <b>Wessen Getachew</b> (<a href="https://twitter.com/7dview" target="_blank" style="color:var(--blue);">@7dview</a>) as part of an ongoing research initiative into the geometric and visual aspects of number theory.</p>
                    <p style="margin-top:10px;">Each project combines:</p>
                    <p>- Rigorous mathematical theory</p>
                    <p>- Interactive web-based visualizations</p>
                    <p>- High-performance computational algorithms</p>
                    <p>- Educational accessibility</p>
                    <p>- Professional-grade export capabilities</p>
                    
                    <p style="margin-top:15px; font-style:italic;">These tools are designed for mathematicians, researchers, educators, and anyone curious about the hidden patterns in numbers.</p>
                </div>
                
                <div class="section" style="margin-top:30px; text-align:center;">
                    <h3>Quick Navigation</h3>
                    <p style="margin:15px 0;">Jump to any visualization category:</p>
                    <div style="display:flex; gap:10px; justify-content:center; flex-wrap:wrap; margin-top:20px;">
                        <button onclick="window.open('https://wessengetachew.github.io/GCD/', '_blank')" style="padding:10px 20px; background:var(--blue); color:white; border:none; border-radius:6px; cursor:pointer;">GCD Explorer</button>
                        <button onclick="window.open('https://wessengetachew.github.io/Farey/', '_blank')" style="padding:10px 20px; background:var(--purple); color:white; border:none; border-radius:6px; cursor:pointer;">Farey Sequences</button>
                        <button onclick="window.open('https://wessengetachew.github.io/Primes/', '_blank')" style="padding:10px 20px; background:var(--green); color:white; border:none; border-radius:6px; cursor:pointer;">Prime Patterns</button>
                        <button onclick="window.open('https://wessengetachew.github.io/Pythagorean-/', '_blank')" style="padding:10px 20px; background:var(--orange); color:white; border:none; border-radius:6px; cursor:pointer;">Pythagorean Triples</button>
                        <button onclick="window.open('https://wessengetachew.github.io/Goldbach/', '_blank')" style="padding:10px 20px; background:var(--red); color:white; border:none; border-radius:6px; cursor:pointer;">Goldbach Conjecture</button>
                    </div>
                </div>
            </div>
        </div>

        <div id="tools" class="panel">
            <div class="section">
                <h2>Mathematical Tools <span class="help-icon tooltip" data-tip="Number theory utilities">?</span></h2>
                
                <h3>GCD Calculator</h3>
                <div class="controls">
                    <div style="display:flex; gap:8px; margin-bottom:10px; flex-wrap:wrap;">
                        <button onclick="setGCDPreset('coprime')" style="padding:6px 12px; font-size:0.9em;">Coprime Example</button>
                        <button onclick="setGCDPreset('common')" style="padding:6px 12px; font-size:0.9em;">Common Factor</button>
                        <button onclick="setGCDPreset('large')" style="padding:6px 12px; font-size:0.9em;">Large Numbers</button>
                        <button onclick="setGCDPreset('many')" style="padding:6px 12px; font-size:0.9em;">Many Numbers</button>
                    </div>
                    <input type="text" id="gi" placeholder="12, 18, 24" style="width:100%; padding:10px">
                    <button onclick="calcGCD()">Calculate</button>
                    <div id="gr" style="margin-top:15px"></div>
                </div>

                <h3>M√∂bius Function Œº(n)</h3>
                <div class="controls">
                    <div style="display:flex; gap:8px; margin-bottom:10px; flex-wrap:wrap;">
                        <button onclick="setMobiusPreset('squarefree')" style="padding:6px 12px; font-size:0.9em;">Square-free</button>
                        <button onclick="setMobiusPreset('notsquarefree')" style="padding:6px 12px; font-size:0.9em;">Not Square-free</button>
                        <button onclick="setMobiusPreset('prime')" style="padding:6px 12px; font-size:0.9em;">Prime Number</button>
                        <button onclick="setMobiusPreset('composite')" style="padding:6px 12px; font-size:0.9em;">Large Composite</button>
                    </div>
                    <input type="number" id="mi" placeholder="30" style="width:100%; padding:10px" min="1">
                    <button onclick="calcMobius()">Calculate</button>
                    <div id="mr2" style="margin-top:15px"></div>
                </div>

                <h3>Prime Factorization</h3>
                <div class="controls">
                    <div style="display:flex; gap:8px; margin-bottom:10px; flex-wrap:wrap;">
                        <button onclick="setPrimePreset('small')" style="padding:6px 12px; font-size:0.9em;">Small Number</button>
                        <button onclick="setPrimePreset('perfect')" style="padding:6px 12px; font-size:0.9em;">Perfect Number</button>
                        <button onclick="setPrimePreset('highly')" style="padding:6px 12px; font-size:0.9em;">Highly Composite</button>
                        <button onclick="setPrimePreset('large')" style="padding:6px 12px; font-size:0.9em;">Large Number</button>
                        <button onclick="setPrimePreset('power')" style="padding:6px 12px; font-size:0.9em;">Prime Power</button>
                    </div>
                    <input type="number" id="pi" placeholder="360" style="width:100%; padding:10px" min="2">
                    <button onclick="calcPrime()">Factorize</button>
                    <div id="pr" style="margin-top:15px"></div>
                </div>

                <h3>Coprimality Checker</h3>
                <div class="controls">
                    <div style="display:flex; gap:8px; margin-bottom:10px; flex-wrap:wrap;">
                        <button onclick="setCoprimePreset('coprime2')" style="padding:6px 12px; font-size:0.9em;">Coprime Pair</button>
                        <button onclick="setCoprimePreset('notcoprime2')" style="padding:6px 12px; font-size:0.9em;">Non-Coprime Pair</button>
                        <button onclick="setCoprimePreset('coprime3')" style="padding:6px 12px; font-size:0.9em;">Coprime Triple</button>
                        <button onclick="setCoprimePreset('consecutive')" style="padding:6px 12px; font-size:0.9em;">Consecutive Numbers</button>
                    </div>
                    <input type="text" id="cci" placeholder="15, 28" style="width:100%; padding:10px">
                    <button onclick="checkCoprime()">Check</button>
                    <div id="ccr" style="margin-top:15px"></div>
                </div>

                <h3>Point Search</h3>
                <div class="controls">
                    <div style="display:flex; gap:8px; margin-bottom:10px; flex-wrap:wrap;">
                        <button onclick="setPointPreset('pythagorean')" style="padding:6px 12px; font-size:0.9em;">Pythagorean Triple</button>
                        <button onclick="setPointPreset('primitive2d')" style="padding:6px 12px; font-size:0.9em;">Primitive 2D</button>
                        <button onclick="setPointPreset('nonprimitive2d')" style="padding:6px 12px; font-size:0.9em;">Non-Primitive 2D</button>
                        <button onclick="setPointPreset('primitive3d')" style="padding:6px 12px; font-size:0.9em;">Primitive 3D</button>
                        <button onclick="setPointPreset('highd')" style="padding:6px 12px; font-size:0.9em;">High-D Point</button>
                    </div>
                    <input type="text" id="psi" placeholder="3, 4 (finds if primitive)" style="width:100%; padding:10px">
                    <button onclick="searchPoint()">Search</button>
                    <div id="psr" style="margin-top:15px"></div>
                </div>
            </div>
        </div>

        <div id="animation" class="panel">
            <div class="section">
                <h2>Animation Player üé¨ <span class="help-icon tooltip" data-tip="Animate through parameters">?</span></h2>
                <p>Create animations by sweeping through radii, dimensions, or moduli. Perfect for presentations and pattern exploration.</p>
                
                <div class="controls">
                    <div style="background:var(--bg3); padding:20px; border-radius:8px; margin-bottom:20px;">
                        <h3 style="color:var(--blue); margin-bottom:15px;">Animation Type</h3>
                        <div style="display:grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap:10px; margin-bottom:20px;">
                            <button id="animRadius" class="active" onclick="setAnimType('radius')" style="padding:12px;">Radius Sweep</button>
                            <button id="animDimension" onclick="setAnimType('dimension')" style="padding:12px;">Dimension Sweep</button>
                            <button id="animModular" onclick="setAnimType('modular')" style="padding:12px;">Modular Pattern</button>
                        </div>
                        
                        <div id="radiusAnimControls">
                            <label>Start Radius: <span id="animStartRv">5</span></label>
                            <input type="range" id="animStartR" min="1" max="100" value="5" step="1" oninput="document.getElementById('animStartRv').textContent=this.value">
                            
                            <label style="margin-top:10px;">End Radius: <span id="animEndRv">50</span></label>
                            <input type="range" id="animEndR" min="5" max="200" value="50" step="1" oninput="document.getElementById('animEndRv').textContent=this.value">
                            
                            <label style="margin-top:10px;">Dimension k: <span id="animKv">2</span></label>
                            <input type="range" id="animK" min="2" max="5" value="2" step="1" oninput="document.getElementById('animKv').textContent=this.value">
                        </div>
                        
                        <div id="dimensionAnimControls" style="display:none;">
                            <label>Start Dimension: <span id="animStartDv">2</span></label>
                            <input type="range" id="animStartD" min="2" max="10" value="2" step="1" oninput="document.getElementById('animStartDv').textContent=this.value">
                            
                            <label style="margin-top:10px;">End Dimension: <span id="animEndDv">8</span></label>
                            <input type="range" id="animEndD" min="2" max="12" value="8" step="1" oninput="document.getElementById('animEndDv').textContent=this.value">
                            
                            <label style="margin-top:10px;">Fixed Radius: <span id="animFixedRv">30</span></label>
                            <input type="range" id="animFixedR" min="10" max="100" value="30" step="5" oninput="document.getElementById('animFixedRv').textContent=this.value">
                        </div>
                        
                        <div id="modularAnimControls" style="display:none;">
                            <label>Start Modulus: <span id="animStartMv">2</span></label>
                            <input type="range" id="animStartM" min="2" max="20" value="2" step="1" oninput="document.getElementById('animStartMv').textContent=this.value">
                            
                            <label style="margin-top:10px;">End Modulus: <span id="animEndMv">12</span></label>
                            <input type="range" id="animEndM" min="2" max="30" value="12" step="1" oninput="document.getElementById('animEndMv').textContent=this.value">
                        </div>
                        
                        <label style="margin-top:20px;"><b>Animation Speed:</b> <span id="animSpeedv">500</span>ms per step</label>
                        <input type="range" id="animSpeed" min="50" max="2000" value="500" step="50" oninput="document.getElementById('animSpeedv').textContent=this.value">
                        
                        <div style="margin-top:20px;">
                            <h4 style="color:var(--blue); margin-bottom:10px;">Quick Presets</h4>
                            <div style="display:flex; gap:8px; flex-wrap:wrap;">
                                <button onclick="setAnimPreset('quick')" style="padding:8px 12px;">R: 1‚Üí30 (Fast)</button>
                                <button onclick="setAnimPreset('medium')" style="padding:8px 12px;">R: 1‚Üí60 (Medium)</button>
                                <button onclick="setAnimPreset('long')" style="padding:8px 12px;">R: 1‚Üí100 (Slow)</button>
                                <button onclick="setAnimPreset('dimensions')" style="padding:8px 12px;">k: 2‚Üí10</button>
                            </div>
                        </div>
                    </div>
                    
                    <div style="text-align:center; margin:20px 0;">
                        <button id="playBtn" onclick="playAnimation()" style="padding:15px 30px; font-size:1.1em; background:var(--green);">‚ñ∂ Play</button>
                        <button id="pauseBtn" onclick="pauseAnimation()" style="padding:15px 30px; font-size:1.1em; background:var(--yellow); display:none;">‚è∏ Pause</button>
                        <button id="stopBtn" onclick="stopAnimation()" style="padding:15px 30px; font-size:1.1em; background:var(--red); display:none;">‚èπ Stop</button>
                    </div>
                    
                    <div id="animProgress" style="background:var(--bg3); padding:15px; border-radius:8px; display:none;">
                        <div style="background:var(--bg); height:30px; border-radius:6px; overflow:hidden; margin-bottom:10px;">
                            <div id="animProgressBar" style="background:linear-gradient(90deg, var(--blue), var(--purple)); height:100%; width:0%; transition:width 0.3s;"></div>
                        </div>
                        <p style="text-align:center; margin:0;"><span id="animCurrentStep">0</span> / <span id="animTotalSteps">0</span> (<span id="animPercent">0</span>%)</p>
                    </div>
                </div>
                
                <div style="margin-top:20px;">
                    <h3 style="color:var(--blue); margin-bottom:15px;">Animation Preview</h3>
                    <canvas id="animCanvas" width="800" height="800" style="max-width:100%; border:2px solid var(--border); border-radius:8px;"></canvas>
                    
                    <div class="stats" id="animStats" style="margin-top:20px;">
                        <div class="stat"><div class="val" id="animParamVal">-</div><div class="lbl" id="animParamLabel">Current Value</div></div>
                        <div class="stat"><div class="val" id="animPrimCount">0</div><div class="lbl">Primitive Points</div></div>
                        <div class="stat"><div class="val" id="animTotalCount">0</div><div class="lbl">Total Points</div></div>
                        <div class="stat"><div class="val" id="animDensity">0%</div><div class="lbl">Density</div></div>
                        <div class="stat"><div class="val" id="animZeta">-</div><div class="lbl">Œ∂(k) or 1/Œ∂(k)</div></div>
                    </div>
                </div>
                
                <div class="formula" style="margin-top:20px;">
                    <p><b>Animation Types:</b></p>
                    <p>‚Ä¢ <b>Radius Sweep:</b> Watch primitive lattice points grow as radius increases from start to end</p>
                    <p>‚Ä¢ <b>Dimension Sweep:</b> See how density approaches 100% as dimension k increases</p>
                    <p>‚Ä¢ <b>Modular Pattern:</b> Observe how residue class distributions change with modulus</p>
                </div>
            </div>
        </div>

        <div id="export" class="panel">
            <div class="section">
                <h2>Advanced Export Center <span class="help-icon tooltip" data-tip="Professional export with titles and legends">?</span></h2>
                <p>Export high-resolution images with custom titles, subtitles, and legends. Choose resolution and canvas to export.</p>
                
                <div class="controls">
                    <div style="background:var(--bg3); padding:20px; border-radius:8px; margin-bottom:20px;">
                        <h3 style="color:var(--blue); margin-bottom:15px;">Export Settings</h3>
                        
                        <label><b>Export Type:</b></label>
                        <select id="exportType" onchange="updateExportType()" style="width:100%; padding:10px; margin:10px 0; border-radius:6px; background:var(--bg); color:var(--text); border:1px solid var(--border);">
                            <option value="single">Single Canvas</option>
                            <option value="grid2x2">2√ó2 Grid (4 Canvases)</option>
                            <option value="fullAnalysis">Full Analysis Panel</option>
                        </select>
                        
                        <div id="singleCanvasControls">
                            <label><b>Canvas to Export:</b></label>
                            <select id="exportCanvas" style="width:100%; padding:10px; margin:10px 0; border-radius:6px; background:var(--bg); color:var(--text); border:1px solid var(--border);">
                                <option value="c2d">2D Lattice Visualization</option>
                                <option value="heatmapCanvas">GCD Heatmap</option>
                                <option value="gcdTableCanvas">GCD Multiplication Table</option>
                                <option value="criticalCanvas">Critical Strip Analysis</option>
                                <option value="patternCanvas">Pattern Visualization</option>
                                <option value="densityCanvas">Density Distribution</option>
                                <option value="angularCanvas">Angular Distribution</option>
                                <option value="radialCanvas">Radial Shell Analysis</option>
                                <option value="compChart">Dimension Comparison Chart</option>
                                <option value="ch">Error Analysis Chart</option>
                            </select>
                        </div>
                        
                        <label style="margin-top:15px;"><b>Resolution:</b></label>
                        <div style="display:grid; grid-template-columns: repeat(auto-fit, minmax(100px, 1fr)); gap:10px; margin:10px 0;">
                            <button id="res2k" onclick="setExportRes('2k')" style="padding:10px;">2K (2048px)</button>
                            <button id="res4k" class="active" onclick="setExportRes('4k')" style="padding:10px;">4K (3840px)</button>
                            <button id="res8k" onclick="setExportRes('8k')" style="padding:10px;">8K (7680px)</button>
                        </div>
                        
                        <label style="margin-top:15px;"><b>Title:</b></label>
                        <input type="text" id="exportTitle" placeholder="e.g., Primitive Lattice Point Distribution" style="width:100%; padding:10px; margin:5px 0; border-radius:6px; background:var(--bg); color:var(--text); border:1px solid var(--border);">
                        
                        <label style="margin-top:10px;"><b>Subtitle:</b></label>
                        <input type="text" id="exportSubtitle" placeholder="e.g., R=100, k=2, showing GCD patterns" style="width:100%; padding:10px; margin:5px 0; border-radius:6px; background:var(--bg); color:var(--text); border:1px solid var(--border);">
                        
                        <label style="margin-top:10px;"><b>Legend/Description:</b></label>
                        <textarea id="exportLegend" placeholder="Blue: Primitive (GCD=1)
Red: Non-Primitive (GCD>1)
Total Points: 12,345
Density: 60.79%" style="width:100%; padding:10px; margin:5px 0; border-radius:6px; background:var(--bg); color:var(--text); border:1px solid var(--border); min-height:100px; font-family:monospace;"></textarea>
                        
                        <label style="margin-top:10px;"><b>Decimal Precision:</b></label>
                        <div style="display:flex; gap:10px; align-items:center; margin:10px 0;">
                            <input type="range" id="exportPrecision" min="2" max="17" value="6" step="1" oninput="document.getElementById('exportPrecisionv').textContent=this.value" style="flex:1;">
                            <span id="exportPrecisionv" style="min-width:30px;">6</span>
                            <span style="font-size:0.9em; color:var(--text2);">decimal places</span>
                        </div>
                        
                        <div style="margin-top:15px;">
                            <label style="display:flex; align-items:center; gap:8px;">
                                <input type="checkbox" id="includeMetadata" checked> Include Title & Legend
                            </label>
                            <label style="display:flex; align-items:center; gap:8px; margin-top:8px;">
                                <input type="checkbox" id="includeTimestamp" checked> Include Timestamp
                            </label>
                            <label style="display:flex; align-items:center; gap:8px; margin-top:8px;">
                                <input type="checkbox" id="includeWatermark" checked> Include "By Wessen Getachew | @7dview"
                            </label>
                            <label style="display:flex; align-items:center; gap:8px; margin-top:8px;">
                                <input type="checkbox" id="includeFullPrecision" checked> Include Full Precision Values
                            </label>
                        </div>
                    </div>
                    
                    <div style="background:var(--bg3); padding:20px; border-radius:8px; margin-bottom:20px;">
                        <h3 style="color:var(--blue); margin-bottom:15px;">Quick Export Presets</h3>
                        <div style="display:grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap:10px;">
                            <button onclick="quickExport2D()" style="padding:12px;">Export Current 2D View</button>
                            <button onclick="quickExport3D()" style="padding:12px;">Export Current 3D View</button>
                            <button onclick="quickExportHeatmap()" style="padding:12px;">Export GCD Heatmap</button>
                            <button onclick="quickExportCritical()" style="padding:12px;">Export Critical Strip</button>
                            <button onclick="quickExportTable()" style="padding:12px;">Export GCD Table</button>
                            <button onclick="quickExportAnalysis()" style="padding:12px;">Export Error Analysis</button>
                            <button onclick="quickExportGrid2x2()" style="padding:12px; background:var(--purple); color:white;">Export 2√ó2 Grid</button>
                            <button onclick="quickExportFullAnalysis()" style="padding:12px; background:var(--green); color:white;">Export Full Panel</button>
                        </div>
                    </div>
                    
                    <div style="text-align:center; margin-top:20px;">
                        <button onclick="performAdvancedExport()" style="padding:15px 40px; font-size:1.1em; background:var(--green); color:white;">
                            Export with Metadata
                        </button>
                    </div>
                </div>
                
                <div id="exportPreview" style="background:var(--bg3); padding:20px; border-radius:8px; margin-top:20px; min-height:200px; text-align:center;">
                    <p style="color:var(--text2); font-style:italic;">Export preview will appear here</p>
                    <canvas id="exportPreviewCanvas" style="max-width:100%; margin-top:20px; display:none; border:2px solid var(--border); border-radius:8px;"></canvas>
                </div>
                
                <div class="formula" style="margin-top:20px;">
                    <p><b>Export Features:</b></p>
                    <p>- High-resolution output (up to 8K: 7680√ó4320)</p>
                    <p>- Custom titles, subtitles, and legends</p>
                    <p>- Automatic parameter documentation</p>
                    <p>- Clean layout without overlap</p>
                    <p>- Professional formatting for publications</p>
                    <p>- Timestamp and attribution options</p>
                    <p>- Configurable decimal precision (2-17 places)</p>
                    <p>- Full precision data preservation</p>
                    
                    <p style="margin-top:15px;"><b>CSV Export Features:</b></p>
                    <p>- Descriptive headers with metadata</p>
                    <p>- ISO 8601 timestamps</p>
                    <p>- Full attribution and licensing info</p>
                    <p>- Up to 17 decimal places for high-k dimensions</p>
                    <p>- Comment lines (# prefix) for documentation</p>
                    <p>- Automatic precision selection based on dimension</p>
                </div>
            </div>
        </div>

        <div id="farey" class="panel">
            <div class="section">
                <h2>Farey Sequences & Visible Points <span class="help-icon tooltip" data-tip="Rational approximations and coprime fractions">?</span></h2>
                <p>The Farey sequence F_n contains all reduced fractions p/q where 0 ‚â§ p ‚â§ q ‚â§ n. These correspond to primitive lattice points and visible points from the origin.</p>
                
                <div class="controls">
                    <label>Order n: <span id="fareyNv">10</span></label>
                    <div style="display:flex; gap:10px; align-items:center; margin-bottom:15px;">
                        <input type="range" id="fareyN" min="2" max="100" value="10" step="1" oninput="updateFareyN()" style="flex:1;">
                        <input type="number" id="fareyNInput" min="2" max="200" value="10" style="width:100px; padding:8px;" oninput="updateFareyN()">
                    </div>
                    
                    <div style="background:var(--bg3); padding:15px; border-radius:8px; margin-bottom:15px;">
                        <label style="font-size:1.1em; color:var(--blue); margin-bottom:10px; display:block;"><b>Visualization:</b></label>
                        <div style="display:grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap:8px;">
                            <button id="fareyList" class="active" onclick="setFareyViz('list')" style="padding:10px;">Sequence List</button>
                            <button id="fareyCircle" onclick="setFareyViz('circle')" style="padding:10px;">Ford Circles</button>
                            <button id="fareyTree" onclick="setFareyViz('tree')" style="padding:10px;">Stern-Brocot Tree</button>
                        </div>
                    </div>
                    
                    <button onclick="computeFarey()">Generate Sequence</button>
                    <button onclick="exportFareyData()">Export Data</button>
                </div>
                
                <div class="stats">
                    <div class="stat"><div class="val" id="fareyCount">0</div><div class="lbl">Fractions in F_n</div></div>
                    <div class="stat"><div class="val" id="fareySum">0</div><div class="lbl">Sum of œÜ(k)</div></div>
                    <div class="stat"><div class="val" id="fareyDensity">0%</div><div class="lbl">Density</div></div>
                    <div class="stat"><div class="val" id="fareyMediant">N/A</div><div class="lbl">Sample Mediant</div></div>
                </div>
                
                <canvas id="fareyCanvas" width="1200" height="600" style="max-width:100%;"></canvas>
                
                <div class="formula" style="margin-top:20px;">
                    <p><b>Farey Sequence Properties:</b></p>
                    <p>‚Ä¢ F_n = {p/q : 0 ‚â§ p ‚â§ q ‚â§ n, gcd(p,q) = 1}</p>
                    <p>‚Ä¢ |F_n| = 1 + Œ£_{k=1}^n œÜ(k) where œÜ is Euler's totient</p>
                    <p>‚Ä¢ Mediant property: If p/q and r/s are consecutive in F_n, then (p+r)/(q+s) appears in F_{q+s}</p>
                    <p>‚Ä¢ Connection to continued fractions and best rational approximations</p>
                    <p>‚Ä¢ Ford circles: Circle at p/q with radius 1/(2q¬≤) - consecutive circles are tangent</p>
                </div>
            </div>
        </div>
        
        <div id="session" class="panel">
            <div class="section">
                <h2>Save & Load Session <span class="help-icon tooltip" data-tip="Preserve your exploration state">?</span></h2>
                <p>Save your current parameters and visualization state to continue your research later or share configurations with others.</p>
                
                <div class="controls">
                    <h3 style="color:var(--blue);">Save Current Session</h3>
                    <label>Session Name:</label>
                    <input type="text" id="sessionName" placeholder="My Research - 2024-12-24" style="width:100%; padding:10px; margin:10px 0; border-radius:6px; background:var(--bg); color:var(--text); border:1px solid var(--border);">
                    
                    <label>Description (optional):</label>
                    <textarea id="sessionDesc" placeholder="Exploring primitive points with R=100, investigating GCD patterns..." style="width:100%; padding:10px; margin:10px 0; border-radius:6px; background:var(--bg); color:var(--text); border:1px solid var(--border); min-height:80px;"></textarea>
                    
                    <div style="margin:20px 0;">
                        <button onclick="saveSession()" style="padding:12px 30px; background:var(--green);">üíæ Save Session</button>
                        <button onclick="exportSession()" style="padding:12px 30px; background:var(--blue);">üì• Export to File</button>
                    </div>
                    
                    <h3 style="color:var(--blue); margin-top:30px;">Load Session</h3>
                    <label>Import from File:</label>
                    <input type="file" id="sessionFile" accept=".json" onchange="importSession()" style="margin:10px 0; padding:10px;">
                    
                    <div style="background:var(--bg3); padding:15px; border-radius:8px; margin-top:20px;">
                        <h4 style="color:var(--blue);">Saved Sessions</h4>
                        <div id="savedSessions" style="margin-top:10px;">
                            <p style="color:var(--text2); font-style:italic;">No saved sessions yet</p>
                        </div>
                    </div>
                    
                    <div style="margin-top:20px;">
                        <button onclick="clearAllSessions()" style="padding:10px 20px; background:var(--red);">üóëÔ∏è Clear All Sessions</button>
                    </div>
                </div>
                
                <div class="formula" style="margin-top:20px;">
                    <p><b>What Gets Saved:</b></p>
                    <p>‚Ä¢ All radius and dimension parameters</p>
                    <p>‚Ä¢ Color modes and visualization settings</p>
                    <p>‚Ä¢ Active tab and display preferences</p>
                    <p>‚Ä¢ Table sizes and configurations</p>
                    <p>‚Ä¢ Label and zoom settings</p>
                    <p><b>Note:</b> Sessions are stored in your browser's local storage and persist between visits.</p>
                </div>
            </div>
        </div>

        <div id="roadmap" class="panel">
            <div class="section">
                <h2>This tab has been removed</h2>
                <p>Features from the roadmap have been implemented throughout the platform. See the Farey Sequences tab and Save/Load Session tab for newly added functionality.</p>
            </div>
        </div>

        <div id="derivation" class="panel">
            <div class="section">
                <h2>Interactive Derivation</h2>
                
                <h3>Step 1: Counting Lattice Points</h3>
                <p>Start with all lattice points in a k-dimensional sphere of radius R:</p>
                <div class="formula">$$L_k(R) = |\{(x_1,...,x_k) \in \mathbb{Z}^k : x_1^2 + ... + x_k^2 \leq R^2\}|$$</div>
                <p>Asymptotically, this equals the volume: L_k(R) ~ V_k R^k</p>

                <h3>Step 2: Separating by GCD</h3>
                <p>Partition points by their greatest common divisor d:</p>
                <div class="formula">$$L_k(R) = \sum_{d=1}^{R} N_k(R/d)$$</div>
                <p>Where N_k(R/d) counts primitive points in a sphere of radius R/d.</p>

                <h3>Step 3: M√∂bius Inversion</h3>
                <p>Inverting the previous relation using M√∂bius function:</p>
                <div class="formula">$$N_k(R) = \sum_{d=1}^{R} \mu(d) L_k(R/d)$$</div>
                
                <h3>Step 4: Asymptotic Expansion</h3>
                <p>Substituting L_k(R/d) ~ V_k (R/d)^k:</p>
                <div class="formula">$$N_k(R) = V_k R^k \sum_{d=1}^{\infty} \frac{\mu(d)}{d^k} + O(R^{k-1})$$</div>

                <h3>Step 5: Zeta Connection</h3>
                <p>The sum equals the reciprocal of the zeta function:</p>
                <div class="formula">$$\sum_{d=1}^{\infty} \frac{\mu(d)}{d^k} = \frac{1}{\zeta(k)}$$</div>
                
                <h3>Final Result</h3>
                <div class="formula">$$N_k(R) = \frac{V_k R^k}{\zeta(k)} + O(R^{k-1})$$</div>
                <p>This elegant formula connects geometry (V_k), analysis (Œ∂(k)), and number theory (primitive points)!</p>
                
                <div class="section" style="margin-top: 30px; background: var(--bg2); padding: 30px; border-radius: 12px;">
                    <h3 style="color: var(--blue); margin-bottom: 20px;">Interactive Derivation Animation</h3>
                    <p>Watch the derivation unfold step-by-step, showing how M√∂bius inversion leads to the zeta function connection.</p>
                    
                    <div class="controls" style="margin-top: 20px;">
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; margin-bottom: 20px;">
                            <div>
                                <label>Radius R: <span id="derivRv">20</span></label>
                                <input type="range" id="derivR" min="5" max="50" value="20" step="1" oninput="updateDerivationParams()">
                            </div>
                            <div>
                                <label>Dimension k: <span id="derivKv">2</span></label>
                                <input type="range" id="derivK" min="2" max="4" value="2" step="1" oninput="updateDerivationParams()">
                            </div>
                            <div>
                                <label>Animation Speed: <span id="derivSpeedv">1000</span>ms</label>
                                <input type="range" id="derivSpeed" min="500" max="3000" value="1000" step="100" oninput="document.getElementById('derivSpeedv').textContent=this.value">
                            </div>
                        </div>
                        
                        <div style="text-align: center; margin: 20px 0;">
                            <button id="derivPlayBtn" onclick="playDerivation()" style="padding: 12px 24px; font-size: 1.1em; background: var(--green);">‚ñ∂ Play Animation</button>
                            <button id="derivPauseBtn" onclick="pauseDerivation()" style="padding: 12px 24px; font-size: 1.1em; background: var(--yellow); display: none;">‚è∏ Pause</button>
                            <button id="derivStopBtn" onclick="stopDerivation()" style="padding: 12px 24px; font-size: 1.1em; background: var(--red); display: none;">‚èπ Stop</button>
                            <button onclick="derivPrevStep()" style="padding: 12px 24px; margin-left: 20px;">‚óÄ Previous</button>
                            <button onclick="derivNextStep()" style="padding: 12px 24px;">Next ‚ñ∂</button>
                        </div>
                        
                        <div id="derivProgress" style="background: var(--bg3); padding: 15px; border-radius: 8px; margin: 20px 0;">
                            <div style="background: var(--bg); height: 30px; border-radius: 6px; overflow: hidden; margin-bottom: 10px;">
                                <div id="derivProgressBar" style="background: linear-gradient(90deg, var(--blue), var(--purple)); height: 100%; width: 0%; transition: width 0.3s;"></div>
                            </div>
                            <p style="text-align: center; margin: 0;">Step <span id="derivCurrentStep">1</span> of 7: <span id="derivStepName">Introduction</span></p>
                        </div>
                    </div>
                    
                    <canvas id="derivationCanvas" width="1200" height="600" style="max-width: 100%; border: 2px solid var(--border); border-radius: 8px; margin: 20px 0;"></canvas>
                    
                    <div id="derivationExplanation" style="background: var(--bg3); padding: 20px; border-radius: 8px; margin: 20px 0; min-height: 150px;">
                        <h4 style="color: var(--blue); margin-bottom: 10px;" id="derivStepTitle">Step 1: Count All Lattice Points</h4>
                        <p id="derivStepText">We begin by counting all lattice points (x,y) where x¬≤ + y¬≤ ‚â§ R¬≤. This gives us L_k(R), the total count including both primitive and non-primitive points.</p>
                    </div>
                    
                    <div class="stats" id="derivationStats">
                        <div class="stat"><div class="val" id="derivTotal">0</div><div class="lbl">Total Points L(R)</div></div>
                        <div class="stat"><div class="val" id="derivPrimitive">0</div><div class="lbl">Primitive Points N(R)</div></div>
                        <div class="stat"><div class="val" id="derivGCD">1</div><div class="lbl">Current GCD d</div></div>
                        <div class="stat"><div class="val" id="derivMobius">0</div><div class="lbl">Œº(d) Value</div></div>
                        <div class="stat"><div class="val" id="derivContribution">0</div><div class="lbl">Step Contribution</div></div>
                    </div>
                </div>
                
                <div style="margin-top:40px;">
                    <h3 style="color:var(--blue);">Bibliography & References</h3>
                    
                    <div class="formula">
                        <p><b>Hardy, G. H., & Wright, E. M.</b> (1979). <i>An Introduction to the Theory of Numbers</i>. Oxford University Press.</p>
                        <p style="margin-left:20px; font-size:0.9em; color:var(--text2);">Classical proofs for 6/œÄ¬≤ density and fundamental results in coprimality.</p>
                    </div>
                    
                    <div class="formula">
                        <p><b>Dirichlet, G. L.</b> (1849). <i>√úber die Bestimmung der mittleren Werthe in der Zahlentheorie</i>.</p>
                        <p style="margin-left:20px; font-size:0.9em; color:var(--text2);">Foundational work on lattice point problems and average values in number theory.</p>
                    </div>
                    
                    <div class="formula">
                        <p><b>Mertens, F.</b> (1874). <i>√úber einige asymptotische Gesetze der Zahlentheorie</i>.</p>
                        <p style="margin-left:20px; font-size:0.9em; color:var(--text2);">Refinement of error bounds in arithmetic sums and the Mertens function.</p>
                    </div>
                    
                    <div class="formula">
                        <p><b>Titchmarsh, E. C.</b> (1986). <i>The Theory of the Riemann Zeta-Function</i>. Oxford Science Publications.</p>
                        <p style="margin-left:20px; font-size:0.9em; color:var(--text2);">Connection between error terms and the Riemann Hypothesis.</p>
                    </div>
                    
                    <div class="formula">
                        <p><b>Ces√†ro, E.</b> (1883). <i>Probabilit√© de certains faits arithm√©tiques</i>.</p>
                        <p style="margin-left:20px; font-size:0.9em; color:var(--text2);">Early work on the probability interpretation of 6/œÄ¬≤.</p>
                    </div>
                    
                    <div class="formula">
                        <p><b>Pillai, S. S., & Chowla, S.</b> (1930). <i>On the Error Terms in Some Asymptotic Formulae</i>.</p>
                        <p style="margin-left:20px; font-size:0.9em; color:var(--text2);">Analysis of k=2 error bounds and refinements.</p>
                    </div>
                    
                    <div class="formula">
                        <p><b>van der Corput, J. G.</b> (1923). <i>Zahlentheoretische Absch√§tzungen</i>.</p>
                        <p style="margin-left:20px; font-size:0.9em; color:var(--text2);">Classical O(R^(2/3)) bound for the Gauss circle problem.</p>
                    </div>
                    
                    <div class="formula" style="margin-top:20px; background:linear-gradient(135deg, rgba(0,102,204,0.1), rgba(111,66,193,0.1));">
                        <p><b>Further Reading:</b></p>
                        <p>- Apostol, T. M. (1976). <i>Introduction to Analytic Number Theory</i>. Springer-Verlag.</p>
                        <p>- Nathanson, M. B. (1996). <i>Additive Number Theory: The Classical Bases</i>. Springer.</p>
                        <p>- Iwaniec, H., & Kowalski, E. (2004). <i>Analytic Number Theory</i>. American Mathematical Society.</p>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <button class="btn-fixed" id="helpBtn" onclick="showHelp()">Help</button>
    <button class="btn-fixed" id="darkBtn" onclick="toggleDark()">Light Mode</button>

    <div class="modal" id="helpModal">
        <div class="modal-content">
            <span class="modal-close" onclick="closeHelp()">&times;</span>
            <h2>Platform Guide</h2>
            <h3>Navigation</h3>
            <p>Use the tabs to explore different aspects of primitive lattice points.</p>
            
            <h3>GCD Heatmap</h3>
            <p><b>Interactive Features:</b></p>
            <p>- Click on any point to see detailed GCD information</p>
            <p>- Three display modes: by GCD value, primitive only, or distance gradient</p>
            <p>- Filter points by specific GCD values (1, 2, 3, or >3)</p>
            <p>- View statistics for each GCD category</p>
            <p>- Export point data for further analysis</p>
            <p>- Supports radius up to 1000 (use input box for large values)</p>
            
            <h3>GCD Table</h3>
            <p><b>Multiplication table showing GCD(row, col):</b></p>
            <p>- Click any cell to see GCD calculation details</p>
            <p>- Three color schemes: heat map, discrete GCD, prime powers</p>
            <p>- Toggle value display and diagonal highlighting</p>
            <p>- Observe symmetry and patterns in divisibility</p>
            <p>- Grid sizes from 5√ó5 up to 500√ó500</p>
            
            <h3>Modular Arithmetic Tables</h3>
            <p><b>Six different table types available:</b></p>
            <p>- <b>GCD Table:</b> Shows gcd(i,j) for all pairs</p>
            <p>- <b>Addition Mod n:</b> Cayley table for (‚Ñ§/n‚Ñ§, +)</p>
            <p>- <b>Multiplication Mod n:</b> Shows (i√ój) mod n</p>
            <p>- <b>Zero Divisors:</b> Highlights pairs where i√ój ‚â° 0 (mod n)</p>
            <p>- <b>Units:</b> Shows invertible elements (coprime to modulus)</p>
            <p>- <b>Euler's œÜ:</b> Displays œÜ(gcd(i,j))</p>
            <p><b>Five color schemes:</b> Heat Map, Discrete, Prime Powers, Binary, Rainbow</p>
            <p><b>Grid Rotation:</b> Rotate by 90¬∞ increments (0¬∞, 90¬∞, 180¬∞, 270¬∞) to view table from different quadrants and reveal symmetries</p>
            <p>- All tables support sizes up to 500√ó500</p>
            <p>- Click cells for detailed algebraic information</p>
            <p>- Export data for further analysis</p>
            
            <h3>2D Visualizations</h3>
            <p><b>Point Labeling Options:</b></p>
            <p>- <b>No Labels:</b> Clean visualization without text</p>
            <p>- <b>By GCD:</b> Shows GCD value for each point</p>
            <p>- <b>Coordinates:</b> Displays (x,y) for each point</p>
            <p>- <b>By Angle:</b> Shows angle in degrees from x-axis</p>
            <p>- Control font size (6-16px) and max labels (10-500)</p>
            <p>- Labels shown for points closest to origin</p>
            <p>- Supports radius up to 1000</p>
            
            <h3>Critical Strip Projection</h3>
            <p><b>Gauss Circle Problem & Riemann Hypothesis:</b></p>
            <p>- Choose between all lattice points or primitive points only</p>
            <p>- Four visualization types:</p>
            <p>&nbsp;&nbsp;- Error vs Radius: Shows Œî(R) oscillating around zero</p>
            <p>&nbsp;&nbsp;- Normalized: Œî(R)/R^(1/2) tests RH bound conjecture</p>
            <p>&nbsp;&nbsp;- Log-Log: Reveals power law relationships</p>
            <p>&nbsp;&nbsp;- With Bounds: Compares against theoretical bounds</p>
            <p>- Click on points to see detailed error analysis</p>
            <p>- RH bound (purple): O(R^(1/2)) - conjectured if RH is true</p>
            <p>- Classical bound (red): O(R^(2/3)) - proven result</p>
            <p>- Error sign indicates over/under counting vs prediction</p>
            
            <h3>2D Visualizations</h3>
            <p><b>View Modes:</b></p>
            <p>- <b>Colored by Mode:</b> Points colored according to selected coloring mode</p>
            <p>- <b>Gauss Circle Problem:</b> All lattice points in purple, comparing against œÄR¬≤</p>
            
            <p style="margin-top:15px;"><b>Coloring Modes (2D):</b></p>
            <p>- <b>GCD=1 vs GCD>1:</b> Blue for primitive (coprime), red for non-primitive</p>
            <p>- <b>By GCD Value:</b> Different color for each GCD (1=blue, 2=red, 3=green, 4=yellow, etc.)</p>
            <p>- <b>By Mod m:</b> Colors based on (x+y) mod m - reveals modular patterns</p>
            <p>- <b>By Quadrant:</b> Four colors for four quadrants (I=blue, II=green, III=yellow, IV=red)</p>
            <p>- <b>By Angular Sector:</b> Rainbow colors dividing circle into sectors</p>
            <p>- <b>GCD √ó Quadrant:</b> Combined coloring showing both GCD structure and spatial position</p>
            <p>- <b>GCD √ó Mod:</b> Combined coloring revealing GCD and modular arithmetic patterns</p>
            
            <p style="margin-top:15px;"><b>View Modes:</b></p>
            <p>‚Ä¢ <b>Colored by Mode:</b> Points colored according to selected coloring mode</p>
            <p>‚Ä¢ <b>Gauss Circle Problem:</b> All lattice points in purple, comparing against œÄR¬≤</p>
            <p>‚Ä¢ <b>GCD=1 vs GCD>1:</b> Blue for primitive (coprime), red for non-primitive</p>
            <p>‚Ä¢ <b>By GCD Value:</b> Different color for each GCD (1=blue, 2=red, 3=green, 4=yellow, etc.)</p>
            <p>‚Ä¢ <b>By Mod m:</b> Colors based on (x+y) mod m - reveals modular patterns</p>
            <p>‚Ä¢ <b>By Quadrant:</b> Four colors for four quadrants (I=blue, II=green, III=yellow, IV=red)</p>
            <p>‚Ä¢ <b>By Angular Sector:</b> Rainbow colors dividing circle into sectors</p>
            <p>‚Ä¢ <b>GCD √ó Quadrant:</b> Combined coloring showing both GCD structure and spatial position</p>
            <p>‚Ä¢ <b>GCD √ó Mod:</b> Combined coloring revealing GCD and modular arithmetic patterns</p>
            
            <h3>3D Visualizations</h3>
            <p><b>Camera Controls:</b></p>
            <p>- Click and drag to rotate view</p>
            <p>- Use zoom slider (30-150) to adjust camera distance</p>
            <p>- Reset button returns to default view</p>
            <p>- Auto-rotate button for continuous rotation</p>
            
            <p style="margin-top:10px;"><b>Point Labeling:</b></p>
            <p>- <b>No Labels:</b> Clean 3D view</p>
            <p>- <b>By GCD:</b> Shows GCD value on sprites</p>
            <p>- <b>Coordinates:</b> Displays (x,y,z) for each labeled point</p>
            <p>- Control max labels (10-200) to avoid clutter</p>
            <p>- Labels shown for points closest to origin</p>
            
            <p style="margin-top:10px;"><b>Boundary Shapes:</b></p>
            <p>- Sphere: Points within distance R (x¬≤+y¬≤+z¬≤ ‚â§ R¬≤)</p>
            <p>- Cube: Points within cube of side 2R (|x|,|y|,|z| ‚â§ R)</p>
            
            <p style="margin-top:15px;"><b>Coloring Modes (3D):</b></p>
            <p>- <b>GCD=1 vs GCD>1:</b> Blue for primitive, red for non-primitive</p>
            <p>- <b>By GCD Value:</b> Different colors for different GCD values</p>
            <p>- <b>By Mod m:</b> Colors based on (x+y+z) mod m</p>
            <p>- <b>By Octant:</b> Eight colors for eight octants in 3D space</p>
            <p>- <b>By Distance:</b> Gradient from center (blue) to boundary (red)</p>
            <p>- <b>GCD √ó Octant:</b> Combined coloring showing GCD and spatial structure</p>
            <p>- <b>GCD √ó Mod:</b> Combined GCD and modular arithmetic visualization</p>
            
            <p style="margin-top:10px;">Click and drag to rotate the view. Adjust point size for clarity.</p>
            
            <h3>Error Analysis</h3>
            <p>Shows error per radius value from start to max radius:</p>
            <p>- <b>Computes for EVERY single R value</b> (no skipping!) - this is the key improvement</p>
            <p>- <b>Absolute Error:</b> |Predicted - Actual| count of points</p>
            <p>- <b>Relative Error:</b> Percentage error relative to prediction</p>
            <p>- <b>Running Average:</b> Cumulative average of errors, shows convergence</p>
            <p>- <b>Boundary Term:</b> Theoretical O(R^(k-1)) error bound</p>
            <p>- <b>Actual Count:</b> The true primitive point count at each radius</p>
            <p>- <b>Click on chart points</b> to see detailed analysis for that radius</p>
            <p>- <b>Computation ranges:</b> k=2 exact up to R=200, k=3 up to R=40, k=4 up to R=15</p>
            
            <h3>Derivation Tab</h3>
            <p><b>Interactive Animation:</b></p>
            <p>- 7-step animated derivation showing how M√∂bius inversion leads to Œ∂(k)</p>
            <p>- Adjustable parameters: Radius R (5-50), Dimension k (2-4)</p>
            <p>- Animation controls: Play, Pause, Stop, Next, Previous</p>
            <p>- Variable speed: 500ms to 3000ms per step</p>
            <p><b>Steps covered:</b></p>
            <p>1. Count all lattice points L_k(R)</p>
            <p>2. Partition by GCD into classes</p>
            <p>3. Visualize specific GCD classes</p>
            <p>4. Introduce M√∂bius function Œº(d)</p>
            <p>5. Apply M√∂bius inversion formula</p>
            <p>6. Show boundary cancellation mechanism</p>
            <p>7. Arrive at final formula with Œ∂(k)</p>
            <p>- Real-time stats show counts and contributions at each step</p>
            <p>- 2D visualization shows actual points colored by GCD</p>
            <p>- Works for k=2, 3, 4 (higher dims show text explanation)</p>
            
            <h3>Animation Player Tab</h3>
            <p><b>Three animation types:</b></p>
            <p>- <b>Radius Sweep:</b> Animate R from start to end, watch pattern growth</p>
            <p>- <b>Dimension Sweep:</b> Animate k=2 to k=12, see density approach 1</p>
            <p>- <b>Modular Pattern:</b> Animate through moduli for pattern exploration</p>
            <p>- Progress bar shows current position in animation</p>
            <p>- All visualizations update in real-time during animation</p>
            <p>- Quick presets: 1‚Üí30, 1‚Üí60, 1‚Üí100, dimensions 2‚Üí10</p>
            
            <h3>Mathematical Presets Tab</h3>
            <p>Pre-configured cases for significant mathematical values:</p>
            <p>- <b>Classic Results:</b> Basel Problem, Ap√©ry's Constant, Gauss Circle</p>
            <p>- <b>Special Radii:</b> Fibonacci primes, Mersenne primes, Perfect numbers</p>
            <p>- <b>High Dimensions:</b> 4D, 8D (E‚Çà), 12D configurations</p>
            <p>- <b>Patterns:</b> Highly composite, prime fields, powers of 2</p>
            <p>- Click any preset to automatically configure all parameters</p>
            
            <h3>Enhanced Export System</h3>
            <p><b>Three export types:</b></p>
            <p>- <b>Single Canvas:</b> One visualization with comprehensive legend</p>
            <p>- <b>2√ó2 Grid:</b> Four canvases (2D, Heatmap, Critical Strip, Comparison)</p>
            <p>- <b>Full Analysis Panel:</b> Grid + extended statistics panel</p>
            <p><b>Resolutions:</b></p>
            <p>- 2K (2048√ó2048)</p>
            <p>- 4K (3840√ó3840) - Default</p>
            <p>- 8K (7680√ó7680)</p>
            <p>- All exports include metadata, legends, and attribution</p>
            
            <h3>Performance Tips</h3>
            <p>- All radius sliders support values up to 500 via number input</p>
            <p>- Keep radius ‚â§ 200 in 2D, ‚â§ 30 in 3D for smooth performance</p>
            <p>- Use zoom slider in 2D to focus on specific regions</p>
            <p>- Limit number of labels for large radius values</p>
            <p>- Use Export tab for high-resolution outputs</p>
            <p>- Compare mode shows multiple dimensions simultaneously</p>
            <p>- Modular arithmetic tables support sizes up to 500√ó500</p>
            <p>- For very large values, use number input boxes (not sliders)</p>
            
            <h3>Export Features</h3>
            <p><b>Advanced Export Center:</b></p>
            <p>- Export at 1K, 2K, 4K, or 8K resolution</p>
            <p>- Add custom titles, subtitles, and legends</p>
            <p>- Include timestamps and attribution</p>
            <p>- Clean layout optimized for publications</p>
            <p>- Quick export presets for each visualization</p>
            <p>- Preview before downloading</p>
            
            <h3>Explore More Tab</h3>
            <p><b>Related Mathematical Visualizations:</b></p>
            <p>- Links to 15+ related number theory visualization projects</p>
            <p>- Organized by category: Core Lattice Theory, Primes, Rationals, Geometry, Advanced Topics</p>
            <p>- Includes: Farey Sequences, Prime Patterns, Pythagorean Triples, Goldbach Conjecture, and more</p>
            <p>- Quick navigation buttons for popular projects</p>
            <p>- All projects by Wessen Getachew (@7dview)</p>
            
            <h3>Precision Display</h3>
            <p>- Higher dimensions (k>6) automatically show up to 17 decimal places</p>
            <p>- All CSV exports include full precision values (12-17 decimals)</p>
            <p>- Theory table shows maximum precision for each dimension</p>
            <p>- Export Center allows custom precision control (2-17 decimals)</p>
            <p>- All statistical values use appropriate precision</p>
            <p>- formatPrecise() removes trailing zeros for clean display</p>
            
            <h3>CSV Export Headers</h3>
            <p><b>All CSV files now include:</b></p>
            <p>- Descriptive header with parameters</p>
            <p>- Generation timestamp (ISO format)</p>
            <p>- Attribution line (Wessen Getachew | @7dview)</p>
            <p>- Column descriptions and formulas</p>
            <p>- Full precision numerical values</p>
            <p>- Metadata comments (lines starting with #)</p>
            
            <h3>Tools Section</h3>
            <p>Calculate GCD, M√∂bius function, prime factorizations, and search for specific lattice points.</p>
        </div>
    </div>

    <script>
        let scene, camera, renderer, chart, autoRotate = false;
        const cache = { mobius: new Map(), gcd: new Map(), points2D: null, points3D: null };
        let mouseDown = false, prevMouse = { x: 0, y: 0 };
        let view2D = 'primitive'; // 'primitive' or 'gauss'
        let comparisonMode = 'fixed'; // 'fixed' or 'multi'
        let comparisonChart = null;
        let shape3D = 'sphere'; // 'sphere' or 'cube'
        let colorMode3D = 'primitive'; // 'primitive', 'gcd', 'mod', 'octant', 'distance', 'gcdoct', 'gcdmod'
        let colorMode2D = 'primitive'; // 'primitive', 'gcd', 'mod', 'quadrant', 'angular', 'gcdquad', 'gcdmod'
        let patternType = 'modular'; // 'modular', 'density', 'angular', 'radial'
        let patternChart = null;
        let heatmapMode = 'gcd'; // 'gcd', 'primitive', 'gradient'
        let heatmapPointsData = [];
        let criticalProblem = 'all'; // 'all' or 'primitive'
        let criticalViz = 'error'; // 'error', 'normalized', 'loglog', 'bounds'
        let labelMode2D = 'none'; // 'none', 'gcd', 'coords', 'angle'
        let labelMode3D = 'none'; // 'none', 'gcd', 'coords'
        let zoom2D = 100; // percentage

        function gcd(a, b) {
            a = Math.abs(a); b = Math.abs(b);
            while (b) [a, b] = [b, a % b];
            return a;
        }

        function gcdArray(arr) { return arr.reduce((a, b) => gcd(a, b)); }

        function isPrime(n) {
            if (n < 2) return false;
            if (n === 2) return true;
            if (n % 2 === 0) return false;
            for (let i = 3; i <= Math.sqrt(n); i += 2)
                if (n % i === 0) return false;
            return true;
        }

        function primeFactors(n) {
            const f = []; let d = 2;
            while (n > 1) {
                while (n % d === 0) { f.push(d); n /= d; }
                d++; if (d * d > n && n > 1) { f.push(n); break; }
            }
            return f;
        }

        function mobius(n) {
            if (cache.mobius.has(n)) return cache.mobius.get(n);
            if (n === 1) return 1;
            const f = primeFactors(n), u = [...new Set(f)];
            const r = f.length !== u.length ? 0 : Math.pow(-1, f.length);
            cache.mobius.set(n, r);
            return r;
        }

        function zeta(k) {
            // High-precision values of Riemann zeta function
            // Values computed to 17+ significant digits for accuracy
            const zetaValues = {
                2: 1.6449340668482264364724151666460251892189499012067984377355582293700074704032008, // œÄ¬≤/6
                3: 1.2020569031595942853997381615114499907649862923404988817922715553418382057863130, // Ap√©ry's constant
                4: 1.0823232337111381915160036965203424602670358005245652215687744977325193292562626, // œÄ‚Å¥/90
                5: 1.0369277551433699263313654864570341680570930368059547801691618005453021345702497,
                6: 1.0173430619844491397145179297909205279018308170593810024936035944827810422974380, // œÄ‚Å∂/945
                7: 1.0083492773819228268397975498927010152708887038172326474908044957211762572377413,
                8: 1.0040773561979443393786852385086524652589112775723573726453156820341030294683245, // œÄ‚Å∏/9450
                9: 1.0020083928260822144178527692324120604207065913078842989761076837454184103963039,
                10: 1.0009945751278180853371459589003190170060195315644005132132960339870433067119427,
                11: 1.0004941886041194645587022825264699365289285294032152077349046639354051175474382,
                12: 1.0002460865533080482986379980477396709829901813802687684994526934234004984493218 // œÄ¬π¬≤/...
            };
            
            if (zetaValues[k]) {
                return zetaValues[k];
            }
            
            // For k > 12, use approximation Œ∂(k) ‚âà 1 + 2^(-k)
            return 1 + Math.pow(2, -k);
        }
        
        function getPiHighPrecision() {
            // œÄ to 50 decimal places
            return 3.14159265358979323846264338327950288419716939937510;
        }

        function sphereVolume(k, R) {
            if (k % 2 === 0) {
                // Even dimensions: V_k = œÄ^(k/2) / (k/2)!
                return Math.pow(Math.PI, k/2) / factorial(k/2) * Math.pow(R, k);
            } else {
                // Odd dimensions: V_k = 2^((k+1)/2) * œÄ^((k-1)/2) / k!!
                return Math.pow(2, (k+1)/2) * Math.pow(Math.PI, (k-1)/2) / doubleFactorial(k) * Math.pow(R, k);
            }
        }

        function factorial(n) {
            if (n <= 1) return 1;
            let res = 1;
            for (let i = 2; i <= n; i++) res *= i;
            return res;
        }

        function doubleFactorial(n) {
            if (n <= 1) return 1;
            let res = 1;
            for (let i = n; i >= 1; i -= 2) res *= i;
            return res;
        }

        function animateValue(id, start, end, duration = 500) {
            const el = document.getElementById(id);
            const range = end - start;
            const increment = range / (duration / 16);
            let current = start;
            const timer = setInterval(() => {
                current += increment;
                if ((increment > 0 && current >= end) || (increment < 0 && current <= end)) {
                    el.textContent = typeof end === 'number' && end % 1 !== 0 ? end.toFixed(3) : Math.round(end).toLocaleString();
                    clearInterval(timer);
                } else {
                    el.textContent = typeof current === 'number' && current % 1 !== 0 ? current.toFixed(3) : Math.round(current).toLocaleString();
                }
            }, 16);
        }

        function showTab(id) {
            document.querySelectorAll('.panel').forEach(p => p.classList.remove('active'));
            document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
            document.getElementById(id).classList.add('active');
            event.target.classList.add('active');
            if (id === 'viz2d') draw2D();
            if (id === 'viz3d' && !scene) init3D();
            if (id === 'comparison') updateComparison();
            if (id === 'patterns') {
                setPatternType('modular');
                updatePatternViz();
            }
            if (id === 'gcdheatmap') {
                updateGCDHeatmap();
            }
            if (id === 'gcdtable') {
                updateGCDTable();
            }
            if (id === 'criticalstrip') {
                updateCriticalStrip();
            }
            if (id === 'export') {
                // Populate export options based on current visualizations
                document.getElementById('exportPreviewCanvas').style.display = 'none';
                document.getElementById('exportPreview').querySelector('p').style.display = 'block';
            }
            if (id === 'roadmap') {
                // Roadmap is static content, no initialization needed
            }
            if (id === 'derivation') {
                // Initialize derivation animation
                if (!derivationData) {
                    computeDerivationData();
                }
                drawDerivationStep(0);
            }
        }

        function updateTheory() {
            const k = parseInt(document.getElementById('tks').value);
            const R = parseInt(document.getElementById('trs').value);
            document.getElementById('tk').textContent = k;
            document.getElementById('tr').textContent = R;
            const z = zeta(k), d = 1/z;
            const vol = sphereVolume(k, R);
            const pred = Math.round(vol / z);
            
            // Use high precision for k > 6
            const precision = k > 6 ? 17 : 6;
            document.getElementById('currentPrecision').textContent = precision;
            
            document.getElementById('sz').textContent = formatPrecise(z, precision);
            document.getElementById('sd').textContent = formatPrecise(d, precision);
            animateValue('sp', parseInt(document.getElementById('sp').textContent.replace(/,/g, '')) || pred, pred);
            document.getElementById('svol').textContent = formatPrecise(vol, precision);
        }

        function set2DView(mode) {
            view2D = mode;
            document.querySelectorAll('#viewPrimitive, #viewGauss').forEach(btn => btn.classList.remove('active'));
            document.getElementById(mode === 'primitive' ? 'viewPrimitive' : 'viewGauss').classList.add('active');
            draw2D();
        }

        function set2DColorMode(mode) {
            colorMode2D = mode;
            document.querySelectorAll('#color2DPrimitive, #color2DGCD, #color2DMod, #color2DQuadrant, #color2DAngular, #color2DGCDQuad, #color2DGCDMod').forEach(btn => btn.classList.remove('active'));
            const btnIds = {
                'primitive': 'color2DPrimitive',
                'gcd': 'color2DGCD',
                'mod': 'color2DMod',
                'quadrant': 'color2DQuadrant',
                'angular': 'color2DAngular',
                'gcdquad': 'color2DGCDQuad',
                'gcdmod': 'color2DGCDMod'
            };
            document.getElementById(btnIds[mode]).classList.add('active');
            
            // Show/hide modulus controls
            document.getElementById('modControls2D').style.display = (mode === 'mod' || mode === 'gcdmod') ? 'block' : 'none';
            document.getElementById('sectorControls2D').style.display = (mode === 'angular') ? 'block' : 'none';
            
            draw2D();
        }

        function update2DRadius(value) {
            const R = parseInt(value);
            if (R < 1 || R > 2000 || isNaN(R)) return;
            
            document.getElementById('r2v').textContent = R;
            document.getElementById('r2').value = Math.min(R, 500);
            document.getElementById('r2input').value = R;
            
            // Show performance warning
            document.getElementById('warn2d').style.display = R > 200 ? 'block' : 'none';
            
            draw2D();
        }
        
        function updateAllRadiusDisplays() {
            // Sync all radius displays
            const r2val = document.getElementById('r2input').value;
            document.getElementById('r2v').textContent = r2val;
        }

        function draw2D() {
            const canvas = document.getElementById('c2d'), ctx = canvas.getContext('2d');
            const R = parseInt(document.getElementById('r2input').value);
            const sz = parseInt(document.getElementById('ps').value);
            document.getElementById('r2v').textContent = R;
            document.getElementById('psv').textContent = sz;
            
            document.getElementById('warn2d').style.display = R > 200 ? 'block' : 'none';
            if (R > 250) {
                document.getElementById('load2d').classList.add('active');
            }
            
            setTimeout(() => {
                ctx.clearRect(0, 0, 1200, 1200);
                const cx = 600, cy = 600;
                const baseScale = 550/R;
                const sc = baseScale * (zoom2D / 100);
                ctx.strokeStyle = getComputedStyle(document.body).getPropertyValue('--border');
                ctx.lineWidth = 2;
                ctx.beginPath(); ctx.arc(cx, cy, R*sc, 0, 2*Math.PI); ctx.stroke();
                
                const allPoints = [];
                let prim = 0, tot = 0;
                
                // Collect all points with properties
                for (let x = -R; x <= R; x++) {
                    for (let y = -R; y <= R; y++) {
                        if (x*x + y*y <= R*R) {
                            tot++;
                            const g = gcd(Math.abs(x), Math.abs(y));
                            const isPrimitive = g === 1;
                            if (isPrimitive) prim++;
                            
                            // Calculate quadrant
                            let quadrant;
                            if (x >= 0 && y >= 0) quadrant = 1;
                            else if (x < 0 && y >= 0) quadrant = 2;
                            else if (x < 0 && y < 0) quadrant = 3;
                            else quadrant = 4;
                            
                            // Calculate angle (0 to 2œÄ)
                            const angle = Math.atan2(y, x) + Math.PI; // 0 to 2œÄ
                            
                            allPoints.push({
                                x, y, gcd: g, isPrimitive, quadrant, angle,
                                sum: x + y
                            });
                        }
                    }
                }
                
                // Group points by color based on mode
                const pointsByColor = {};
                const modulus = parseInt(document.getElementById('mod2D').value);
                const numSectors = parseInt(document.getElementById('sectors2D').value);
                
                allPoints.forEach(pt => {
                    let colorKey;
                    
                    if (view2D === 'gauss') {
                        colorKey = 'all';
                    } else {
                        switch(colorMode2D) {
                            case 'primitive':
                                colorKey = pt.isPrimitive ? 'prim' : 'nonprim';
                                break;
                            case 'gcd':
                                colorKey = `gcd${Math.min(pt.gcd, 8)}`;
                                break;
                            case 'mod':
                                colorKey = `mod${((pt.x + pt.y) % modulus + modulus) % modulus}`;
                                break;
                            case 'quadrant':
                                colorKey = `quad${pt.quadrant}`;
                                break;
                            case 'angular':
                                const sector = Math.floor(pt.angle / (2 * Math.PI / numSectors));
                                colorKey = `sector${sector}`;
                                break;
                            case 'gcdquad':
                                colorKey = `gcd${Math.min(pt.gcd, 4)}_q${pt.quadrant}`;
                                break;
                            case 'gcdmod':
                                const modVal = ((pt.x + pt.y) % modulus + modulus) % modulus;
                                colorKey = `gcd${Math.min(pt.gcd, 4)}_m${modVal}`;
                                break;
                        }
                    }
                    
                    if (!pointsByColor[colorKey]) pointsByColor[colorKey] = [];
                    pointsByColor[colorKey].push(pt);
                });
                
                // Define color palettes
                const colors = {
                    all: '#6f42c1',
                    prim: '#0066cc',
                    nonprim: '#dc3545',
                    gcd1: '#0066cc', gcd2: '#dc3545', gcd3: '#28a745', gcd4: '#ffc107',
                    gcd5: '#6f42c1', gcd6: '#fd7e14', gcd7: '#00d4ff', gcd8: '#ff006e',
                    quad1: '#0066cc', quad2: '#28a745', quad3: '#ffc107', quad4: '#dc3545',
                    mod0: '#0066cc', mod1: '#dc3545', mod2: '#28a745', mod3: '#ffc107',
                    mod4: '#6f42c1', mod5: '#fd7e14', mod6: '#00d4ff', mod7: '#ff006e',
                    mod8: '#20c997', mod9: '#e83e8c', mod10: '#17a2b8', mod11: '#6610f2'
                };
                
                // Generate sector colors (rainbow)
                for (let i = 0; i < 16; i++) {
                    const hue = (i / 16) * 360;
                    colors[`sector${i}`] = `hsl(${hue}, 70%, 50%)`;
                }
                
                // Generate combined colors
                const baseColors = ['#0066cc', '#dc3545', '#28a745', '#ffc107'];
                for (let g = 1; g <= 4; g++) {
                    for (let q = 1; q <= 4; q++) {
                        colors[`gcd${g}_q${q}`] = baseColors[(g - 1 + q - 1) % 4];
                    }
                    for (let m = 0; m < 12; m++) {
                        const hue = ((g - 1) * 90 + m * 30) % 360;
                        colors[`gcd${g}_m${m}`] = `hsl(${hue}, 65%, 50%)`;
                    }
                }
                
                // Draw points
                Object.entries(pointsByColor).forEach(([colorKey, points]) => {
                    ctx.fillStyle = colors[colorKey] || '#999';
                    points.forEach(pt => {
                        ctx.beginPath();
                        ctx.arc(cx + pt.x*sc, cy - pt.y*sc, sz, 0, 2*Math.PI);
                        ctx.fill();
                    });
                });
                
                cache.points2D = { primitive: allPoints.filter(p => p.isPrimitive), 
                                   nonPrimitive: allPoints.filter(p => !p.isPrimitive), R };
                
                // Draw labels if enabled
                if (labelMode2D !== 'none') {
                    const labelSize = parseInt(document.getElementById('labelSize2D').value);
                    const maxLabels = parseInt(document.getElementById('maxLabels2D').value);
                    document.getElementById('labelSize2Dv').textContent = labelSize;
                    document.getElementById('maxLabels2Dv').textContent = maxLabels;
                    
                    // Sort points by distance from origin
                    const sortedPoints = [...allPoints].sort((a, b) => 
                        (a.x*a.x + a.y*a.y) - (b.x*b.x + b.y*b.y)
                    ).slice(0, maxLabels);
                    
                    ctx.fillStyle = getComputedStyle(document.body).getPropertyValue('--text');
                    ctx.font = `${labelSize}px system-ui`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    
                    sortedPoints.forEach(pt => {
                        let label;
                        if (labelMode2D === 'gcd') {
                            label = pt.gcd.toString();
                        } else if (labelMode2D === 'coords') {
                            label = `(${pt.x},${pt.y})`;
                        } else if (labelMode2D === 'angle') {
                            const angle = Math.atan2(pt.y, pt.x) * 180 / Math.PI;
                            label = `${angle.toFixed(0)}¬∞`;
                        }
                        
                        const screenX = cx + pt.x*sc;
                        const screenY = cy - pt.y*sc;
                        
                        // Draw background for label
                        const metrics = ctx.measureText(label);
                        const labelWidth = metrics.width + 4;
                        const labelHeight = labelSize + 2;
                        ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                        ctx.fillRect(screenX - labelWidth/2, screenY - labelHeight/2, labelWidth, labelHeight);
                        
                        // Draw label text
                        ctx.fillStyle = '#fff';
                        ctx.fillText(label, screenX, screenY);
                    });
                }
                
                const pred = Math.round(Math.PI * R * R / zeta(2));
                const error = Math.abs(pred - prim);
                
                // Update stats based on view mode
                if (view2D === 'gauss') {
                    document.getElementById('p2').parentElement.querySelector('.lbl').textContent = 'Total Lattice Points';
                    animateValue('p2', 0, tot);
                    document.getElementById('t2').parentElement.querySelector('.lbl').textContent = 'Expected (œÄR¬≤)';
                    animateValue('t2', 0, Math.round(Math.PI * R * R));
                    document.getElementById('d2').parentElement.querySelector('.lbl').textContent = 'Error';
                    document.getElementById('d2').textContent = Math.abs(tot - Math.PI * R * R).toFixed(1);
                    document.getElementById('e2').parentElement.querySelector('.lbl').textContent = '% of Expected';
                    document.getElementById('e2').textContent = ((tot / (Math.PI * R * R)) * 100).toFixed(2) + '%';
                } else {
                    document.getElementById('p2').parentElement.querySelector('.lbl').textContent = 'Primitive Points';
                    animateValue('p2', 0, prim);
                    document.getElementById('t2').parentElement.querySelector('.lbl').textContent = 'Total Points';
                    animateValue('t2', 0, tot);
                    document.getElementById('d2').parentElement.querySelector('.lbl').textContent = 'Density';
                    document.getElementById('d2').textContent = ((prim/tot)*100).toFixed(1) + '%';
                    document.getElementById('e2').parentElement.querySelector('.lbl').textContent = '|Predicted - Actual|';
                    animateValue('e2', 0, error);
                }
                
                document.getElementById('load2d').classList.remove('active');
            }, 100);
        }

        function init3D() {
            const c = document.getElementById('c3d');
            scene = new THREE.Scene();
            scene.background = new THREE.Color(document.body.classList.contains('light') ? 0xffffff : 0x1a1a1a);
            camera = new THREE.PerspectiveCamera(75, c.clientWidth/800, 0.1, 1000);
            camera.position.set(50, 50, 50);
            camera.lookAt(0, 0, 0);
            renderer = new THREE.WebGLRenderer({ antialias: true, preserveDrawingBuffer: true });
            renderer.setSize(c.clientWidth, 800);
            c.appendChild(renderer.domElement);
            
            const light1 = new THREE.AmbientLight(0xffffff, 0.6);
            const light2 = new THREE.DirectionalLight(0xffffff, 0.4);
            light2.position.set(1, 1, 1);
            scene.add(light1, light2);
            
            const axes = new THREE.AxesHelper(35);
            scene.add(axes);
            
            const canvas = renderer.domElement;
            canvas.addEventListener('mousedown', e => {
                mouseDown = true;
                prevMouse = { x: e.clientX, y: e.clientY };
            });
            canvas.addEventListener('mousemove', e => {
                if (mouseDown && !autoRotate) {
                    const dx = e.clientX - prevMouse.x;
                    const dy = e.clientY - prevMouse.y;
                    const rotSpeed = 0.005;
                    camera.position.applyAxisAngle(new THREE.Vector3(0, 1, 0), dx * rotSpeed);
                    const right = new THREE.Vector3(1, 0, 0).applyQuaternion(camera.quaternion);
                    camera.position.applyAxisAngle(right, dy * rotSpeed);
                    camera.lookAt(0, 0, 0);
                    prevMouse = { x: e.clientX, y: e.clientY };
                }
            });
            canvas.addEventListener('mouseup', () => mouseDown = false);
            canvas.addEventListener('mouseleave', () => mouseDown = false);
            
            draw3D();
            animate3D();
        }

        function set3DShape(shape) {
            shape3D = shape;
            document.querySelectorAll('#shape3DSphere, #shape3DCube').forEach(btn => btn.classList.remove('active'));
            document.getElementById(shape === 'sphere' ? 'shape3DSphere' : 'shape3DCube').classList.add('active');
            draw3D();
        }

        function set3DColorMode(mode) {
            colorMode3D = mode;
            document.querySelectorAll('#colorPrimitive, #colorGCD, #colorMod, #colorOctant, #colorDistance, #colorGCDOct, #colorGCDMod').forEach(btn => btn.classList.remove('active'));
            const btnIds = {
                'primitive': 'colorPrimitive',
                'gcd': 'colorGCD',
                'mod': 'colorMod',
                'octant': 'colorOctant',
                'distance': 'colorDistance',
                'gcdoct': 'colorGCDOct',
                'gcdmod': 'colorGCDMod'
            };
            document.getElementById(btnIds[mode]).classList.add('active');
            
            // Show/hide modulus controls
            document.getElementById('modControls3D').style.display = (mode === 'mod' || mode === 'gcdmod') ? 'block' : 'none';
            
            draw3D();
        }

        function draw3D() {
            if (!scene) return;
            while(scene.children.length > 3) scene.remove(scene.children[3]);
            
            const R = parseInt(document.getElementById('r3').value);
            const pointSize = parseFloat(document.getElementById('ps3').value);
            document.getElementById('r3v').textContent = R;
            document.getElementById('ps3v').textContent = pointSize;
            document.getElementById('warn3d').style.display = R > 30 ? 'block' : 'none';
            
            if (R > 25) document.getElementById('load3d').classList.add('active');
            
            setTimeout(() => {
                // Add boundary shape
                if (shape3D === 'sphere') {
                    const sg = new THREE.SphereGeometry(R, 32, 32);
                    const sm = new THREE.MeshBasicMaterial({ 
                        color: 0x6f42c1, wireframe: true, transparent: true, opacity: 0.15 
                    });
                    scene.add(new THREE.Mesh(sg, sm));
                } else {
                    const boxGeometry = new THREE.BoxGeometry(2*R, 2*R, 2*R);
                    const edges = new THREE.EdgesGeometry(boxGeometry);
                    const line = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ 
                        color: 0x6f42c1, transparent: true, opacity: 0.3 
                    }));
                    scene.add(line);
                }
                
                // Collect all points with their properties
                const allPoints = [];
                let prim = 0, tot = 0;
                const modulus = parseInt(document.getElementById('mod3D').value);
                
                for (let x = -R; x <= R; x++) {
                    for (let y = -R; y <= R; y++) {
                        for (let z = -R; z <= R; z++) {
                            const distSq = x*x + y*y + z*z;
                            const inBounds = shape3D === 'sphere' ? 
                                (distSq <= R*R) : 
                                (Math.abs(x) <= R && Math.abs(y) <= R && Math.abs(z) <= R);
                            
                            if (inBounds) {
                                tot++;
                                const g = gcdArray([Math.abs(x), Math.abs(y), Math.abs(z)]);
                                const isPrimitive = g === 1;
                                if (isPrimitive) prim++;
                                
                                // Determine octant (1-8)
                                let octant = 1;
                                if (x >= 0 && y >= 0 && z >= 0) octant = 1;
                                else if (x < 0 && y >= 0 && z >= 0) octant = 2;
                                else if (x < 0 && y < 0 && z >= 0) octant = 3;
                                else if (x >= 0 && y < 0 && z >= 0) octant = 4;
                                else if (x >= 0 && y >= 0 && z < 0) octant = 5;
                                else if (x < 0 && y >= 0 && z < 0) octant = 6;
                                else if (x < 0 && y < 0 && z < 0) octant = 7;
                                else octant = 8;
                                
                                allPoints.push({
                                    x, y, z,
                                    gcd: g,
                                    isPrimitive,
                                    distance: Math.sqrt(distSq),
                                    sum: x + y + z,
                                    octant
                                });
                            }
                        }
                    }
                }
                
                cache.points3D = { 
                    primitive: allPoints.filter(p => p.isPrimitive),
                    nonPrimitive: allPoints.filter(p => !p.isPrimitive),
                    R 
                };
                
                // Color points based on mode
                const pointsByColor = {};
                
                allPoints.forEach(pt => {
                    let colorKey;
                    
                    switch(colorMode3D) {
                        case 'primitive':
                            colorKey = pt.isPrimitive ? 'prim' : 'nonprim';
                            break;
                        case 'gcd':
                            colorKey = `gcd${Math.min(pt.gcd, 8)}`;
                            break;
                        case 'mod':
                            colorKey = `mod${((pt.sum % modulus) + modulus) % modulus}`;
                            break;
                        case 'octant':
                            colorKey = `oct${pt.octant}`;
                            break;
                        case 'distance':
                            const distBucket = Math.floor(pt.distance / (R / 5));
                            colorKey = `dist${Math.min(distBucket, 5)}`;
                            break;
                        case 'gcdoct':
                            colorKey = `gcd${Math.min(pt.gcd, 4)}_oct${pt.octant}`;
                            break;
                        case 'gcdmod':
                            const modVal = ((pt.sum % modulus) + modulus) % modulus;
                            colorKey = `gcd${Math.min(pt.gcd, 4)}_m${modVal}`;
                            break;
                    }
                    
                    if (!pointsByColor[colorKey]) pointsByColor[colorKey] = [];
                    pointsByColor[colorKey].push(pt.x, pt.y, pt.z);
                });
                
                // Define color schemes
                const colorMap = {
                    prim: 0x0066cc,
                    nonprim: 0xdc3545,
                    gcd1: 0x0066cc, gcd2: 0xdc3545, gcd3: 0x28a745, gcd4: 0xffc107,
                    gcd5: 0x6f42c1, gcd6: 0xfd7e14, gcd7: 0x00d4ff, gcd8: 0xff006e,
                    oct1: 0x0066cc, oct2: 0xdc3545, oct3: 0x28a745, oct4: 0xffc107,
                    oct5: 0x6f42c1, oct6: 0xfd7e14, oct7: 0x00d4ff, oct8: 0xff006e,
                    dist0: 0x0066cc, dist1: 0x00d4ff, dist2: 0x28a745, 
                    dist3: 0xffc107, dist4: 0xfd7e14, dist5: 0xdc3545,
                    mod0: 0x0066cc, mod1: 0xdc3545, mod2: 0x28a745, mod3: 0xffc107,
                    mod4: 0x6f42c1, mod5: 0xfd7e14, mod6: 0x00d4ff, mod7: 0xff006e,
                    mod8: 0x20c997, mod9: 0xe83e8c, mod10: 0x17a2b8, mod11: 0x6610f2
                };
                
                // Generate combined colors
                const baseColors = [0x0066cc, 0xdc3545, 0x28a745, 0xffc107, 0x6f42c1, 0xfd7e14, 0x00d4ff, 0xff006e];
                for (let g = 1; g <= 4; g++) {
                    for (let o = 1; o <= 8; o++) {
                        colorMap[`gcd${g}_oct${o}`] = baseColors[(g - 1 + o - 1) % 8];
                    }
                    for (let m = 0; m < 12; m++) {
                        colorMap[`gcd${g}_m${m}`] = baseColors[(g - 1 + m) % 8];
                    }
                }
                
                // Create point groups
                Object.entries(pointsByColor).forEach(([colorKey, positions]) => {
                    if (positions.length > 0) {
                        const geometry = new THREE.BufferGeometry();
                        geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
                        
                        const color = colorMap[colorKey] || 0x999999;
                        const material = new THREE.PointsMaterial({ color, size: pointSize });
                        scene.add(new THREE.Points(geometry, material));
                    }
                });
                
                // Add labels if enabled
                if (labelMode3D !== 'none') {
                    const maxLabels = parseInt(document.getElementById('maxLabels3D').value);
                    document.getElementById('maxLabels3Dv').textContent = maxLabels;
                    
                    // Sort by distance and take closest points
                    const sortedPoints = [...allPoints].sort((a, b) => a.distance - b.distance).slice(0, maxLabels);
                    
                    sortedPoints.forEach(pt => {
                        let labelText;
                        if (labelMode3D === 'gcd') {
                            labelText = pt.gcd.toString();
                        } else if (labelMode3D === 'coords') {
                            labelText = `(${pt.x},${pt.y},${pt.z})`;
                        }
                        
                        // Create sprite for label
                        const canvas = document.createElement('canvas');
                        const context = canvas.getContext('2d');
                        canvas.width = 128;
                        canvas.height = 64;
                        
                        context.fillStyle = 'rgba(0, 0, 0, 0.8)';
                        context.fillRect(0, 0, canvas.width, canvas.height);
                        
                        context.font = 'Bold 24px Arial';
                        context.fillStyle = 'white';
                        context.textAlign = 'center';
                        context.textBaseline = 'middle';
                        context.fillText(labelText, canvas.width/2, canvas.height/2);
                        
                        const texture = new THREE.CanvasTexture(canvas);
                        const spriteMaterial = new THREE.SpriteMaterial({ map: texture });
                        const sprite = new THREE.Sprite(spriteMaterial);
                        sprite.position.set(pt.x, pt.y, pt.z);
                        sprite.scale.set(4, 2, 1);
                        scene.add(sprite);
                    });
                }
                
                const pred = Math.round(4 * Math.PI * R**3 / (3 * zeta(3)));
                const error = Math.abs(pred - prim);
                
                animateValue('p3', 0, prim);
                animateValue('t3', 0, tot);
                document.getElementById('d3').textContent = ((prim/tot)*100).toFixed(1) + '%';
                animateValue('e3', 0, error);
                
                document.getElementById('load3d').classList.remove('active');
            }, 100);
        }

        function animate3D() {
            requestAnimationFrame(animate3D);
            if (renderer && scene && camera) {
                if (autoRotate) {
                    camera.position.applyAxisAngle(new THREE.Vector3(0, 1, 0), 0.005);
                    camera.lookAt(0, 0, 0);
                }
                renderer.render(scene, camera);
            }
        }

        function reset3D() {
            if (camera) { 
                camera.position.set(50, 50, 50); 
                camera.lookAt(0, 0, 0); 
            }
        }

        function toggleRotation() {
            autoRotate = !autoRotate;
            event.target.textContent = autoRotate ? 'Stop Rotation' : 'Auto-Rotate';
        }

        function setComparisonMode(mode) {
            comparisonMode = mode;
            document.querySelectorAll('#modeFixed, #modeMulti').forEach(btn => btn.classList.remove('active'));
            document.getElementById(mode === 'fixed' ? 'modeFixed' : 'modeMulti').classList.add('active');
            
            if (mode === 'fixed') {
                document.getElementById('fixedRadiusControls').style.display = 'block';
                document.getElementById('multiRadiusControls').style.display = 'none';
            } else {
                document.getElementById('fixedRadiusControls').style.display = 'none';
                document.getElementById('multiRadiusControls').style.display = 'block';
            }
            updateComparison();
        }

        function updateComparisonRadius(value) {
            const R = parseInt(value);
            if (R < 1 || R > 200 || isNaN(R)) return;
            
            document.getElementById('crv').textContent = R;
            document.getElementById('cr').value = Math.min(R, 100);
            document.getElementById('crinput').value = R;
            updateComparison();
        }

        function updateComparison() {
            const grid = document.getElementById('compGrid');
            const showDensity = document.getElementById('showDensity').checked;
            const showVolume = document.getElementById('showVolume').checked;
            const showZeta = document.getElementById('showZeta').checked;
            const showChart = document.getElementById('showChart').checked;
            
            const dims = [];
            for (let k = 2; k <= 10; k++) {
                if (document.getElementById(`compk${k}`)?.checked) dims.push(k);
            }
            
            if (dims.length === 0) {
                grid.innerHTML = '<p style="color:var(--red);">Please select at least one dimension</p>';
                return;
            }
            
            grid.innerHTML = '';
            
            if (comparisonMode === 'fixed') {
                const R = parseInt(document.getElementById('crinput').value);
                
                dims.forEach(k => {
                    const z = zeta(k);
                    const vol = sphereVolume(k, R);
                    const pred = Math.round(vol / z);
                    const density = (1/z * 100).toFixed(2);
                    
                    let content = `
                        <div class="compare-item">
                            <h3 style="color:var(--blue); margin-bottom:15px;">Dimension k = ${k}</h3>
                            <div style="background:var(--bg); padding:10px; border-radius:6px; margin-bottom:10px;">
                                <p style="font-size:1.1em;"><b>Predicted Points:</b> ${pred.toLocaleString()}</p>
                            </div>
                    `;
                    
                    if (showZeta) {
                        content += `
                            <div style="background:var(--bg); padding:10px; border-radius:6px; margin-bottom:10px;">
                                <p><b>Œ∂(${k}):</b> ${z.toFixed(6)}</p>
                            </div>
                        `;
                    }
                    
                    if (showDensity) {
                        content += `
                            <div style="background:var(--bg); padding:10px; border-radius:6px; margin-bottom:10px;">
                                <p><b>Primitive Density:</b> ${density}%</p>
                                <p style="font-size:0.9em; color:var(--text2);">1/Œ∂(${k}) = ${(1/z).toFixed(6)}</p>
                            </div>
                        `;
                    }
                    
                    if (showVolume) {
                        content += `
                            <div style="background:var(--bg); padding:10px; border-radius:6px; margin-bottom:10px;">
                                <p><b>Sphere Volume:</b></p>
                                <p style="font-size:0.95em;">${vol.toExponential(4)}</p>
                            </div>
                        `;
                    }
                    
                    // Add growth rate info
                    content += `
                        <div style="background:var(--bg); padding:10px; border-radius:6px; margin-bottom:10px;">
                            <p><b>Growth Rate:</b> O(R^${k})</p>
                            <p style="font-size:0.9em; color:var(--text2);">Error: O(R^${k-1})</p>
                        </div>
                    `;
                    
                    content += `</div>`;
                    grid.innerHTML += content;
                });
            } else {
                // Multiple radii mode
                const radiiStr = document.getElementById('multiRadii').value;
                const radii = radiiStr.split(',').map(r => parseInt(r.trim())).filter(r => !isNaN(r) && r > 0);
                
                if (radii.length === 0) {
                    grid.innerHTML = '<p style="color:var(--red);">Please enter valid radii (e.g., 10, 20, 30)</p>';
                    return;
                }
                
                dims.forEach(k => {
                    const precision = k > 6 ? 17 : 6;
                    let content = `
                        <div class="compare-item">
                            <h3 style="color:var(--blue); margin-bottom:15px;">Dimension k = ${k}</h3>
                    `;
                    
                    if (showZeta) {
                        const z = zeta(k);
                        content += `
                            <div style="background:var(--bg); padding:10px; border-radius:6px; margin-bottom:10px;">
                                <p><b>Œ∂(${k}):</b> ${formatPrecise(z, precision)}</p>
                                <p><b>Density:</b> ${((1/z)*100).toFixed(2)}%</p>
                                <p style="font-size:0.9em; color:var(--text2);">1/Œ∂(${k}) = ${formatPrecise(1/z, precision)}</p>
                            </div>
                        `;
                    }
                    
                    content += '<table style="width:100%; font-size:0.9em;"><thead><tr><th>R</th><th>Predicted</th>';
                    if (showVolume) content += '<th>Volume</th>';
                    content += '</tr></thead><tbody>';
                    
                    radii.forEach(R => {
                        const vol = sphereVolume(k, R);
                        const pred = Math.round(vol / zeta(k));
                        content += `<tr><td>${R}</td><td>${pred.toLocaleString()}</td>`;
                        if (showVolume) content += `<td>${formatPrecise(vol, Math.min(precision, 6))}</td>`;
                        content += '</tr>';
                    });
                    
                    content += '</tbody></table></div>';
                    grid.innerHTML += content;
                });
            }
            
            // Update chart
            if (showChart) {
                document.getElementById('comparisonChart').style.display = 'block';
                updateComparisonChart(dims);
            } else {
                document.getElementById('comparisonChart').style.display = 'none';
            }
        }

        function updateComparisonChart(dims) {
            const canvas = document.getElementById('compChart');
            const ctx = canvas.getContext('2d');
            
            if (comparisonChart) comparisonChart.destroy();
            
            const colors = ['#0066cc', '#ffc107', '#00d4ff', '#ff006e', '#28a745', '#6f42c1', '#fd7e14', '#dc3545', '#20c997'];
            
            if (comparisonMode === 'fixed') {
                const R = parseInt(document.getElementById('crinput').value);
                
                const data = dims.map(k => {
                    const vol = sphereVolume(k, R);
                    return Math.round(vol / zeta(k));
                });
                
                comparisonChart = new Chart(ctx, {
                    type: 'bar',
                    data: {
                        labels: dims.map(k => `k=${k}`),
                        datasets: [{
                            label: `Primitive Points (R=${R})`,
                            data: data,
                            backgroundColor: dims.map((k, i) => colors[i % colors.length]),
                            borderColor: dims.map((k, i) => colors[i % colors.length]),
                            borderWidth: 2
                        }]
                    },
                    options: {
                        responsive: true,
                        scales: {
                            y: {
                                type: 'logarithmic',
                                title: { display: true, text: 'Number of Primitive Points', font: { size: 14 } }
                            },
                            x: {
                                title: { display: true, text: 'Dimension', font: { size: 14 } }
                            }
                        },
                        plugins: {
                            title: {
                                display: true,
                                text: `Primitive Lattice Points Across Dimensions (R=${R})`,
                                font: { size: 16, weight: 'bold' }
                            },
                            legend: { display: true }
                        }
                    }
                });
            } else {
                // Multiple radii - show lines
                const radiiStr = document.getElementById('multiRadii').value;
                const radii = radiiStr.split(',').map(r => parseInt(r.trim())).filter(r => !isNaN(r) && r > 0);
                
                const datasets = dims.map((k, i) => {
                    const data = radii.map(R => {
                        const vol = sphereVolume(k, R);
                        return { x: R, y: Math.round(vol / zeta(k)) };
                    });
                    
                    return {
                        label: `k=${k}`,
                        data: data,
                        borderColor: colors[i % colors.length],
                        backgroundColor: colors[i % colors.length] + '33',
                        borderWidth: 2,
                        tension: 0.1,
                        fill: false
                    };
                });
                
                comparisonChart = new Chart(ctx, {
                    type: 'line',
                    data: { datasets },
                    options: {
                        responsive: true,
                        scales: {
                            y: {
                                type: 'logarithmic',
                                title: { display: true, text: 'Number of Primitive Points', font: { size: 14 } }
                            },
                            x: {
                                title: { display: true, text: 'Radius R', font: { size: 14 } }
                            }
                        },
                        plugins: {
                            title: {
                                display: true,
                                text: 'Primitive Lattice Points Growth Across Dimensions',
                                font: { size: 16, weight: 'bold' }
                            },
                            legend: { display: true }
                        }
                    }
                });
            }
        }

        function exportComparisonChart() {
            if (!comparisonChart) {
                alert('Please generate a comparison chart first');
                return;
            }
            exportCanvas('compChart', 'dimension-comparison-chart');
        }

        let fareyViz = 'list';
        let fareyData = null;
        
        function updateFareyN() {
            const val = parseInt(document.getElementById('fareyNInput').value) || parseInt(document.getElementById('fareyN').value);
            document.getElementById('fareyNv').textContent = val;
            document.getElementById('fareyN').value = Math.min(val, 100);
            document.getElementById('fareyNInput').value = val;
        }
        
        function setFareyViz(mode) {
            fareyViz = mode;
            document.querySelectorAll('#fareyList, #fareyCircle, #fareyTree').forEach(btn => btn.classList.remove('active'));
            const btnIds = { 'list': 'fareyList', 'circle': 'fareyCircle', 'tree': 'fareyTree' };
            document.getElementById(btnIds[mode]).classList.add('active');
            if (fareyData) drawFareyViz();
        }
        
        function computeFarey() {
            const n = parseInt(document.getElementById('fareyNInput').value) || parseInt(document.getElementById('fareyN').value);
            
            // Generate Farey sequence F_n
            const fractions = [];
            
            for (let q = 1; q <= n; q++) {
                for (let p = 0; p <= q; p++) {
                    if (gcd(p, q) === 1) {
                        fractions.push({ p, q, value: p / q });
                    }
                }
            }
            
            // Sort by value
            fractions.sort((a, b) => a.value - b.value);
            
            // Calculate sum of phi
            let sumPhi = 1; // for 0/1
            for (let k = 1; k <= n; k++) {
                sumPhi += eulerPhi(k);
            }
            
            // Sample mediant
            const sampleMediant = fractions.length > 2 ? 
                `(${fractions[1].p}+${fractions[2].p})/(${fractions[1].q}+${fractions[2].q}) = ${fractions[1].p + fractions[2].p}/${fractions[1].q + fractions[2].q}` : 
                'N/A';
            
            fareyData = {
                n,
                fractions,
                count: fractions.length,
                sumPhi,
                sampleMediant
            };
            
            // Update stats
            animateValue('fareyCount', 0, fareyData.count);
            animateValue('fareySum', 0, sumPhi);
            document.getElementById('fareyDensity').textContent = ((fareyData.count / (n * (n + 1) / 2)) * 100).toFixed(2) + '%';
            document.getElementById('fareyMediant').textContent = sampleMediant;
            
            drawFareyViz();
        }
        
        function drawFareyViz() {
            if (!fareyData) return;
            
            const canvas = document.getElementById('fareyCanvas');
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            ctx.fillStyle = document.body.classList.contains('light') ? '#ffffff' : '#1a1a1a';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            if (fareyViz === 'list') {
                // Draw as a number line with fractions
                const padding = 60;
                const lineY = 100;
                const lineWidth = canvas.width - 2 * padding;
                
                // Draw number line
                ctx.strokeStyle = getComputedStyle(document.body).getPropertyValue('--text');
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(padding, lineY);
                ctx.lineTo(canvas.width - padding, lineY);
                ctx.stroke();
                
                // Draw fractions
                ctx.fillStyle = getComputedStyle(document.body).getPropertyValue('--text');
                ctx.font = '12px system-ui';
                ctx.textAlign = 'center';
                
                const maxDisplay = Math.min(fareyData.fractions.length, 50);
                const step = Math.ceil(fareyData.fractions.length / maxDisplay);
                
                fareyData.fractions.forEach((frac, i) => {
                    if (i % step === 0 || i === 0 || i === fareyData.fractions.length - 1) {
                        const x = padding + frac.value * lineWidth;
                        
                        // Tick mark
                        ctx.beginPath();
                        ctx.moveTo(x, lineY - 10);
                        ctx.lineTo(x, lineY + 10);
                        ctx.stroke();
                        
                        // Label
                        ctx.fillText(`${frac.p}/${frac.q}`, x, lineY + 30);
                        ctx.fillText(frac.value.toFixed(3), x, lineY + 45);
                    }
                });
                
                // Draw list of fractions
                ctx.font = '14px monospace';
                ctx.textAlign = 'left';
                let yPos = 180;
                const cols = 8;
                const colWidth = canvas.width / cols;
                
                ctx.fillStyle = getComputedStyle(document.body).getPropertyValue('--blue');
                ctx.font = 'bold 16px system-ui';
                ctx.fillText(`Farey Sequence F_${fareyData.n} (${fareyData.count} fractions):`, 20, 160);
                
                ctx.font = '13px monospace';
                ctx.fillStyle = getComputedStyle(document.body).getPropertyValue('--text');
                
                fareyData.fractions.forEach((frac, i) => {
                    const col = i % cols;
                    const row = Math.floor(i / cols);
                    const x = 20 + col * colWidth;
                    const y = yPos + row * 20;
                    
                    if (y < canvas.height - 20) {
                        ctx.fillText(`${frac.p}/${frac.q}`, x, y);
                    }
                });
                
            } else if (fareyViz === 'circle') {
                // Ford circles visualization
                const baseY = canvas.height - 50;
                const scale = canvas.width - 100;
                
                // Draw x-axis
                ctx.strokeStyle = getComputedStyle(document.body).getPropertyValue('--text');
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(50, baseY);
                ctx.lineTo(canvas.width - 50, baseY);
                ctx.stroke();
                
                // Draw Ford circles
                const maxQ = Math.min(fareyData.n, 20); // Limit for visibility
                
                fareyData.fractions.forEach(frac => {
                    if (frac.q <= maxQ) {
                        const centerX = 50 + frac.value * scale;
                        const radius = scale / (2 * frac.q * frac.q);
                        const centerY = baseY - radius;
                        
                        if (radius > 1) {
                            // Draw circle
                            const hue = (frac.q / maxQ) * 240;
                            ctx.strokeStyle = `hsl(${hue}, 70%, 50%)`;
                            ctx.lineWidth = 2;
                            ctx.beginPath();
                            ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI);
                            ctx.stroke();
                            
                            // Label
                            if (radius > 15) {
                                ctx.fillStyle = getComputedStyle(document.body).getPropertyValue('--text');
                                ctx.font = `${Math.min(12, radius / 2)}px system-ui`;
                                ctx.textAlign = 'center';
                                ctx.fillText(`${frac.p}/${frac.q}`, centerX, centerY + 4);
                            }
                        }
                    }
                });
                
                // Title and explanation
                ctx.fillStyle = getComputedStyle(document.body).getPropertyValue('--text');
                ctx.font = 'bold 18px system-ui';
                ctx.textAlign = 'left';
                ctx.fillText('Ford Circles', 20, 30);
                ctx.font = '14px system-ui';
                ctx.fillText(`Circle at p/q has radius 1/(2q¬≤)`, 20, 55);
                ctx.fillText(`Consecutive Farey fractions have tangent circles`, 20, 75);
                
            } else if (fareyViz === 'tree') {
                // Stern-Brocot tree
                ctx.fillStyle = getComputedStyle(document.body).getPropertyValue('--text');
                ctx.font = 'bold 18px system-ui';
                ctx.fillText('Stern-Brocot Tree', 20, 30);
                ctx.font = '14px system-ui';
                ctx.fillText('Binary tree of all positive rationals in lowest terms', 20, 55);
                
                // Draw tree structure
                const levels = Math.min(5, Math.floor(Math.log2(fareyData.n)) + 2);
                const startX = canvas.width / 2;
                const startY = 100;
                const levelHeight = 80;
                
                function drawNode(p, q, x, y, level, maxLevel, leftP, leftQ, rightP, rightQ) {
                    if (level > maxLevel || q > fareyData.n) return;
                    
                    // Draw node
                    ctx.fillStyle = '#0066cc';
                    ctx.beginPath();
                    ctx.arc(x, y, 20, 0, 2 * Math.PI);
                    ctx.fill();
                    
                    // Label
                    ctx.fillStyle = '#fff';
                    ctx.font = 'bold 12px system-ui';
                    ctx.textAlign = 'center';
                    ctx.fillText(`${p}/${q}`, x, y + 4);
                    
                    // Draw children
                    if (level < maxLevel) {
                        const leftChildP = p + leftP;
                        const leftChildQ = q + leftQ;
                        const rightChildP = p + rightP;
                        const rightChildQ = q + rightQ;
                        
                        const childY = y + levelHeight;
                        const spread = canvas.width / Math.pow(2, level + 2);
                        const leftX = x - spread;
                        const rightX = x + spread;
                        
                        // Draw lines to children
                        ctx.strokeStyle = getComputedStyle(document.body).getPropertyValue('--border');
                        ctx.lineWidth = 2;
                        
                        if (leftChildQ <= fareyData.n) {
                            ctx.beginPath();
                            ctx.moveTo(x, y + 20);
                            ctx.lineTo(leftX, childY - 20);
                            ctx.stroke();
                            drawNode(leftChildP, leftChildQ, leftX, childY, level + 1, maxLevel, leftP, leftQ, p, q);
                        }
                        
                        if (rightChildQ <= fareyData.n) {
                            ctx.beginPath();
                            ctx.moveTo(x, y + 20);
                            ctx.lineTo(rightX, childY - 20);
                            ctx.stroke();
                            drawNode(rightChildP, rightChildQ, rightX, childY, level + 1, maxLevel, p, q, rightP, rightQ);
                        }
                    }
                }
                
                // Start with 1/1 as root
                drawNode(1, 1, startX, startY, 1, levels, 0, 1, 1, 0);
            }
        }
        
        function exportFareyData() {
            if (!fareyData) { alert('Generate Farey sequence first'); return; }
            
            let csv = `# Farey Sequence F_${fareyData.n}\n`;
            csv += `# Generated: ${new Date().toISOString()}\n`;
            csv += `# By Wessen Getachew | @7dview | wessengetachew.github.io\n`;
            csv += `#\n`;
            csv += `# Total fractions: ${fareyData.count}\n`;
            csv += `# Sum of œÜ(k) for k=1 to ${fareyData.n}: ${fareyData.sumPhi}\n`;
            csv += `#\n`;
            csv += `numerator,denominator,decimal_value,continued_fraction\n`;
            
            fareyData.fractions.forEach(frac => {
                // Compute simple continued fraction representation
                let cf = [];
                let p = frac.p, q = frac.q;
                while (q !== 0) {
                    cf.push(Math.floor(p / q));
                    [p, q] = [q, p % q];
                }
                const cfStr = '[' + cf.join(';') + ']';
                
                csv += `${frac.p},${frac.q},${frac.value.toFixed(10)},${cfStr}\n`;
            });
            
            downloadCSV(csv, `farey-sequence-F${fareyData.n}.csv`);
        }
        
        // Save/Load Session functions
        function saveSession() {
            const sessionName = document.getElementById('sessionName').value.trim() || `Session ${new Date().toLocaleString()}`;
            const sessionDesc = document.getElementById('sessionDesc').value.trim();
            
            const session = {
                name: sessionName,
                description: sessionDesc,
                timestamp: new Date().toISOString(),
                data: {
                    // 2D params
                    r2: document.getElementById('r2input').value,
                    view2D: view2D,
                    colorMode2D: colorMode2D,
                    labelMode2D: labelMode2D,
                    zoom2D: zoom2D,
                    
                    // 3D params
                    r3: document.getElementById('r3').value,
                    shape3D: shape3D,
                    colorMode3D: colorMode3D,
                    labelMode3D: labelMode3D,
                    
                    // Theory params
                    theoryK: document.getElementById('tks').value,
                    theoryR: document.getElementById('trs').value,
                    
                    // Heatmap params
                    heatmapR: document.getElementById('heatmapRinput').value,
                    heatmapMode: heatmapMode,
                    heatmapPointSize: document.getElementById('heatmapPS').value,
                    
                    // GCD Table params
                    gcdTableSize: document.getElementById('gcdTableSizeInput').value,
                    gcdTableType: gcdTableType,
                    gcdTableColorMode: gcdTableColorMode,
                    gcdTableRotation: gcdTableRotation,
                    gcdTableRotation: gcdTableRotation,
                    
                    // Critical Strip params
                    criticalMaxR: document.getElementById('criticalMaxRinput').value,
                    criticalProblem: criticalProblem,
                    criticalViz: criticalViz,
                    
                    // Pattern params
                    patternType: patternType,
                    
                    // Analysis params
                    analysisK: document.getElementById('analysisK').value,
                    analysisMaxR: document.getElementById('mrinput').value,
                    
                    // Comparison params
                    comparisonMode: comparisonMode,
                    comparisonR: document.getElementById('crinput').value
                }
            };
            
            // Get existing sessions
            let sessions = JSON.parse(localStorage.getItem('fareyLattice_sessions') || '[]');
            
            // Add new session
            sessions.push(session);
            
            // Keep only last 10 sessions
            if (sessions.length > 10) {
                sessions = sessions.slice(-10);
            }
            
            // Save
            localStorage.setItem('fareyLattice_sessions', JSON.stringify(sessions));
            
            alert(`Session "${sessionName}" saved successfully!`);
            
            // Clear input fields
            document.getElementById('sessionName').value = '';
            document.getElementById('sessionDesc').value = '';
            
            // Refresh session list
            displaySavedSessions();
        }
        
        function loadSession(index) {
            const sessions = JSON.parse(localStorage.getItem('fareyLattice_sessions') || '[]');
            
            if (index < 0 || index >= sessions.length) {
                alert('Session not found');
                return;
            }
            
            const session = sessions[index];
            const data = session.data;
            
            // Restore 2D params
            if (data.r2) update2DRadius(data.r2);
            if (data.view2D) set2DView(data.view2D);
            if (data.colorMode2D) set2DColorMode(data.colorMode2D);
            if (data.labelMode2D) set2DLabelMode(data.labelMode2D);
            if (data.zoom2D) {
                zoom2D = data.zoom2D;
                document.getElementById('zoom2D').value = data.zoom2D;
                document.getElementById('zoom2Dv').textContent = data.zoom2D;
            }
            
            // Restore 3D params
            if (data.r3) {
                document.getElementById('r3').value = data.r3;
                document.getElementById('r3v').textContent = data.r3;
            }
            if (data.shape3D) set3DShape(data.shape3D);
            if (data.colorMode3D) set3DColorMode(data.colorMode3D);
            if (data.labelMode3D) set3DLabelMode(data.labelMode3D);
            
            // Restore theory params
            if (data.theoryK) {
                document.getElementById('tks').value = data.theoryK;
            }
            if (data.theoryR) {
                document.getElementById('trs').value = data.theoryR;
            }
            updateTheory();
            
            // Restore heatmap params
            if (data.heatmapR) updateHeatmapR(data.heatmapR);
            if (data.heatmapMode) setHeatmapMode(data.heatmapMode);
            if (data.heatmapPointSize) {
                document.getElementById('heatmapPS').value = data.heatmapPointSize;
            }
            
            // Restore GCD table params
            if (data.gcdTableSize) {
                document.getElementById('gcdTableSizeInput').value = data.gcdTableSize;
                updateGCDTableSize();
            }
            if (data.gcdTableType) setTableType(data.gcdTableType);
            if (data.gcdTableColorMode) setGCDTableColor(data.gcdTableColorMode);
            if (data.gcdTableRotation !== undefined) setGCDTableRotation(data.gcdTableRotation);
            
            // Restore critical strip params
            if (data.criticalMaxR) updateCriticalMaxR(data.criticalMaxR);
            if (data.criticalProblem) setCriticalProblem(data.criticalProblem);
            if (data.criticalViz) setCriticalViz(data.criticalViz);
            
            // Restore pattern params
            if (data.patternType) setPatternType(data.patternType);
            
            // Restore analysis params
            if (data.analysisK) {
                document.getElementById('analysisK').value = data.analysisK;
            }
            if (data.analysisMaxR) updateAnalysisRadius(data.analysisMaxR);
            
            // Restore comparison params
            if (data.comparisonMode) setComparisonMode(data.comparisonMode);
            if (data.comparisonR) updateComparisonRadius(data.comparisonR);
            
            alert(`Session "${session.name}" loaded successfully!`);
        }
        
        function exportSession() {
            const sessionName = document.getElementById('sessionName').value.trim() || `Session ${new Date().toLocaleString()}`;
            const sessionDesc = document.getElementById('sessionDesc').value.trim();
            
            const session = {
                name: sessionName,
                description: sessionDesc,
                timestamp: new Date().toISOString(),
                version: '1.0',
                data: {
                    r2: document.getElementById('r2input').value,
                    view2D: view2D,
                    colorMode2D: colorMode2D,
                    labelMode2D: labelMode2D,
                    zoom2D: zoom2D,
                    r3: document.getElementById('r3').value,
                    shape3D: shape3D,
                    colorMode3D: colorMode3D,
                    labelMode3D: labelMode3D,
                    theoryK: document.getElementById('tks').value,
                    theoryR: document.getElementById('trs').value,
                    heatmapR: document.getElementById('heatmapRinput').value,
                    heatmapMode: heatmapMode,
                    heatmapPointSize: document.getElementById('heatmapPS').value,
                    gcdTableSize: document.getElementById('gcdTableSizeInput').value,
                    gcdTableType: gcdTableType,
                    gcdTableColorMode: gcdTableColorMode,
                    criticalMaxR: document.getElementById('criticalMaxRinput').value,
                    criticalProblem: criticalProblem,
                    criticalViz: criticalViz,
                    patternType: patternType,
                    analysisK: document.getElementById('analysisK').value,
                    analysisMaxR: document.getElementById('mrinput').value,
                    comparisonMode: comparisonMode,
                    comparisonR: document.getElementById('crinput').value
                }
            };
            
            const json = JSON.stringify(session, null, 2);
            const blob = new Blob([json], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            link.download = `lattice-session-${sessionName.replace(/\s+/g, '-')}.json`;
            link.click();
            URL.revokeObjectURL(url);
        }
        
        function importSession() {
            const fileInput = document.getElementById('sessionFile');
            const file = fileInput.files[0];
            
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const session = JSON.parse(e.target.result);
                    
                    if (!session.data) {
                        alert('Invalid session file format');
                        return;
                    }
                    
                    const data = session.data;
                    
                    // Restore all parameters (same as loadSession)
                    if (data.r2) update2DRadius(data.r2);
                    if (data.view2D) set2DView(data.view2D);
                    if (data.colorMode2D) set2DColorMode(data.colorMode2D);
                    if (data.labelMode2D) set2DLabelMode(data.labelMode2D);
                    if (data.zoom2D) {
                        zoom2D = data.zoom2D;
                        document.getElementById('zoom2D').value = data.zoom2D;
                        document.getElementById('zoom2Dv').textContent = data.zoom2D;
                    }
                    if (data.r3) {
                        document.getElementById('r3').value = data.r3;
                        document.getElementById('r3v').textContent = data.r3;
                    }
                    if (data.shape3D) set3DShape(data.shape3D);
                    if (data.colorMode3D) set3DColorMode(data.colorMode3D);
                    if (data.labelMode3D) set3DLabelMode(data.labelMode3D);
                    if (data.theoryK) document.getElementById('tks').value = data.theoryK;
                    if (data.theoryR) document.getElementById('trs').value = data.theoryR;
                    updateTheory();
                    if (data.heatmapR) updateHeatmapR(data.heatmapR);
                    if (data.heatmapMode) setHeatmapMode(data.heatmapMode);
                    if (data.heatmapPointSize) document.getElementById('heatmapPS').value = data.heatmapPointSize;
                    if (data.gcdTableSize) {
                        document.getElementById('gcdTableSizeInput').value = data.gcdTableSize;
                        updateGCDTableSize();
                    }
                    if (data.gcdTableType) setTableType(data.gcdTableType);
                    if (data.gcdTableColorMode) setGCDTableColor(data.gcdTableColorMode);
                    if (data.gcdTableRotation !== undefined) setGCDTableRotation(data.gcdTableRotation);
                    if (data.criticalMaxR) updateCriticalMaxR(data.criticalMaxR);
                    if (data.criticalProblem) setCriticalProblem(data.criticalProblem);
                    if (data.criticalViz) setCriticalViz(data.criticalViz);
                    if (data.patternType) setPatternType(data.patternType);
                    if (data.analysisK) document.getElementById('analysisK').value = data.analysisK;
                    if (data.analysisMaxR) updateAnalysisRadius(data.analysisMaxR);
                    if (data.comparisonMode) setComparisonMode(data.comparisonMode);
                    if (data.comparisonR) updateComparisonRadius(data.comparisonR);
                    
                    alert(`Session "${session.name}" imported successfully!`);
                } catch (error) {
                    alert('Error loading session file: ' + error.message);
                }
            };
            reader.readAsText(file);
        }
        
        function displaySavedSessions() {
            const sessions = JSON.parse(localStorage.getItem('fareyLattice_sessions') || '[]');
            const container = document.getElementById('savedSessions');
            
            if (sessions.length === 0) {
                container.innerHTML = '<p style="color:var(--text2); font-style:italic;">No saved sessions yet</p>';
                return;
            }
            
            let html = '';
            sessions.forEach((session, index) => {
                const date = new Date(session.timestamp).toLocaleString();
                html += `
                    <div style="background:var(--bg); padding:15px; border-radius:8px; margin-bottom:10px; border:1px solid var(--border);">
                        <h4 style="color:var(--blue); margin-bottom:8px;">${session.name}</h4>
                        <p style="font-size:0.9em; color:var(--text2); margin-bottom:8px;">${date}</p>
                        ${session.description ? `<p style="font-size:0.9em; margin-bottom:10px;">${session.description}</p>` : ''}
                        <div style="display:flex; gap:8px;">
                            <button onclick="loadSession(${index})" style="padding:6px 12px; background:var(--green); font-size:0.9em;">Load</button>
                            <button onclick="deleteSession(${index})" style="padding:6px 12px; background:var(--red); font-size:0.9em;">Delete</button>
                        </div>
                    </div>
                `;
            });
            
            container.innerHTML = html;
        }
        
        function deleteSession(index) {
            if (!confirm('Are you sure you want to delete this session?')) return;
            
            let sessions = JSON.parse(localStorage.getItem('fareyLattice_sessions') || '[]');
            sessions.splice(index, 1);
            localStorage.setItem('fareyLattice_sessions', JSON.stringify(sessions));
            displaySavedSessions();
        }
        
        function clearAllSessions() {
            if (!confirm('Are you sure you want to delete ALL saved sessions? This cannot be undone.')) return;
            
            localStorage.removeItem('fareyLattice_sessions');
            displaySavedSessions();
            alert('All sessions cleared');
        }

        function updateComparison() {
            const grid = document.getElementById('compGrid');
            const showDensity = document.getElementById('showDensity').checked;
            const showVolume = document.getElementById('showVolume').checked;
            const showZeta = document.getElementById('showZeta').checked;
            const showChart = document.getElementById('showChart').checked;
            
            const dims = [];
            for (let k = 2; k <= 10; k++) {
                if (document.getElementById(`compk${k}`)?.checked) dims.push(k);
            }
            
            if (dims.length === 0) {
                grid.innerHTML = '<p style="color:var(--red);">Please select at least one dimension</p>';
                return;
            }
            
            grid.innerHTML = '';
            
            if (comparisonMode === 'fixed') {
                const R = parseInt(document.getElementById('crinput').value);
                
                dims.forEach(k => {
                    const z = zeta(k);
                    const vol = sphereVolume(k, R);
                    const pred = Math.round(vol / z);
                    const density = (1/z * 100).toFixed(2);
                    
                    let content = `
                        <div class="compare-item">
                            <h3 style="color:var(--blue); margin-bottom:15px;">Dimension k = ${k}</h3>
                            <div style="background:var(--bg); padding:10px; border-radius:6px; margin-bottom:10px;">
                                <p style="font-size:1.1em;"><b>Predicted Points:</b> ${pred.toLocaleString()}</p>
                            </div>
                    `;
                    
                    if (showZeta) {
                        content += `
                            <div style="background:var(--bg); padding:10px; border-radius:6px; margin-bottom:10px;">
                                <p><b>Œ∂(${k}):</b> ${z.toFixed(6)}</p>
                            </div>
                        `;
                    }
                    
                    if (showDensity) {
                        content += `
                            <div style="background:var(--bg); padding:10px; border-radius:6px; margin-bottom:10px;">
                                <p><b>Primitive Density:</b> ${density}%</p>
                                <p style="font-size:0.9em; color:var(--text2);">1/Œ∂(${k}) = ${(1/z).toFixed(6)}</p>
                            </div>
                        `;
                    }
                    
                    if (showVolume) {
                        content += `
                            <div style="background:var(--bg); padding:10px; border-radius:6px; margin-bottom:10px;">
                                <p><b>Sphere Volume:</b></p>
                                <p style="font-size:0.95em;">${vol.toExponential(4)}</p>
                            </div>
                        `;
                    }
                    
                    // Add growth rate info
                    content += `
                        <div style="background:var(--bg); padding:10px; border-radius:6px; margin-bottom:10px;">
                            <p><b>Growth Rate:</b> O(R^${k})</p>
                            <p style="font-size:0.9em; color:var(--text2);">Error: O(R^${k-1})</p>
                        </div>
                    `;
                    
                    content += `</div>`;
                    grid.innerHTML += content;
                });
            } else {
                // Multiple radii mode
                const radiiStr = document.getElementById('multiRadii').value;
                const radii = radiiStr.split(',').map(r => parseInt(r.trim())).filter(r => !isNaN(r) && r > 0);
                
                if (radii.length === 0) {
                    grid.innerHTML = '<p style="color:var(--red);">Please enter valid radii (e.g., 10, 20, 30)</p>';
                    return;
                }
                
                dims.forEach(k => {
                    let content = `
                        <div class="compare-item">
                            <h3 style="color:var(--blue); margin-bottom:15px;">Dimension k = ${k}</h3>
                    `;
                    
                    if (showZeta) {
                        const z = zeta(k);
                        content += `
                            <div style="background:var(--bg); padding:10px; border-radius:6px; margin-bottom:10px;">
                                <p><b>Œ∂(${k}):</b> ${z.toFixed(6)}</p>
                                <p><b>Density:</b> ${((1/z)*100).toFixed(2)}%</p>
                            </div>
                        `;
                    }
                    
                    content += '<table style="width:100%; font-size:0.9em;"><thead><tr><th>R</th><th>Predicted</th>';
                    if (showVolume) content += '<th>Volume</th>';
                    content += '</tr></thead><tbody>';
                    
                    radii.forEach(R => {
                        const vol = sphereVolume(k, R);
                        const pred = Math.round(vol / zeta(k));
                        content += `<tr><td>${R}</td><td>${pred.toLocaleString()}</td>`;
                        if (showVolume) content += `<td>${vol.toExponential(2)}</td>`;
                        content += '</tr>';
                    });
                    
                    content += '</tbody></table></div>';
                    grid.innerHTML += content;
                });
            }
            
            // Update chart
            if (showChart) {
                document.getElementById('comparisonChart').style.display = 'block';
                updateComparisonChart(dims);
            } else {
                document.getElementById('comparisonChart').style.display = 'none';
            }
        }

        function updateAnalysisRadius(value) {
            const R = parseInt(value);
            if (R < 10 || R > 1000 || isNaN(R)) return;
            
            document.getElementById('mrv').textContent = R;
            document.getElementById('mr').value = Math.min(R, 200);
            document.getElementById('mrinput').value = R;
        }

        function runAnalysis() {
            const canvas = document.getElementById('ch');
            const ctx = canvas.getContext('2d');
            const k = parseInt(document.getElementById('analysisK').value);
            const maxR = parseInt(document.getElementById('mrinput').value);
            const minR = parseInt(document.getElementById('minr').value);
            
            const showAbsError = document.getElementById('showAbsError').checked;
            const showRelError = document.getElementById('showRelError').checked;
            const showBoundary = document.getElementById('showBoundary').checked;
            const showActualCount = document.getElementById('showActualCount').checked;
            const showRunningAvg = document.getElementById('showRunningAvg')?.checked || false;
            
            document.getElementById('loadAnalysis').classList.add('active');
            
            setTimeout(() => {
                if (chart) chart.destroy();
                
                const labels = [];
                const absErrorData = [];
                const relErrorData = [];
                const boundaryData = [];
                const actualCountData = [];
                const runningAvgData = [];
                
                let sumError = 0;
                
                // Compute for EVERY SINGLE radius from minR to maxR (no stepping)
                for (let R = minR; R <= maxR; R++) {
                    labels.push(R);
                    
                    const vol = sphereVolume(k, R);
                    const pred = vol / zeta(k);
                    
                    let actual = 0;
                    
                    // Compute actual count based on dimension and feasibility
                    if (k === 2) {
                        // 2D: Can compute exactly up to R=200
                        if (R <= 200) {
                            for (let x = -R; x <= R; x++) {
                                for (let y = -R; y <= R; y++) {
                                    if (x*x + y*y <= R*R && gcd(Math.abs(x), Math.abs(y)) === 1) {
                                        actual++;
                                    }
                                }
                            }
                        } else {
                            actual = Math.round(pred); // Use prediction for very large R
                        }
                    } else if (k === 3) {
                        // 3D: Can compute exactly up to R=40
                        if (R <= 40) {
                            for (let x = -R; x <= R; x++) {
                                for (let y = -R; y <= R; y++) {
                                    for (let z = -R; z <= R; z++) {
                                        if (x*x + y*y + z*z <= R*R && gcdArray([Math.abs(x), Math.abs(y), Math.abs(z)]) === 1) {
                                            actual++;
                                        }
                                    }
                                }
                            }
                        } else {
                            actual = Math.round(pred);
                        }
                    } else if (k === 4) {
                        // 4D: Can compute exactly up to R=15
                        if (R <= 15) {
                            for (let x = -R; x <= R; x++) {
                                for (let y = -R; y <= R; y++) {
                                    for (let z = -R; z <= R; z++) {
                                        for (let w = -R; w <= R; w++) {
                                            if (x*x + y*y + z*z + w*w <= R*R && gcdArray([Math.abs(x), Math.abs(y), Math.abs(z), Math.abs(w)]) === 1) {
                                                actual++;
                                            }
                                        }
                                    }
                                }
                            }
                        } else {
                            actual = Math.round(pred);
                        }
                    } else {
                        // Higher dimensions: use prediction
                        actual = Math.round(pred);
                    }
                    
                    const error = actual - pred;
                    const absError = Math.abs(error);
                    const relError = pred > 0 ? (absError / pred) * 100 : 0;
                    const boundary = Math.pow(R, k - 1);
                    
                    sumError += absError;
                    const runningAvg = sumError / (R - minR + 1);
                    
                    absErrorData.push(absError);
                    relErrorData.push(relError);
                    boundaryData.push(boundary);
                    actualCountData.push(actual);
                    runningAvgData.push(runningAvg);
                }
                
                const datasets = [];
                
                if (showActualCount) {
                    datasets.push({
                        label: `Actual Primitive Count (k=${k})`,
                        data: actualCountData,
                        backgroundColor: 'rgba(0, 102, 204, 0.5)',
                        borderColor: '#0066cc',
                        borderWidth: 1,
                        type: 'bar',
                        yAxisID: 'y1',
                        order: 5
                    });
                }
                
                if (showAbsError) {
                    datasets.push({
                        label: `Absolute Error |Actual - Pred| (k=${k})`,
                        data: absErrorData,
                        backgroundColor: 'rgba(220, 53, 69, 0.6)',
                        borderColor: '#dc3545',
                        borderWidth: 2,
                        type: 'bar',
                        yAxisID: 'y',
                        order: 4
                    });
                }
                
                if (showRunningAvg) {
                    datasets.push({
                        label: `Running Average of |Error| (k=${k})`,
                        data: runningAvgData,
                        backgroundColor: 'rgba(40, 167, 69, 0.2)',
                        borderColor: '#28a745',
                        borderWidth: 3,
                        pointRadius: 0,
                        type: 'line',
                        yAxisID: 'y',
                        order: 2,
                        fill: true,
                        tension: 0.4
                    });
                }
                
                if (showRelError) {
                    datasets.push({
                        label: `Relative Error % (k=${k})`,
                        data: relErrorData,
                        backgroundColor: 'rgba(255, 193, 7, 0.6)',
                        borderColor: '#ffc107',
                        borderWidth: 2,
                        pointRadius: 1,
                        pointHoverRadius: 5,
                        type: 'line',
                        yAxisID: 'y2',
                        order: 3,
                        fill: false
                    });
                }
                
                if (showBoundary) {
                    datasets.push({
                        label: `Theoretical Boundary O(R^${k-1})`,
                        data: boundaryData,
                        backgroundColor: 'rgba(111, 66, 193, 0.3)',
                        borderColor: '#6f42c1',
                        borderWidth: 2,
                        borderDash: [5, 5],
                        pointRadius: 0,
                        type: 'line',
                        yAxisID: 'y',
                        order: 1,
                        fill: false
                    });
                }
                
                const scales = {
                    x: { 
                        title: { display: true, text: 'Radius R', font: { size: 14 } }
                    },
                    y: {
                        type: 'logarithmic',
                        position: 'left',
                        title: { display: true, text: 'Count / Error', font: { size: 14 } },
                        display: showAbsError || showBoundary || showActualCount
                    }
                };
                
                if (showActualCount) {
                    scales.y1 = {
                        type: 'logarithmic',
                        position: 'right',
                        title: { display: true, text: 'Actual Count', font: { size: 14 } },
                        grid: { drawOnChartArea: false }
                    };
                }
                
                if (showRelError) {
                    scales.y2 = {
                        type: 'linear',
                        position: 'right',
                        title: { display: true, text: 'Relative Error %', font: { size: 14 } },
                        grid: { drawOnChartArea: false }
                    };
                }
                
                chart = new Chart(ctx, {
                    type: 'bar',
                    data: { labels, datasets },
                    options: { 
                        responsive: true,
                        maintainAspectRatio: true,
                        onClick: (event, elements) => {
                            if (elements.length > 0) {
                                const index = elements[0].index;
                                const R = labels[index];
                                displayPointAnalysis(R, actualCountData[index], absErrorData[index], relErrorData[index]);
                            }
                        },
                        scales,
                        plugins: {
                            legend: { 
                                display: true,
                                position: 'top',
                                labels: { font: { size: 11 } }
                            },
                            title: {
                                display: true,
                                text: `Error Analysis: Œî(R) for ALL radius values (k=${k}, R=${minR} to ${maxR})`,
                                font: { size: 16, weight: 'bold' }
                            },
                            tooltip: { 
                                mode: 'index', 
                                intersect: false,
                                callbacks: {
                                    label: function(context) {
                                        let label = context.dataset.label || '';
                                        if (label) label += ': ';
                                        if (context.parsed.y !== null) {
                                            if (label.includes('%')) {
                                                label += context.parsed.y.toFixed(4) + '%';
                                            } else {
                                                label += context.parsed.y.toLocaleString(undefined, {
                                                    minimumFractionDigits: 0,
                                                    maximumFractionDigits: 2
                                                });
                                            }
                                        }
                                        return label;
                                    }
                                }
                            }
                        },
                        interaction: {
                            mode: 'index',
                            intersect: false
                        }
                    }
                });
                
                // Store data globally for point analysis
                window.errorAnalysisData = {
                    k, minR, maxR,
                    labels, actualCountData, absErrorData, relErrorData, boundaryData, runningAvgData
                };
                
                document.getElementById('loadAnalysis').classList.remove('active');
            }, 100);
        }

        function displayPointAnalysis(R, actualCount, absError, relError) {
            const k = window.errorAnalysisData?.k || 2;
            const vol = sphereVolume(k, R);
            const predicted = vol / zeta(k);
            const error = actualCount - predicted;
            const boundary = Math.pow(R, k - 1);
            const errorRatio = (absError / boundary * 100).toFixed(2);
            
            const infoDiv = document.getElementById('pointAnalysisResult');
            infoDiv.classList.add('point-info-active');
            setTimeout(() => infoDiv.classList.remove('point-info-active'), 500);
            
            infoDiv.innerHTML = `
                <h3 style="color:var(--blue); margin-bottom:15px;">Analysis for R = ${R}, k = ${k}</h3>
                <div style="display:grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap:15px;">
                    <div>
                        <p><b>Predicted N(R):</b> ${formatPrecise(predicted, 6)}</p>
                        <p><b>Actual N(R):</b> ${actualCount}</p>
                        <p><b>Error Œî(R):</b> <span style="color:${error > 0 ? 'var(--green)' : 'var(--red)'}">${error > 0 ? '+' : ''}${formatPrecise(error, 6)}</span></p>
                        <p><b>Absolute Error:</b> ${formatPrecise(absError, 6)}</p>
                    </div>
                    <div>
                        <p><b>Relative Error:</b> ${formatPrecise(relError, 4)}%</p>
                        <p><b>Boundary O(R^${k-1}):</b> ${formatPrecise(boundary, 6)}</p>
                        <p><b>Error/Boundary:</b> ${errorRatio}%</p>
                        <p><b>Growth Rate:</b> O(R^${k})</p>
                    </div>
                </div>
                <div style="margin-top:15px; padding:10px; background:var(--bg); border-radius:6px;">
                    <p style="font-size:0.9em; color:var(--text2);">
                        ${error > 0 ? 'Positive error: More primitive points than predicted' : 'Negative error: Fewer primitive points than predicted'}
                    </p>
                    <p style="font-size:0.9em; color:var(--text2); margin-top:5px;">
                        The error is ${errorRatio}% of the theoretical boundary term R^${k-1}
                    </p>
                </div>
            `;
        }

        function analyzeSpecificPoint() {
            const R = prompt('Enter radius R to analyze:', '100');
            if (!R || isNaN(R)) return;
            
            const data = window.errorAnalysisData;
            if (!data) {
                alert('Please run the analysis first');
                return;
            }
            
            const Rval = parseInt(R);
            const index = data.labels.indexOf(Rval);
            
            if (index === -1 || Rval < data.minR || Rval > data.maxR) {
                alert(`R=${Rval} is outside the analyzed range [${data.minR}, ${data.maxR}]`);
                return;
            }
            
            displayPointAnalysis(Rval, data.actualCountData[index], data.absErrorData[index], data.relErrorData[index]);
        }

        function updateDimScale() {
            const k = parseInt(document.getElementById('dimScaleKSlider').value);
            const R = parseInt(document.getElementById('dimScaleRSlider').value);
            
            document.getElementById('dimScaleK').textContent = k;
            document.getElementById('dimScaleR').textContent = R;
            
            const mainTerm = Math.pow(R, k);
            const boundaryTerm = Math.pow(R, k - 1);
            const relativeError = (boundaryTerm / mainTerm * 100).toFixed(2);
            const density = 1 / zeta(k);
            
            document.getElementById('mainTerm').textContent = mainTerm.toLocaleString();
            document.getElementById('boundaryTerm').textContent = boundaryTerm.toLocaleString();
            document.getElementById('relativeError').textContent = relativeError + '%';
            document.getElementById('densityVal').textContent = density.toFixed(4);
        }

        function set2DPreset(preset) {
            const presets = {
                'small': 10,
                'medium': 50,
                'large': 100,
                'xlarge': 200,
                'huge': 500
            };
            update2DRadius(presets[preset]);
        }

        function set3DPreset(preset) {
            const presets = {
                'tiny': 5,
                'small': 10,
                'medium': 20,
                'large': 30
            };
            document.getElementById('r3').value = presets[preset];
            document.getElementById('r3v').textContent = presets[preset];
            draw3D();
        }

        function setComparisonPreset(preset) {
            // Uncheck all dimensions first
            for (let k = 2; k <= 10; k++) {
                const checkbox = document.getElementById(`compk${k}`);
                if (checkbox) checkbox.checked = false;
            }
            
            if (preset === 'low') {
                [2, 3, 4].forEach(k => document.getElementById(`compk${k}`).checked = true);
            } else if (preset === 'mid') {
                [3, 4, 5, 6].forEach(k => document.getElementById(`compk${k}`).checked = true);
            } else if (preset === 'high') {
                [5, 6, 7, 8, 9, 10].forEach(k => document.getElementById(`compk${k}`).checked = true);
            } else if (preset === 'all') {
                for (let k = 2; k <= 10; k++) {
                    document.getElementById(`compk${k}`).checked = true;
                }
            } else if (preset === 'growth') {
                setComparisonMode('multi');
                [2, 3, 4, 5].forEach(k => document.getElementById(`compk${k}`).checked = true);
                document.getElementById('multiRadii').value = '5, 10, 15, 20, 25, 30';
            }
            
            updateComparison();
        }

        function setAnalysisPreset(preset) {
            if (preset === 'quick') {
                updateAnalysisRadius(50);
            } else if (preset === 'standard') {
                updateAnalysisRadius(100);
            } else if (preset === 'detailed') {
                updateAnalysisRadius(200);
            } else if (preset === 'extended') {
                updateAnalysisRadius(500);
            }
            
            runAnalysis();
        }

        function setGCDPreset(preset) {
            const presets = {
                'coprime': '15, 28',
                'common': '12, 18, 24',
                'large': '1024, 2048, 4096',
                'many': '60, 72, 90, 120, 150'
            };
            document.getElementById('gi').value = presets[preset];
            calcGCD();
        }

        function setMobiusPreset(preset) {
            const presets = {
                'squarefree': 30,
                'notsquarefree': 72,
                'prime': 17,
                'composite': 210
            };
            document.getElementById('mi').value = presets[preset];
            calcMobius();
        }

        function setPrimePreset(preset) {
            const presets = {
                'small': 60,
                'perfect': 28,
                'highly': 5040,
                'large': 65536,
                'power': 243
            };
            document.getElementById('pi').value = presets[preset];
            calcPrime();
        }

        function setCoprimePreset(preset) {
            const presets = {
                'coprime2': '35, 64',
                'notcoprime2': '24, 36',
                'coprime3': '7, 11, 13',
                'consecutive': '100, 101, 102'
            };
            document.getElementById('cci').value = presets[preset];
            checkCoprime();
        }

        function setPointPreset(preset) {
            const presets = {
                'pythagorean': '3, 4, 5',
                'primitive2d': '7, 9',
                'nonprimitive2d': '6, 8',
                'primitive3d': '1, 2, 3',
                'highd': '1, 1, 1, 1, 1'
            };
            document.getElementById('psi').value = presets[preset];
            searchPoint();
        }

        function calcGCD() {
            const inp = document.getElementById('gi').value;
            const nums = inp.split(',').map(n => parseInt(n.trim())).filter(n => !isNaN(n));
            if (nums.length < 2) {
                document.getElementById('gr').innerHTML = '<p style="color:var(--red)">Need 2+ numbers</p>';
                return;
            }
            const g = gcdArray(nums);
            const coprime = g === 1 ? '<span style="color:var(--green)">Yes - Coprime</span>' : '<span style="color:var(--red)">No - Not Coprime</span>';
            
            // Show step-by-step GCD calculation for pairs
            let steps = '<div style="background:var(--bg3); padding:15px; border-radius:8px; margin-top:10px;">';
            steps += '<b>Step-by-step calculation:</b><br>';
            let current = nums[0];
            for (let i = 1; i < nums.length; i++) {
                const prev = current;
                current = gcd(current, nums[i]);
                steps += `gcd(${prev}, ${nums[i]}) = ${current}<br>`;
            }
            steps += '</div>';
            
            // Prime factorizations
            let factorizations = '<div style="background:var(--bg3); padding:15px; border-radius:8px; margin-top:10px;">';
            factorizations += '<b>Prime factorizations:</b><br>';
            nums.forEach(n => {
                const f = primeFactors(Math.abs(n));
                const fc = {};
                f.forEach(p => fc[p] = (fc[p]||0) + 1);
                const fs = Object.entries(fc).map(([p,c]) => c>1 ? `${p}^${c}` : p).join(' √ó ');
                factorizations += `${n} = ${fs || '1'}<br>`;
            });
            
            // GCD factorization
            if (g > 1) {
                const gf = primeFactors(g);
                const gfc = {};
                gf.forEach(p => gfc[p] = (gfc[p]||0) + 1);
                const gfs = Object.entries(gfc).map(([p,c]) => c>1 ? `${p}^${c}` : p).join(' √ó ');
                factorizations += `<br><b>GCD = ${g} = ${gfs}</b>`;
            }
            factorizations += '</div>';
            
            document.getElementById('gr').innerHTML = `
                <p><b>Numbers:</b> ${nums.join(', ')}</p>
                <p><b>GCD:</b> ${g}</p>
                <p>${coprime}</p>
                ${steps}
                ${factorizations}
            `;
        }

        function calcMobius() {
            const n = parseInt(document.getElementById('mi').value);
            if (!n || n < 1) return;
            const mu = mobius(n), f = primeFactors(n);
            const u = [...new Set(f)];
            const sqfree = f.length === u.length;
            const interp = mu === 0 ? 'Not square-free (has repeated prime factors)' : mu === 1 ? 'Even number of distinct prime factors' : 'Odd number of distinct prime factors';
            
            // Build prime factorization display
            const fc = {};
            f.forEach(p => fc[p] = (fc[p]||0) + 1);
            const fs = Object.entries(fc).map(([p,c]) => c>1 ? `${p}^${c}` : p).join(' √ó ');
            const repeatedPrimes = Object.entries(fc).filter(([p,c]) => c > 1).map(([p,c]) => `${p} (appears ${c} times)`);
            
            let details = '<div style="background:var(--bg3); padding:15px; border-radius:8px; margin-top:10px;">';
            details += `<b>Prime factorization:</b> ${n} = ${fs || '1'}<br>`;
            details += `<b>Distinct primes:</b> {${u.join(', ')}}<br>`;
            details += `<b>Number of distinct primes:</b> ${u.length}<br>`;
            if (repeatedPrimes.length > 0) {
                details += `<b>Repeated primes:</b> ${repeatedPrimes.join(', ')}<br>`;
            }
            details += `<b>Square-free:</b> ${sqfree ? '‚úì Yes' : '‚úó No'}<br>`;
            details += '</div>';
            
            let formula = '<div style="background:var(--bg3); padding:15px; border-radius:8px; margin-top:10px;">';
            formula += '<b>Formula calculation:</b><br>';
            if (mu === 0) {
                formula += `Œº(${n}) = 0 (not square-free)<br>`;
            } else {
                formula += `Œº(${n}) = (-1)^${u.length} = (-1)^${u.length} = ${mu}<br>`;
            }
            formula += '</div>';
            
            document.getElementById('mr2').innerHTML = `
                <p style="font-size:1.3em;"><b>Œº(${n}) = ${mu}</b></p>
                <p style="color:var(--blue);"><b>${interp}</b></p>
                ${details}
                ${formula}
            `;
        }

        function calcPrime() {
            const n = parseInt(document.getElementById('pi').value);
            if (!n || n < 2) return;
            const f = primeFactors(n);
            const fc = {};
            f.forEach(p => fc[p] = (fc[p]||0) + 1);
            const fs = Object.entries(fc).map(([p,c]) => c>1 ? `${p}^${c}` : p).join(' √ó ');
            
            let details = '<div style="background:var(--bg3); padding:15px; border-radius:8px; margin-top:10px;">';
            details += '<b>Detailed breakdown:</b><br>';
            details += `<b>All prime factors:</b> ${f.join(' √ó ')}<br>`;
            details += `<b>Distinct primes:</b> ${Object.keys(fc).join(', ')}<br>`;
            details += `<b>Number of distinct primes:</b> ${Object.keys(fc).length}<br>`;
            details += `<b>Total number of prime factors (with repetition):</b> ${f.length}<br>`;
            
            // Show exponent breakdown
            details += '<br><b>Exponent breakdown:</b><br>';
            Object.entries(fc).forEach(([p, c]) => {
                details += `${p} appears ${c} time${c > 1 ? 's' : ''}<br>`;
            });
            
            // Divisor information
            const numDivisors = Object.values(fc).reduce((prod, exp) => prod * (exp + 1), 1);
            details += `<br><b>Number of divisors:</b> ${numDivisors}<br>`;
            
            // Sum of divisors (for small numbers)
            if (n <= 1000) {
                let sumDiv = 0;
                for (let i = 1; i <= n; i++) {
                    if (n % i === 0) sumDiv += i;
                }
                details += `<b>Sum of divisors:</b> ${sumDiv}<br>`;
                const perfect = sumDiv === 2 * n;
                const abundant = sumDiv > 2 * n;
                const deficient = sumDiv < 2 * n;
                details += `<b>Number type:</b> ${perfect ? 'Perfect' : abundant ? 'Abundant' : 'Deficient'}<br>`;
            }
            
            details += '</div>';
            
            document.getElementById('pr').innerHTML = `
                <p style="font-size:1.3em;"><b>${n} = ${fs}</b></p>
                <p style="font-size:1.1em;">${isPrime(n) ? '<span style="color:var(--green)">PRIME NUMBER</span>' : '<span style="color:var(--blue)">COMPOSITE NUMBER</span>'}</p>
                ${details}
            `;
        }

        function checkCoprime() {
            const inp = document.getElementById('cci').value;
            const nums = inp.split(',').map(n => parseInt(n.trim())).filter(n => !isNaN(n));
            if (nums.length < 2) {
                document.getElementById('ccr').innerHTML = '<p style="color:var(--red)">Need 2+ numbers</p>';
                return;
            }
            const g = gcdArray(nums);
            const coprime = g === 1;
            
            // Prime factorizations
            let factorInfo = '<div style="background:var(--bg3); padding:15px; border-radius:8px; margin-top:10px;">';
            factorInfo += '<b>Prime factorizations:</b><br>';
            nums.forEach(n => {
                const f = primeFactors(Math.abs(n));
                const fc = {};
                f.forEach(p => fc[p] = (fc[p]||0) + 1);
                const fs = Object.entries(fc).map(([p,c]) => c>1 ? `${p}^${c}` : p).join(' √ó ');
                factorInfo += `${n} = ${fs || '1'}<br>`;
            });
            factorInfo += '</div>';
            
            // Common factors
            let commonInfo = '<div style="background:var(--bg3); padding:15px; border-radius:8px; margin-top:10px;">';
            if (coprime) {
                commonInfo += '<b>Common factors:</b> Only 1 (coprime)<br>';
                commonInfo += 'These numbers share no prime factors.';
            } else {
                const gf = primeFactors(g);
                const gfc = {};
                gf.forEach(p => gfc[p] = (gfc[p]||0) + 1);
                const gfs = Object.entries(gfc).map(([p,c]) => c>1 ? `${p}^${c}` : p).join(' √ó ');
                commonInfo += `<b>Common factors:</b> Divisors of ${g}<br>`;
                commonInfo += `<b>GCD breakdown:</b> ${g} = ${gfs}<br>`;
                commonInfo += `<b>Shared primes:</b> ${Object.keys(gfc).join(', ')}`;
            }
            commonInfo += '</div>';
            
            document.getElementById('ccr').innerHTML = `
                <p><b>Numbers:</b> ${nums.join(', ')}</p>
                <p><b>GCD:</b> ${g}</p>
                <p style="font-size:1.2em; margin-top:10px">${coprime ? '<span style="color:var(--green)">COPRIME (Primitive point)</span>' : '<span style="color:var(--red)">NOT COPRIME (Non-primitive)</span>'}</p>
                ${factorInfo}
                ${commonInfo}
            `;
        }

        function searchPoint() {
            const inp = document.getElementById('psi').value;
            const coords = inp.split(',').map(n => parseInt(n.trim())).filter(n => !isNaN(n));
            if (coords.length < 2) {
                document.getElementById('psr').innerHTML = '<p style="color:var(--red)">Need 2+ coordinates</p>';
                return;
            }
            const g = gcdArray(coords);
            const isPrim = g === 1;
            const dist = Math.sqrt(coords.reduce((sum, x) => sum + x*x, 0));
            
            // Point factorization
            let pointInfo = '<div style="background:var(--bg3); padding:15px; border-radius:8px; margin-top:10px;">';
            pointInfo += '<b>Coordinate factorizations:</b><br>';
            coords.forEach((c, i) => {
                const label = ['x', 'y', 'z', 'w', 'v', 'u'][i] || `x${i}`;
                if (c === 0) {
                    pointInfo += `${label} = 0<br>`;
                } else {
                    const f = primeFactors(Math.abs(c));
                    const fc = {};
                    f.forEach(p => fc[p] = (fc[p]||0) + 1);
                    const fs = Object.entries(fc).map(([p,cnt]) => cnt>1 ? `${p}^${cnt}` : p).join(' √ó ');
                    const sign = c < 0 ? '-' : '';
                    pointInfo += `${label} = ${sign}${fs || '1'}<br>`;
                }
            });
            pointInfo += '</div>';
            
            // GCD analysis
            let gcdInfo = '<div style="background:var(--bg3); padding:15px; border-radius:8px; margin-top:10px;">';
            if (g === 1) {
                gcdInfo += '<b>GCD Analysis:</b><br>';
                gcdInfo += 'GCD = 1 ‚Üí Coordinates are coprime<br>';
                gcdInfo += 'This point cannot be expressed as d¬∑(simpler point) where d > 1';
            } else {
                const reduced = coords.map(c => c / g);
                const gf = primeFactors(g);
                const gfc = {};
                gf.forEach(p => gfc[p] = (gfc[p]||0) + 1);
                const gfs = Object.entries(gfc).map(([p,c]) => c>1 ? `${p}^${c}` : p).join(' √ó ');
                gcdInfo += '<b>GCD Analysis:</b><br>';
                gcdInfo += `GCD = ${g} = ${gfs}<br>`;
                gcdInfo += `<b>Reduced form:</b> (${reduced.join(', ')}) is the primitive point<br>`;
                gcdInfo += `<b>Relationship:</b> (${coords.join(', ')}) = ${g} √ó (${reduced.join(', ')})`;
            }
            gcdInfo += '</div>';
            
            // Geometric properties
            let geomInfo = '<div style="background:var(--bg3); padding:15px; border-radius:8px; margin-top:10px;">';
            geomInfo += '<b>Geometric Properties:</b><br>';
            geomInfo += `<b>Euclidean norm:</b> ||point|| = ‚àö(${coords.map(c => c + '¬≤').join(' + ')}) = ${dist.toFixed(4)}<br>`;
            geomInfo += `<b>Manhattan distance:</b> ${coords.reduce((sum, c) => sum + Math.abs(c), 0)}<br>`;
            geomInfo += `<b>Max coordinate:</b> ${Math.max(...coords.map(Math.abs))}<br>`;
            const numZeros = coords.filter(c => c === 0).length;
            if (numZeros > 0) {
                geomInfo += `<b>Zero coordinates:</b> ${numZeros} (lies on ${coords.length - numZeros}D subspace)`;
            }
            geomInfo += '</div>';
            
            document.getElementById('psr').innerHTML = `
                <p><b>Point:</b> (${coords.join(', ')})</p>
                <p><b>Dimension:</b> ${coords.length}</p>
                <p><b>GCD of coordinates:</b> ${g}</p>
                <p style="font-size:1.2em; margin-top:10px">${isPrim ? '<span style="color:var(--green)">PRIMITIVE LATTICE POINT</span>' : '<span style="color:var(--red)">NON-PRIMITIVE LATTICE POINT</span>'}</p>
                ${pointInfo}
                ${gcdInfo}
                ${geomInfo}
            `;
        }

        function exportCanvas(canvasId, filename) {
            const canvas = document.getElementById(canvasId);
            const link = document.createElement('a');
            link.download = `${filename}.png`;
            link.href = canvas.toDataURL();
            link.click();
        }

        function exportPointData2D() {
            if (!cache.points2D) { alert('Generate 2D visualization first'); return; }
            const data = cache.points2D;
            let csv = 'x,y,type\n';
            data.primitive.forEach(p => csv += `${p.x},${p.y},primitive\n`);
            data.nonPrimitive.forEach(p => csv += `${p.x},${p.y},non-primitive\n`);
            downloadCSV(csv, '2d-lattice-points.csv');
        }

        function export3DData() {
            if (!cache.points3D) { alert('Generate 3D visualization first'); return; }
            const data = cache.points3D;
            let csv = 'x,y,z,type\n';
            data.primitive.forEach(p => csv += `${p.x},${p.y},${p.z},primitive\n`);
            data.nonPrimitive.forEach(p => csv += `${p.x},${p.y},${p.z},non-primitive\n`);
            downloadCSV(csv, '3d-lattice-points.csv');
        }

        function exportTheoryData() {
            const k = parseInt(document.getElementById('tks').value);
            const R = parseInt(document.getElementById('trs').value);
            const z = zeta(k);
            const vol = sphereVolume(k, R);
            const pred = vol / z;
            const precision = k > 6 ? 17 : 12;
            
            let csv = `# Primitive Lattice Point Theory - Complete Data\n`;
            csv += `# Generated: ${new Date().toISOString()}\n`;
            csv += `# By Wessen Getachew | @7dview | wessengetachew.github.io\n`;
            csv += `#\n`;
            csv += `# Current parameters: k=${k}, R=${R}\n`;
            csv += `# Formula: N_k(R) = V_k¬∑R^k/Œ∂(k) + O(R^(k-1))\n`;
            csv += `#\n`;
            csv += `dimension_k,radius_R,zeta_k,density_1_over_zeta,sphere_volume_Vk,predicted_primitive_points\n`;
            csv += `${k},${R},${formatPrecise(z, precision)},${formatPrecise(1/z, precision)},${formatPrecise(vol, precision)},${formatPrecise(pred, precision)}\n`;
            csv += `#\n`;
            csv += `# Complete table for all dimensions 2-12:\n`;
            csv += `dimension_k,zeta_k,density_1_over_zeta,unit_sphere_volume\n`;
            
            for (let dim = 2; dim <= 12; dim++) {
                const zd = zeta(dim);
                const dimPrecision = dim > 6 ? 17 : 12;
                const vd = dim % 2 === 0 ? 
                    (Math.pow(Math.PI, dim/2) / factorial(dim/2)) :
                    (2 * factorial((dim-1)/2) * Math.pow(Math.PI, (dim-1)/2) / factorial(dim));
                csv += `${dim},${formatPrecise(zd, dimPrecision)},${formatPrecise(1/zd, dimPrecision)},${formatPrecise(vd, dimPrecision)}\n`;
            }
            
            downloadCSV(csv, `theory-complete-k${k}-r${R}.csv`);
        }

        function exportChartData() {
            if (!window.errorAnalysisData) { 
                alert('Run error analysis first'); 
                return; 
            }
            
            const data = window.errorAnalysisData;
            const precision = data.k > 6 ? 17 : 12;
            
            let csv = `# Error Analysis Data - Dimension k=${data.k}\n`;
            csv += `# Generated: ${new Date().toISOString()}\n`;
            csv += `# By Wessen Getachew | @7dview | wessengetachew.github.io\n`;
            csv += `#\n`;
            csv += `# This dataset contains error analysis for EVERY radius from ${data.minR} to ${data.maxR}\n`;
            csv += `# Formula: N(R) = R^k/Œ∂(k) + Œî(R), where Œî(R) = O(R^(k-1))\n`;
            csv += `# Œ∂(${data.k}) = ${formatPrecise(zeta(data.k), precision)}\n`;
            csv += `#\n`;
            csv += `radius,actual_count,predicted_count,error_delta,abs_error,relative_error_pct,boundary_term,running_avg_error\n`;
            
            for (let i = 0; i < data.labels.length; i++) {
                const R = data.labels[i];
                const actual = data.actualCountData[i];
                const vol = sphereVolume(data.k, R);
                const predicted = vol / zeta(data.k);
                const error = actual - predicted;
                const absErr = data.absErrorData[i];
                const relErr = data.relErrorData[i];
                const boundary = data.boundaryData[i];
                const runningAvg = data.runningAvgData[i];
                
                csv += `${R},${actual},${formatPrecise(predicted, precision)},${formatPrecise(error, precision)},${formatPrecise(absErr, precision)},${formatPrecise(relErr, precision)},${formatPrecise(boundary, precision)},${formatPrecise(runningAvg, precision)}\n`;
            }
            
            downloadCSV(csv, `error-analysis-k${data.k}-r${data.minR}-${data.maxR}.csv`);
        }

        function exportComparisonData() {
            const showDensity = document.getElementById('showDensity').checked;
            const showVolume = document.getElementById('showVolume').checked;
            const showZeta = document.getElementById('showZeta').checked;
            
            const dims = [];
            for (let k = 2; k <= 10; k++) {
                if (document.getElementById(`compk${k}`)?.checked) dims.push(k);
            }
            
            if (dims.length === 0) {
                alert('Please select at least one dimension');
                return;
            }
            
            let csv = `# Dimension Comparison Analysis\n`;
            csv += `# Generated: ${new Date().toISOString()}\n`;
            csv += `# By Wessen Getachew | @7dview | wessengetachew.github.io\n`;
            csv += `#\n`;
            csv += `# Comparing dimensions: ${dims.join(', ')}\n`;
            csv += `# Mode: ${comparisonMode === 'fixed' ? 'Fixed Radius' : 'Multiple Radii'}\n`;
            csv += `#\n`;
            
            csv += 'dimension_k,';
            if (comparisonMode === 'fixed') {
                csv += 'radius_R,';
            }
            if (showZeta) csv += 'zeta_k,';
            if (showDensity) csv += 'density_1_over_zeta,';
            csv += 'predicted_primitive_points';
            if (showVolume) csv += ',sphere_volume';
            csv += '\n';
            
            if (comparisonMode === 'fixed') {
                const R = parseInt(document.getElementById('crinput').value);
                dims.forEach(k => {
                    const z = zeta(k);
                    const precision = k > 6 ? 17 : 12;
                    const vol = sphereVolume(k, R);
                    const pred = vol / z;
                    csv += `${k},${R},`;
                    if (showZeta) csv += `${formatPrecise(z, precision)},`;
                    if (showDensity) csv += `${formatPrecise(1/z, precision)},`;
                    csv += `${formatPrecise(pred, precision)}`;
                    if (showVolume) csv += `,${formatPrecise(vol, precision)}`;
                    csv += '\n';
                });
            } else {
                const radiiStr = document.getElementById('multiRadii').value;
                const radii = radiiStr.split(',').map(r => parseInt(r.trim())).filter(r => !isNaN(r) && r > 0);
                
                dims.forEach(k => {
                    const z = zeta(k);
                    const precision = k > 6 ? 17 : 12;
                    radii.forEach(R => {
                        const vol = sphereVolume(k, R);
                        const pred = vol / z;
                        csv += `${k},${R},`;
                        if (showZeta) csv += `${formatPrecise(z, precision)},`;
                        if (showDensity) csv += `${formatPrecise(1/z, precision)},`;
                        csv += `${formatPrecise(pred, precision)}`;
                        if (showVolume) csv += `,${formatPrecise(vol, precision)}`;
                        csv += '\n';
                    });
                });
            }
            
            downloadCSV(csv, `dimension-comparison-${comparisonMode}.csv`);
        }

        function downloadCSV(content, filename) {
            const blob = new Blob([content], { type: 'text/csv' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            link.download = filename;
            link.click();
            URL.revokeObjectURL(url);
        }

        function toggleDark() {
            document.body.classList.toggle('light');
            const btn = document.getElementById('darkBtn');
            btn.textContent = document.body.classList.contains('light') ? 'Dark Mode' : 'Light Mode';
            if (scene) scene.background = new THREE.Color(document.body.classList.contains('light') ? 0xffffff : 0x1a1a1a);
        }

        function showHelp() {
            document.getElementById('helpModal').classList.add('active');
        }

        function closeHelp() {
            document.getElementById('helpModal').classList.remove('active');
        }

        let derivationStep = 0;
        let derivationRunning = false;
        let derivationPaused = false;
        let derivationTimer = null;
        let derivationR = 20;
        let derivationK = 2;
        let derivationData = null;

        function updateDerivationParams() {
            derivationR = parseInt(document.getElementById('derivR').value);
            derivationK = parseInt(document.getElementById('derivK').value);
            document.getElementById('derivRv').textContent = derivationR;
            document.getElementById('derivKv').textContent = derivationK;
            
            // Recompute data
            computeDerivationData();
            
            // Redraw current step
            drawDerivationStep(derivationStep);
        }
        
        function computeDerivationData() {
            const R = derivationR;
            const k = derivationK;
            
            derivationData = {
                R, k,
                allPoints: [],
                primitivePoints: [],
                gcdClasses: {},
                mobiusSum: 0
            };
            
            // Compute all points and categorize by GCD
            if (k === 2) {
                for (let x = -R; x <= R; x++) {
                    for (let y = -R; y <= R; y++) {
                        if (x*x + y*y <= R*R) {
                            const g = gcd(Math.abs(x), Math.abs(y));
                            const point = { x, y, gcd: g };
                            derivationData.allPoints.push(point);
                            
                            if (g === 1) {
                                derivationData.primitivePoints.push(point);
                            }
                            
                            if (!derivationData.gcdClasses[g]) {
                                derivationData.gcdClasses[g] = [];
                            }
                            derivationData.gcdClasses[g].push(point);
                        }
                    }
                }
            } else if (k === 3) {
                for (let x = -R; x <= R; x++) {
                    for (let y = -R; y <= R; y++) {
                        for (let z = -R; z <= R; z++) {
                            if (x*x + y*y + z*z <= R*R) {
                                const g = gcdArray([Math.abs(x), Math.abs(y), Math.abs(z)]);
                                const point = { x, y, z, gcd: g };
                                derivationData.allPoints.push(point);
                                
                                if (g === 1) {
                                    derivationData.primitivePoints.push(point);
                                }
                                
                                if (!derivationData.gcdClasses[g]) {
                                    derivationData.gcdClasses[g] = [];
                                }
                                derivationData.gcdClasses[g].push(point);
                            }
                        }
                    }
                }
            } else if (k === 4) {
                // For k=4, limit to smaller R for performance
                const maxR = Math.min(R, 15);
                for (let x = -maxR; x <= maxR; x++) {
                    for (let y = -maxR; y <= maxR; y++) {
                        for (let z = -maxR; z <= maxR; z++) {
                            for (let w = -maxR; w <= maxR; w++) {
                                if (x*x + y*y + z*z + w*w <= maxR*maxR) {
                                    const g = gcdArray([Math.abs(x), Math.abs(y), Math.abs(z), Math.abs(w)]);
                                    const point = { x, y, z, w, gcd: g };
                                    derivationData.allPoints.push(point);
                                    
                                    if (g === 1) {
                                        derivationData.primitivePoints.push(point);
                                    }
                                    
                                    if (!derivationData.gcdClasses[g]) {
                                        derivationData.gcdClasses[g] = [];
                                    }
                                    derivationData.gcdClasses[g].push(point);
                                }
                            }
                        }
                    }
                }
            }
        }
        
        function playDerivation() {
            if (derivationPaused) {
                derivationPaused = false;
                document.getElementById('derivPlayBtn').style.display = 'none';
                document.getElementById('derivPauseBtn').style.display = 'inline-block';
                continueDerivation();
                return;
            }
            
            derivationRunning = true;
            derivationPaused = false;
            derivationStep = 0;
            
            document.getElementById('derivPlayBtn').style.display = 'none';
            document.getElementById('derivPauseBtn').style.display = 'inline-block';
            document.getElementById('derivStopBtn').style.display = 'inline-block';
            
            if (!derivationData) {
                computeDerivationData();
            }
            
            runDerivationStep();
        }
        
        function runDerivationStep() {
            if (!derivationRunning || derivationPaused) return;
            
            drawDerivationStep(derivationStep);
            
            if (derivationStep < 6) {
                const speed = parseInt(document.getElementById('derivSpeed').value);
                derivationTimer = setTimeout(() => {
                    derivationStep++;
                    runDerivationStep();
                }, speed);
            } else {
                stopDerivation();
            }
        }
        
        function continueDerivation() {
            runDerivationStep();
        }
        
        function pauseDerivation() {
            derivationPaused = true;
            if (derivationTimer) clearTimeout(derivationTimer);
            document.getElementById('derivPauseBtn').style.display = 'none';
            document.getElementById('derivPlayBtn').style.display = 'inline-block';
        }
        
        function stopDerivation() {
            derivationRunning = false;
            derivationPaused = false;
            if (derivationTimer) clearTimeout(derivationTimer);
            
            document.getElementById('derivPlayBtn').style.display = 'inline-block';
            document.getElementById('derivPauseBtn').style.display = 'none';
            document.getElementById('derivStopBtn').style.display = 'none';
            
            derivationStep = 0;
            drawDerivationStep(0);
        }
        
        function derivNextStep() {
            if (derivationStep < 6) {
                derivationStep++;
                drawDerivationStep(derivationStep);
            }
        }
        
        function derivPrevStep() {
            if (derivationStep > 0) {
                derivationStep--;
                drawDerivationStep(derivationStep);
            }
        }
        
        function drawDerivationStep(step) {
            if (!derivationData) {
                computeDerivationData();
            }
            
            const canvas = document.getElementById('derivationCanvas');
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            const R = derivationData.R;
            const k = derivationData.k;
            
            // Update progress
            const progress = ((step + 1) / 7) * 100;
            document.getElementById('derivProgressBar').style.width = progress + '%';
            document.getElementById('derivCurrentStep').textContent = step + 1;
            
            const steps = [
                { name: 'Count All Lattice Points', title: 'Step 1: Count All Lattice Points L_k(R)' },
                { name: 'Partition by GCD', title: 'Step 2: Partition Points by GCD' },
                { name: 'Show GCD Classes', title: 'Step 3: Visualize GCD Classes' },
                { name: 'M√∂bius Function', title: 'Step 4: Introduce M√∂bius Function Œº(d)' },
                { name: 'M√∂bius Inversion', title: 'Step 5: Apply M√∂bius Inversion' },
                { name: 'Cancellation Pattern', title: 'Step 6: Observe Cancellation' },
                { name: 'Final Formula', title: 'Step 7: Arrive at Zeta Function' }
            ];
            
            document.getElementById('derivStepName').textContent = steps[step].name;
            document.getElementById('derivStepTitle').textContent = steps[step].title;
            
            // Only draw 2D for visualization
            if (k === 2) {
                const cx = canvas.width / 2;
                const cy = canvas.height / 2;
                const scale = Math.min(canvas.width, canvas.height) / (2.5 * R);
                
                // Draw circle boundary
                ctx.strokeStyle = getComputedStyle(document.body).getPropertyValue('--border');
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(cx, cy, R * scale, 0, 2 * Math.PI);
                ctx.stroke();
                
                // Draw based on step
                switch(step) {
                    case 0: // All points
                        derivationData.allPoints.forEach(pt => {
                            ctx.fillStyle = '#0066cc';
                            ctx.beginPath();
                            ctx.arc(cx + pt.x * scale, cy - pt.y * scale, 3, 0, 2*Math.PI);
                            ctx.fill();
                        });
                        
                        document.getElementById('derivStepText').textContent = `We count all lattice points (x,y) where x¬≤ + y¬≤ ‚â§ ${R}¬≤. This gives L_${k}(${R}) = ${derivationData.allPoints.length} total points, including both primitive and non-primitive.`;
                        
                        document.getElementById('derivTotal').textContent = derivationData.allPoints.length;
                        document.getElementById('derivPrimitive').textContent = '?';
                        document.getElementById('derivGCD').textContent = 'All';
                        document.getElementById('derivMobius').textContent = 'N/A';
                        document.getElementById('derivContribution').textContent = 'N/A';
                        break;
                        
                    case 1: // Partition by GCD
                        const gcdColors = { 1: '#0066cc', 2: '#dc3545', 3: '#28a745', 4: '#ffc107', 5: '#6f42c1', 6: '#fd7e14' };
                        
                        derivationData.allPoints.forEach(pt => {
                            ctx.fillStyle = gcdColors[Math.min(pt.gcd, 6)] || '#999';
                            ctx.beginPath();
                            ctx.arc(cx + pt.x * scale, cy - pt.y * scale, 3, 0, 2*Math.PI);
                            ctx.fill();
                        });
                        
                        // Legend
                        let legendY = 30;
                        Object.keys(derivationData.gcdClasses).slice(0, 6).forEach(g => {
                            const count = derivationData.gcdClasses[g].length;
                            ctx.fillStyle = gcdColors[Math.min(g, 6)] || '#999';
                            ctx.fillRect(20, legendY, 15, 15);
                            ctx.fillStyle = getComputedStyle(document.body).getPropertyValue('--text');
                            ctx.font = '14px system-ui';
                            ctx.fillText(`GCD=${g}: ${count} points`, 45, legendY + 12);
                            legendY += 25;
                        });
                        
                        document.getElementById('derivStepText').textContent = `We partition all ${derivationData.allPoints.length} points by their GCD. Each color represents a different GCD class. Notice that GCD=1 (blue) are the primitive points we want to count!`;
                        
                        document.getElementById('derivTotal').textContent = derivationData.allPoints.length;
                        document.getElementById('derivPrimitive').textContent = derivationData.primitivePoints.length;
                        document.getElementById('derivGCD').textContent = 'Various';
                        document.getElementById('derivMobius').textContent = 'N/A';
                        document.getElementById('derivContribution').textContent = 'N/A';
                        break;
                        
                    case 2: // Show specific GCD class
                        // Highlight GCD=2 class
                        derivationData.allPoints.forEach(pt => {
                            if (pt.gcd === 2) {
                                ctx.fillStyle = '#dc3545';
                                ctx.beginPath();
                                ctx.arc(cx + pt.x * scale, cy - pt.y * scale, 5, 0, 2*Math.PI);
                                ctx.fill();
                            } else {
                                ctx.fillStyle = 'rgba(200, 200, 200, 0.3)';
                                ctx.beginPath();
                                ctx.arc(cx + pt.x * scale, cy - pt.y * scale, 2, 0, 2*Math.PI);
                                ctx.fill();
                            }
                        });
                        
                        const gcd2count = derivationData.gcdClasses[2]?.length || 0;
                        const gcd1count = derivationData.primitivePoints.length;
                        
                        document.getElementById('derivStepText').textContent = `Points with GCD=2 (red) are exactly those of the form 2¬∑(a,b) where gcd(a,b)=1. There are ${gcd2count} such points, which equals N_${k}(${R}/2) = ${gcd1count} scaled. This pattern holds for all d: points with GCD=d equal N_${k}(R/d).`;
                        
                        document.getElementById('derivTotal').textContent = derivationData.allPoints.length;
                        document.getElementById('derivPrimitive').textContent = '?';
                        document.getElementById('derivGCD').textContent = '2';
                        document.getElementById('derivMobius').textContent = 'N/A';
                        document.getElementById('derivContribution').textContent = gcd2count;
                        break;
                        
                    case 3: // M√∂bius function
                        // Show a table of M√∂bius values
                        ctx.fillStyle = getComputedStyle(document.body).getPropertyValue('--text');
                        ctx.font = 'bold 24px system-ui';
                        ctx.fillText('M√∂bius Function Œº(d)', 50, 50);
                        
                        ctx.font = '18px monospace';
                        let y = 90;
                        for (let d = 1; d <= Math.min(12, R); d++) {
                            const mu = mobius(d);
                            const muStr = mu === 0 ? '0' : (mu === 1 ? '+1' : '-1');
                            const factors = primeFactors(d);
                            const factorStr = factors.length > 0 ? factors.join('√ó') : '1';
                            
                            ctx.fillStyle = mu === 1 ? '#0066cc' : (mu === -1 ? '#dc3545' : '#999');
                            ctx.fillText(`Œº(${d.toString().padStart(2)}) = ${muStr.padStart(3)}    (${d} = ${factorStr})`, 100, y);
                            y += 30;
                        }
                        
                        ctx.fillStyle = getComputedStyle(document.body).getPropertyValue('--text');
                        ctx.font = '16px system-ui';
                        ctx.fillText('Œº(d) = +1 for even # of distinct prime factors', 100, y + 20);
                        ctx.fillText('Œº(d) = -1 for odd # of distinct prime factors', 100, y + 45);
                        ctx.fillText('Œº(d) = 0 if d has a squared prime factor', 100, y + 70);
                        
                        document.getElementById('derivStepText').textContent = `The M√∂bius function Œº(d) is defined based on prime factorization. It equals +1, -1, or 0 depending on the number of distinct prime factors. This alternating pattern is key to the cancellation we'll see next.`;
                        
                        document.getElementById('derivTotal').textContent = derivationData.allPoints.length;
                        document.getElementById('derivPrimitive').textContent = '?';
                        document.getElementById('derivGCD').textContent = 'Various';
                        document.getElementById('derivMobius').textContent = 'See table';
                        document.getElementById('derivContribution').textContent = 'N/A';
                        break;
                        
                    case 4: // M√∂bius inversion
                        ctx.fillStyle = getComputedStyle(document.body).getPropertyValue('--text');
                        ctx.font = 'bold 28px system-ui';
                        ctx.fillText('M√∂bius Inversion Formula', canvas.width/2 - 200, 50);
                        
                        ctx.font = '20px system-ui';
                        ctx.fillText(`L_${k}(R) = ‚àë_{d=1}^{R} N_${k}(R/d)`, 100, 120);
                        ctx.fillText('‚Üì  (Apply M√∂bius inversion)', 100, 160);
                        ctx.fillText(`N_${k}(R) = ‚àë_{d=1}^{R} Œº(d) ¬∑ L_${k}(R/d)`, 100, 200);
                        
                        ctx.font = '18px system-ui';
                        ctx.fillText('This reverses the sum, using Œº(d) to cancel unwanted terms', 100, 260);
                        
                        // Show first few terms
                        ctx.font = '16px monospace';
                        let yPos = 320;
                        let runningSum = 0;
                        for (let d = 1; d <= Math.min(8, R); d++) {
                            const mu = mobius(d);
                            if (mu !== 0) {
                                const scaledR = Math.floor(R / d);
                                let countAtScale = 0;
                                
                                // Approximate count
                                if (k === 2) {
                                    countAtScale = Math.round(Math.PI * scaledR * scaledR);
                                } else if (k === 3) {
                                    countAtScale = Math.round(4/3 * Math.PI * scaledR * scaledR * scaledR);
                                }
                                
                                runningSum += mu * countAtScale;
                                const sign = mu > 0 ? '+' : '';
                                ctx.fillText(`d=${d}: ${sign}Œº(${d}) √ó L(${scaledR}) = ${sign}${mu} √ó ${countAtScale} = ${sign}${mu * countAtScale}`, 120, yPos);
                                yPos += 25;
                            }
                        }
                        
                        ctx.fillText(`...`, 120, yPos);
                        yPos += 30;
                        ctx.font = 'bold 18px system-ui';
                        ctx.fillText(`Running sum ‚âà ${runningSum} (approaching N_${k}(${R}))`, 120, yPos);
                        
                        document.getElementById('derivStepText').textContent = `M√∂bius inversion reverses the partition sum. We multiply each term by Œº(d) and sum over all divisors. The alternating signs create systematic cancellation of the boundary terms.`;
                        
                        document.getElementById('derivTotal').textContent = derivationData.allPoints.length;
                        document.getElementById('derivPrimitive').textContent = derivationData.primitivePoints.length;
                        document.getElementById('derivGCD').textContent = 'All';
                        document.getElementById('derivMobius').textContent = 'Applied';
                        document.getElementById('derivContribution').textContent = runningSum;
                        break;
                        
                    case 5: // Cancellation
                        // Visualize cancellation
                        ctx.fillStyle = getComputedStyle(document.body).getPropertyValue('--text');
                        ctx.font = 'bold 24px system-ui';
                        ctx.fillText('Boundary Cancellation Mechanism', 100, 50);
                        
                        ctx.font = '18px system-ui';
                        ctx.fillText('Main volume term:', 100, 100);
                        ctx.font = '16px monospace';
                        ctx.fillStyle = '#0066cc';
                        ctx.fillText(`V_${k} ¬∑ R^${k} = œÄ^${k/2}/Œì(${k/2}+1) ¬∑ ${R}^${k} ‚âà ${sphereVolume(k, R).toFixed(2)}`, 120, 130);
                        
                        ctx.fillStyle = getComputedStyle(document.body).getPropertyValue('--text');
                        ctx.font = '18px system-ui';
                        ctx.fillText('Boundary error terms:', 100, 180);
                        ctx.font = '16px monospace';
                        ctx.fillStyle = '#dc3545';
                        ctx.fillText(`O(R^${k-1}) from discretization`, 120, 210);
                        ctx.fillText(`These cancel via Œº(d) alternation!`, 120, 240);
                        
                        ctx.fillStyle = getComputedStyle(document.body).getPropertyValue('--text');
                        ctx.font = '18px system-ui';
                        ctx.fillText('Result after cancellation:', 100, 290);
                        ctx.font = 'bold 20px monospace';
                        ctx.fillStyle = '#28a745';
                        ctx.fillText(`N_${k}(R) = V_${k} ¬∑ R^${k} ¬∑ ‚àë_{d=1}^‚àû Œº(d)/d^${k} + O(R^${k-1})`, 120, 330);
                        
                        ctx.fillStyle = getComputedStyle(document.body).getPropertyValue('--text');
                        ctx.font = '18px system-ui';
                        ctx.fillText('The infinite sum equals:', 100, 380);
                        ctx.font = 'bold 24px monospace';
                        ctx.fillStyle = '#6f42c1';
                        ctx.fillText(`‚àë_{d=1}^‚àû Œº(d)/d^${k} = 1/Œ∂(${k})`, 120, 420);
                        
                        document.getElementById('derivStepText').textContent = `The M√∂bius function causes systematic cancellation of boundary terms. The remaining sum ‚àë Œº(d)/d^k equals 1/Œ∂(k) by the Euler product formula. This is the key connection!`;
                        
                        document.getElementById('derivTotal').textContent = derivationData.allPoints.length;
                        document.getElementById('derivPrimitive').textContent = derivationData.primitivePoints.length;
                        document.getElementById('derivGCD').textContent = 'All';
                        document.getElementById('derivMobius').textContent = 'Sum = 1/Œ∂(k)';
                        document.getElementById('derivContribution').textContent = 'Cancelled';
                        break;
                        
                    case 6: // Final formula
                        ctx.fillStyle = getComputedStyle(document.body).getPropertyValue('--text');
                        ctx.font = 'bold 32px system-ui';
                        ctx.fillText('Final Result: The Grand Formula', canvas.width/2 - 250, 80);
                        
                        ctx.font = 'bold 36px system-ui';
                        ctx.fillStyle = '#0066cc';
                        ctx.fillText(`N_${k}(R) = V_${k} ¬∑ R^${k} / Œ∂(${k}) + O(R^${k-1})`, canvas.width/2 - 350, 160);
                        
                        ctx.fillStyle = getComputedStyle(document.body).getPropertyValue('--text');
                        ctx.font = '20px system-ui';
                        ctx.fillText(`For our case (k=${k}, R=${R}):`, 100, 240);
                        
                        const vol = sphereVolume(k, R);
                        const z = zeta(k);
                        const predicted = vol / z;
                        const actual = derivationData.primitivePoints.length;
                        const error = Math.abs(actual - predicted);
                        
                        ctx.font = '18px monospace';
                        ctx.fillText(`Volume V_${k}(R) = ${vol.toFixed(4)}`, 120, 280);
                        ctx.fillText(`Œ∂(${k}) = ${z.toFixed(6)}`, 120, 310);
                        ctx.fillText(`Predicted N_${k}(${R}) = ${predicted.toFixed(2)}`, 120, 340);
                        ctx.fillText(`Actual N_${k}(${R}) = ${actual}`, 120, 370);
                        ctx.fillText(`Error |Œî| = ${error.toFixed(2)} = O(R^${k-1}) ‚úì`, 120, 400);
                        
                        ctx.fillStyle = '#28a745';
                        ctx.font = 'bold 22px system-ui';
                        ctx.fillText('Formula verified!', 120, 450);
                        
                        ctx.fillStyle = getComputedStyle(document.body).getPropertyValue('--text');
                        ctx.font = '16px system-ui';
                        ctx.fillText('This connects number theory (Œ∂ function), geometry (sphere volume),', 100, 510);
                        ctx.fillText('and algebra (M√∂bius inversion) in one elegant formula.', 100, 535);
                        
                        document.getElementById('derivStepText').textContent = `We arrive at the final formula! The density of primitive points equals 1/Œ∂(k), connecting the geometric problem to the Riemann zeta function. The error term O(R^(k-1)) comes from the boundary, which we've shown cancels systematically.`;
                        
                        document.getElementById('derivTotal').textContent = actual;
                        document.getElementById('derivPrimitive').textContent = actual;
                        document.getElementById('derivGCD').textContent = '1';
                        document.getElementById('derivMobius').textContent = `1/Œ∂(${k})`;
                        document.getElementById('derivContribution').textContent = predicted.toFixed(0);
                        break;
                }
            } else {
                // For k>2, show text-based explanation
                ctx.fillStyle = getComputedStyle(document.body).getPropertyValue('--text');
                ctx.font = 'bold 24px system-ui';
                ctx.textAlign = 'center';
                ctx.fillText(`Derivation for ${k}D case (k=${k})`, canvas.width/2, 100);
                ctx.textAlign = 'left';
                ctx.font = '18px system-ui';
                ctx.fillText('The same derivation applies in higher dimensions:', 100, 200);
                ctx.fillText(`‚Ä¢ L_${k}(R) counts all points in ${k}D ball`, 120, 240);
                ctx.fillText(`‚Ä¢ N_${k}(R) counts primitive points (gcd = 1)`, 120, 270);
                ctx.fillText(`‚Ä¢ M√∂bius inversion: N_${k}(R) = ‚àë Œº(d)¬∑L_${k}(R/d)`, 120, 300);
                ctx.fillText(`‚Ä¢ This yields: N_${k}(R) = V_${k}¬∑R^${k}/Œ∂(${k}) + O(R^${k-1})`, 120, 330);
                
                const vol = sphereVolume(k, R);
                const z = zeta(k);
                const predicted = vol / z;
                
                ctx.font = '16px monospace';
                ctx.fillText(`Computed: ${derivationData.primitivePoints.length} primitive points`, 120, 390);
                ctx.fillText(`Predicted: ${predicted.toFixed(2)}`, 120, 420);
                ctx.fillText(`Match confirms formula! ‚úì`, 120, 450);
            }
        }
        
        function showDerivationAnimation() {
            // This function is replaced by the new playDerivation() system
            derivationStep = 0;
            if (!derivationData) {
                computeDerivationData();
            }
            drawDerivationStep(0);
        }

        function updateRadialMaxR() {
            const val = parseInt(document.getElementById('radialMaxRInput').value) || parseInt(document.getElementById('radialMaxR').value);
            document.getElementById('radialMaxRv').textContent = val;
            document.getElementById('radialMaxR').value = Math.min(val, 200);
            document.getElementById('radialMaxRInput').value = val;
            updatePatternViz();
        }

        function updateAngularR() {
            const val = parseInt(document.getElementById('angularRInput').value) || parseInt(document.getElementById('angularR').value);
            document.getElementById('angularRv').textContent = val;
            document.getElementById('angularR').value = Math.min(val, 200);
            document.getElementById('angularRInput').value = val;
            updatePatternViz();
        }

        function updatePatternR() {
            const val = parseInt(document.getElementById('patternRInput').value) || parseInt(document.getElementById('patternR').value);
            document.getElementById('patternRv').textContent = val;
            document.getElementById('patternR').value = Math.min(val, 200);
            document.getElementById('patternRInput').value = val;
            updatePatternViz();
        }

        function setPatternType(type) {
            patternType = type;
            document.querySelectorAll('#patternModular, #patternDensity, #patternAngular, #patternRadial').forEach(btn => btn.classList.remove('active'));
            const btnIds = {
                'modular': 'patternModular',
                'density': 'patternDensity',
                'angular': 'patternAngular',
                'radial': 'patternRadial'
            };
            document.getElementById(btnIds[type]).classList.add('active');
            
            // Show/hide appropriate controls
            document.getElementById('modularPatternControls').style.display = type === 'modular' ? 'block' : 'none';
            document.getElementById('densityPatternControls').style.display = type === 'density' ? 'block' : 'none';
            document.getElementById('angularPatternControls').style.display = type === 'angular' ? 'block' : 'none';
            document.getElementById('radialPatternControls').style.display = type === 'radial' ? 'block' : 'none';
            
            updatePatternViz();
        }

        function updatePatternViz() {
            if (patternType === 'modular') {
                const mEl = document.getElementById('patternMod');
                const rEl = document.getElementById('patternR');
                const rInputEl = document.getElementById('patternRInput');
                
                const m = mEl ? parseInt(mEl.value) : 7;
                const R = rInputEl ? parseInt(rInputEl.value) : (rEl ? parseInt(rEl.value) : 30);
                const showExpected = document.getElementById('showExpected')?.checked ?? true;
                
                if (document.getElementById('patternModv')) document.getElementById('patternModv').textContent = m;
                if (document.getElementById('patternRv')) document.getElementById('patternRv').textContent = R;
                
                // Count primitive points by residue class
                const counts = new Array(m).fill(0);
                let totalPrimitive = 0;
                
                for (let x = -R; x <= R; x++) {
                    for (let y = -R; y <= R; y++) {
                        if (x*x + y*y <= R*R && gcd(Math.abs(x), Math.abs(y)) === 1) {
                            const residue = ((x + y) % m + m) % m;
                            counts[residue]++;
                            totalPrimitive++;
                        }
                    }
                }
                
                // Expected uniform distribution
                const expected = totalPrimitive / m;
                
                // Display chart
                const canvas = document.getElementById('patternCanvas');
                const ctx = canvas.getContext('2d');
                
                if (patternChart) patternChart.destroy();
                
                const datasets = [{
                    label: 'Observed Count',
                    data: counts,
                    backgroundColor: 'rgba(0, 102, 204, 0.6)',
                    borderColor: '#0066cc',
                    borderWidth: 2
                }];
                
                if (showExpected) {
                    datasets.push({
                        label: 'Expected (Uniform)',
                        data: new Array(m).fill(expected),
                        type: 'line',
                        borderColor: '#dc3545',
                        borderWidth: 2,
                        borderDash: [5, 5],
                        pointRadius: 0,
                        fill: false
                    });
                }
                
                patternChart = new Chart(ctx, {
                    type: 'bar',
                    data: {
                        labels: Array.from({length: m}, (_, i) => i),
                        datasets
                    },
                    options: {
                        responsive: true,
                        scales: {
                            y: {
                                title: { display: true, text: 'Number of Primitive Points', font: { size: 14 } },
                                beginAtZero: true
                            },
                            x: {
                                title: { display: true, text: `Residue Class (x+y) mod ${m}`, font: { size: 14 } }
                            }
                        },
                        plugins: {
                            title: {
                                display: true,
                                text: `Modular Distribution: Primitive Points mod ${m} (R=${R})`,
                                font: { size: 16, weight: 'bold' }
                            },
                            legend: { display: true }
                        }
                    }
                });
                
                // Update stats
                const statsDiv = document.getElementById('patternStats');
                const maxCount = Math.max(...counts);
                const minCount = Math.min(...counts);
                const variance = counts.reduce((sum, c) => sum + Math.pow(c - expected, 2), 0) / m;
                const stdDev = Math.sqrt(variance);
                
                statsDiv.innerHTML = `
                    <div class="stat"><div class="val">${totalPrimitive}</div><div class="lbl">Total Primitive</div></div>
                    <div class="stat"><div class="val">${expected.toFixed(1)}</div><div class="lbl">Expected per Class</div></div>
                    <div class="stat"><div class="val">${maxCount}</div><div class="lbl">Max Count</div></div>
                    <div class="stat"><div class="val">${minCount}</div><div class="lbl">Min Count</div></div>
                    <div class="stat"><div class="val">${stdDev.toFixed(2)}</div><div class="lbl">Std Deviation</div></div>
                `;
                
            } else if (patternType === 'density') {
                const gridSizeEl = document.getElementById('gridSize');
                const gridSizeInputEl = document.getElementById('gridSizeInput');
                const densityREl = document.getElementById('densityR');
                const densityRInputEl = document.getElementById('densityRInput');
                
                const gridSize = gridSizeInputEl ? parseInt(gridSizeInputEl.value) : (gridSizeEl ? parseInt(gridSizeEl.value) : 10);
                const R = densityRInputEl ? parseInt(densityRInputEl.value) : (densityREl ? parseInt(densityREl.value) : 50);
                
                if (document.getElementById('gridSizev')) document.getElementById('gridSizev').textContent = gridSize;
                if (document.getElementById('densityRv')) document.getElementById('densityRv').textContent = R;
                
                const canvas = document.getElementById('densityCanvas');
                const ctx = canvas.getContext('2d');
                const cellSize = 800 / gridSize;
                
                ctx.clearRect(0, 0, 800, 800);
                
                // Compute density in each grid cell
                const cellR = R / gridSize;
                const densities = [];
                let maxDensity = 0;
                
                for (let i = 0; i < gridSize; i++) {
                    densities[i] = [];
                    for (let j = 0; j < gridSize; j++) {
                        const cx = (i - gridSize/2) * cellR;
                        const cy = (j - gridSize/2) * cellR;
                        
                        let primCount = 0, totalCount = 0;
                        
                        // Count points in this cell
                        for (let x = Math.floor(cx - cellR); x <= Math.ceil(cx + cellR); x++) {
                            for (let y = Math.floor(cy - cellR); y <= Math.ceil(cy + cellR); y++) {
                                const dx = x - cx, dy = y - cy;
                                if (dx*dx + dy*dy <= cellR*cellR) {
                                    totalCount++;
                                    if (gcd(Math.abs(x), Math.abs(y)) === 1) primCount++;
                                }
                            }
                        }
                        
                        const density = totalCount > 0 ? primCount / totalCount : 0;
                        densities[i][j] = density;
                        maxDensity = Math.max(maxDensity, density);
                    }
                }
                
                // Draw heatmap
                for (let i = 0; i < gridSize; i++) {
                    for (let j = 0; j < gridSize; j++) {
                        const density = densities[i][j];
                        const intensity = density / (maxDensity || 1);
                        const hue = 240 - intensity * 240; // Blue to red
                        ctx.fillStyle = `hsl(${hue}, 70%, 50%)`;
                        ctx.fillRect(i * cellSize, j * cellSize, cellSize, cellSize);
                        
                        // Draw border
                        ctx.strokeStyle = 'rgba(255,255,255,0.2)';
                        ctx.strokeRect(i * cellSize, j * cellSize, cellSize, cellSize);
                    }
                }
                
                // Add legend
                ctx.fillStyle = 'rgba(255,255,255,0.9)';
                ctx.fillRect(20, 720, 200, 60);
                ctx.fillStyle = '#000';
                ctx.font = '14px system-ui';
                ctx.fillText('Density Scale:', 30, 740);
                ctx.fillText(`0% ‚Üí ${(maxDensity * 100).toFixed(1)}%`, 30, 760);
                
            } else if (patternType === 'angular') {
                const numSectors = parseInt(document.getElementById('numSectors').value);
                const R = parseInt(document.getElementById('angularRInput').value) || parseInt(document.getElementById('angularR').value);
                
                document.getElementById('numSectorsv').textContent = numSectors;
                document.getElementById('angularRv').textContent = R;
                
                const sectorCounts = new Array(numSectors).fill(0);
                let totalPrimitive = 0;
                
                for (let x = -R; x <= R; x++) {
                    for (let y = -R; y <= R; y++) {
                        if (x*x + y*y <= R*R && gcd(Math.abs(x), Math.abs(y)) === 1) {
                            const angle = Math.atan2(y, x) + Math.PI; // 0 to 2œÄ
                            const sector = Math.floor(angle / (2 * Math.PI / numSectors)) % numSectors;
                            sectorCounts[sector]++;
                            totalPrimitive++;
                        }
                    }
                }
                
                const expected = totalPrimitive / numSectors;
                
                const canvas = document.getElementById('angularCanvas');
                const ctx = canvas.getContext('2d');
                
                if (patternChart) patternChart.destroy();
                
                patternChart = new Chart(ctx, {
                    type: 'bar',
                    data: {
                        labels: Array.from({length: numSectors}, (_, i) => {
                            const startAngle = (i * 360 / numSectors).toFixed(0);
                            const endAngle = ((i + 1) * 360 / numSectors).toFixed(0);
                            return `${startAngle}¬∞-${endAngle}¬∞`;
                        }),
                        datasets: [{
                            label: 'Primitive Points',
                            data: sectorCounts,
                            backgroundColor: Array.from({length: numSectors}, (_, i) => {
                                const hue = (i / numSectors) * 360;
                                return `hsla(${hue}, 70%, 50%, 0.6)`;
                            }),
                            borderWidth: 2
                        }, {
                            label: 'Expected (Uniform)',
                            data: new Array(numSectors).fill(expected),
                            type: 'line',
                            borderColor: '#dc3545',
                            borderWidth: 2,
                            borderDash: [5, 5],
                            pointRadius: 0,
                            fill: false
                        }]
                    },
                    options: {
                        responsive: true,
                        scales: {
                            y: { title: { display: true, text: 'Count', font: { size: 14 } } },
                            x: { title: { display: true, text: 'Angular Sector', font: { size: 14 } } }
                        },
                        plugins: {
                            title: {
                                display: true,
                                text: `Angular Distribution (${numSectors} sectors, R=${R})`,
                                font: { size: 16, weight: 'bold' }
                            }
                        }
                    }
                });
                
            } else if (patternType === 'radial') {
                const shellThick = parseInt(document.getElementById('shellThick').value);
                const maxR = parseInt(document.getElementById('radialMaxRInput').value) || parseInt(document.getElementById('radialMaxR').value);
                
                document.getElementById('shellThickv').textContent = shellThick;
                document.getElementById('radialMaxRv').textContent = maxR;
                
                const numShells = Math.floor(maxR / shellThick);
                const shellCounts = [];
                const radii = [];
                
                for (let i = 0; i < numShells; i++) {
                    const innerR = i * shellThick;
                    const outerR = (i + 1) * shellThick;
                    radii.push(outerR);
                    
                    let count = 0;
                    for (let x = -outerR; x <= outerR; x++) {
                        for (let y = -outerR; y <= outerR; y++) {
                            const distSq = x*x + y*y;
                            if (distSq > innerR*innerR && distSq <= outerR*outerR && 
                                gcd(Math.abs(x), Math.abs(y)) === 1) {
                                count++;
                            }
                        }
                    }
                    shellCounts.push(count);
                }
                
                const canvas = document.getElementById('radialCanvas');
                const ctx = canvas.getContext('2d');
                
                if (patternChart) patternChart.destroy();
                
                patternChart = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: radii,
                        datasets: [{
                            label: 'Primitive Points in Shell',
                            data: shellCounts,
                            backgroundColor: 'rgba(0, 102, 204, 0.2)',
                            borderColor: '#0066cc',
                            borderWidth: 2,
                            fill: true,
                            tension: 0.3
                        }]
                    },
                    options: {
                        responsive: true,
                        scales: {
                            y: { 
                                title: { display: true, text: 'Count per Shell', font: { size: 14 } },
                                beginAtZero: true
                            },
                            x: { title: { display: true, text: 'Radius', font: { size: 14 } } }
                        },
                        plugins: {
                            title: {
                                display: true,
                                text: `Radial Shell Distribution (thickness=${shellThick})`,
                                font: { size: 16, weight: 'bold' }
                            }
                        }
                    }
                });
            }
        }

        function exportPatternData() {
            if (!patternChart) { alert('Generate a pattern visualization first'); return; }
            
            let csv = `# Pattern Analysis - ${patternType}\n`;
            csv += `# Generated: ${new Date().toISOString()}\n`;
            csv += `# By Wessen Getachew | @7dview | wessengetachew.github.io\n`;
            csv += `#\n`;
            
            const data = patternChart.data;
            
            if (patternType === 'modular') {
                const m = parseInt(document.getElementById('patternMod').value);
                const R = parseInt(document.getElementById('patternR').value);
                csv += `# Modular Pattern: mod ${m}, Radius ${R}\n#\n`;
                csv += 'residue_class,count,expected_uniform\n';
                const total = data.datasets[0].data.reduce((a, b) => a + b, 0);
                const expected = total / m;
                data.labels.forEach((label, i) => {
                    csv += `${label},${data.datasets[0].data[i]},${formatPrecise(expected, 6)}\n`;
                });
            } else if (patternType === 'angular') {
                const numSectors = parseInt(document.getElementById('numSectors').value);
                const R = parseInt(document.getElementById('angularR').value);
                csv += `# Angular Distribution: ${numSectors} sectors, Radius ${R}\n#\n`;
                csv += 'sector,angle_range,count\n';
                data.labels.forEach((label, i) => {
                    csv += `${i},${label},${data.datasets[0].data[i]}\n`;
                });
            } else if (patternType === 'radial') {
                const shellThick = parseInt(document.getElementById('shellThick').value);
                csv += `# Radial Shell Distribution: thickness ${shellThick}\n#\n`;
                csv += 'outer_radius,count_in_shell\n';
                data.labels.forEach((label, i) => {
                    csv += `${label},${data.datasets[0].data[i]}\n`;
                });
            }
            
            downloadCSV(csv, `pattern-${patternType}-analysis.csv`);
        }

        function set2DLabelMode(mode) {
            labelMode2D = mode;
            document.querySelectorAll('#label2DNone, #label2DGCD, #label2DCoords, #label2DAngle').forEach(btn => btn.classList.remove('active'));
            const btnIds = { 'none': 'label2DNone', 'gcd': 'label2DGCD', 'coords': 'label2DCoords', 'angle': 'label2DAngle' };
            document.getElementById(btnIds[mode]).classList.add('active');
            document.getElementById('labelControls2D').style.display = mode === 'none' ? 'none' : 'block';
            draw2D();
        }

        function set3DLabelMode(mode) {
            labelMode3D = mode;
            document.querySelectorAll('#label3DNone, #label3DGCD, #label3DCoords').forEach(btn => btn.classList.remove('active'));
            const btnIds = { 'none': 'label3DNone', 'gcd': 'label3DGCD', 'coords': 'label3DCoords' };
            document.getElementById(btnIds[mode]).classList.add('active');
            document.getElementById('labelControls3D').style.display = mode === 'none' ? 'none' : 'block';
            draw3D();
        }

        function update3DZoom() {
            if (!camera) return;
            const zoom = parseInt(document.getElementById('zoom3D').value);
            document.getElementById('zoom3Dv').textContent = zoom;
            const angle = Math.atan2(camera.position.y, Math.sqrt(camera.position.x**2 + camera.position.z**2));
            const azimuth = Math.atan2(camera.position.x, camera.position.z);
            camera.position.x = zoom * Math.sin(azimuth) * Math.cos(angle);
            camera.position.z = zoom * Math.cos(azimuth) * Math.cos(angle);
            camera.position.y = zoom * Math.sin(angle);
            camera.lookAt(0, 0, 0);
        }

        function setGCDTablePreset(preset) {
            const presets = { 'small': 20, 'medium': 50, 'large': 100, 'xlarge': 200, 'huge': 500 };
            const size = presets[preset];
            document.getElementById('gcdTableSize').value = Math.min(size, 500);
            document.getElementById('gcdTableSizeInput').value = size;
            document.getElementById('gcdTableSizev').textContent = size;
            updateGCDTable();
        }

        let gcdTableColorMode = 'heat'; // 'heat', 'discrete', 'prime', 'binary', 'rainbow'
        let gcdTableType = 'gcd'; // 'gcd', 'addition', 'multiplication', 'zerodivisors', 'units', 'totient'
        let gcdTableRotation = 0; // 0, 90, 180, 270 degrees

        function setTableType(type) {
            gcdTableType = type;
            document.querySelectorAll('#tableTypeGCD, #tableTypeAdd, #tableTypeMult, #tableTypeZeroDiv, #tableTypeUnits, #tableTypeTotient').forEach(btn => btn.classList.remove('active'));
            const btnIds = {
                'gcd': 'tableTypeGCD',
                'addition': 'tableTypeAdd',
                'multiplication': 'tableTypeMult',
                'zerodivisors': 'tableTypeZeroDiv',
                'units': 'tableTypeUnits',
                'totient': 'tableTypeTotient'
            };
            document.getElementById(btnIds[type]).classList.add('active');
            updateGCDTable();
        }
        
        function setGCDTableColor(mode) {
            gcdTableColorMode = mode;
            document.querySelectorAll('#gcdTableHeat, #gcdTableDiscrete, #gcdTablePrime, #gcdTableBinary, #gcdTableRainbow').forEach(btn => btn.classList.remove('active'));
            const btnIds = {
                'heat': 'gcdTableHeat',
                'discrete': 'gcdTableDiscrete',
                'prime': 'gcdTablePrime',
                'binary': 'gcdTableBinary',
                'rainbow': 'gcdTableRainbow'
            };
            document.getElementById(btnIds[mode]).classList.add('active');
            updateGCDTable();
        }
        
        function setGCDTableRotation(degrees) {
            gcdTableRotation = degrees;
            document.querySelectorAll('#gcdTableRot0, #gcdTableRot90, #gcdTableRot180, #gcdTableRot270').forEach(btn => btn.classList.remove('active'));
            const btnIds = {
                0: 'gcdTableRot0',
                90: 'gcdTableRot90',
                180: 'gcdTableRot180',
                270: 'gcdTableRot270'
            };
            document.getElementById(btnIds[degrees]).classList.add('active');
            updateGCDTable();
        }

        function updateGCDTableSize() {
            const val = parseInt(document.getElementById('gcdTableSizeInput').value) || parseInt(document.getElementById('gcdTableSize').value);
            document.getElementById('gcdTableSizev').textContent = val;
            document.getElementById('gcdTableSize').value = Math.min(val, 500);
            document.getElementById('gcdTableSizeInput').value = val;
            updateGCDTable();
        }
        
        function updateTablePatternInfo() {
            const infoEl = document.getElementById('tablePatternInfo');
            if (!infoEl) return;
            
            const patterns = {
                'gcd': '‚Ä¢ Diagonal elements: gcd(n, n) = n<br>‚Ä¢ Symmetry: gcd(a, b) = gcd(b, a)<br>‚Ä¢ Rows/columns of primes: mostly 1s except at multiples<br>‚Ä¢ Coprimality appears as value 1<br>‚Ä¢ Patterns reveal divisibility relationships<br>‚Ä¢ <b>TIP:</b> Rotate to view from different quadrants',
                'addition': '‚Ä¢ Every row/column is a permutation of {0, 1, ..., n-1}<br>‚Ä¢ Diagonal shows (i + i) mod n = 2i mod n<br>‚Ä¢ Symmetric: (a + b) mod n = (b + a) mod n<br>‚Ä¢ Forms an abelian group under addition<br>‚Ä¢ Identity element is 0<br>‚Ä¢ <b>TIP:</b> Rotation reveals different symmetries',
                'multiplication': '‚Ä¢ Rows/columns for units are permutations<br>‚Ä¢ Zero row/column for multiples of n<br>‚Ä¢ Symmetric: (a √ó b) mod n = (b √ó a) mod n<br>‚Ä¢ Identity element is 1<br>‚Ä¢ Zero divisors visible as zero entries<br>‚Ä¢ <b>TIP:</b> Rotation highlights different structural aspects',
                'zerodivisors': '‚Ä¢ Bright cells: a √ó b ‚â° 0 (mod n)<br>‚Ä¢ Shows non-trivial zero divisors<br>‚Ä¢ Only exists when n is composite<br>‚Ä¢ Symmetric pattern<br>‚Ä¢ Related to prime factorization of n<br>‚Ä¢ <b>TIP:</b> 4 rotations show complete divisor structure',
                'units': '‚Ä¢ Bright cells: elements coprime to n<br>‚Ä¢ Count equals Euler\'s œÜ(n)<br>‚Ä¢ Forms multiplicative group Z/nZ*<br>‚Ä¢ Diagonal shows gcd(i, n)<br>‚Ä¢ Pattern reveals group structure<br>‚Ä¢ <b>TIP:</b> Each rotation emphasizes different coprimality patterns',
                'totient': '‚Ä¢ Shows œÜ(gcd(i,j)) for each cell<br>‚Ä¢ Diagonal: œÜ(n) values<br>‚Ä¢ Related to primitive roots<br>‚Ä¢ Symmetric pattern<br>‚Ä¢ Connects to Euler\'s theorem<br>‚Ä¢ <b>TIP:</b> Rotation reveals totient function symmetries'
            };
            
            infoEl.innerHTML = patterns[gcdTableType] || patterns['gcd'];
        }

        function updateGCDTable() {
            const size = parseInt(document.getElementById('gcdTableSizeInput').value) || parseInt(document.getElementById('gcdTableSize').value);
            const showValues = document.getElementById('showGCDValues').checked;
            const highlightDiag = document.getElementById('highlightDiagonal').checked;
            
            document.getElementById('gcdTableSizev').textContent = size;
            document.getElementById('gcdTableSize').value = Math.min(size, 500);
            document.getElementById('gcdTableSizeInput').value = size;
            
            const canvas = document.getElementById('gcdTableCanvas');
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Save context and apply rotation
            ctx.save();
            
            // Translate to center for rotation
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            ctx.translate(centerX, centerY);
            ctx.rotate((gcdTableRotation * Math.PI) / 180);
            ctx.translate(-centerX, -centerY);
            
            const cellSize = Math.min(canvas.width / (size + 1), 30); // +1 for labels
            const startX = 40, startY = 40;
            
            // Compute values and determine range based on table type
            let maxValue = 0, minValue = 0;
            const values = [];
            
            for (let i = 1; i <= size; i++) {
                values[i] = [];
                for (let j = 1; j <= size; j++) {
                    let val;
                    
                    if (gcdTableType === 'gcd') {
                        val = gcd(i, j);
                    } else if (gcdTableType === 'addition') {
                        val = (i + j) % size;
                    } else if (gcdTableType === 'multiplication') {
                        val = (i * j) % size;
                    } else if (gcdTableType === 'zerodivisors') {
                        val = ((i * j) % size === 0) ? 1 : 0;
                    } else if (gcdTableType === 'units') {
                        val = (gcd(i, size) === 1) ? 1 : 0;
                    } else if (gcdTableType === 'totient') {
                        // For totient, we show œÜ(gcd(i,j))
                        const g = gcd(i, j);
                        val = eulerPhi(g);
                    }
                    
                    values[i][j] = val;
                    maxValue = Math.max(maxValue, val);
                    minValue = Math.min(minValue, val);
                }
            }
            
            // Store data for click detection
            window.gcdTableData = [];
            
            // Draw cells
            for (let i = 1; i <= size; i++) {
                for (let j = 1; j <= size; j++) {
                    const val = values[i][j];
                    const x = startX + (j - 1) * cellSize;
                    const y = startY + (i - 1) * cellSize;
                    
                    let color;
                    if (gcdTableColorMode === 'heat') {
                        const intensity = maxValue > minValue ? (val - minValue) / (maxValue - minValue) : 0;
                        const hue = 240 - intensity * 240; // Blue to red
                        color = `hsl(${hue}, 70%, 50%)`;
                    } else if (gcdTableColorMode === 'discrete') {
                        const colors = ['#0066cc', '#dc3545', '#28a745', '#ffc107', '#6f42c1', '#fd7e14', '#00d4ff', '#ff006e'];
                        color = colors[Math.min(val, 7)] || '#999';
                    } else if (gcdTableColorMode === 'prime') {
                        color = isPrime(val) ? '#6f42c1' : (val === 1 ? '#0066cc' : val === 0 ? '#333' : '#dc3545');
                    } else if (gcdTableColorMode === 'binary') {
                        color = val > 0 ? '#28a745' : '#dc3545';
                    } else if (gcdTableColorMode === 'rainbow') {
                        const hue = maxValue > 0 ? (val / maxValue) * 360 : 0;
                        color = `hsl(${hue}, 70%, 50%)`;
                    }
                    
                    ctx.fillStyle = color;
                    ctx.fillRect(x, y, cellSize, cellSize);
                    
                    // Highlight diagonal
                    if (highlightDiag && i === j) {
                        ctx.strokeStyle = '#fff';
                        ctx.lineWidth = 2;
                        ctx.strokeRect(x, y, cellSize, cellSize);
                    }
                    
                    // Draw border
                    ctx.strokeStyle = 'rgba(255,255,255,0.1)';
                    ctx.lineWidth = 1;
                    ctx.strokeRect(x, y, cellSize, cellSize);
                    
                    // Draw value
                    if (showValues && cellSize > 12) {
                        ctx.fillStyle = '#fff';
                        ctx.font = `${Math.min(cellSize * 0.4, 12)}px system-ui`;
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText(val, x + cellSize/2, y + cellSize/2);
                    }
                    
                    // Store for click detection (with inverse rotation applied)
                    const angle = -(gcdTableRotation * Math.PI) / 180;
                    const dx = x + cellSize/2 - centerX;
                    const dy = y + cellSize/2 - centerY;
                    const rotatedX = centerX + dx * Math.cos(angle) - dy * Math.sin(angle);
                    const rotatedY = centerY + dx * Math.sin(angle) + dy * Math.cos(angle);
                    
                    window.gcdTableData.push({ i, j, val, x: rotatedX - cellSize/2, y: rotatedY - cellSize/2, size: cellSize });
                }
            }
            
            // Draw row/column labels
            ctx.fillStyle = getComputedStyle(document.body).getPropertyValue('--text');
            ctx.font = 'bold 10px system-ui';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            
            const labelStep = Math.max(1, Math.floor(size / 20));
            
            // Adjust labels based on rotation
            if (gcdTableRotation === 0) {
                for (let i = 1; i <= size; i += labelStep) {
                    // Row labels (left)
                    ctx.fillText(i, 20, startY + (i - 0.5) * cellSize);
                    // Column labels (top)
                    ctx.fillText(i, startX + (i - 0.5) * cellSize, 20);
                }
            } else if (gcdTableRotation === 90) {
                for (let i = 1; i <= size; i += labelStep) {
                    // Labels rotated 90¬∞
                    ctx.fillText(i, startX + (i - 0.5) * cellSize, canvas.height - 20);
                    ctx.fillText(i, 20, startY + (i - 0.5) * cellSize);
                }
            } else if (gcdTableRotation === 180) {
                for (let i = 1; i <= size; i += labelStep) {
                    // Labels rotated 180¬∞
                    ctx.fillText(size - i + 1, canvas.width - 20, startY + (i - 0.5) * cellSize);
                    ctx.fillText(size - i + 1, startX + (i - 0.5) * cellSize, canvas.height - 20);
                }
            } else if (gcdTableRotation === 270) {
                for (let i = 1; i <= size; i += labelStep) {
                    // Labels rotated 270¬∞
                    ctx.fillText(size - i + 1, startX + (i - 0.5) * cellSize, 20);
                    ctx.fillText(size - i + 1, canvas.width - 20, startY + (i - 0.5) * cellSize);
                }
            }
            
            // Restore context
            ctx.restore();
            
            // Update pattern info
            updateTablePatternInfo();
        }
        
        function eulerPhi(n) {
            if (n === 1) return 1;
            let result = n;
            const primes = [...new Set(primeFactors(n))];
            primes.forEach(p => {
                result *= (1 - 1/p);
            });
            return Math.floor(result);
        }

        function exportGCDTableData() {
            const size = parseInt(document.getElementById('gcdTableSizeInput').value);
            
            const tableNames = {
                'gcd': 'GCD Table',
                'addition': 'Addition Modulo Table',
                'multiplication': 'Multiplication Modulo Table',
                'zerodivisors': 'Zero Divisors Table',
                'units': 'Units (Invertible Elements) Table',
                'totient': 'Euler Totient Table'
            };
            
            let csv = `# ${tableNames[gcdTableType]} - ${size}√ó${size}\n`;
            csv += `# Generated: ${new Date().toISOString()}\n`;
            csv += `# Color Scheme: ${gcdTableColorMode}\n`;
            csv += `# By Wessen Getachew | @7dview | wessengetachew.github.io\n`;
            csv += `#\n`;
            
            if (gcdTableType === 'gcd') {
                csv += '# Each entry shows GCD(row, column)\n';
                csv += '# Symmetric matrix: GCD(a,b) = GCD(b,a)\n';
                csv += '# Diagonal: GCD(n,n) = n\n';
                csv += 'row,column,gcd,coprime\n';
                for (let i = 1; i <= size; i++) {
                    for (let j = 1; j <= size; j++) {
                        const g = gcd(i, j);
                        csv += `${i},${j},${g},${g === 1 ? 'true' : 'false'}\n`;
                    }
                }
            } else if (gcdTableType === 'addition') {
                csv += `# Each entry shows (row + column) mod ${size}\n`;
                csv += '# Forms abelian group (‚Ñ§/n‚Ñ§, +)\n';
                csv += 'row,column,sum_mod_n\n';
                for (let i = 1; i <= size; i++) {
                    for (let j = 1; j <= size; j++) {
                        csv += `${i},${j},${(i + j) % size}\n`;
                    }
                }
            } else if (gcdTableType === 'multiplication') {
                csv += `# Each entry shows (row √ó column) mod ${size}\n`;
                csv += '# Zero divisors appear as 0 entries\n';
                csv += 'row,column,product_mod_n,is_zero_divisor\n';
                for (let i = 1; i <= size; i++) {
                    for (let j = 1; j <= size; j++) {
                        const prod = (i * j) % size;
                        csv += `${i},${j},${prod},${prod === 0 ? 'true' : 'false'}\n`;
                    }
                }
            } else if (gcdTableType === 'zerodivisors') {
                csv += `# 1 if row √ó column ‚â° 0 (mod ${size}), 0 otherwise\n`;
                csv += 'row,column,is_zero_divisor_pair\n';
                for (let i = 1; i <= size; i++) {
                    for (let j = 1; j <= size; j++) {
                        const isZero = ((i * j) % size === 0) ? 1 : 0;
                        csv += `${i},${j},${isZero}\n`;
                    }
                }
            } else if (gcdTableType === 'units') {
                csv += `# 1 if element is coprime to ${size} (unit), 0 otherwise\n`;
                csv += `# Units form group (‚Ñ§/${size}‚Ñ§)* under multiplication\n`;
                csv += 'element,is_unit,gcd_with_modulus\n';
                for (let i = 1; i <= size; i++) {
                    const g = gcd(i, size);
                    csv += `${i},${g === 1 ? 1 : 0},${g}\n`;
                }
            } else if (gcdTableType === 'totient') {
                csv += '# Shows œÜ(gcd(row, column))\n';
                csv += 'row,column,gcd,totient_of_gcd\n';
                for (let i = 1; i <= size; i++) {
                    for (let j = 1; j <= size; j++) {
                        const g = gcd(i, j);
                        csv += `${i},${j},${g},${eulerPhi(g)}\n`;
                    }
                }
            }
            
            downloadCSV(csv, `${gcdTableType}-table-${size}x${size}.csv`);
        }

        function updateGridSize() {
            const val = parseInt(document.getElementById('gridSizeInput').value) || parseInt(document.getElementById('gridSize').value);
            document.getElementById('gridSizev').textContent = val;
            document.getElementById('gridSize').value = Math.min(val, 50);
            document.getElementById('gridSizeInput').value = val;
        }

        function updateDensityR() {
            const val = parseInt(document.getElementById('densityRInput').value) || parseInt(document.getElementById('densityR').value);
            document.getElementById('densityRv').textContent = val;
            document.getElementById('densityR').value = Math.min(val, 200);
            document.getElementById('densityRInput').value = val;
        }

        function updateHeatmapR() {
            const val = parseInt(document.getElementById('heatmapRinput').value) || parseInt(document.getElementById('heatmapR').value);
            if (val < 5 || val > 500 || isNaN(val)) return;
            document.getElementById('heatmapRv').textContent = val;
            document.getElementById('heatmapR').value = Math.min(val, 200);
            document.getElementById('heatmapRinput').value = val;
            updateGCDHeatmap();
        }

        function updateCriticalMaxR() {
            const val = parseInt(document.getElementById('criticalMaxRinput').value) || parseInt(document.getElementById('criticalMaxR').value);
            document.getElementById('criticalMaxRv').textContent = val;
            document.getElementById('criticalMaxR').value = Math.min(val, 500);
            document.getElementById('criticalMaxRinput').value = val;
        }

        function updateCriticalStep() {
            const val = parseInt(document.getElementById('criticalStepInput').value) || parseInt(document.getElementById('criticalStep').value);
            document.getElementById('criticalStepv').textContent = val;
            document.getElementById('criticalStep').value = Math.min(val, 10);
            document.getElementById('criticalStepInput').value = val;
        }

        function update2DZoom() {
            zoom2D = parseInt(document.getElementById('zoom2D').value);
            document.getElementById('zoom2Dv').textContent = zoom2D;
            draw2D();
        }

        function formatPrecise(num, maxDecimals = 17) {
            if (Number.isInteger(num)) return num.toString();
            const str = num.toFixed(maxDecimals);
            // Remove trailing zeros
            return str.replace(/\.?0+$/, '');
        }

        let exportResolution = '4k';
        let exportType = 'single';
        let animationType = 'radius';
        let animationRunning = false;
        let animationPaused = false;
        let animationTimer = null;
        let currentAnimStep = 0;

        function setExportRes(res) {
            exportResolution = res;
            document.querySelectorAll('#res2k, #res4k, #res8k').forEach(btn => btn.classList.remove('active'));
            document.getElementById(`res${res}`).classList.add('active');
        }

        function getExportDimensions() {
            const dims = {
                '2k': [2048, 2048],
                '4k': [3840, 3840],
                '8k': [7680, 7680]
            };
            return dims[exportResolution] || [3840, 3840];
        }
        
        function updateExportType() {
            exportType = document.getElementById('exportType').value;
            const singleControls = document.getElementById('singleCanvasControls');
            if (singleControls) {
                singleControls.style.display = exportType === 'single' ? 'block' : 'none';
            }
        }
        
        function setAnimType(type) {
            animationType = type;
            document.querySelectorAll('#animRadius, #animDimension, #animModular').forEach(btn => btn.classList.remove('active'));
            const btnIds = { 'radius': 'animRadius', 'dimension': 'animDimension', 'modular': 'animModular' };
            document.getElementById(btnIds[type]).classList.add('active');
            
            document.getElementById('radiusAnimControls').style.display = type === 'radius' ? 'block' : 'none';
            document.getElementById('dimensionAnimControls').style.display = type === 'dimension' ? 'block' : 'none';
            document.getElementById('modularAnimControls').style.display = type === 'modular' ? 'block' : 'none';
        }
        
        function setAnimPreset(preset) {
            if (preset === 'quick') {
                setAnimType('radius');
                document.getElementById('animStartR').value = 1;
                document.getElementById('animEndR').value = 30;
                document.getElementById('animSpeed').value = 300;
            } else if (preset === 'medium') {
                setAnimType('radius');
                document.getElementById('animStartR').value = 1;
                document.getElementById('animEndR').value = 60;
                document.getElementById('animSpeed').value = 400;
            } else if (preset === 'long') {
                setAnimType('radius');
                document.getElementById('animStartR').value = 1;
                document.getElementById('animEndR').value = 100;
                document.getElementById('animSpeed').value = 500;
            } else if (preset === 'dimensions') {
                setAnimType('dimension');
                document.getElementById('animStartD').value = 2;
                document.getElementById('animEndD').value = 10;
                document.getElementById('animSpeed').value = 800;
            }
            
            // Update displays
            document.getElementById('animStartRv').textContent = document.getElementById('animStartR').value;
            document.getElementById('animEndRv').textContent = document.getElementById('animEndR').value;
            document.getElementById('animStartDv').textContent = document.getElementById('animStartD').value;
            document.getElementById('animEndDv').textContent = document.getElementById('animEndD').value;
            document.getElementById('animSpeedv').textContent = document.getElementById('animSpeed').value;
        }
        
        function playAnimation() {
            if (animationPaused) {
                animationPaused = false;
                document.getElementById('playBtn').style.display = 'none';
                document.getElementById('pauseBtn').style.display = 'inline-block';
                continueAnimation();
                return;
            }
            
            animationRunning = true;
            animationPaused = false;
            currentAnimStep = 0;
            
            document.getElementById('playBtn').style.display = 'none';
            document.getElementById('pauseBtn').style.display = 'inline-block';
            document.getElementById('stopBtn').style.display = 'inline-block';
            document.getElementById('animProgress').style.display = 'block';
            
            let start, end, totalSteps;
            
            if (animationType === 'radius') {
                start = parseInt(document.getElementById('animStartR').value);
                end = parseInt(document.getElementById('animEndR').value);
                totalSteps = end - start + 1;
            } else if (animationType === 'dimension') {
                start = parseInt(document.getElementById('animStartD').value);
                end = parseInt(document.getElementById('animEndD').value);
                totalSteps = end - start + 1;
            } else if (animationType === 'modular') {
                start = parseInt(document.getElementById('animStartM').value);
                end = parseInt(document.getElementById('animEndM').value);
                totalSteps = end - start + 1;
            }
            
            document.getElementById('animTotalSteps').textContent = totalSteps;
            runAnimationStep(start, end, 0);
        }
        
        function runAnimationStep(start, end, step) {
            if (!animationRunning || animationPaused) return;
            
            const currentValue = start + step;
            if (currentValue > end) {
                stopAnimation();
                return;
            }
            
            // Draw on the animation canvas
            drawAnimationFrame(currentValue);
            
            // Update progress
            const totalSteps = end - start + 1;
            const progress = ((step + 1) / totalSteps) * 100;
            document.getElementById('animProgressBar').style.width = progress + '%';
            document.getElementById('animCurrentStep').textContent = step + 1;
            document.getElementById('animPercent').textContent = progress.toFixed(1);
            
            currentAnimStep = step + 1;
            const speed = parseInt(document.getElementById('animSpeed').value);
            animationTimer = setTimeout(() => runAnimationStep(start, end, step + 1), speed);
        }
        
        function drawAnimationFrame(currentValue) {
            const canvas = document.getElementById('animCanvas');
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Background
            ctx.fillStyle = document.body.classList.contains('light') ? '#ffffff' : '#1a1a1a';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            const cx = canvas.width / 2;
            const cy = canvas.height / 2;
            
            if (animationType === 'radius') {
                const R = currentValue;
                const k = parseInt(document.getElementById('animK').value);
                const scale = 350 / Math.max(R, 10);
                
                // Draw circle boundary
                ctx.strokeStyle = getComputedStyle(document.body).getPropertyValue('--border');
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(cx, cy, R * scale, 0, 2 * Math.PI);
                ctx.stroke();
                
                // Draw points
                let primCount = 0, totalCount = 0;
                
                for (let x = -R; x <= R; x++) {
                    for (let y = -R; y <= R; y++) {
                        if (x*x + y*y <= R*R) {
                            totalCount++;
                            const g = gcd(Math.abs(x), Math.abs(y));
                            const isPrim = g === 1;
                            if (isPrim) primCount++;
                            
                            ctx.fillStyle = isPrim ? '#0066cc' : '#dc3545';
                            ctx.beginPath();
                            ctx.arc(cx + x*scale, cy - y*scale, Math.max(2, 4 - R/30), 0, 2*Math.PI);
                            ctx.fill();
                        }
                    }
                }
                
                // Update stats
                document.getElementById('animParamLabel').textContent = 'Radius R';
                document.getElementById('animParamVal').textContent = R;
                document.getElementById('animPrimCount').textContent = primCount.toLocaleString();
                document.getElementById('animTotalCount').textContent = totalCount.toLocaleString();
                document.getElementById('animDensity').textContent = ((primCount/totalCount)*100).toFixed(2) + '%';
                document.getElementById('animZeta').textContent = '1/Œ∂(2) = ' + (1/zeta(2)).toFixed(4);
                
                // Draw title
                ctx.fillStyle = getComputedStyle(document.body).getPropertyValue('--text');
                ctx.font = 'bold 24px system-ui';
                ctx.textAlign = 'center';
                ctx.fillText(`R = ${R}`, cx, 40);
                ctx.font = '16px system-ui';
                ctx.fillText(`Primitive: ${primCount} | Total: ${totalCount} | Density: ${((primCount/totalCount)*100).toFixed(1)}%`, cx, 70);
                
            } else if (animationType === 'dimension') {
                const k = currentValue;
                const R = parseInt(document.getElementById('animFixedR').value);
                const z = zeta(k);
                const density = 1 / z;
                
                // Draw bar chart showing density for each dimension
                const barWidth = 60;
                const maxHeight = 500;
                const startX = 100;
                const baseY = 650;
                
                ctx.fillStyle = getComputedStyle(document.body).getPropertyValue('--text');
                ctx.font = 'bold 24px system-ui';
                ctx.textAlign = 'center';
                ctx.fillText(`Dimension k = ${k}`, cx, 40);
                ctx.font = '16px system-ui';
                ctx.fillText(`Œ∂(${k}) = ${z.toFixed(6)} | Density = ${(density*100).toFixed(2)}%`, cx, 70);
                
                // Draw bars for dimensions 2 to current
                for (let dim = 2; dim <= currentValue; dim++) {
                    const dimZ = zeta(dim);
                    const dimDensity = 1 / dimZ;
                    const barHeight = dimDensity * maxHeight;
                    const x = startX + (dim - 2) * (barWidth + 20);
                    
                    // Bar
                    const hue = 240 - (dimDensity * 240);
                    ctx.fillStyle = dim === currentValue ? '#0066cc' : `hsl(${hue}, 60%, 50%)`;
                    ctx.fillRect(x, baseY - barHeight, barWidth, barHeight);
                    
                    // Border for current
                    if (dim === currentValue) {
                        ctx.strokeStyle = '#fff';
                        ctx.lineWidth = 3;
                        ctx.strokeRect(x, baseY - barHeight, barWidth, barHeight);
                    }
                    
                    // Label
                    ctx.fillStyle = getComputedStyle(document.body).getPropertyValue('--text');
                    ctx.font = '14px system-ui';
                    ctx.textAlign = 'center';
                    ctx.fillText(`k=${dim}`, x + barWidth/2, baseY + 20);
                    ctx.fillText(`${(1/zeta(dim)*100).toFixed(1)}%`, x + barWidth/2, baseY - barHeight - 10);
                }
                
                // Draw 100% reference line
                ctx.strokeStyle = '#28a745';
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]);
                ctx.beginPath();
                ctx.moveTo(startX - 20, baseY - maxHeight);
                ctx.lineTo(startX + (currentValue - 1) * (barWidth + 20), baseY - maxHeight);
                ctx.stroke();
                ctx.setLineDash([]);
                ctx.fillStyle = '#28a745';
                ctx.font = '14px system-ui';
                ctx.textAlign = 'left';
                ctx.fillText('100% (limit as k‚Üí‚àû)', startX - 20, baseY - maxHeight - 10);
                
                // Update stats
                document.getElementById('animParamLabel').textContent = 'Dimension k';
                document.getElementById('animParamVal').textContent = k;
                const vol = sphereVolume(k, R);
                const predicted = Math.round(vol / z);
                document.getElementById('animPrimCount').textContent = predicted.toLocaleString();
                document.getElementById('animTotalCount').textContent = Math.round(vol).toLocaleString();
                document.getElementById('animDensity').textContent = (density*100).toFixed(2) + '%';
                document.getElementById('animZeta').textContent = 'Œ∂(' + k + ') = ' + z.toFixed(6);
                
            } else if (animationType === 'modular') {
                const m = currentValue;
                const R = 30;
                const scale = 350 / R;
                
                // Count points by residue class
                const counts = new Array(m).fill(0);
                let total = 0;
                
                for (let x = -R; x <= R; x++) {
                    for (let y = -R; y <= R; y++) {
                        if (x*x + y*y <= R*R && gcd(Math.abs(x), Math.abs(y)) === 1) {
                            const residue = ((x + y) % m + m) % m;
                            counts[residue]++;
                            total++;
                        }
                    }
                }
                
                // Draw circle with colored points
                ctx.strokeStyle = getComputedStyle(document.body).getPropertyValue('--border');
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(cx, cy - 50, R * scale, 0, 2 * Math.PI);
                ctx.stroke();
                
                for (let x = -R; x <= R; x++) {
                    for (let y = -R; y <= R; y++) {
                        if (x*x + y*y <= R*R && gcd(Math.abs(x), Math.abs(y)) === 1) {
                            const residue = ((x + y) % m + m) % m;
                            const hue = (residue / m) * 360;
                            ctx.fillStyle = `hsl(${hue}, 70%, 50%)`;
                            ctx.beginPath();
                            ctx.arc(cx + x*scale, cy - 50 - y*scale, 3, 0, 2*Math.PI);
                            ctx.fill();
                        }
                    }
                }
                
                // Draw bar chart of residue distribution
                const barWidth = Math.min(40, (canvas.width - 100) / m);
                const maxBarHeight = 150;
                const maxCount = Math.max(...counts);
                const barBaseY = canvas.height - 50;
                
                for (let i = 0; i < m; i++) {
                    const barHeight = (counts[i] / maxCount) * maxBarHeight;
                    const x = 50 + i * barWidth;
                    const hue = (i / m) * 360;
                    
                    ctx.fillStyle = `hsl(${hue}, 70%, 50%)`;
                    ctx.fillRect(x, barBaseY - barHeight, barWidth - 2, barHeight);
                    
                    if (barWidth > 15) {
                        ctx.fillStyle = getComputedStyle(document.body).getPropertyValue('--text');
                        ctx.font = '10px system-ui';
                        ctx.textAlign = 'center';
                        ctx.fillText(i, x + barWidth/2 - 1, barBaseY + 15);
                    }
                }
                
                // Title
                ctx.fillStyle = getComputedStyle(document.body).getPropertyValue('--text');
                ctx.font = 'bold 24px system-ui';
                ctx.textAlign = 'center';
                ctx.fillText(`Modulus m = ${m}`, cx, 40);
                ctx.font = '16px system-ui';
                ctx.fillText(`Distribution of (x+y) mod ${m} for primitive points`, cx, 70);
                
                // Update stats
                document.getElementById('animParamLabel').textContent = 'Modulus m';
                document.getElementById('animParamVal').textContent = m;
                document.getElementById('animPrimCount').textContent = total.toLocaleString();
                document.getElementById('animTotalCount').textContent = m + ' classes';
                document.getElementById('animDensity').textContent = (total/m).toFixed(1) + ' avg/class';
                document.getElementById('animZeta').textContent = 'œÜ(' + m + ') = ' + eulerPhi(m);
            }
        }
        
        function continueAnimation() {
            let start, end;
            if (animationType === 'radius') {
                start = parseInt(document.getElementById('animStartR').value);
                end = parseInt(document.getElementById('animEndR').value);
            } else if (animationType === 'dimension') {
                start = parseInt(document.getElementById('animStartD').value);
                end = parseInt(document.getElementById('animEndD').value);
            } else if (animationType === 'modular') {
                start = parseInt(document.getElementById('animStartM').value);
                end = parseInt(document.getElementById('animEndM').value);
            }
            runAnimationStep(start, end, currentAnimStep);
        }
        
        function pauseAnimation() {
            animationPaused = true;
            if (animationTimer) clearTimeout(animationTimer);
            document.getElementById('pauseBtn').style.display = 'none';
            document.getElementById('playBtn').style.display = 'inline-block';
        }
        
        function stopAnimation() {
            animationRunning = false;
            animationPaused = false;
            if (animationTimer) clearTimeout(animationTimer);
            
            document.getElementById('playBtn').style.display = 'inline-block';
            document.getElementById('pauseBtn').style.display = 'none';
            document.getElementById('stopBtn').style.display = 'none';
            document.getElementById('animProgress').style.display = 'none';
            document.getElementById('animProgressBar').style.width = '0%';
        }
        
        function applyPreset(name) {
            const presets = {
                'basel': { tab: 'theory', k: 2, R: 10 },
                'apery': { tab: 'viz3d', k: 3, R: 20 },
                'gauss': { tab: 'criticalstrip', R: 100 },
                'fibonacci': { tab: 'viz2d', R: 89 },
                'mersenne': { tab: 'viz2d', R: 31 },
                'perfect': { tab: 'viz2d', R: 28 },
                'golden': { tab: 'viz2d', R: 161 },
                '4d': { tab: 'comparison', k: 4, R: 15 },
                'e8': { tab: 'comparison', k: 8, R: 10 },
                'highdim': { tab: 'comparison', k: 12, R: 5 },
                'composite': { tab: 'patterns', modulus: 12 },
                'primefield': { tab: 'patterns', modulus: 17 },
                'power2': { tab: 'viz2d', R: 64 }
            };
            
            const preset = presets[name];
            if (!preset) return;
            
            // Navigate to appropriate tab
            showTab(preset.tab);
            
            // Apply parameters
            if (preset.k && document.getElementById('tks')) {
                document.getElementById('tks').value = preset.k;
                updateTheory();
            }
            if (preset.R && document.getElementById('r2input')) {
                update2DRadius(preset.R);
            }
            if (preset.modulus && document.getElementById('patternMod')) {
                document.getElementById('patternMod').value = preset.modulus;
                document.getElementById('patternModv').textContent = preset.modulus;
                updatePatternViz();
            }
        }

        function performAdvancedExport() {
            const exportTypeVal = document.getElementById('exportType').value;
            
            if (exportTypeVal === 'single') {
                exportSingleCanvas();
            } else if (exportTypeVal === 'grid2x2') {
                export2x2Grid();
            } else if (exportTypeVal === 'fullAnalysis') {
                exportFullAnalysisPanel();
            }
        }
        
        function exportSingleCanvas() {
            const canvasId = document.getElementById('exportCanvas').value;
            const sourceCanvas = document.getElementById(canvasId);
            
            if (!sourceCanvas) {
                alert('Please generate the visualization first before exporting');
                return;
            }
            
            const includeMetadata = document.getElementById('includeMetadata').checked;
            const includeTimestamp = document.getElementById('includeTimestamp').checked;
            const includeWatermark = document.getElementById('includeWatermark').checked;
            const title = document.getElementById('exportTitle').value || 'Primitive Lattice Point Analysis';
            const subtitle = document.getElementById('exportSubtitle').value;
            const legend = document.getElementById('exportLegend').value;
            
            const [width, height] = getExportDimensions();
            
            // Create high-res canvas
            const exportCanvas = document.createElement('canvas');
            exportCanvas.width = width;
            exportCanvas.height = height;
            const ctx = exportCanvas.getContext('2d');
            
            // White background
            ctx.fillStyle = document.body.classList.contains('light') ? '#ffffff' : '#1a1a1a';
            ctx.fillRect(0, 0, width, height);
            
            // Calculate layout
            const padding = Math.floor(width * 0.03);
            const titleHeight = includeMetadata ? Math.floor(height * 0.12) : 0;
            const legendWidth = legend && includeMetadata ? Math.floor(width * 0.25) : 0;
            const footerHeight = includeWatermark || includeTimestamp ? Math.floor(height * 0.04) : 0;
            
            const contentWidth = width - 2 * padding - legendWidth;
            const contentHeight = height - titleHeight - footerHeight - 2 * padding;
            const contentX = padding;
            const contentY = titleHeight + padding;
            
            // Draw title
            if (includeMetadata && title) {
                ctx.fillStyle = document.body.classList.contains('light') ? '#212529' : '#e0e0e0';
                ctx.font = `bold ${Math.floor(height * 0.04)}px system-ui`;
                ctx.textAlign = 'center';
                ctx.fillText(title, width / 2, padding + Math.floor(height * 0.035));
                
                if (subtitle) {
                    ctx.font = `${Math.floor(height * 0.025)}px system-ui`;
                    ctx.fillStyle = document.body.classList.contains('light') ? '#495057' : '#b0b0b0';
                    ctx.fillText(subtitle, width / 2, padding + Math.floor(height * 0.07));
                }
            }
            
            // Draw source canvas (scaled to fit)
            const scale = Math.min(contentWidth / sourceCanvas.width, contentHeight / sourceCanvas.height);
            const scaledWidth = sourceCanvas.width * scale;
            const scaledHeight = sourceCanvas.height * scale;
            const centerX = contentX + (contentWidth - scaledWidth) / 2;
            const centerY = contentY + (contentHeight - scaledHeight) / 2;
            
            ctx.drawImage(sourceCanvas, centerX, centerY, scaledWidth, scaledHeight);
            
            // Draw legend
            if (legend && includeMetadata && legendWidth > 0) {
                const legendX = width - legendWidth - padding;
                const legendY = contentY;
                
                ctx.fillStyle = document.body.classList.contains('light') ? '#f8f9fa' : '#2d2d2d';
                ctx.fillRect(legendX, legendY, legendWidth - padding, contentHeight);
                
                ctx.fillStyle = document.body.classList.contains('light') ? '#212529' : '#e0e0e0';
                ctx.font = `bold ${Math.floor(height * 0.02)}px system-ui`;
                ctx.textAlign = 'left';
                ctx.fillText('Legend', legendX + padding / 2, legendY + padding);
                
                const lines = legend.split('\n');
                ctx.font = `${Math.floor(height * 0.016)}px monospace`;
                let yPos = legendY + padding * 2;
                lines.forEach(line => {
                    if (yPos < legendY + contentHeight - padding) {
                        ctx.fillText(line, legendX + padding / 2, yPos);
                        yPos += Math.floor(height * 0.025);
                    }
                });
            }
            
            // Draw footer
            if (includeWatermark || includeTimestamp) {
                const footerY = height - footerHeight;
                ctx.fillStyle = document.body.classList.contains('light') ? '#212529' : '#e0e0e0';
                ctx.font = `${Math.floor(height * 0.018)}px system-ui`;
                ctx.textAlign = 'left';
                
                if (includeWatermark) {
                    ctx.fillText('By Wessen Getachew | @7dview | wessengetachew.github.io', padding, footerY + footerHeight * 0.6);
                }
                
                if (includeTimestamp) {
                    ctx.textAlign = 'right';
                    const timestamp = new Date().toLocaleString();
                    ctx.fillText(`Generated: ${timestamp}`, width - padding, footerY + footerHeight * 0.6);
                }
            }
            
            // Download
            const link = document.createElement('a');
            const filename = `${title.replace(/\s+/g, '-').toLowerCase()}-${exportResolution}.png`;
            link.download = filename;
            link.href = exportCanvas.toDataURL('image/png');
            link.click();
            
            // Show preview
            const previewCanvas = document.getElementById('exportPreviewCanvas');
            previewCanvas.width = 800;
            previewCanvas.height = 800;
            const previewCtx = previewCanvas.getContext('2d');
            previewCtx.drawImage(exportCanvas, 0, 0, 800, 800);
            previewCanvas.style.display = 'block';
            document.getElementById('exportPreview').querySelector('p').style.display = 'none';
        }
        
        function export2x2Grid() {
            const [width, height] = getExportDimensions();
            
            const gridCanvas = document.createElement('canvas');
            gridCanvas.width = width;
            gridCanvas.height = height;
            const ctx = gridCanvas.getContext('2d');
            
            ctx.fillStyle = document.body.classList.contains('light') ? '#ffffff' : '#1a1a1a';
            ctx.fillRect(0, 0, width, height);
            
            // Get canvases
            const canvases = [
                { id: 'c2d', name: '2D Lattice' },
                { id: 'heatmapCanvas', name: 'GCD Heatmap' },
                { id: 'criticalCanvas', name: 'Critical Strip' },
                { id: 'ch', name: 'Error Analysis' }
            ];
            
            const padding = 40;
            const titleHeight = 100;
            const cellWidth = (width - 3 * padding) / 2;
            const cellHeight = (height - titleHeight - 3 * padding) / 2;
            
            // Title
            ctx.fillStyle = document.body.classList.contains('light') ? '#212529' : '#e0e0e0';
            ctx.font = 'bold 48px system-ui';
            ctx.textAlign = 'center';
            ctx.fillText('Primitive Lattice Point Analysis - Multi-View', width / 2, 60);
            
            // Draw each canvas in grid
            canvases.forEach((c, i) => {
                const col = i % 2;
                const row = Math.floor(i / 2);
                const x = padding + col * (cellWidth + padding);
                const y = titleHeight + padding + row * (cellHeight + padding);
                
                const sourceCanvas = document.getElementById(c.id);
                if (sourceCanvas) {
                    const scale = Math.min(cellWidth / sourceCanvas.width, cellHeight / sourceCanvas.height);
                    const sw = sourceCanvas.width * scale;
                    const sh = sourceCanvas.height * scale;
                    const sx = x + (cellWidth - sw) / 2;
                    const sy = y + (cellHeight - sh) / 2;
                    
                    ctx.drawImage(sourceCanvas, sx, sy, sw, sh);
                    
                    // Label
                    ctx.fillStyle = document.body.classList.contains('light') ? '#495057' : '#b0b0b0';
                    ctx.font = 'bold 24px system-ui';
                    ctx.textAlign = 'center';
                    ctx.fillText(c.name, x + cellWidth / 2, y - 10);
                }
            });
            
            // Footer
            ctx.fillStyle = document.body.classList.contains('light') ? '#212529' : '#e0e0e0';
            ctx.font = '20px system-ui';
            ctx.textAlign = 'left';
            ctx.fillText('By Wessen Getachew | @7dview', padding, height - 20);
            ctx.textAlign = 'right';
            ctx.fillText(new Date().toLocaleString(), width - padding, height - 20);
            
            // Download
            const link = document.createElement('a');
            link.download = `lattice-analysis-2x2-grid-${exportResolution}.png`;
            link.href = gridCanvas.toDataURL('image/png');
            link.click();
        }
        
        function exportFullAnalysisPanel() {
            const [width, height] = getExportDimensions();
            
            const fullCanvas = document.createElement('canvas');
            fullCanvas.width = width;
            fullCanvas.height = Math.floor(height * 1.4); // Taller for analysis panel
            const ctx = fullCanvas.getContext('2d');
            
            ctx.fillStyle = document.body.classList.contains('light') ? '#ffffff' : '#1a1a1a';
            ctx.fillRect(0, 0, fullCanvas.width, fullCanvas.height);
            
            // Title
            ctx.fillStyle = document.body.classList.contains('light') ? '#212529' : '#e0e0e0';
            ctx.font = 'bold 56px system-ui';
            ctx.textAlign = 'center';
            ctx.fillText('Comprehensive Lattice Point Analysis', width / 2, 70);
            
            // 2√ó2 grid of canvases (top portion)
            const gridTop = 120;
            const gridHeight = Math.floor(height * 0.7);
            const canvases = [
                { id: 'c2d', name: '2D Visualization' },
                { id: 'heatmapCanvas', name: 'GCD Heatmap' },
                { id: 'criticalCanvas', name: 'Critical Strip' },
                { id: 'compChart', name: 'Dimension Comparison' }
            ];
            
            const padding = 40;
            const cellWidth = (width - 3 * padding) / 2;
            const cellHeight = (gridHeight - 3 * padding) / 2;
            
            canvases.forEach((c, i) => {
                const col = i % 2;
                const row = Math.floor(i / 2);
                const x = padding + col * (cellWidth + padding);
                const y = gridTop + padding + row * (cellHeight + padding);
                
                const sourceCanvas = document.getElementById(c.id);
                if (sourceCanvas) {
                    const scale = Math.min(cellWidth / sourceCanvas.width, (cellHeight - 30) / sourceCanvas.height);
                    const sw = sourceCanvas.width * scale;
                    const sh = sourceCanvas.height * scale;
                    const sx = x + (cellWidth - sw) / 2;
                    const sy = y + 30 + (cellHeight - 30 - sh) / 2;
                    
                    ctx.drawImage(sourceCanvas, sx, sy, sw, sh);
                    
                    ctx.fillStyle = document.body.classList.contains('light') ? '#495057' : '#b0b0b0';
                    ctx.font = 'bold 28px system-ui';
                    ctx.textAlign = 'center';
                    ctx.fillText(c.name, x + cellWidth / 2, y + 25);
                }
            });
            
            // Analysis panel (bottom portion)
            const analysisTop = gridTop + gridHeight;
            const analysisHeight = fullCanvas.height - analysisTop - 60;
            
            ctx.fillStyle = document.body.classList.contains('light') ? '#f8f9fa' : '#2d2d2d';
            ctx.fillRect(padding, analysisTop, width - 2 * padding, analysisHeight);
            
            ctx.fillStyle = document.body.classList.contains('light') ? '#212529' : '#e0e0e0';
            ctx.font = 'bold 32px system-ui';
            ctx.textAlign = 'left';
            ctx.fillText('Extended Analysis', padding + 20, analysisTop + 40);
            
            // Add analysis content
            ctx.font = '24px monospace';
            let yPos = analysisTop + 80;
            const lineHeight = 35;
            
            const analysisLines = [
                `Current Parameters:`,
                `  Radius R: ${document.getElementById('r2input')?.value || 'N/A'}`,
                `  Dimension k: ${document.getElementById('tks')?.value || '2'}`,
                `  Œ∂(k): ${document.getElementById('sz')?.textContent || 'N/A'}`,
                `  Density 1/Œ∂(k): ${document.getElementById('sd')?.textContent || 'N/A'}`,
                ``,
                `Statistics:`,
                `  Primitive Points: ${document.getElementById('p2')?.textContent || 'N/A'}`,
                `  Total Points: ${document.getElementById('t2')?.textContent || 'N/A'}`,
                `  Predicted: ${document.getElementById('sp')?.textContent || 'N/A'}`,
                `  Error: ${document.getElementById('e2')?.textContent || 'N/A'}`,
                ``,
                `Theoretical Foundation:`,
                `  N_k(R) = V_k¬∑R^k/Œ∂(k) + O(R^(k-1))`,
                `  Boundary cancellation via M√∂bius inversion`,
                `  Connection to Riemann Hypothesis through error term`
            ];
            
            analysisLines.forEach(line => {
                if (yPos < fullCanvas.height - 100) {
                    ctx.fillText(line, padding + 40, yPos);
                    yPos += lineHeight;
                }
            });
            
            // Footer
            ctx.fillStyle = document.body.classList.contains('light') ? '#212529' : '#e0e0e0';
            ctx.font = '24px system-ui';
            ctx.textAlign = 'left';
            ctx.fillText('By Wessen Getachew | @7dview | wessengetachew.github.io', padding, fullCanvas.height - 25);
            ctx.textAlign = 'right';
            ctx.fillText(new Date().toLocaleString(), width - padding, fullCanvas.height - 25);
            
            // Download
            const link = document.createElement('a');
            link.download = `lattice-full-analysis-${exportResolution}.png`;
            link.href = fullCanvas.toDataURL('image/png');
            link.click();
        }

        function quickExport2D() {
            document.getElementById('exportType').value = 'single';
            updateExportType();
            document.getElementById('exportCanvas').value = 'c2d';
            const R = document.getElementById('r2input').value;
            document.getElementById('exportTitle').value = '2D Primitive Lattice Points';
            document.getElementById('exportSubtitle').value = `Radius R=${R}, showing ${colorMode2D} coloring`;
            document.getElementById('exportLegend').value = `View Mode: ${view2D}
Color Mode: ${colorMode2D}
Radius: ${R}
Total Points: ${document.getElementById('t2').textContent}
Primitive Points: ${document.getElementById('p2').textContent}
Density: ${document.getElementById('d2').textContent}`;
            showTab('export');
        }

        function quickExport3D() {
            alert('3D export: Please use browser screenshot or the 2√ó2 Grid export to capture the 3D visualization.');
        }

        function quickExportHeatmap() {
            document.getElementById('exportType').value = 'single';
            updateExportType();
            document.getElementById('exportCanvas').value = 'heatmapCanvas';
            const R = document.getElementById('heatmapRinput').value;
            document.getElementById('exportTitle').value = 'GCD Heatmap Visualization';
            document.getElementById('exportSubtitle').value = `Radius R=${R}, ${heatmapMode} mode`;
            document.getElementById('exportLegend').value = `Display Mode: ${heatmapMode}
Radius: ${R}
Total Points: ${document.getElementById('heatmapTotal').textContent}
GCD=1: ${document.getElementById('heatmapPrim').textContent}
GCD=2: ${document.getElementById('heatmapGCD2').textContent}
GCD=3: ${document.getElementById('heatmapGCD3').textContent}`;
            showTab('export');
        }

        function quickExportCritical() {
            document.getElementById('exportType').value = 'single';
            updateExportType();
            document.getElementById('exportCanvas').value = 'criticalCanvas';
            const maxR = document.getElementById('criticalMaxRinput').value;
            document.getElementById('exportTitle').value = 'Critical Strip Error Analysis';
            document.getElementById('exportSubtitle').value = `${criticalProblem === 'all' ? 'Gauss Circle Problem' : 'Primitive Points'}, ${criticalViz} visualization, Max R=${maxR}`;
            document.getElementById('exportLegend').value = `Problem: ${criticalProblem}
Visualization: ${criticalViz}
Max Radius: ${maxR}
Data Points: ${document.getElementById('criticalPoints').textContent}
Max Error: ${document.getElementById('criticalMaxErr').textContent}
Avg Error: ${document.getElementById('criticalAvgErr').textContent}`;
            showTab('export');
        }

        function quickExportTable() {
            document.getElementById('exportType').value = 'single';
            updateExportType();
            document.getElementById('exportCanvas').value = 'gcdTableCanvas';
            const size = document.getElementById('gcdTableSizeInput').value;
            document.getElementById('exportTitle').value = 'GCD Multiplication Table';
            document.getElementById('exportSubtitle').value = `${size}√ó${size} grid, ${gcdTableColorMode} coloring`;
            document.getElementById('exportLegend').value = `Grid Size: ${size}√ó${size}
Color Scheme: ${gcdTableColorMode}
Each cell shows: GCD(row, col)`;
            showTab('export');
        }

        function quickExportAnalysis() {
            document.getElementById('exportType').value = 'single';
            updateExportType();
            document.getElementById('exportCanvas').value = 'ch';
            const k = document.getElementById('analysisK').value;
            const maxR = document.getElementById('mrinput').value;
            document.getElementById('exportTitle').value = 'Error Analysis';
            document.getElementById('exportSubtitle').value = `Dimension k=${k}, Max Radius R=${maxR}`;
            document.getElementById('exportLegend').value = `Dimension: k=${k}
Max Radius: ${maxR}
Shows error term growth
as predicted by theory`;
            showTab('export');
        }
        
        function quickExportGrid2x2() {
            document.getElementById('exportType').value = 'grid2x2';
            updateExportType();
            document.getElementById('exportTitle').value = 'Lattice Point Analysis - Multi-View';
            document.getElementById('exportSubtitle').value = 'Comprehensive visualization suite';
            showTab('export');
            // Auto-export
            setTimeout(() => export2x2Grid(), 500);
        }
        
        function quickExportFullAnalysis() {
            document.getElementById('exportType').value = 'fullAnalysis';
            updateExportType();
            document.getElementById('exportTitle').value = 'Complete Lattice Point Analysis';
            document.getElementById('exportSubtitle').value = 'Full analysis panel with extended statistics';
            showTab('export');
            // Auto-export
            setTimeout(() => exportFullAnalysisPanel(), 500);
        }

        function setGCDHeatmapPreset(preset) {
            const presets = { 'small': 15, 'medium': 30, 'large': 50, 'xlarge': 100, 'huge': 200 };
            const R = presets[preset];
            document.getElementById('heatmapR').value = Math.min(R, 100);
            document.getElementById('heatmapRinput').value = R;
            document.getElementById('heatmapRv').textContent = R;
            updateGCDHeatmap();
        }

        function setHeatmapMode(mode) {
            heatmapMode = mode;
            document.querySelectorAll('#heatmapGCD, #heatmapPrimitive, #heatmapGradient').forEach(btn => btn.classList.remove('active'));
            const btnIds = { 'gcd': 'heatmapGCD', 'primitive': 'heatmapPrimitive', 'gradient': 'heatmapGradient' };
            document.getElementById(btnIds[mode]).classList.add('active');
            updateGCDHeatmap();
        }

        function updateGCDHeatmap() {
            const R = parseInt(document.getElementById('heatmapRinput').value) || parseInt(document.getElementById('heatmapR').value);
            const pointSize = parseInt(document.getElementById('heatmapPS').value);
            
            document.getElementById('heatmapRv').textContent = R;
            document.getElementById('heatmapPSv').textContent = pointSize;
            document.getElementById('heatmapR').value = Math.min(R, 80);
            document.getElementById('heatmapRinput').value = R;
            
            const canvas = document.getElementById('heatmapCanvas');
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            const cx = canvas.width / 2, cy = canvas.height / 2;
            const scale = Math.min(canvas.width, canvas.height) / (2.2 * R);
            
            // Draw axes
            ctx.strokeStyle = getComputedStyle(document.body).getPropertyValue('--border');
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(0, cy); ctx.lineTo(canvas.width, cy);
            ctx.moveTo(cx, 0); ctx.lineTo(cx, canvas.height);
            ctx.stroke();
            
            // Draw circle boundary
            ctx.beginPath();
            ctx.arc(cx, cy, R * scale, 0, 2 * Math.PI);
            ctx.stroke();
            
            // Collect and categorize points
            heatmapPointsData = [];
            let counts = { total: 0, gcd1: 0, gcd2: 0, gcd3: 0, gcdOther: 0 };
            
            const filterGCD1 = document.getElementById('filterGCD1').checked;
            const filterGCD2 = document.getElementById('filterGCD2').checked;
            const filterGCD3 = document.getElementById('filterGCD3').checked;
            const filterGCDOther = document.getElementById('filterGCDOther').checked;
            
            for (let x = -R; x <= R; x++) {
                for (let y = -R; y <= R; y++) {
                    const distSq = x*x + y*y;
                    if (distSq <= R*R) {
                        counts.total++;
                        const g = gcd(Math.abs(x), Math.abs(y));
                        const dist = Math.sqrt(distSq);
                        
                        if (g === 1) counts.gcd1++;
                        else if (g === 2) counts.gcd2++;
                        else if (g === 3) counts.gcd3++;
                        else counts.gcdOther++;
                        
                        // Apply filters
                        let shouldDisplay = false;
                        if (g === 1 && filterGCD1) shouldDisplay = true;
                        if (g === 2 && filterGCD2) shouldDisplay = true;
                        if (g === 3 && filterGCD3) shouldDisplay = true;
                        if (g > 3 && filterGCDOther) shouldDisplay = true;
                        
                        if (shouldDisplay) {
                            heatmapPointsData.push({ x, y, gcd: g, dist, screenX: cx + x*scale, screenY: cy - y*scale });
                        }
                    }
                }
            }
            
            // Draw points based on mode
            heatmapPointsData.forEach(pt => {
                let color;
                
                if (heatmapMode === 'gcd') {
                    const gcdColors = {
                        1: '#0066cc', 2: '#dc3545', 3: '#28a745', 4: '#ffc107',
                        5: '#6f42c1', 6: '#fd7e14', 7: '#00d4ff', 8: '#ff006e'
                    };
                    color = gcdColors[Math.min(pt.gcd, 8)] || '#999';
                } else if (heatmapMode === 'primitive') {
                    color = pt.gcd === 1 ? '#0066cc' : '#e0e0e0';
                } else if (heatmapMode === 'gradient') {
                    const ratio = pt.dist / R;
                    const hue = 240 - ratio * 240; // Blue to red
                    color = `hsl(${hue}, 70%, 50%)`;
                }
                
                ctx.fillStyle = color;
                ctx.beginPath();
                ctx.arc(pt.screenX, pt.screenY, pointSize, 0, 2*Math.PI);
                ctx.fill();
            });
            
            // Update stats
            animateValue('heatmapTotal', 0, counts.total);
            animateValue('heatmapPrim', 0, counts.gcd1);
            animateValue('heatmapGCD2', 0, counts.gcd2);
            animateValue('heatmapGCD3', 0, counts.gcd3);
            animateValue('heatmapGCDOther', 0, counts.gcdOther);
        }

        function exportHeatmapData() {
            if (heatmapPointsData.length === 0) { alert('Generate heatmap first'); return; }
            let csv = 'x,y,gcd,distance\n';
            heatmapPointsData.forEach(pt => csv += `${pt.x},${pt.y},${pt.gcd},${pt.dist.toFixed(4)}\n`);
            downloadCSV(csv, 'gcd-heatmap-data.csv');
        }

        function setCriticalStripPreset(preset) {
            if (preset === 'standard') {
                document.getElementById('criticalMaxR').value = 100;
                document.getElementById('criticalMaxRinput').value = 100;
                document.getElementById('criticalStep').value = 1;
            } else if (preset === 'detailed') {
                document.getElementById('criticalMaxR').value = 200;
                document.getElementById('criticalMaxRinput').value = 200;
                document.getElementById('criticalStep').value = 1;
            } else if (preset === 'extended') {
                document.getElementById('criticalMaxR').value = 300;
                document.getElementById('criticalMaxRinput').value = 300;
                document.getElementById('criticalStep').value = 2;
            }
            document.getElementById('criticalStepv').textContent = document.getElementById('criticalStep').value;
            updateCriticalStrip();
        }

        function setCriticalProblem(type) {
            criticalProblem = type;
            document.querySelectorAll('#criticalAllPoints, #criticalPrimitive').forEach(btn => btn.classList.remove('active'));
            document.getElementById(type === 'all' ? 'criticalAllPoints' : 'criticalPrimitive').classList.add('active');
            updateCriticalStrip();
        }

        function setCriticalViz(type) {
            criticalViz = type;
            document.querySelectorAll('#criticalVizError, #criticalVizNormalized, #criticalVizLog, #criticalVizBounds').forEach(btn => btn.classList.remove('active'));
            const btnIds = {
                'error': 'criticalVizError',
                'normalized': 'criticalVizNormalized',
                'loglog': 'criticalVizLog',
                'bounds': 'criticalVizBounds'
            };
            document.getElementById(btnIds[type]).classList.add('active');
            updateCriticalStrip();
        }

        function updateCriticalStrip() {
            const maxR = parseInt(document.getElementById('criticalMaxRinput').value) || parseInt(document.getElementById('criticalMaxR').value);
            const step = parseInt(document.getElementById('criticalStep').value);
            
            document.getElementById('criticalMaxRv').textContent = maxR;
            document.getElementById('criticalStepv').textContent = step;
            document.getElementById('criticalMaxR').value = Math.min(maxR, 500);
            document.getElementById('criticalMaxRinput').value = maxR;
            
            const showZeroLine = document.getElementById('showZeroLine').checked;
            const showRHBound = document.getElementById('showRHBound').checked;
            const showClassicalBound = document.getElementById('showClassicalBound').checked;
            const colorBySign = document.getElementById('colorBySign').checked;
            
            document.getElementById('loadCritical').classList.add('active');
            
            setTimeout(() => {
                const canvas = document.getElementById('criticalCanvas');
                const ctx = canvas.getContext('2d');
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                // Background
                ctx.fillStyle = document.body.classList.contains('light') ? '#ffffff' : '#0a0e1a';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Setup coordinate system with more padding for labels
                const paddingLeft = 100;
                const paddingRight = 80;
                const paddingTop = 120;
                const paddingBottom = 80;
                const plotWidth = canvas.width - paddingLeft - paddingRight;
                const plotHeight = canvas.height - paddingTop - paddingBottom;
                
                // Collect error data with EXACT computation where possible
                const errorData = [];
                let maxAbsError = 0, sumAbsError = 0, sumSqError = 0;
                let maxNormalizedError = 0;
                let minError = Infinity, maxError = -Infinity;
                
                for (let R = step; R <= maxR; R += step) {
                    // Calculate actual count with EXACT COMPUTATION for reasonable R
                    let actualCount = 0;
                    
                    if (criticalProblem === 'all') {
                        // Gauss Circle Problem - exact count for R <= 200
                        if (R <= 200) {
                            for (let x = -R; x <= R; x++) {
                                for (let y = -R; y <= R; y++) {
                                    if (x*x + y*y <= R*R) {
                                        actualCount++;
                                    }
                                }
                            }
                        } else {
                            // Use approximation for large R
                            actualCount = Math.round(Math.PI * R * R);
                        }
                    } else {
                        // Primitive points only - exact count for R <= 100
                        if (R <= 100) {
                            for (let x = -R; x <= R; x++) {
                                for (let y = -R; y <= R; y++) {
                                    if (x*x + y*y <= R*R && gcd(Math.abs(x), Math.abs(y)) === 1) {
                                        actualCount++;
                                    }
                                }
                            }
                        } else {
                            // Use approximation for large R
                            actualCount = Math.round(Math.PI * R * R / zeta(2));
                        }
                    }
                    
                    // Predicted value (smooth asymptotic formula)
                    let predicted;
                    if (criticalProblem === 'all') {
                        predicted = Math.PI * R * R;
                    } else {
                        predicted = Math.PI * R * R / zeta(2);
                    }
                    
                    const error = actualCount - predicted;
                    const absError = Math.abs(error);
                    const normalizedError = absError / Math.sqrt(R);
                    
                    maxAbsError = Math.max(maxAbsError, absError);
                    sumAbsError += absError;
                    sumSqError += error * error;
                    maxNormalizedError = Math.max(maxNormalizedError, normalizedError);
                    minError = Math.min(minError, error);
                    maxError = Math.max(maxError, error);
                    
                    errorData.push({ 
                        R, 
                        error, 
                        absError, 
                        normalizedError,
                        actualCount,
                        predicted
                    });
                }
                
                // Determine axis ranges based on visualization type
                let xMin, xMax, yMin, yMax, xLabel, yLabel;
                
                if (criticalViz === 'error') {
                    xMin = 0; 
                    xMax = maxR;
                    const margin = (maxError - minError) * 0.1;
                    yMin = minError - margin;
                    yMax = maxError + margin;
                    xLabel = 'Radius R';
                    yLabel = 'Error Œî(R) = N(R) - œÄR¬≤' + (criticalProblem === 'primitive' ? '/Œ∂(2)' : '');
                } else if (criticalViz === 'normalized') {
                    xMin = 0; 
                    xMax = maxR;
                    yMin = -maxNormalizedError * 1.2;
                    yMax = maxNormalizedError * 1.2;
                    xLabel = 'Radius R';
                    yLabel = 'Normalized Error Œî(R)/‚àöR';
                } else if (criticalViz === 'loglog') {
                    xMin = Math.log10(step);
                    xMax = Math.log10(maxR);
                    const validErrors = errorData.filter(d => d.absError > 0);
                    if (validErrors.length > 0) {
                        yMin = Math.log10(Math.min(...validErrors.map(d => d.absError)));
                        yMax = Math.log10(maxAbsError) * 1.1;
                    } else {
                        yMin = -1; yMax = 1;
                    }
                    xLabel = 'log‚ÇÅ‚ÇÄ(R)';
                    yLabel = 'log‚ÇÅ‚ÇÄ(|Œî(R)|)';
                } else if (criticalViz === 'bounds') {
                    xMin = 0; 
                    xMax = maxR;
                    yMin = 0;
                    const rhBound = Math.sqrt(maxR) * 5;
                    const classicalBound = Math.pow(maxR, 2/3) * 2;
                    yMax = Math.max(maxAbsError, rhBound, classicalBound) * 1.15;
                    xLabel = 'Radius R';
                    yLabel = '|Œî(R)| Absolute Error';
                }
                
                // Draw grid lines FIRST (behind everything)
                ctx.strokeStyle = 'rgba(128, 128, 128, 0.15)';
                ctx.lineWidth = 1;
                const numGridLines = 10;
                
                // Vertical grid lines
                for (let i = 0; i <= numGridLines; i++) {
                    const x = paddingLeft + (i / numGridLines) * plotWidth;
                    ctx.beginPath();
                    ctx.moveTo(x, paddingTop);
                    ctx.lineTo(x, canvas.height - paddingBottom);
                    ctx.stroke();
                }
                
                // Horizontal grid lines
                for (let i = 0; i <= numGridLines; i++) {
                    const y = paddingTop + (i / numGridLines) * plotHeight;
                    ctx.beginPath();
                    ctx.moveTo(paddingLeft, y);
                    ctx.lineTo(canvas.width - paddingRight, y);
                    ctx.stroke();
                }
                
                // Draw main axes
                ctx.strokeStyle = getComputedStyle(document.body).getPropertyValue('--text');
                ctx.lineWidth = 2;
                
                // X-axis
                ctx.beginPath();
                ctx.moveTo(paddingLeft, canvas.height - paddingBottom);
                ctx.lineTo(canvas.width - paddingRight, canvas.height - paddingBottom);
                ctx.stroke();
                
                // Y-axis
                ctx.beginPath();
                ctx.moveTo(paddingLeft, paddingTop);
                ctx.lineTo(paddingLeft, canvas.height - paddingBottom);
                ctx.stroke();
                
                // Helper function to map data to screen coordinates
                function mapX(val) {
                    if (criticalViz === 'loglog' && val > 0) val = Math.log10(val);
                    const normalized = (val - xMin) / (xMax - xMin);
                    return paddingLeft + normalized * plotWidth;
                }
                
                function mapY(val) {
                    if (criticalViz === 'loglog' && val > 0) val = Math.log10(val);
                    const normalized = (val - yMin) / (yMax - yMin);
                    return canvas.height - paddingBottom - normalized * plotHeight;
                }
                
                // Draw zero line
                if (showZeroLine && (criticalViz === 'error' || criticalViz === 'normalized')) {
                    ctx.strokeStyle = 'rgba(128, 128, 128, 0.5)';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([5, 5]);
                    ctx.beginPath();
                    const y0 = mapY(0);
                    ctx.moveTo(paddingLeft, y0);
                    ctx.lineTo(canvas.width - paddingRight, y0);
                    ctx.stroke();
                    ctx.setLineDash([]);
                    
                    // Label the zero line
                    ctx.fillStyle = 'rgba(128, 128, 128, 0.8)';
                    ctx.font = 'bold 14px system-ui';
                    ctx.textAlign = 'right';
                    ctx.fillText('Œî(R) = 0', paddingLeft - 10, y0 + 5);
                }
                
                // Draw theoretical bounds
                if (showRHBound && (criticalViz === 'bounds' || criticalViz === 'loglog')) {
                    ctx.strokeStyle = 'rgba(111, 66, 193, 0.8)';
                    ctx.lineWidth = 3;
                    ctx.setLineDash([10, 5]);
                    ctx.beginPath();
                    
                    let firstPoint = true;
                    for (let R = step; R <= maxR; R += Math.max(1, Math.floor(step * 2))) {
                        const bound = Math.sqrt(R) * (criticalViz === 'loglog' ? 1 : 5);
                        const x = mapX(R);
                        const y = mapY(bound);
                        if (firstPoint) {
                            ctx.moveTo(x, y);
                            firstPoint = false;
                        } else {
                            ctx.lineTo(x, y);
                        }
                    }
                    ctx.stroke();
                    ctx.setLineDash([]);
                    
                    // Add label with formula
                    ctx.fillStyle = 'rgba(111, 66, 193, 0.9)';
                    ctx.font = 'bold 16px system-ui';
                    ctx.textAlign = 'right';
                    const labelText = criticalViz === 'loglog' ? '1/2 slope (RH bound)' : '5‚àöR (RH conjecture)';
                    ctx.fillText(labelText, canvas.width - paddingRight - 10, paddingTop + 30);
                    
                    // Draw small legend box
                    ctx.setLineDash([10, 5]);
                    ctx.strokeStyle = 'rgba(111, 66, 193, 0.8)';
                    ctx.beginPath();
                    ctx.moveTo(canvas.width - paddingRight - 150, paddingTop + 20);
                    ctx.lineTo(canvas.width - paddingRight - 110, paddingTop + 20);
                    ctx.stroke();
                    ctx.setLineDash([]);
                }
                
                if (showClassicalBound && (criticalViz === 'bounds' || criticalViz === 'loglog')) {
                    ctx.strokeStyle = 'rgba(220, 53, 69, 0.8)';
                    ctx.lineWidth = 3;
                    ctx.setLineDash([5, 10]);
                    ctx.beginPath();
                    
                    let firstPoint = true;
                    for (let R = step; R <= maxR; R += Math.max(1, Math.floor(step * 2))) {
                        const bound = Math.pow(R, 2/3) * (criticalViz === 'loglog' ? 1 : 2);
                        const x = mapX(R);
                        const y = mapY(bound);
                        if (firstPoint) {
                            ctx.moveTo(x, y);
                            firstPoint = false;
                        } else {
                            ctx.lineTo(x, y);
                        }
                    }
                    ctx.stroke();
                    ctx.setLineDash([]);
                    
                    // Add label
                    ctx.fillStyle = 'rgba(220, 53, 69, 0.9)';
                    ctx.font = 'bold 16px system-ui';
                    ctx.textAlign = 'right';
                    const labelText = criticalViz === 'loglog' ? '2/3 slope (proven)' : '2R^(2/3) (van der Corput)';
                    ctx.fillText(labelText, canvas.width - paddingRight - 10, paddingTop + 60);
                    
                    ctx.setLineDash([5, 10]);
                    ctx.strokeStyle = 'rgba(220, 53, 69, 0.8)';
                    ctx.beginPath();
                    ctx.moveTo(canvas.width - paddingRight - 150, paddingTop + 50);
                    ctx.lineTo(canvas.width - paddingRight - 110, paddingTop + 50);
                    ctx.stroke();
                    ctx.setLineDash([]);
                }
                
                // Draw data points with proper click detection coordinates
                errorData.forEach((d, i) => {
                    let x, y, color;
                    const pointSize = 5;
                    
                    if (criticalViz === 'error') {
                        x = mapX(d.R);
                        y = mapY(d.error);
                        color = colorBySign ? 
                            (d.error > 0 ? 'rgba(0, 102, 204, 0.8)' : 'rgba(220, 53, 69, 0.8)') : 
                            'rgba(0, 102, 204, 0.8)';
                    } else if (criticalViz === 'normalized') {
                        x = mapX(d.R);
                        y = mapY(d.error / Math.sqrt(d.R));
                        color = colorBySign ? 
                            (d.error > 0 ? 'rgba(0, 102, 204, 0.8)' : 'rgba(220, 53, 69, 0.8)') : 
                            'rgba(0, 102, 204, 0.8)';
                    } else if (criticalViz === 'loglog') {
                        if (d.absError > 0) {
                            x = mapX(d.R);
                            y = mapY(d.absError);
                            const ratio = d.normalizedError / maxNormalizedError;
                            const hue = 240 - ratio * 240;
                            color = `hsla(${hue}, 70%, 50%, 0.8)`;
                        } else {
                            return; // Skip points with zero error in log-log plot
                        }
                    } else if (criticalViz === 'bounds') {
                        x = mapX(d.R);
                        y = mapY(d.absError);
                        const ratio = d.absError / maxAbsError;
                        const hue = 240 - ratio * 240;
                        color = `hsla(${hue}, 70%, 50%, 0.8)`;
                    }
                    
                    // Draw point
                    ctx.fillStyle = color;
                    ctx.beginPath();
                    ctx.arc(x, y, pointSize, 0, 2*Math.PI);
                    ctx.fill();
                    
                    // Add subtle outline for better visibility
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                    ctx.lineWidth = 1;
                    ctx.stroke();
                    
                    // Store EXACT screen coordinates for click detection
                    d.screenX = x;
                    d.screenY = y;
                    d.screenRadius = pointSize + 5; // Larger hit area for easier clicking
                });
                
                // Axis labels
                ctx.fillStyle = getComputedStyle(document.body).getPropertyValue('--text');
                ctx.font = 'bold 18px system-ui';
                ctx.textAlign = 'center';
                
                // X-axis label
                ctx.fillText(xLabel, canvas.width / 2, canvas.height - 20);
                
                // Y-axis label (rotated)
                ctx.save();
                ctx.translate(25, canvas.height / 2);
                ctx.rotate(-Math.PI/2);
                ctx.fillText(yLabel, 0, 0);
                ctx.restore();
                
                // Title with formula
                ctx.font = 'bold 20px system-ui';
                ctx.textAlign = 'center';
                const problemTitle = criticalProblem === 'all' ? 
                    'Gauss Circle Problem: N(R) = œÄR¬≤ + Œî(R)' : 
                    'Primitive Points: N(R) = œÄR¬≤/Œ∂(2) + Œî(R)';
                ctx.fillText(problemTitle, canvas.width / 2, 30);
                
                ctx.font = '16px system-ui';
                ctx.fillStyle = getComputedStyle(document.body).getPropertyValue('--text2');
                const vizTitle = {
                    'error': 'Error Term Œî(R) vs Radius',
                    'normalized': 'Normalized Error Œî(R)/‚àöR (should be bounded if RH true)',
                    'loglog': 'Log-Log Plot (slope reveals growth rate)',
                    'bounds': 'Absolute Error with Theoretical Bounds'
                }[criticalViz];
                ctx.fillText(vizTitle, canvas.width / 2, 55);
                
                // Description box
                ctx.fillStyle = document.body.classList.contains('light') ? 'rgba(248, 249, 250, 0.95)' : 'rgba(26, 30, 42, 0.95)';
                ctx.fillRect(paddingLeft + 10, paddingTop + 100, 380, 120);
                ctx.strokeStyle = getComputedStyle(document.body).getPropertyValue('--border');
                ctx.lineWidth = 2;
                ctx.strokeRect(paddingLeft + 10, paddingTop + 100, 380, 120);
                
                ctx.fillStyle = getComputedStyle(document.body).getPropertyValue('--text');
                ctx.font = 'bold 14px system-ui';
                ctx.textAlign = 'left';
                ctx.fillText('What This Shows:', paddingLeft + 20, paddingTop + 120);
                
                ctx.font = '13px system-ui';
                const description = criticalViz === 'error' ? 
                    ['‚Ä¢ Œî(R) oscillates around zero', '‚Ä¢ Positive: overcounting vs smooth formula', '‚Ä¢ Negative: undercounting vs smooth formula', '‚Ä¢ Click any point for detailed analysis'] :
                    criticalViz === 'normalized' ?
                    ['‚Ä¢ Œî(R)/‚àöR should stay bounded', '‚Ä¢ If RH true: O(R^(1/2+Œµ)) for any Œµ>0', '‚Ä¢ Unbounded growth would disprove RH', '‚Ä¢ Click points to see normalized values'] :
                    criticalViz === 'loglog' ?
                    ['‚Ä¢ Log-log reveals power law exponent', '‚Ä¢ Slope = growth rate of error', '‚Ä¢ RH: slope < 1/2 (+ Œµ)', '‚Ä¢ Classical bound: slope < 2/3'] :
                    ['‚Ä¢ Shows |Œî(R)| with theoretical bounds', '‚Ä¢ Purple: RH conjecture 5‚àöR', '‚Ä¢ Red: Proven bound 2R^(2/3)', '‚Ä¢ Click to compare error to bounds'];
                
                let yPos = paddingTop + 145;
                description.forEach(line => {
                    ctx.fillText(line, paddingLeft + 20, yPos);
                    yPos += 20;
                });
                
                // Tick marks and labels with better formatting
                ctx.font = '13px system-ui';
                ctx.fillStyle = getComputedStyle(document.body).getPropertyValue('--text');
                ctx.strokeStyle = getComputedStyle(document.body).getPropertyValue('--text');
                ctx.lineWidth = 2;
                
                // X-axis ticks
                const numXTicks = Math.min(10, Math.floor(maxR / step));
                for (let i = 0; i <= numXTicks; i++) {
                    const val = xMin + (xMax - xMin) * i / numXTicks;
                    const displayVal = criticalViz === 'loglog' ? Math.pow(10, val) : val;
                    const x = mapX(criticalViz === 'loglog' ? Math.pow(10, val) : val);
                    
                    // Tick mark
                    ctx.beginPath();
                    ctx.moveTo(x, canvas.height - paddingBottom);
                    ctx.lineTo(x, canvas.height - paddingBottom + 8);
                    ctx.stroke();
                    
                    // Label
                    ctx.textAlign = 'center';
                    const label = criticalViz === 'loglog' ? 
                        displayVal.toFixed(0) : 
                        displayVal.toFixed(0);
                    ctx.fillText(label, x, canvas.height - paddingBottom + 25);
                }
                
                // Y-axis ticks
                const numYTicks = 8;
                for (let i = 0; i <= numYTicks; i++) {
                    const val = yMin + (yMax - yMin) * i / numYTicks;
                    const displayVal = criticalViz === 'loglog' ? Math.pow(10, val) : val;
                    const y = mapY(criticalViz === 'loglog' ? Math.pow(10, val) : val);
                    
                    // Tick mark
                    ctx.beginPath();
                    ctx.moveTo(paddingLeft - 8, y);
                    ctx.lineTo(paddingLeft, y);
                    ctx.stroke();
                    
                    // Label
                    ctx.textAlign = 'right';
                    const label = criticalViz === 'loglog' ? 
                        displayVal.toExponential(0) : 
                        displayVal.toFixed(1);
                    ctx.fillText(label, paddingLeft - 12, y + 5);
                }
                
                // Store data globally for click detection
                window.criticalStripData = errorData;
                window.criticalStripMapX = mapX;
                window.criticalStripMapY = mapY;
                
                // Update stats
                const rmsError = Math.sqrt(sumSqError / errorData.length);
                const avgError = sumAbsError / errorData.length;
                
                document.getElementById('criticalPoints').textContent = errorData.length;
                animateValue('criticalMaxErr', 0, maxAbsError);
                animateValue('criticalAvgErr', 0, avgError);
                animateValue('criticalRMSErr', 0, rmsError);
                document.getElementById('criticalMaxNorm').textContent = maxNormalizedError.toFixed(3);
                
                document.getElementById('loadCritical').classList.remove('active');
            }, 100);
        }

        function exportCriticalData() {
            if (!window.criticalStripData) { alert('Generate critical strip analysis first'); return; }
            const problemType = criticalProblem === 'all' ? 'all_points' : 'primitive_points';
            let csv = 'radius,actual_count,predicted_count,error,abs_error,normalized_error\n';
            window.criticalStripData.forEach(d => {
                csv += `${d.R},${d.actualCount},${d.predicted.toFixed(4)},${d.error.toFixed(4)},${d.absError.toFixed(4)},${d.normalizedError.toFixed(6)}\n`;
            });
            downloadCSV(csv, `critical-strip-${problemType}-data.csv`);
        }

        // Init
        updateTheory();
        updateDimScale();
        const tb = document.getElementById('tbl');
        for (let k = 2; k <= 12; k++) {
            const z = zeta(k);
            const precision = k > 6 ? 17 : 6;
            const v = sphereVolume(k, 1);
            tb.innerHTML += `<tr><td>${k}</td><td>${formatPrecise(z, precision)}</td><td>${formatPrecise(1/z, precision)}</td><td>${formatPrecise(v, precision)}</td></tr>`;
        }
        
        // Display saved sessions
        displaySavedSessions();
        
        document.getElementById('helpModal').addEventListener('click', e => {
            if (e.target.id === 'helpModal') closeHelp();
        });
        
        // Add click handlers for interactive canvases
        document.getElementById('heatmapCanvas').addEventListener('click', function(e) {
            const rect = this.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            // Find closest point
            let closestPoint = null;
            let minDist = Infinity;
            
            heatmapPointsData.forEach(pt => {
                const dist = Math.sqrt((x - pt.screenX)**2 + (y - pt.screenY)**2);
                if (dist < minDist && dist < 15) {
                    minDist = dist;
                    closestPoint = pt;
                }
            });
            
            if (closestPoint) {
                const factors = primeFactors(closestPoint.gcd);
                const fc = {};
                factors.forEach(p => fc[p] = (fc[p]||0) + 1);
                const factorStr = Object.entries(fc).map(([p,c]) => c>1 ? `${p}^${c}` : p).join(' √ó ');
                
                const isPrimitive = closestPoint.gcd === 1;
                const reducedX = closestPoint.x / closestPoint.gcd;
                const reducedY = closestPoint.y / closestPoint.gcd;
                
                const infoDiv = document.getElementById('pointInfo');
                infoDiv.classList.add('point-info-active');
                setTimeout(() => infoDiv.classList.remove('point-info-active'), 500);
                
                infoDiv.innerHTML = `
                    <h3 style="color:var(--blue); margin-bottom:15px;">Point: (${closestPoint.x}, ${closestPoint.y})</h3>
                    <div style="display:grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap:15px;">
                        <div>
                            <p><b>GCD:</b> ${closestPoint.gcd}</p>
                            <p><b>Prime factorization:</b> ${factorStr || '1'}</p>
                            <p><b>Distance:</b> ${closestPoint.dist.toFixed(4)}</p>
                        </div>
                        <div>
                            <p><b>Type:</b> <span style="color:${isPrimitive ? 'var(--green)' : 'var(--red)'}">${isPrimitive ? 'Primitive' : 'Non-Primitive'}</span></p>
                            ${!isPrimitive ? `<p><b>Reduced form:</b> (${reducedX}, ${reducedY})</p>` : ''}
                            ${!isPrimitive ? `<p><b>Relationship:</b> ${closestPoint.gcd} √ó (${reducedX}, ${reducedY})</p>` : ''}
                        </div>
                    </div>
                `;
            }
        });
        
        document.getElementById('gcdTableCanvas').addEventListener('click', function(e) {
            if (!window.gcdTableData) return;
            
            const rect = this.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            // Find clicked cell
            let clickedCell = null;
            
            window.gcdTableData.forEach(cell => {
                if (x >= cell.x && x <= cell.x + cell.size &&
                    y >= cell.y && y <= cell.y + cell.size) {
                    clickedCell = cell;
                }
            });
            
            if (clickedCell) {
                const i = clickedCell.i;
                const j = clickedCell.j;
                const val = clickedCell.val;
                
                const infoDiv = document.getElementById('gcdTableInfo');
                infoDiv.classList.add('point-info-active');
                setTimeout(() => infoDiv.classList.remove('point-info-active'), 500);
                
                let content = '';
                
                if (gcdTableType === 'gcd') {
                    const factorsI = primeFactors(i);
                    const factorsJ = primeFactors(j);
                    const factorsG = primeFactors(val);
                    
                    const fci = {};
                    factorsI.forEach(p => fci[p] = (fci[p]||0) + 1);
                    const fcj = {};
                    factorsJ.forEach(p => fcj[p] = (fcj[p]||0) + 1);
                    const fcg = {};
                    factorsG.forEach(p => fcg[p] = (fcg[p]||0) + 1);
                    
                    const strI = Object.entries(fci).map(([p,c]) => c>1 ? `${p}^${c}` : p).join(' √ó ') || '1';
                    const strJ = Object.entries(fcj).map(([p,c]) => c>1 ? `${p}^${c}` : p).join(' √ó ') || '1';
                    const strG = Object.entries(fcg).map(([p,c]) => c>1 ? `${p}^${c}` : p).join(' √ó ') || '1';
                    
                    const coprime = val === 1;
                    
                    content = `
                        <h3 style="color:var(--blue); margin-bottom:15px;">GCD(${i}, ${j}) = ${val}</h3>
                        <div style="display:grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap:15px;">
                            <div>
                                <p><b>${i} =</b> ${strI}</p>
                                <p><b>${j} =</b> ${strJ}</p>
                                <p><b>GCD =</b> ${strG}</p>
                            </div>
                            <div>
                                <p><b>Coprime:</b> <span style="color:${coprime ? 'var(--green)' : 'var(--red)'}">${coprime ? 'Yes' : 'No'}</span></p>
                                <p><b>LCM(${i}, ${j}):</b> ${(i * j) / val}</p>
                                ${!coprime ? `<p><b>Common factors:</b> Divisors of ${val}</p>` : ''}
                            </div>
                        </div>
                    `;
                } else if (gcdTableType === 'addition') {
                    const size = parseInt(document.getElementById('gcdTableSizeInput').value);
                    content = `
                        <h3 style="color:var(--blue); margin-bottom:15px;">${i} + ${j} ‚â° ${val} (mod ${size})</h3>
                        <div style="display:grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap:15px;">
                            <div>
                                <p><b>Operation:</b> Addition mod ${size}</p>
                                <p><b>Result:</b> (${i} + ${j}) mod ${size} = ${val}</p>
                                <p><b>Commutative:</b> ${i} + ${j} = ${j} + ${i}</p>
                            </div>
                            <div>
                                <p><b>Inverse of ${i}:</b> ${(size - i) % size}</p>
                                <p><b>Identity:</b> 0</p>
                                <p><b>Group:</b> (‚Ñ§/${size}‚Ñ§, +)</p>
                            </div>
                        </div>
                    `;
                } else if (gcdTableType === 'multiplication') {
                    const size = parseInt(document.getElementById('gcdTableSizeInput').value);
                    const isUnit = gcd(i, size) === 1 && gcd(j, size) === 1;
                    content = `
                        <h3 style="color:var(--blue); margin-bottom:15px;">${i} √ó ${j} ‚â° ${val} (mod ${size})</h3>
                        <div style="display:grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap:15px;">
                            <div>
                                <p><b>Operation:</b> Multiplication mod ${size}</p>
                                <p><b>Result:</b> (${i} √ó ${j}) mod ${size} = ${val}</p>
                                <p><b>Zero divisor:</b> ${val === 0 ? 'Yes' : 'No'}</p>
                            </div>
                            <div>
                                <p><b>${i} is unit:</b> ${gcd(i, size) === 1 ? 'Yes' : 'No'}</p>
                                <p><b>${j} is unit:</b> ${gcd(j, size) === 1 ? 'Yes' : 'No'}</p>
                                <p><b>Identity:</b> 1</p>
                            </div>
                        </div>
                    `;
                } else if (gcdTableType === 'zerodivisors') {
                    const size = parseInt(document.getElementById('gcdTableSizeInput').value);
                    content = `
                        <h3 style="color:var(--blue); margin-bottom:15px;">Zero Divisor Check: ${i} √ó ${j} mod ${size}</h3>
                        <div style="display:grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap:15px;">
                            <div>
                                <p><b>Product:</b> ${i} √ó ${j} = ${i * j}</p>
                                <p><b>Mod ${size}:</b> ${(i * j) % size}</p>
                                <p><b>Is zero divisor pair:</b> <span style="color:${val ? 'var(--red)' : 'var(--green)'}">${val ? 'YES' : 'NO'}</span></p>
                            </div>
                            <div>
                                <p><b>gcd(${i}, ${size}):</b> ${gcd(i, size)}</p>
                                <p><b>gcd(${j}, ${size}):</b> ${gcd(j, size)}</p>
                                ${val ? `<p style="color:var(--red);"><b>${i} and ${j} form a zero divisor pair</b></p>` : ''}
                            </div>
                        </div>
                    `;
                } else if (gcdTableType === 'units') {
                    const size = parseInt(document.getElementById('gcdTableSizeInput').value);
                    content = `
                        <h3 style="color:var(--blue); margin-bottom:15px;">Unit Check for ${i} in ‚Ñ§/${size}‚Ñ§</h3>
                        <div style="display:grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap:15px;">
                            <div>
                                <p><b>Element:</b> ${i}</p>
                                <p><b>Modulus:</b> ${size}</p>
                                <p><b>gcd(${i}, ${size}):</b> ${gcd(i, size)}</p>
                            </div>
                            <div>
                                <p><b>Is unit:</b> <span style="color:${val ? 'var(--green)' : 'var(--red)'}">${val ? 'YES' : 'NO'}</span></p>
                                <p><b>Invertible:</b> ${val ? 'Yes' : 'No'}</p>
                                ${val ? `<p><b>Part of (‚Ñ§/${size}‚Ñ§)*</b></p>` : `<p><b>Not invertible</b></p>`}
                            </div>
                        </div>
                    `;
                } else if (gcdTableType === 'totient') {
                    const g = gcd(i, j);
                    content = `
                        <h3 style="color:var(--blue); margin-bottom:15px;">œÜ(gcd(${i}, ${j})) = œÜ(${g}) = ${val}</h3>
                        <div style="display:grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap:15px;">
                            <div>
                                <p><b>gcd(${i}, ${j}):</b> ${g}</p>
                                <p><b>œÜ(${g}):</b> ${val}</p>
                                <p><b>Meaning:</b> ${val} numbers ‚â§ ${g} coprime to ${g}</p>
                            </div>
                            <div>
                                <p><b>œÜ(${i}):</b> ${eulerPhi(i)}</p>
                                <p><b>œÜ(${j}):</b> ${eulerPhi(j)}</p>
                                <p><b>Euler's theorem:</b> a^œÜ(n) ‚â° 1 (mod n)</p>
                            </div>
                        </div>
                    `;
                }
                
                infoDiv.innerHTML = content;
            }
        });
        
        document.getElementById('criticalCanvas').addEventListener('click', function(e) {
            if (!window.criticalStripData) return;
            
            const rect = this.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            // Find closest point
            let closestPoint = null;
            let minDist = Infinity;
            
            window.criticalStripData.forEach(d => {
                const dist = Math.sqrt((x - d.screenX)**2 + (y - d.screenY)**2);
                if (dist < minDist && dist < 20) {
                    minDist = dist;
                    closestPoint = d;
                }
            });
            
            if (closestPoint) {
                const errorPercent = ((Math.abs(closestPoint.error) / closestPoint.predicted) * 100).toFixed(4);
                const rhBound = Math.sqrt(closestPoint.R) * 5;
                const classicalBound = Math.pow(closestPoint.R, 2/3) * 2;
                const exceedsRH = closestPoint.absError > rhBound;
                const exceedsClassical = closestPoint.absError > classicalBound;
                
                const problemType = criticalProblem === 'all' ? 'All lattice points' : 'Primitive points only';
                const formula = criticalProblem === 'all' ? 
                    'N(R) = œÄR¬≤ + Œî(R)' : 
                    'N_prim(R) = œÄR¬≤/Œ∂(2) + Œî(R)';
                
                const infoDiv = document.getElementById('criticalPointInfo');
                infoDiv.classList.add('point-info-active');
                setTimeout(() => infoDiv.classList.remove('point-info-active'), 500);
                
                infoDiv.innerHTML = `
                    <h3 style="color:var(--blue); margin-bottom:15px;">Radius R = ${closestPoint.R} (${problemType})</h3>
                    <div style="display:grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap:15px;">
                        <div>
                            <p><b>Formula:</b> ${formula}</p>
                            <p><b>Predicted N(R):</b> ${closestPoint.predicted.toFixed(2)}</p>
                            <p><b>Actual N(R):</b> ${closestPoint.actualCount}</p>
                            <p><b>Error Œî(R):</b> <span style="color:${closestPoint.error > 0 ? 'var(--green)' : 'var(--red)'}">${closestPoint.error > 0 ? '+' : ''}${closestPoint.error.toFixed(2)}</span></p>
                            <p><b>Relative Error:</b> ${errorPercent}%</p>
                        </div>
                        <div>
                            <p><b>Normalized:</b> Œî(R)/R^(1/2) = ${closestPoint.normalizedError.toFixed(4)}</p>
                            <p><b>RH Bound (5R^(1/2)):</b> ${rhBound.toFixed(2)}</p>
                            <p><b>Classical Bound (2R^(2/3)):</b> ${classicalBound.toFixed(2)}</p>
                            <p style="margin-top:8px;">
                                <b>Status:</b> 
                                ${exceedsRH ? '<span style="color:var(--red)">Warning: Exceeds RH bound</span>' : '<span style="color:var(--green)">Within RH bound</span>'}
                            </p>
                        </div>
                    </div>
                    <div style="margin-top:15px; padding:10px; background:var(--bg); border-radius:6px;">
                        <p style="font-size:0.9em; color:var(--text2);">
                            <b>Interpretation:</b> ${closestPoint.error > 0 ? 
                                'Positive error means more points than predicted by the smooth approximation.' : 
                                'Negative error means fewer points than predicted by the smooth approximation.'} 
                            ${!exceedsRH ? 
                                'The error is consistent with the Riemann Hypothesis bound O(R^(1/2+Œµ)).' : 
                                'The error exceeds our simplified RH bound, but note this is just a constant multiple.'}
                        </p>
                    </div>
                `;
            }
        });
    </script>
</body>
</html>

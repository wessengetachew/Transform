
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Primitive Lattice Point Theory</title>
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        :root {
            --bg: #1a1a1a; --bg2: #2d2d2d; --bg3: #3a3a3a; --text: #e0e0e0; --text2: #b0b0b0;
            --border: #4a4a4a; --blue: #0066cc; --purple: #6f42c1; --green: #28a745; --red: #dc3545;
            --yellow: #ffc107; --orange: #fd7e14;
        }
        body.light { --bg: #fff; --bg2: #f8f9fa; --bg3: #e9ecef; --text: #212529; --text2: #495057; --border: #dee2e6; }
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: system-ui; background: var(--bg); color: var(--text); line-height: 1.6; transition: background 0.3s, color 0.3s; }
        .container { max-width: 1400px; margin: 0 auto; padding: 20px; }
        .header { text-align: center; padding: 40px 20px; background: linear-gradient(135deg, var(--blue), var(--purple));
            color: white; border-radius: 12px; margin-bottom: 30px; position: relative; overflow: hidden; }
        .header::before { content: ''; position: absolute; top: -50%; left: -50%; width: 200%; height: 200%;
            background: radial-gradient(circle, rgba(255,255,255,0.1) 0%, transparent 70%); animation: pulse 4s infinite; }
        @keyframes pulse { 0%, 100% { transform: scale(1); } 50% { transform: scale(1.1); } }
        .header h1 { font-size: 2.5rem; margin-bottom: 10px; position: relative; z-index: 1; }
        .header p { position: relative; z-index: 1; }
        .tabs { display: flex; gap: 5px; margin-bottom: 30px; background: var(--bg2); padding: 10px; border-radius: 12px; flex-wrap: wrap; }
        .tab-btn { flex: 1; min-width: 120px; padding: 12px 20px; border: none; background: var(--bg3); color: var(--text);
            cursor: pointer; border-radius: 8px; font-weight: 600; transition: all 0.3s; }
        .tab-btn:hover { background: var(--blue); color: white; transform: translateY(-2px); }
        .tab-btn.active { background: var(--blue); color: white; box-shadow: 0 4px 12px rgba(0,102,204,0.3); }
        .controls button.active { background: var(--purple); }
        .panel { display: none; animation: fadeIn 0.5s; }
        .panel.active { display: block; }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }
        .section { background: var(--bg2); padding: 30px; border-radius: 12px; margin-bottom: 30px; transition: all 0.3s; }
        .section:hover { box-shadow: 0 4px 20px rgba(0,0,0,0.1); }
        .section h2 { color: var(--blue); margin-bottom: 20px; display: flex; align-items: center; gap: 10px; }
        .help-icon { display: inline-block; width: 20px; height: 20px; background: var(--blue); color: white;
            border-radius: 50%; text-align: center; line-height: 20px; font-size: 12px; cursor: help; }
        .tooltip { position: relative; }
        .tooltip:hover::after { content: attr(data-tip); position: absolute; bottom: 125%; left: 50%;
            transform: translateX(-50%); padding: 8px 12px; background: var(--text); color: var(--bg);
            border-radius: 6px; white-space: nowrap; z-index: 1000; font-size: 12px; }
        .controls { margin: 20px 0; padding: 20px; background: var(--bg3); border-radius: 8px; }
        .controls label { display: block; margin: 10px 0; font-weight: 600; }
        .controls input[type="range"] { width: 100%; }
        .controls button { padding: 10px 20px; background: var(--blue); color: white; border: none;
            border-radius: 6px; cursor: pointer; margin: 5px; transition: all 0.3s; }
        .controls button:hover { background: var(--purple); transform: scale(1.05); }
        .controls button:disabled { background: var(--text2); cursor: not-allowed; transform: none; }
        .stats { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; margin: 20px 0; }
        .stat { background: var(--bg3); padding: 20px; border-radius: 8px; text-align: center; transition: all 0.3s; }
        .stat:hover { transform: translateY(-5px); box-shadow: 0 4px 12px rgba(0,0,0,0.15); }
        .stat .val { font-size: 2rem; font-weight: bold; color: var(--blue); transition: all 0.5s; }
        .stat .lbl { font-size: 0.9rem; color: var(--text2); }
        canvas { border: 2px solid var(--border); border-radius: 8px; display: block; margin: 20px auto; max-width: 100%; }
        #canvas3d, #c3d { width: 100%; height: 800px; cursor: grab; }
        #canvas3d:active, #c3d:active { cursor: grabbing; }
        table { width: 100%; border-collapse: collapse; margin: 20px 0; overflow-x: auto; display: block; }
        th, td { padding: 12px; text-align: left; border-bottom: 1px solid var(--border); }
        th { background: var(--bg3); color: var(--blue); font-weight: 600; position: sticky; top: 0; }
        .btn-fixed { position: fixed; bottom: 20px; padding: 12px 24px; border: none; border-radius: 25px;
            cursor: pointer; font-weight: 600; z-index: 1000; color: white; transition: all 0.3s; }
        .btn-fixed:hover { transform: translateY(-3px); box-shadow: 0 6px 20px rgba(0,0,0,0.3); }
        #darkBtn { right: 20px; background: var(--blue); }
        #helpBtn { right: 140px; background: var(--green); }
        .formula { background: var(--bg3); padding: 20px; border-left: 4px solid var(--blue); border-radius: 8px; margin: 20px 0; }
        .warning { background: #3d3106; color: #ffc107; padding: 15px; border-left: 4px solid var(--yellow); border-radius: 8px; margin: 20px 0; }
        body.light .warning { background: #fff3cd; color: #856404; }
        .loading { display: none; text-align: center; padding: 20px; }
        .loading.active { display: block; }
        .spinner { border: 4px solid var(--border); border-top: 4px solid var(--blue); border-radius: 50%;
            width: 40px; height: 40px; animation: spin 1s linear infinite; margin: 20px auto; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        .compare-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 20px; }
        .compare-item { background: var(--bg3); padding: 15px; border-radius: 8px; }
        .modal { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7);
            z-index: 2000; align-items: center; justify-content: center; }
        .modal.active { display: flex; }
        .modal-content { background: var(--bg); padding: 30px; border-radius: 12px; max-width: 600px; max-height: 80vh;
            overflow-y: auto; position: relative; }
        .modal-close { position: absolute; top: 10px; right: 10px; font-size: 24px; cursor: pointer; color: var(--text2); }
        .export-buttons { display: flex; gap: 10px; flex-wrap: wrap; }
        .data-table-container { max-height: 400px; overflow-y: auto; }
        .point-info-active { background: var(--bg3) !important; border: 2px solid var(--blue); animation: highlightPulse 0.5s ease; }
        @keyframes highlightPulse { 0%, 100% { transform: scale(1); } 50% { transform: scale(1.02); } }
        @media (max-width: 768px) {
            .header h1 { font-size: 1.8rem; }
            .tabs { flex-direction: column; }
            .tab-btn { min-width: 100%; }
            #canvas3d, #c3d { height: 500px; }
            .btn-fixed { padding: 10px 16px; font-size: 14px; }
            #helpBtn { right: 20px; bottom: 70px; }
        }
    </style>
</head>
<body>
    <div class="container">
        <header class="header">
            <h1>Primitive Lattice Point Theory</h1>
            <p>A Computational Framework for Boundary Cancellation Analysis</p>
            <p style="margin-top:10px; font-size:0.9rem">By Wessen Getachew | <a href="https://twitter.com/7dview" style="color:white">@7dview</a></p>
        </header>

        <nav class="tabs">
            <button class="tab-btn active" onclick="showTab('theory')">Theory</button>
            <button class="tab-btn" onclick="showTab('patterns')">Pattern Explorer</button>
            <button class="tab-btn" onclick="showTab('gcdheatmap')">GCD Heatmap</button>
            <button class="tab-btn" onclick="showTab('criticalstrip')">Critical Strip</button>
            <button class="tab-btn" onclick="showTab('viz2d')">2D Viz</button>
            <button class="tab-btn" onclick="showTab('viz3d')">3D Viz</button>
            <button class="tab-btn" onclick="showTab('comparison')">Compare</button>
            <button class="tab-btn" onclick="showTab('analysis')">Analysis</button>
            <button class="tab-btn" onclick="showTab('tools')">Tools</button>
            <button class="tab-btn" onclick="showTab('derivation')">Derivation</button>
        </nav>

        <div id="theory" class="panel active">
            <div class="section">
                <h2>Abstract <span class="help-icon tooltip" data-tip="Core theoretical framework">?</span></h2>
                <p>We present a framework for counting primitive lattice points in k-dimensional spheres. Points (x₁, x₂, ..., xₖ) with gcd(x₁, x₂, ..., xₖ) = 1 follow the asymptotic formula:</p>
                <div class="formula">$$N_k(R) = \frac{V_k R^k}{\zeta(k)} + O(R^{k-1})$$</div>
                <p style="margin-top:15px">Where V_k is the volume of the unit k-sphere and ζ(k) is the Riemann zeta function. The density of primitive points approaches 1/ζ(k) as R → ∞.</p>
            </div>
            
            <div class="section">
                <h2>Boundary Cancellation Principle</h2>
                <p>The key insight is that non-primitive points (those sharing a common factor d > 1) can be expressed as d·(primitive point). Through Möbius inversion, we show that boundary contributions from non-primitive points cancel systematically, leaving only the volume term divided by ζ(k).</p>
                <div class="formula">$$N_k(R) = \sum_{d=1}^{R} \mu(d) \cdot |\{(x_1,...,x_k) : \sum x_i^2 \leq (R/d)^2\}|$$</div>
                <p style="margin-top:15px">The Möbius function μ(d) = (-1)^ω(d) for square-free d (where ω counts distinct prime factors) ensures alternating cancellation of boundary terms.</p>
            </div>

            <div class="section">
                <h2>Interactive Explorer <span class="help-icon tooltip" data-tip="Adjust parameters to see predictions">?</span></h2>
                <div class="controls">
                    <label>Dimension k: <span id="tk">3</span></label>
                    <input type="range" id="tks" min="2" max="12" value="3" oninput="updateTheory()">
                    <label>Radius R: <span id="tr">50</span></label>
                    <input type="range" id="trs" min="10" max="200" value="50" step="10" oninput="updateTheory()">
                    <button onclick="exportTheoryData()">Export Data</button>
                </div>
                <div class="stats">
                    <div class="stat"><div class="val" id="sz">1.202</div><div class="lbl">ζ(k)</div></div>
                    <div class="stat"><div class="val" id="sp">4186</div><div class="lbl">Predicted N_k(R)</div></div>
                    <div class="stat"><div class="val" id="sd">0.832</div><div class="lbl">Density (1/ζ(k))</div></div>
                    <div class="stat"><div class="val" id="svol">523.6</div><div class="lbl">Sphere Volume</div></div>
                </div>
                <div class="data-table-container">
                    <table><thead><tr><th>k</th><th>ζ(k)</th><th>1/ζ(k)</th><th>V_k (unit sphere)</th></tr></thead><tbody id="tbl"></tbody></table>
                </div>
            </div>
        </div>

        <div id="patterns" class="panel">
            <div class="section">
                <h2>Pattern Explorer <span class="help-icon tooltip" data-tip="Discover patterns in primitive lattice points">?</span></h2>
                <p>Explore mathematical patterns and structures within primitive lattice point distributions. Interactive tools reveal modular patterns, density variations, and symmetry properties.</p>
                
                <div class="controls">
                    <label><b>Select Pattern Type:</b></label>
                    <div style="display:grid; grid-template-columns: repeat(auto-fit, minmax(180px, 1fr)); gap:10px; margin:15px 0;">
                        <button id="patternModular" class="active" onclick="setPatternType('modular')" style="padding:12px;">Modular Residue Classes</button>
                        <button id="patternDensity" onclick="setPatternType('density')" style="padding:12px;">Density Distribution</button>
                        <button id="patternAngular" onclick="setPatternType('angular')" style="padding:12px;">Angular Distribution</button>
                        <button id="patternRadial" onclick="setPatternType('radial')" style="padding:12px;">Radial Shells</button>
                    </div>
                    
                    <div id="modularPatternControls">
                        <div style="background:var(--bg3); padding:20px; border-radius:8px; margin:15px 0;">
                            <h3 style="color:var(--blue); margin-bottom:15px;">Modular Arithmetic Patterns</h3>
                            <p style="margin-bottom:15px;">Analyze how primitive points distribute across residue classes modulo m. This reveals deep connections between coprimality and modular arithmetic.</p>
                            
                            <label>Modulus m: <span id="patternModv">7</span></label>
                            <input type="range" id="patternMod" min="2" max="20" value="7" step="1" oninput="updatePatternViz()">
                            
                            <label style="margin-top:15px;">Radius R: <span id="patternRv">30</span></label>
                            <input type="range" id="patternR" min="10" max="100" value="30" step="5" oninput="updatePatternViz()">
                            
                            <div style="margin-top:15px;">
                                <label><input type="checkbox" id="showExpected" checked onchange="updatePatternViz()"> Show Expected Distribution</label>
                            </div>
                        </div>
                        
                        <div style="margin:20px 0;">
                            <button onclick="updatePatternViz()" style="padding:12px 24px;">Compute Pattern</button>
                            <button onclick="exportPatternData()" style="padding:12px 24px;">Export Data</button>
                        </div>
                        
                        <canvas id="patternCanvas" width="1000" height="600" style="max-width:100%;"></canvas>
                        
                        <div class="stats" id="patternStats" style="margin-top:20px;"></div>
                        
                        <div class="formula" style="margin-top:20px;">
                            <p><b>Theoretical Background:</b></p>
                            <p>For modulus m and primitive points with gcd(x,y) = 1, the distribution across residue classes (x+y) mod m reveals patterns related to Euler's totient function φ(m). Residue classes coprime to m tend to have higher concentrations of primitive points.</p>
                        </div>
                    </div>
                    
                    <div id="densityPatternControls" style="display:none;">
                        <div style="background:var(--bg3); padding:20px; border-radius:8px; margin:15px 0;">
                            <h3 style="color:var(--blue); margin-bottom:15px;">Density Distribution Analysis</h3>
                            <p style="margin-bottom:15px;">Examine how the density of primitive points varies across different regions of the lattice.</p>
                            
                            <label>Grid Size: <span id="gridSizev">10</span></label>
                            <input type="range" id="gridSize" min="5" max="20" value="10" step="1" oninput="updatePatternViz()">
                            
                            <label style="margin-top:15px;">Max Radius: <span id="densityRv">50</span></label>
                            <input type="range" id="densityR" min="20" max="100" value="50" step="5" oninput="updatePatternViz()">
                        </div>
                        
                        <button onclick="updatePatternViz()" style="padding:12px 24px; margin:10px 0;">Compute Density Map</button>
                        
                        <canvas id="densityCanvas" width="800" height="800" style="max-width:100%;"></canvas>
                        
                        <div class="formula" style="margin-top:20px;">
                            <p><b>Observation:</b> Density approaches 1/ζ(2) ≈ 60.79% uniformly as radius increases, confirming the asymptotic formula.</p>
                        </div>
                    </div>
                    
                    <div id="angularPatternControls" style="display:none;">
                        <div style="background:var(--bg3); padding:20px; border-radius:8px; margin:15px 0;">
                            <h3 style="color:var(--blue); margin-bottom:15px;">Angular Distribution</h3>
                            <p style="margin-bottom:15px;">How are primitive points distributed by angle around the origin?</p>
                            
                            <label>Number of Sectors: <span id="numSectorsv">16</span></label>
                            <input type="range" id="numSectors" min="4" max="32" value="16" step="1" oninput="updatePatternViz()">
                            
                            <label style="margin-top:15px;">Radius: <span id="angularRv">40</span></label>
                            <input type="range" id="angularR" min="10" max="100" value="40" step="5" oninput="updatePatternViz()">
                        </div>
                        
                        <button onclick="updatePatternViz()" style="padding:12px 24px; margin:10px 0;">Analyze Angular Distribution</button>
                        
                        <canvas id="angularCanvas" width="1000" height="600" style="max-width:100%;"></canvas>
                        
                        <div class="formula" style="margin-top:20px;">
                            <p><b>Expected Result:</b> For large R, angular distribution should be approximately uniform, with each sector containing roughly (total primitive points) / (number of sectors).</p>
                        </div>
                    </div>
                    
                    <div id="radialPatternControls" style="display:none;">
                        <div style="background:var(--bg3); padding:20px; border-radius:8px; margin:15px 0;">
                            <h3 style="color:var(--blue); margin-bottom:15px;">Radial Shell Analysis</h3>
                            <p style="margin-bottom:15px;">Count primitive points in concentric shells to observe growth patterns.</p>
                            
                            <label>Shell Thickness: <span id="shellThickv">2</span></label>
                            <input type="range" id="shellThick" min="1" max="10" value="2" step="1" oninput="updatePatternViz()">
                            
                            <label style="margin-top:15px;">Maximum Radius: <span id="radialMaxRv">60</span></label>
                            <input type="range" id="radialMaxR" min="20" max="100" value="60" step="5" oninput="updatePatternViz()">
                        </div>
                        
                        <button onclick="updatePatternViz()" style="padding:12px 24px; margin:10px 0;">Compute Radial Distribution</button>
                        
                        <canvas id="radialCanvas" width="1000" height="600" style="max-width:100%;"></canvas>
                        
                        <div class="formula" style="margin-top:20px;">
                            <p><b>Growth Pattern:</b> The number of primitive points in shell [r, r+Δr] grows approximately as 2πrΔr/ζ(2), reflecting the density theorem.</p>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div id="gcdheatmap" class="panel">
            <div class="section">
                <h2>Interactive GCD Heatmap <span class="help-icon tooltip" data-tip="Click on points to see details">?</span></h2>
                <p>Explore GCD patterns in the lattice. Click on any point to see detailed information about its coordinates and GCD value.</p>
                
                <div class="controls">
                    <div style="margin-bottom:10px;">
                        <label><b>Presets:</b></label>
                        <div style="display:flex; gap:8px; flex-wrap:wrap; margin-top:5px;">
                            <button onclick="setGCDHeatmapPreset('small')" style="padding:6px 12px; font-size:0.9em;">Small (R=15)</button>
                            <button onclick="setGCDHeatmapPreset('medium')" style="padding:6px 12px; font-size:0.9em;">Medium (R=30)</button>
                            <button onclick="setGCDHeatmapPreset('large')" style="padding:6px 12px; font-size:0.9em;">Large (R=50)</button>
                        </div>
                    </div>
                    
                    <label>Radius: <span id="heatmapRv">25</span></label>
                    <div style="display:flex; gap:10px; align-items:center; margin-bottom:15px;">
                        <input type="range" id="heatmapR" min="5" max="80" value="25" step="1" oninput="updateGCDHeatmap()" style="flex:1;">
                        <input type="number" id="heatmapRinput" min="5" max="100" value="25" style="width:100px; padding:8px;" oninput="updateGCDHeatmap()">
                    </div>
                    
                    <div style="background:var(--bg3); padding:15px; border-radius:8px; margin-bottom:15px;">
                        <label style="font-size:1.1em; color:var(--blue); margin-bottom:10px; display:block;"><b>Display Mode:</b></label>
                        <div style="display:grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap:8px;">
                            <button id="heatmapGCD" class="active" onclick="setHeatmapMode('gcd')" style="padding:10px;">By GCD Value</button>
                            <button id="heatmapPrimitive" onclick="setHeatmapMode('primitive')" style="padding:10px;">Primitive Only</button>
                            <button id="heatmapGradient" onclick="setHeatmapMode('gradient')" style="padding:10px;">Distance Gradient</button>
                        </div>
                    </div>
                    
                    <div style="background:var(--bg3); padding:15px; border-radius:8px; margin-bottom:15px;">
                        <label style="font-size:1.1em; color:var(--blue); margin-bottom:10px; display:block;"><b>Filter Options:</b></label>
                        <label style="display:flex; align-items:center; gap:8px; margin:8px 0;">
                            <input type="checkbox" id="filterGCD1" checked onchange="updateGCDHeatmap()"> Show GCD = 1 (Primitive)
                        </label>
                        <label style="display:flex; align-items:center; gap:8px; margin:8px 0;">
                            <input type="checkbox" id="filterGCD2" checked onchange="updateGCDHeatmap()"> Show GCD = 2
                        </label>
                        <label style="display:flex; align-items:center; gap:8px; margin:8px 0;">
                            <input type="checkbox" id="filterGCD3" checked onchange="updateGCDHeatmap()"> Show GCD = 3
                        </label>
                        <label style="display:flex; align-items:center; gap:8px; margin:8px 0;">
                            <input type="checkbox" id="filterGCDOther" checked onchange="updateGCDHeatmap()"> Show GCD > 3
                        </label>
                    </div>
                    
                    <label>Point Size: <span id="heatmapPSv">4</span></label>
                    <input type="range" id="heatmapPS" min="2" max="10" value="4" oninput="updateGCDHeatmap()">
                    
                    <div style="margin-top:15px;">
                        <button onclick="updateGCDHeatmap()">Refresh Heatmap</button>
                        <button onclick="exportCanvas('heatmapCanvas', 'gcd-heatmap')">Export Image</button>
                        <button onclick="exportHeatmapData()">Export Data</button>
                    </div>
                </div>
                
                <canvas id="heatmapCanvas" width="1200" height="1200" style="max-width:100%; cursor:crosshair;"></canvas>
                
                <div id="pointInfo" style="background:var(--bg3); padding:20px; border-radius:8px; margin-top:20px; min-height:100px;">
                    <p style="color:var(--text2); font-style:italic;">Click on a point to see details</p>
                </div>
                
                <div class="stats">
                    <div class="stat"><div class="val" id="heatmapTotal">0</div><div class="lbl">Total Points</div></div>
                    <div class="stat"><div class="val" id="heatmapPrim">0</div><div class="lbl">Primitive (GCD=1)</div></div>
                    <div class="stat"><div class="val" id="heatmapGCD2">0</div><div class="lbl">GCD = 2</div></div>
                    <div class="stat"><div class="val" id="heatmapGCD3">0</div><div class="lbl">GCD = 3</div></div>
                    <div class="stat"><div class="val" id="heatmapGCDOther">0</div><div class="lbl">GCD > 3</div></div>
                </div>
                
                <div class="formula" style="margin-top:20px;">
                    <p><b>GCD Patterns:</b></p>
                    <p>• Points with GCD = d form a scaled copy of the primitive lattice, scaled by factor d</p>
                    <p>• The number of points with GCD = d in radius R is approximately N₁(R/d) where N₁ is the primitive count</p>
                    <p>• GCD values reveal the arithmetic structure of the lattice - patterns repeat at each GCD level</p>
                </div>
            </div>
        </div>

        <div id="criticalstrip" class="panel">
            <div class="section">
                <h2>Critical Strip Projection <span class="help-icon tooltip" data-tip="Maps error onto complex plane">?</span></h2>
                <p>Maps the error term Δ(R) = N(R) - V₂R²/ζ(2) onto the complex plane to test Riemann Hypothesis predictions. The distribution of error terms in the critical strip (0 < Re(s) < 1) reveals deep connections to prime numbers.</p>
                
                <div class="controls">
                    <div style="margin-bottom:10px;">
                        <label><b>Presets:</b></label>
                        <div style="display:flex; gap:8px; flex-wrap:wrap; margin-top:5px;">
                            <button onclick="setCriticalStripPreset('standard')" style="padding:6px 12px; font-size:0.9em;">Standard View</button>
                            <button onclick="setCriticalStripPreset('detailed')" style="padding:6px 12px; font-size:0.9em;">Detailed</button>
                            <button onclick="setCriticalStripPreset('wide')" style="padding:6px 12px; font-size:0.9em;">Wide Range</button>
                        </div>
                    </div>
                    
                    <label>Max Radius for Error: <span id="criticalMaxRv">100</span></label>
                    <div style="display:flex; gap:10px; align-items:center; margin-bottom:15px;">
                        <input type="range" id="criticalMaxR" min="20" max="200" value="100" step="10" oninput="updateCriticalStrip()" style="flex:1;">
                        <input type="number" id="criticalMaxRinput" min="20" max="300" value="100" step="10" style="width:100px; padding:8px;" oninput="updateCriticalStrip()">
                    </div>
                    
                    <label>Step Size: <span id="criticalStepv">2</span></label>
                    <input type="range" id="criticalStep" min="1" max="10" value="2" step="1" oninput="updateCriticalStrip()">
                    
                    <div style="background:var(--bg3); padding:15px; border-radius:8px; margin:15px 0;">
                        <label style="font-size:1.1em; color:var(--blue); margin-bottom:10px; display:block;"><b>Visualization Options:</b></label>
                        <label style="display:flex; align-items:center; gap:8px; margin:8px 0;">
                            <input type="checkbox" id="showCriticalLine" checked onchange="updateCriticalStrip()"> Show Critical Line (Re = 1/2)
                        </label>
                        <label style="display:flex; align-items:center; gap:8px; margin:8px 0;">
                            <input type="checkbox" id="showStripBounds" checked onchange="updateCriticalStrip()"> Show Strip Boundaries
                        </label>
                        <label style="display:flex; align-items:center; gap:8px; margin:8px 0;">
                            <input type="checkbox" id="colorByMagnitude" checked onchange="updateCriticalStrip()"> Color by Error Magnitude
                        </label>
                    </div>
                    
                    <label>Point Size: <span id="criticalPSv">5</span></label>
                    <input type="range" id="criticalPS" min="2" max="12" value="5" step="1" oninput="updateCriticalStrip()">
                    
                    <div style="margin-top:15px;">
                        <button onclick="updateCriticalStrip()">Compute Projection</button>
                        <button onclick="exportCanvas('criticalCanvas', 'critical-strip')">Export Image</button>
                        <button onclick="exportCriticalData()">Export Data</button>
                    </div>
                </div>
                
                <div class="loading" id="loadCritical"><div class="spinner"></div><p>Computing error projections...</p></div>
                
                <canvas id="criticalCanvas" width="1400" height="1000" style="max-width:100%; cursor:crosshair;"></canvas>
                
                <div id="criticalPointInfo" style="background:var(--bg3); padding:20px; border-radius:8px; margin-top:20px; min-height:100px;">
                    <p style="color:var(--text2); font-style:italic;">Click on a point to see error details for that radius</p>
                </div>
                
                <div class="stats">
                    <div class="stat"><div class="val" id="criticalPoints">0</div><div class="lbl">Error Points Plotted</div></div>
                    <div class="stat"><div class="val" id="criticalMaxErr">0</div><div class="lbl">Max |Δ(R)|</div></div>
                    <div class="stat"><div class="val" id="criticalAvgErr">0</div><div class="lbl">Avg |Δ(R)|</div></div>
                    <div class="stat"><div class="val" id="criticalPositive">0</div><div class="lbl">Positive Errors</div></div>
                    <div class="stat"><div class="val" id="criticalNegative">0</div><div class="lbl">Negative Errors</div></div>
                </div>
                
                <div class="formula" style="margin-top:20px;">
                    <p><b>Riemann Hypothesis Connection:</b></p>
                    <p>The error term Δ(R) = N(R) - πR²/ζ(2) is deeply connected to the zeros of the Riemann zeta function. The Riemann Hypothesis states that all non-trivial zeros lie on the critical line Re(s) = 1/2.</p>
                    <p style="margin-top:10px;"><b>Key insights:</b></p>
                    <p>• If RH is true, |Δ(R)| = O(R^(1/2 + ε)) for any ε > 0</p>
                    <p>• The distribution of error signs reveals information about zero spacing</p>
                    <p>• Oscillations in Δ(R) correspond to contributions from zeta zeros</p>
                    <p>• The critical strip (0 < Re(s) < 1) contains all the mystery of prime distribution</p>
                </div>
            </div>
        </div>

        <div id="viz2d" class="panel">
            <div class="section">
                <h2>2D Lattice Visualization <span class="help-icon tooltip" data-tip="Explore primitive lattice points">?</span></h2>
                <div class="controls">
                    <div style="background: var(--bg3); padding: 15px; border-radius: 8px; margin-bottom: 15px;">
                        <label style="font-size: 1.1em; color: var(--blue); margin-bottom: 10px; display: block;"><b>View Mode:</b></label>
                        <div style="display:flex; gap:10px; flex-wrap:wrap;">
                            <button id="viewPrimitive" class="active" onclick="set2DView('primitive')" style="flex:1; min-width:150px; padding: 12px;">Colored by Mode</button>
                            <button id="viewGauss" onclick="set2DView('gauss')" style="flex:1; min-width:150px; padding: 12px;">Circle Problem (All Points)</button>
                        </div>
                    </div>
                    
                    <div style="background: var(--bg3); padding: 15px; border-radius: 8px; margin-bottom: 15px;">
                        <label style="font-size: 1.1em; color: var(--blue); margin-bottom: 10px; display: block;"><b>Coloring Mode:</b></label>
                        <div style="display:grid; grid-template-columns: repeat(auto-fit, minmax(160px, 1fr)); gap:8px;">
                            <button id="color2DPrimitive" class="active" onclick="set2DColorMode('primitive')" style="padding:10px 12px; font-size:0.85em;">GCD=1 vs GCD>1</button>
                            <button id="color2DGCD" onclick="set2DColorMode('gcd')" style="padding:10px 12px; font-size:0.85em;">By GCD Value</button>
                            <button id="color2DMod" onclick="set2DColorMode('mod')" style="padding:10px 12px; font-size:0.85em;">By Mod m</button>
                            <button id="color2DQuadrant" onclick="set2DColorMode('quadrant')" style="padding:10px 12px; font-size:0.85em;">By Quadrant</button>
                            <button id="color2DAngular" onclick="set2DColorMode('angular')" style="padding:10px 12px; font-size:0.85em;">By Angular Sector</button>
                            <button id="color2DGCDQuad" onclick="set2DColorMode('gcdquad')" style="padding:10px 12px; font-size:0.85em;">GCD × Quadrant</button>
                            <button id="color2DGCDMod" onclick="set2DColorMode('gcdmod')" style="padding:10px 12px; font-size:0.85em;">GCD × Mod</button>
                        </div>
                        <div id="modControls2D" style="display:none; margin-top:10px;">
                            <label>Modulus m: <span id="mod2Dv">3</span></label>
                            <input type="range" id="mod2D" min="2" max="12" value="3" step="1" oninput="document.getElementById('mod2Dv').textContent=this.value; draw2D()">
                        </div>
                        <div id="sectorControls2D" style="display:none; margin-top:10px;">
                            <label>Angular Sectors: <span id="sectors2Dv">8</span></label>
                            <input type="range" id="sectors2D" min="4" max="16" value="8" step="1" oninput="document.getElementById('sectors2Dv').textContent=this.value; draw2D()">
                        </div>
                    </div>
                    <div style="margin-bottom:10px;">
                        <label><b>Presets:</b></label>
                        <div style="display:flex; gap:8px; flex-wrap:wrap; margin-top:5px;">
                            <button onclick="set2DPreset('small')" style="padding:6px 12px; font-size:0.9em;">Small (R=10)</button>
                            <button onclick="set2DPreset('medium')" style="padding:6px 12px; font-size:0.9em;">Medium (R=50)</button>
                            <button onclick="set2DPreset('large')" style="padding:6px 12px; font-size:0.9em;">Large (R=100)</button>
                            <button onclick="set2DPreset('xlarge')" style="padding:6px 12px; font-size:0.9em;">X-Large (R=200)</button>
                        </div>
                    </div>
                    <label>Radius: <span id="r2v">20</span></label>
                    <div style="display:flex; gap:10px; align-items:center; margin-bottom:10px;">
                        <input type="range" id="r2" min="1" max="500" value="20" step="1" oninput="update2DRadius(this.value)" style="flex:1;">
                        <input type="number" id="r2input" min="1" max="1000" value="20" style="width:100px; padding:8px;" oninput="update2DRadius(this.value)">
                    </div>
                    <label>Point Size: <span id="psv">3</span></label>
                    <input type="range" id="ps" min="1" max="10" value="3" oninput="draw2D()">
                    <button onclick="exportCanvas('c2d', '2d-lattice')">Export Image</button>
                    <button onclick="exportPointData2D()">Export Points</button>
                </div>
                <div class="warning" id="warn2d" style="display:none;">
                    ⚠️ Large radius values may slow performance. Consider using R ≤ 200 for smooth rendering.
                </div>
                <div class="loading" id="load2d"><div class="spinner"></div><p>Computing lattice points...</p></div>
                <canvas id="c2d" width="1200" height="1200" style="max-width:100%;"></canvas>
                <div class="stats">
                    <div class="stat"><div class="val" id="p2">0</div><div class="lbl">Primitive Points</div></div>
                    <div class="stat"><div class="val" id="t2">0</div><div class="lbl">Total Points</div></div>
                    <div class="stat"><div class="val" id="d2">0%</div><div class="lbl">Density</div></div>
                    <div class="stat"><div class="val" id="e2">0</div><div class="lbl">|Predicted - Actual|</div></div>
                </div>
            </div>
        </div>

        <div id="viz3d" class="panel">
            <div class="section">
                <h2>3D Lattice Visualization <span class="help-icon tooltip" data-tip="Click and drag to rotate">?</span></h2>
                <div class="controls">
                    <div style="background: var(--bg3); padding: 15px; border-radius: 8px; margin-bottom: 15px;">
                        <label style="font-size: 1.1em; color: var(--blue); margin-bottom: 10px; display: block;"><b>Boundary Shape:</b></label>
                        <div style="display:flex; gap:10px; flex-wrap:wrap;">
                            <button id="shape3DSphere" class="active" onclick="set3DShape('sphere')" style="flex:1; min-width:120px; padding: 12px;">Sphere (x²+y²+z² ≤ R²)</button>
                            <button id="shape3DCube" onclick="set3DShape('cube')" style="flex:1; min-width:120px; padding: 12px;">Cube (|x|,|y|,|z| ≤ R)</button>
                        </div>
                    </div>
                    
                    <div style="background: var(--bg3); padding: 15px; border-radius: 8px; margin-bottom: 15px;">
                        <label style="font-size: 1.1em; color: var(--blue); margin-bottom: 10px; display: block;"><b>Coloring Mode:</b></label>
                        <div style="display:grid; grid-template-columns: repeat(auto-fit, minmax(160px, 1fr)); gap:8px;">
                            <button id="colorPrimitive" class="active" onclick="set3DColorMode('primitive')" style="padding:10px 12px; font-size:0.85em;">GCD=1 vs GCD>1</button>
                            <button id="colorGCD" onclick="set3DColorMode('gcd')" style="padding:10px 12px; font-size:0.85em;">By GCD Value</button>
                            <button id="colorMod" onclick="set3DColorMode('mod')" style="padding:10px 12px; font-size:0.85em;">By Mod m</button>
                            <button id="colorOctant" onclick="set3DColorMode('octant')" style="padding:10px 12px; font-size:0.85em;">By Octant</button>
                            <button id="colorDistance" onclick="set3DColorMode('distance')" style="padding:10px 12px; font-size:0.85em;">By Distance</button>
                            <button id="colorGCDOct" onclick="set3DColorMode('gcdoct')" style="padding:10px 12px; font-size:0.85em;">GCD × Octant</button>
                            <button id="colorGCDMod" onclick="set3DColorMode('gcdmod')" style="padding:10px 12px; font-size:0.85em;">GCD × Mod</button>
                        </div>
                        <div id="modControls3D" style="display:none; margin-top:10px;">
                            <label>Modulus m: <span id="mod3Dv">3</span></label>
                            <input type="range" id="mod3D" min="2" max="12" value="3" step="1" oninput="document.getElementById('mod3Dv').textContent=this.value; draw3D()">
                        </div>
                    </div>
                    
                    <div style="margin-bottom:10px;">
                        <label><b>Presets:</b></label>
                        <div style="display:flex; gap:8px; flex-wrap:wrap; margin-top:5px;">
                            <button onclick="set3DPreset('tiny')" style="padding:6px 12px; font-size:0.9em;">Tiny (R=5)</button>
                            <button onclick="set3DPreset('small')" style="padding:6px 12px; font-size:0.9em;">Small (R=10)</button>
                            <button onclick="set3DPreset('medium')" style="padding:6px 12px; font-size:0.9em;">Medium (R=20)</button>
                            <button onclick="set3DPreset('large')" style="padding:6px 12px; font-size:0.9em;">Large (R=30)</button>
                        </div>
                    </div>
                    <label>Radius: <span id="r3v">10</span></label>
                    <input type="range" id="r3" min="1" max="40" value="10" step="1" oninput="draw3D()">
                    
                    <label>Point Size: <span id="ps3v">0.6</span></label>
                    <input type="range" id="ps3" min="0.2" max="2.0" value="0.6" step="0.1" oninput="draw3D()">
                    
                    <button onclick="reset3D()">Reset View</button>
                    <button onclick="toggleRotation()">Auto-Rotate</button>
                    <button onclick="export3DData()">Export Points</button>
                </div>
                <div class="warning" id="warn3d" style="display:none;">
                    ⚠️ Radius > 30 generates many points and may impact performance.
                </div>
                <div class="loading" id="load3d"><div class="spinner"></div><p>Generating 3D lattice...</p></div>
                <div id="c3d" style="width:100%; height:800px;"></div>
                <div class="stats">
                    <div class="stat"><div class="val" id="p3">0</div><div class="lbl">Primitive Points</div></div>
                    <div class="stat"><div class="val" id="t3">0</div><div class="lbl">Total Points</div></div>
                    <div class="stat"><div class="val" id="d3">0%</div><div class="lbl">Density</div></div>
                    <div class="stat"><div class="val" id="e3">0</div><div class="lbl">Error</div></div>
                </div>
            </div>
        </div>

        <div id="comparison" class="panel">
            <div class="section">
                <h2>Dimension Comparison <span class="help-icon tooltip" data-tip="Compare different dimensions">?</span></h2>
                <p>Compare how primitive lattice point counts change across dimensions for a fixed radius, or analyze how different radii affect each dimension.</p>
                
                <div class="controls">
                    <label>Comparison Mode:</label>
                    <div style="display:flex; gap:10px; margin-bottom:15px; flex-wrap:wrap;">
                        <button id="modeFixed" class="active" onclick="setComparisonMode('fixed')" style="flex:1; min-width:150px;">Fixed Radius</button>
                        <button id="modeMulti" onclick="setComparisonMode('multi')" style="flex:1; min-width:150px;">Multiple Radii</button>
                    </div>
                    
                    <div style="margin-bottom:10px;">
                        <label><b>Presets:</b></label>
                        <div style="display:flex; gap:8px; flex-wrap:wrap; margin-top:5px;">
                            <button onclick="setComparisonPreset('low')" style="padding:6px 12px; font-size:0.9em;">Low Dimensions (2-4)</button>
                            <button onclick="setComparisonPreset('mid')" style="padding:6px 12px; font-size:0.9em;">Mid Dimensions (3-6)</button>
                            <button onclick="setComparisonPreset('high')" style="padding:6px 12px; font-size:0.9em;">High Dimensions (5-10)</button>
                            <button onclick="setComparisonPreset('all')" style="padding:6px 12px; font-size:0.9em;">All Dimensions (2-10)</button>
                            <button onclick="setComparisonPreset('growth')" style="padding:6px 12px; font-size:0.9em;">Growth Analysis</button>
                        </div>
                    </div>
                    
                    <div id="fixedRadiusControls">
                        <label>Radius: <span id="crv">15</span></label>
                        <div style="display:flex; gap:10px; align-items:center; margin-bottom:15px;">
                            <input type="range" id="cr" min="1" max="100" value="15" step="1" oninput="updateComparisonRadius(this.value)" style="flex:1;">
                            <input type="number" id="crinput" min="1" max="200" value="15" style="width:100px; padding:8px;" oninput="updateComparisonRadius(this.value)">
                        </div>
                    </div>
                    
                    <div id="multiRadiusControls" style="display:none;">
                        <label>Radii to compare (comma-separated): </label>
                        <input type="text" id="multiRadii" value="10, 20, 30, 40, 50" style="width:100%; padding:10px; margin-bottom:15px;" oninput="updateComparison()">
                    </div>
                    
                    <div style="margin-bottom:15px;">
                        <p><b>Dimensions to compare:</b></p>
                        <div style="display:grid; grid-template-columns: repeat(auto-fit, minmax(80px, 1fr)); gap:10px; margin-top:10px;">
                            <label style="display:flex; align-items:center; gap:8px;">
                                <input type="checkbox" id="compk2" checked onchange="updateComparison()"> k=2
                            </label>
                            <label style="display:flex; align-items:center; gap:8px;">
                                <input type="checkbox" id="compk3" checked onchange="updateComparison()"> k=3
                            </label>
                            <label style="display:flex; align-items:center; gap:8px;">
                                <input type="checkbox" id="compk4" checked onchange="updateComparison()"> k=4
                            </label>
                            <label style="display:flex; align-items:center; gap:8px;">
                                <input type="checkbox" id="compk5" checked onchange="updateComparison()"> k=5
                            </label>
                            <label style="display:flex; align-items:center; gap:8px;">
                                <input type="checkbox" id="compk6" checked onchange="updateComparison()"> k=6
                            </label>
                            <label style="display:flex; align-items:center; gap:8px;">
                                <input type="checkbox" id="compk7" onchange="updateComparison()"> k=7
                            </label>
                            <label style="display:flex; align-items:center; gap:8px;">
                                <input type="checkbox" id="compk8" onchange="updateComparison()"> k=8
                            </label>
                            <label style="display:flex; align-items:center; gap:8px;">
                                <input type="checkbox" id="compk9" onchange="updateComparison()"> k=9
                            </label>
                            <label style="display:flex; align-items:center; gap:8px;">
                                <input type="checkbox" id="compk10" onchange="updateComparison()"> k=10
                            </label>
                        </div>
                    </div>
                    
                    <div style="margin-bottom:15px;">
                        <p><b>Display options:</b></p>
                        <label style="display:flex; align-items:center; gap:8px; margin:8px 0;">
                            <input type="checkbox" id="showDensity" checked onchange="updateComparison()"> Show Density (1/ζ(k))
                        </label>
                        <label style="display:flex; align-items:center; gap:8px; margin:8px 0;">
                            <input type="checkbox" id="showVolume" checked onchange="updateComparison()"> Show Sphere Volume
                        </label>
                        <label style="display:flex; align-items:center; gap:8px; margin:8px 0;">
                            <input type="checkbox" id="showZeta" checked onchange="updateComparison()"> Show ζ(k) Values
                        </label>
                        <label style="display:flex; align-items:center; gap:8px; margin:8px 0;">
                            <input type="checkbox" id="showChart" checked onchange="updateComparison()"> Show Comparison Chart
                        </label>
                    </div>
                    
                    <button onclick="updateComparison()">Refresh Comparison</button>
                    <button onclick="exportComparisonData()">Export Data</button>
                    <button onclick="exportComparisonChart()">Export Chart</button>
                </div>
                
                <div class="compare-grid" id="compGrid"></div>
                
                <div id="comparisonChart" style="margin-top:30px;">
                    <canvas id="compChart" width="800" height="400"></canvas>
                </div>
                
                <div class="formula" style="margin-top:20px;">
                    <p><b>Key Observations:</b></p>
                    <p>• As dimension k increases, ζ(k) approaches 1, meaning the density 1/ζ(k) approaches 100%</p>
                    <p>• Higher dimensions have exponentially more lattice points (grows as R^k)</p>
                    <p>• The ratio of primitive to total points stabilizes at 1/ζ(k) for each dimension</p>
                    <p>• Sphere volume grows dramatically with dimension, following the gamma function pattern</p>
                </div>
            </div>
        </div>

        <div id="analysis" class="panel">
            <div class="section">
                <h2>Error Analysis <span class="help-icon tooltip" data-tip="Study O(R^(k-1)) error term">?</span></h2>
                <p>Visualization of the error term Δ(R) for different dimensions. The chart shows absolute and relative errors for each radius value.</p>
                <div class="controls">
                    <div style="margin-bottom:10px;">
                        <label><b>Presets:</b></label>
                        <div style="display:flex; gap:8px; flex-wrap:wrap; margin-top:5px;">
                            <button onclick="setAnalysisPreset('quick')" style="padding:6px 12px; font-size:0.9em;">Quick (R≤50)</button>
                            <button onclick="setAnalysisPreset('standard')" style="padding:6px 12px; font-size:0.9em;">Standard (R≤100)</button>
                            <button onclick="setAnalysisPreset('detailed')" style="padding:6px 12px; font-size:0.9em;">Detailed (R≤150)</button>
                            <button onclick="setAnalysisPreset('absolute')" style="padding:6px 12px; font-size:0.9em;">Absolute Only</button>
                            <button onclick="setAnalysisPreset('relative')" style="padding:6px 12px; font-size:0.9em;">Relative Only</button>
                            <button onclick="setAnalysisPreset('boundary')" style="padding:6px 12px; font-size:0.9em;">Boundary Only</button>
                        </div>
                    </div>
                    
                    <label>Dimension k: <span id="analysisKv">2</span></label>
                    <input type="range" id="analysisK" min="2" max="5" value="2" step="1" oninput="document.getElementById('analysisKv').textContent=this.value">
                    
                    <label>Max Radius: <span id="mrv">100</span></label>
                    <div style="display:flex; gap:10px; align-items:center; margin-bottom:10px;">
                        <input type="range" id="mr" min="10" max="200" value="100" step="5" oninput="updateAnalysisRadius(this.value)" style="flex:1;">
                        <input type="number" id="mrinput" min="10" max="300" value="100" step="5" style="width:100px; padding:8px;" oninput="updateAnalysisRadius(this.value)">
                    </div>
                    
                    <label>Start from Radius: <span id="minrv">1</span></label>
                    <input type="range" id="minr" min="1" max="50" value="1" step="1" oninput="document.getElementById('minrv').textContent=this.value">
                    
                    <div style="margin-top:20px;">
                        <label style="display:flex; align-items:center; gap:8px; margin:8px 0;">
                            <input type="checkbox" id="showAbsError" checked onchange="runAnalysis()"> Show Absolute Error
                        </label>
                        <label style="display:flex; align-items:center; gap:8px; margin:8px 0;">
                            <input type="checkbox" id="showRelError" checked onchange="runAnalysis()"> Show Relative Error (%)
                        </label>
                        <label style="display:flex; align-items:center; gap:8px; margin:8px 0;">
                            <input type="checkbox" id="showBoundary" onchange="runAnalysis()"> Show Theoretical Boundary R^(k-1)
                        </label>
                        <label style="display:flex; align-items:center; gap:8px; margin:8px 0;">
                            <input type="checkbox" id="showActualCount" onchange="runAnalysis()"> Show Actual Primitive Count
                        </label>
                    </div>
                    
                    <button onclick="runAnalysis()" style="margin-top:15px;">Compute Analysis</button>
                    <button onclick="exportChartData()">Export Chart Data</button>
                </div>
                <div class="loading" id="loadAnalysis"><div class="spinner"></div><p>Computing error analysis...</p></div>
                <canvas id="ch" width="1600" height="1000" style="max-width: 100%;"></canvas>
                <div class="formula" style="margin-top: 20px;">
                    <p><b>Error Bound Theory:</b></p>
                    <p>The error term O(R^(k-1)) arises from boundary effects. For k=2, the error is O(R), corresponding to points near the circle boundary. As k increases, the error term becomes relatively smaller compared to the main term R^k.</p>
                    <p style="margin-top:10px;"><b>Relative Error:</b> Shows |Predicted - Actual| / Predicted as a percentage. This decreases as R grows, confirming the asymptotic accuracy.</p>
                    <p style="margin-top:10px;"><b>Boundary Term:</b> The theoretical R^(k-1) term, showing the expected growth rate of the error.</p>
                </div>
            </div>
        </div>

        <div id="tools" class="panel">
            <div class="section">
                <h2>Mathematical Tools <span class="help-icon tooltip" data-tip="Number theory utilities">?</span></h2>
                
                <h3>GCD Calculator</h3>
                <div class="controls">
                    <div style="display:flex; gap:8px; margin-bottom:10px; flex-wrap:wrap;">
                        <button onclick="setGCDPreset('coprime')" style="padding:6px 12px; font-size:0.9em;">Coprime Example</button>
                        <button onclick="setGCDPreset('common')" style="padding:6px 12px; font-size:0.9em;">Common Factor</button>
                        <button onclick="setGCDPreset('large')" style="padding:6px 12px; font-size:0.9em;">Large Numbers</button>
                        <button onclick="setGCDPreset('many')" style="padding:6px 12px; font-size:0.9em;">Many Numbers</button>
                    </div>
                    <input type="text" id="gi" placeholder="12, 18, 24" style="width:100%; padding:10px">
                    <button onclick="calcGCD()">Calculate</button>
                    <div id="gr" style="margin-top:15px"></div>
                </div>

                <h3>Möbius Function μ(n)</h3>
                <div class="controls">
                    <div style="display:flex; gap:8px; margin-bottom:10px; flex-wrap:wrap;">
                        <button onclick="setMobiusPreset('squarefree')" style="padding:6px 12px; font-size:0.9em;">Square-free</button>
                        <button onclick="setMobiusPreset('notsquarefree')" style="padding:6px 12px; font-size:0.9em;">Not Square-free</button>
                        <button onclick="setMobiusPreset('prime')" style="padding:6px 12px; font-size:0.9em;">Prime Number</button>
                        <button onclick="setMobiusPreset('composite')" style="padding:6px 12px; font-size:0.9em;">Large Composite</button>
                    </div>
                    <input type="number" id="mi" placeholder="30" style="width:100%; padding:10px" min="1">
                    <button onclick="calcMobius()">Calculate</button>
                    <div id="mr2" style="margin-top:15px"></div>
                </div>

                <h3>Prime Factorization</h3>
                <div class="controls">
                    <div style="display:flex; gap:8px; margin-bottom:10px; flex-wrap:wrap;">
                        <button onclick="setPrimePreset('small')" style="padding:6px 12px; font-size:0.9em;">Small Number</button>
                        <button onclick="setPrimePreset('perfect')" style="padding:6px 12px; font-size:0.9em;">Perfect Number</button>
                        <button onclick="setPrimePreset('highly')" style="padding:6px 12px; font-size:0.9em;">Highly Composite</button>
                        <button onclick="setPrimePreset('large')" style="padding:6px 12px; font-size:0.9em;">Large Number</button>
                        <button onclick="setPrimePreset('power')" style="padding:6px 12px; font-size:0.9em;">Prime Power</button>
                    </div>
                    <input type="number" id="pi" placeholder="360" style="width:100%; padding:10px" min="2">
                    <button onclick="calcPrime()">Factorize</button>
                    <div id="pr" style="margin-top:15px"></div>
                </div>

                <h3>Coprimality Checker</h3>
                <div class="controls">
                    <div style="display:flex; gap:8px; margin-bottom:10px; flex-wrap:wrap;">
                        <button onclick="setCoprimePreset('coprime2')" style="padding:6px 12px; font-size:0.9em;">Coprime Pair</button>
                        <button onclick="setCoprimePreset('notcoprime2')" style="padding:6px 12px; font-size:0.9em;">Non-Coprime Pair</button>
                        <button onclick="setCoprimePreset('coprime3')" style="padding:6px 12px; font-size:0.9em;">Coprime Triple</button>
                        <button onclick="setCoprimePreset('consecutive')" style="padding:6px 12px; font-size:0.9em;">Consecutive Numbers</button>
                    </div>
                    <input type="text" id="cci" placeholder="15, 28" style="width:100%; padding:10px">
                    <button onclick="checkCoprime()">Check</button>
                    <div id="ccr" style="margin-top:15px"></div>
                </div>

                <h3>Point Search</h3>
                <div class="controls">
                    <div style="display:flex; gap:8px; margin-bottom:10px; flex-wrap:wrap;">
                        <button onclick="setPointPreset('pythagorean')" style="padding:6px 12px; font-size:0.9em;">Pythagorean Triple</button>
                        <button onclick="setPointPreset('primitive2d')" style="padding:6px 12px; font-size:0.9em;">Primitive 2D</button>
                        <button onclick="setPointPreset('nonprimitive2d')" style="padding:6px 12px; font-size:0.9em;">Non-Primitive 2D</button>
                        <button onclick="setPointPreset('primitive3d')" style="padding:6px 12px; font-size:0.9em;">Primitive 3D</button>
                        <button onclick="setPointPreset('highd')" style="padding:6px 12px; font-size:0.9em;">High-D Point</button>
                    </div>
                    <input type="text" id="psi" placeholder="3, 4 (finds if primitive)" style="width:100%; padding:10px">
                    <button onclick="searchPoint()">Search</button>
                    <div id="psr" style="margin-top:15px"></div>
                </div>
            </div>
        </div>

        <div id="derivation" class="panel">
            <div class="section">
                <h2>Interactive Derivation</h2>
                
                <h3>Step 1: Counting Lattice Points</h3>
                <p>Start with all lattice points in a k-dimensional sphere of radius R:</p>
                <div class="formula">$$L_k(R) = |\{(x_1,...,x_k) \in \mathbb{Z}^k : x_1^2 + ... + x_k^2 \leq R^2\}|$$</div>
                <p>Asymptotically, this equals the volume: L_k(R) ~ V_k R^k</p>

                <h3>Step 2: Separating by GCD</h3>
                <p>Partition points by their greatest common divisor d:</p>
                <div class="formula">$$L_k(R) = \sum_{d=1}^{R} N_k(R/d)$$</div>
                <p>Where N_k(R/d) counts primitive points in a sphere of radius R/d.</p>

                <h3>Step 3: Möbius Inversion</h3>
                <p>Inverting the previous relation using Möbius function:</p>
                <div class="formula">$$N_k(R) = \sum_{d=1}^{R} \mu(d) L_k(R/d)$$</div>
                
                <h3>Step 4: Asymptotic Expansion</h3>
                <p>Substituting L_k(R/d) ~ V_k (R/d)^k:</p>
                <div class="formula">$$N_k(R) = V_k R^k \sum_{d=1}^{\infty} \frac{\mu(d)}{d^k} + O(R^{k-1})$$</div>

                <h3>Step 5: Zeta Connection</h3>
                <p>The sum equals the reciprocal of the zeta function:</p>
                <div class="formula">$$\sum_{d=1}^{\infty} \frac{\mu(d)}{d^k} = \frac{1}{\zeta(k)}$$</div>
                
                <h3>Final Result</h3>
                <div class="formula">$$N_k(R) = \frac{V_k R^k}{\zeta(k)} + O(R^{k-1})$$</div>
                <p>This elegant formula connects geometry (V_k), analysis (ζ(k)), and number theory (primitive points)!</p>
                
                <div class="controls" style="margin-top: 30px;">
                    <button onclick="showDerivationAnimation()">Animate Derivation</button>
                </div>
            </div>
        </div>
    </div>

    <button class="btn-fixed" id="helpBtn" onclick="showHelp()">Help</button>
    <button class="btn-fixed" id="darkBtn" onclick="toggleDark()">Light Mode</button>

    <div class="modal" id="helpModal">
        <div class="modal-content">
            <span class="modal-close" onclick="closeHelp()">&times;</span>
            <h2>Platform Guide</h2>
            <h3>Navigation</h3>
            <p>Use the tabs to explore different aspects of primitive lattice points.</p>
            
            <h3>GCD Heatmap</h3>
            <p><b>Interactive Features:</b></p>
            <p>• Click on any point to see detailed GCD information</p>
            <p>• Three display modes: by GCD value, primitive only, or distance gradient</p>
            <p>• Filter points by specific GCD values (1, 2, 3, or >3)</p>
            <p>• View statistics for each GCD category</p>
            <p>• Export point data for further analysis</p>
            
            <h3>Critical Strip Projection</h3>
            <p><b>Riemann Hypothesis Connection:</b></p>
            <p>• Maps error term Δ(R) onto the complex plane</p>
            <p>• Critical line Re(s) = 1/2 shown in purple (where RH predicts all zeros)</p>
            <p>• Points colored by error magnitude or sign</p>
            <p>• Click on points to see detailed error information for that radius</p>
            <p>• Strip boundaries show the critical strip 0 < Re(s) < 1</p>
            <p>• Error oscillations reveal connections to zeta function zeros</p>
            
            <h3>2D Visualizations</h3>
            <p><b>View Modes:</b></p>
            <p>• <b>Colored by Mode:</b> Points colored according to selected coloring mode</p>
            <p>• <b>Gauss Circle Problem:</b> All lattice points in purple, comparing against πR²</p>
            
            <p style="margin-top:15px;"><b>Coloring Modes (2D):</b></p>
            <p>• <b>GCD=1 vs GCD>1:</b> Blue for primitive (coprime), red for non-primitive</p>
            <p>• <b>By GCD Value:</b> Different color for each GCD (1=blue, 2=red, 3=green, 4=yellow, etc.)</p>
            <p>• <b>By Mod m:</b> Colors based on (x+y) mod m - reveals modular patterns</p>
            <p>• <b>By Quadrant:</b> Four colors for four quadrants (I=blue, II=green, III=yellow, IV=red)</p>
            <p>• <b>By Angular Sector:</b> Rainbow colors dividing circle into sectors</p>
            <p>• <b>GCD × Quadrant:</b> Combined coloring showing both GCD structure and spatial position</p>
            <p>• <b>GCD × Mod:</b> Combined coloring revealing GCD and modular arithmetic patterns</p>
            
            <h3>3D Visualizations</h3>
            <p><b>Boundary Shapes:</b></p>
            <p>• Sphere: Points within distance R (x²+y²+z² ≤ R²)</p>
            <p>• Cube: Points within cube of side 2R (|x|,|y|,|z| ≤ R)</p>
            
            <p style="margin-top:15px;"><b>Coloring Modes (3D):</b></p>
            <p>• <b>GCD=1 vs GCD>1:</b> Blue for primitive, red for non-primitive</p>
            <p>• <b>By GCD Value:</b> Different colors for different GCD values</p>
            <p>• <b>By Mod m:</b> Colors based on (x+y+z) mod m</p>
            <p>• <b>By Octant:</b> Eight colors for eight octants in 3D space</p>
            <p>• <b>By Distance:</b> Gradient from center (blue) to boundary (red)</p>
            <p>• <b>GCD × Octant:</b> Combined coloring showing GCD and spatial structure</p>
            <p>• <b>GCD × Mod:</b> Combined GCD and modular arithmetic visualization</p>
            
            <p style="margin-top:10px;">Click and drag to rotate the view. Adjust point size for clarity.</p>
            
            <h3>Error Analysis</h3>
            <p>Shows error per radius value from start to max radius:</p>
            <p>• <b>Absolute Error:</b> |Predicted - Actual| count of points</p>
            <p>• <b>Relative Error:</b> Percentage error relative to prediction</p>
            <p>• <b>Boundary Term:</b> Theoretical R^(k-1) error bound</p>
            <p>• <b>Actual Count:</b> The true primitive point count at each radius</p>
            
            <h3>Performance Tips</h3>
            <p>• Keep radius ≤ 100 in 2D, ≤ 30 in 3D for smooth performance</p>
            <p>• Use Export buttons to save data and images</p>
            <p>• Compare mode shows multiple dimensions simultaneously</p>
            
            <h3>Tools Section</h3>
            <p>Calculate GCD, Möbius function, prime factorizations, and search for specific lattice points.</p>
        </div>
    </div>

    <script>
        let scene, camera, renderer, chart, autoRotate = false;
        const cache = { mobius: new Map(), gcd: new Map(), points2D: null, points3D: null };
        let mouseDown = false, prevMouse = { x: 0, y: 0 };
        let view2D = 'primitive'; // 'primitive' or 'gauss'
        let comparisonMode = 'fixed'; // 'fixed' or 'multi'
        let comparisonChart = null;
        let shape3D = 'sphere'; // 'sphere' or 'cube'
        let colorMode3D = 'primitive'; // 'primitive', 'gcd', 'mod', 'octant', 'distance', 'gcdoct', 'gcdmod'
        let colorMode2D = 'primitive'; // 'primitive', 'gcd', 'mod', 'quadrant', 'angular', 'gcdquad', 'gcdmod'
        let patternType = 'modular'; // 'modular', 'density', 'angular', 'radial'
        let patternChart = null;
        let heatmapMode = 'gcd'; // 'gcd', 'primitive', 'gradient'
        let heatmapPointsData = [];

        function gcd(a, b) {
            a = Math.abs(a); b = Math.abs(b);
            while (b) [a, b] = [b, a % b];
            return a;
        }

        function gcdArray(arr) { return arr.reduce((a, b) => gcd(a, b)); }

        function isPrime(n) {
            if (n < 2) return false;
            if (n === 2) return true;
            if (n % 2 === 0) return false;
            for (let i = 3; i <= Math.sqrt(n); i += 2)
                if (n % i === 0) return false;
            return true;
        }

        function primeFactors(n) {
            const f = []; let d = 2;
            while (n > 1) {
                while (n % d === 0) { f.push(d); n /= d; }
                d++; if (d * d > n && n > 1) { f.push(n); break; }
            }
            return f;
        }

        function mobius(n) {
            if (cache.mobius.has(n)) return cache.mobius.get(n);
            if (n === 1) return 1;
            const f = primeFactors(n), u = [...new Set(f)];
            const r = f.length !== u.length ? 0 : Math.pow(-1, f.length);
            cache.mobius.set(n, r);
            return r;
        }

        function zeta(k) {
            const z = { 2: Math.PI**2/6, 3: 1.2020569, 4: Math.PI**4/90, 5: 1.0369278, 6: Math.PI**6/945, 
                       7: 1.0083493, 8: Math.PI**8/9450, 9: 1.00200839, 10: 1.00099457, 11: 1.00049419, 12: 1.00024608 };
            return z[k] || 1 + 2**-k;
        }

        function sphereVolume(k, R) {
            const gamma = k % 2 === 0 ? 
                Math.PI**(k/2) / factorial(k/2) : 
                2 * factorial((k-1)/2) * Math.PI**((k-1)/2) / factorial(k);
            return gamma * R**k;
        }

        function factorial(n) {
            if (n <= 1) return 1;
            let res = 1;
            for (let i = 2; i <= n; i++) res *= i;
            return res;
        }

        function animateValue(id, start, end, duration = 500) {
            const el = document.getElementById(id);
            const range = end - start;
            const increment = range / (duration / 16);
            let current = start;
            const timer = setInterval(() => {
                current += increment;
                if ((increment > 0 && current >= end) || (increment < 0 && current <= end)) {
                    el.textContent = typeof end === 'number' && end % 1 !== 0 ? end.toFixed(3) : Math.round(end).toLocaleString();
                    clearInterval(timer);
                } else {
                    el.textContent = typeof current === 'number' && current % 1 !== 0 ? current.toFixed(3) : Math.round(current).toLocaleString();
                }
            }, 16);
        }

        function showTab(id) {
            document.querySelectorAll('.panel').forEach(p => p.classList.remove('active'));
            document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
            document.getElementById(id).classList.add('active');
            event.target.classList.add('active');
            if (id === 'viz2d') draw2D();
            if (id === 'viz3d' && !scene) init3D();
            if (id === 'comparison') updateComparison();
            if (id === 'patterns') {
                setPatternType('modular');
                updatePatternViz();
            }
            if (id === 'gcdheatmap') {
                updateGCDHeatmap();
            }
            if (id === 'criticalstrip') {
                updateCriticalStrip();
            }
        }

        function updateTheory() {
            const k = parseInt(document.getElementById('tks').value);
            const R = parseInt(document.getElementById('trs').value);
            document.getElementById('tk').textContent = k;
            document.getElementById('tr').textContent = R;
            const z = zeta(k), d = 1/z;
            const vol = sphereVolume(k, R);
            const pred = Math.round(vol / z);
            
            animateValue('sz', parseFloat(document.getElementById('sz').textContent) || z, z);
            animateValue('sd', parseFloat(document.getElementById('sd').textContent) || d, d);
            animateValue('sp', parseInt(document.getElementById('sp').textContent.replace(/,/g, '')) || pred, pred);
            animateValue('svol', parseFloat(document.getElementById('svol').textContent) || vol, vol);
        }

        function set2DView(mode) {
            view2D = mode;
            document.querySelectorAll('#viewPrimitive, #viewGauss').forEach(btn => btn.classList.remove('active'));
            document.getElementById(mode === 'primitive' ? 'viewPrimitive' : 'viewGauss').classList.add('active');
            draw2D();
        }

        function set2DColorMode(mode) {
            colorMode2D = mode;
            document.querySelectorAll('#color2DPrimitive, #color2DGCD, #color2DMod, #color2DQuadrant, #color2DAngular, #color2DGCDQuad, #color2DGCDMod').forEach(btn => btn.classList.remove('active'));
            const btnIds = {
                'primitive': 'color2DPrimitive',
                'gcd': 'color2DGCD',
                'mod': 'color2DMod',
                'quadrant': 'color2DQuadrant',
                'angular': 'color2DAngular',
                'gcdquad': 'color2DGCDQuad',
                'gcdmod': 'color2DGCDMod'
            };
            document.getElementById(btnIds[mode]).classList.add('active');
            
            // Show/hide modulus controls
            document.getElementById('modControls2D').style.display = (mode === 'mod' || mode === 'gcdmod') ? 'block' : 'none';
            document.getElementById('sectorControls2D').style.display = (mode === 'angular') ? 'block' : 'none';
            
            draw2D();
        }

        function update2DRadius(value) {
            const R = parseInt(value);
            if (R < 1 || R > 1000 || isNaN(R)) return;
            
            document.getElementById('r2v').textContent = R;
            document.getElementById('r2').value = Math.min(R, 500);
            document.getElementById('r2input').value = R;
            
            // Show performance warning
            document.getElementById('warn2d').style.display = R > 200 ? 'block' : 'none';
            
            draw2D();
        }

        function draw2D() {
            const canvas = document.getElementById('c2d'), ctx = canvas.getContext('2d');
            const R = parseInt(document.getElementById('r2input').value);
            const sz = parseInt(document.getElementById('ps').value);
            document.getElementById('r2v').textContent = R;
            document.getElementById('psv').textContent = sz;
            
            document.getElementById('warn2d').style.display = R > 200 ? 'block' : 'none';
            if (R > 250) {
                document.getElementById('load2d').classList.add('active');
            }
            
            setTimeout(() => {
                ctx.clearRect(0, 0, 1200, 1200);
                const cx = 600, cy = 600, sc = 550/R;
                ctx.strokeStyle = getComputedStyle(document.body).getPropertyValue('--border');
                ctx.lineWidth = 2;
                ctx.beginPath(); ctx.arc(cx, cy, R*sc, 0, 2*Math.PI); ctx.stroke();
                
                const allPoints = [];
                let prim = 0, tot = 0;
                
                // Collect all points with properties
                for (let x = -R; x <= R; x++) {
                    for (let y = -R; y <= R; y++) {
                        if (x*x + y*y <= R*R) {
                            tot++;
                            const g = gcd(Math.abs(x), Math.abs(y));
                            const isPrimitive = g === 1;
                            if (isPrimitive) prim++;
                            
                            // Calculate quadrant
                            let quadrant;
                            if (x >= 0 && y >= 0) quadrant = 1;
                            else if (x < 0 && y >= 0) quadrant = 2;
                            else if (x < 0 && y < 0) quadrant = 3;
                            else quadrant = 4;
                            
                            // Calculate angle (0 to 2π)
                            const angle = Math.atan2(y, x) + Math.PI; // 0 to 2π
                            
                            allPoints.push({
                                x, y, gcd: g, isPrimitive, quadrant, angle,
                                sum: x + y
                            });
                        }
                    }
                }
                
                // Group points by color based on mode
                const pointsByColor = {};
                const modulus = parseInt(document.getElementById('mod2D').value);
                const numSectors = parseInt(document.getElementById('sectors2D').value);
                
                allPoints.forEach(pt => {
                    let colorKey;
                    
                    if (view2D === 'gauss') {
                        colorKey = 'all';
                    } else {
                        switch(colorMode2D) {
                            case 'primitive':
                                colorKey = pt.isPrimitive ? 'prim' : 'nonprim';
                                break;
                            case 'gcd':
                                colorKey = `gcd${Math.min(pt.gcd, 8)}`;
                                break;
                            case 'mod':
                                colorKey = `mod${((pt.x + pt.y) % modulus + modulus) % modulus}`;
                                break;
                            case 'quadrant':
                                colorKey = `quad${pt.quadrant}`;
                                break;
                            case 'angular':
                                const sector = Math.floor(pt.angle / (2 * Math.PI / numSectors));
                                colorKey = `sector${sector}`;
                                break;
                            case 'gcdquad':
                                colorKey = `gcd${Math.min(pt.gcd, 4)}_q${pt.quadrant}`;
                                break;
                            case 'gcdmod':
                                const modVal = ((pt.x + pt.y) % modulus + modulus) % modulus;
                                colorKey = `gcd${Math.min(pt.gcd, 4)}_m${modVal}`;
                                break;
                        }
                    }
                    
                    if (!pointsByColor[colorKey]) pointsByColor[colorKey] = [];
                    pointsByColor[colorKey].push(pt);
                });
                
                // Define color palettes
                const colors = {
                    all: '#6f42c1',
                    prim: '#0066cc',
                    nonprim: '#dc3545',
                    gcd1: '#0066cc', gcd2: '#dc3545', gcd3: '#28a745', gcd4: '#ffc107',
                    gcd5: '#6f42c1', gcd6: '#fd7e14', gcd7: '#00d4ff', gcd8: '#ff006e',
                    quad1: '#0066cc', quad2: '#28a745', quad3: '#ffc107', quad4: '#dc3545',
                    mod0: '#0066cc', mod1: '#dc3545', mod2: '#28a745', mod3: '#ffc107',
                    mod4: '#6f42c1', mod5: '#fd7e14', mod6: '#00d4ff', mod7: '#ff006e',
                    mod8: '#20c997', mod9: '#e83e8c', mod10: '#17a2b8', mod11: '#6610f2'
                };
                
                // Generate sector colors (rainbow)
                for (let i = 0; i < 16; i++) {
                    const hue = (i / 16) * 360;
                    colors[`sector${i}`] = `hsl(${hue}, 70%, 50%)`;
                }
                
                // Generate combined colors
                const baseColors = ['#0066cc', '#dc3545', '#28a745', '#ffc107'];
                for (let g = 1; g <= 4; g++) {
                    for (let q = 1; q <= 4; q++) {
                        colors[`gcd${g}_q${q}`] = baseColors[(g - 1 + q - 1) % 4];
                    }
                    for (let m = 0; m < 12; m++) {
                        const hue = ((g - 1) * 90 + m * 30) % 360;
                        colors[`gcd${g}_m${m}`] = `hsl(${hue}, 65%, 50%)`;
                    }
                }
                
                // Draw points
                Object.entries(pointsByColor).forEach(([colorKey, points]) => {
                    ctx.fillStyle = colors[colorKey] || '#999';
                    points.forEach(pt => {
                        ctx.beginPath();
                        ctx.arc(cx + pt.x*sc, cy - pt.y*sc, sz, 0, 2*Math.PI);
                        ctx.fill();
                    });
                });
                
                cache.points2D = { primitive: allPoints.filter(p => p.isPrimitive), 
                                   nonPrimitive: allPoints.filter(p => !p.isPrimitive), R };
                
                const pred = Math.round(Math.PI * R * R / zeta(2));
                const error = Math.abs(pred - prim);
                
                // Update stats based on view mode
                if (view2D === 'gauss') {
                    document.getElementById('p2').parentElement.querySelector('.lbl').textContent = 'Total Lattice Points';
                    animateValue('p2', 0, tot);
                    document.getElementById('t2').parentElement.querySelector('.lbl').textContent = 'Expected (πR²)';
                    animateValue('t2', 0, Math.round(Math.PI * R * R));
                    document.getElementById('d2').parentElement.querySelector('.lbl').textContent = 'Error';
                    document.getElementById('d2').textContent = Math.abs(tot - Math.PI * R * R).toFixed(1);
                    document.getElementById('e2').parentElement.querySelector('.lbl').textContent = '% of Expected';
                    document.getElementById('e2').textContent = ((tot / (Math.PI * R * R)) * 100).toFixed(2) + '%';
                } else {
                    document.getElementById('p2').parentElement.querySelector('.lbl').textContent = 'Primitive Points';
                    animateValue('p2', 0, prim);
                    document.getElementById('t2').parentElement.querySelector('.lbl').textContent = 'Total Points';
                    animateValue('t2', 0, tot);
                    document.getElementById('d2').parentElement.querySelector('.lbl').textContent = 'Density';
                    document.getElementById('d2').textContent = ((prim/tot)*100).toFixed(1) + '%';
                    document.getElementById('e2').parentElement.querySelector('.lbl').textContent = '|Predicted - Actual|';
                    animateValue('e2', 0, error);
                }
                
                document.getElementById('load2d').classList.remove('active');
            }, 100);
        }

        function init3D() {
            const c = document.getElementById('c3d');
            scene = new THREE.Scene();
            scene.background = new THREE.Color(document.body.classList.contains('light') ? 0xffffff : 0x1a1a1a);
            camera = new THREE.PerspectiveCamera(75, c.clientWidth/800, 0.1, 1000);
            camera.position.set(50, 50, 50);
            camera.lookAt(0, 0, 0);
            renderer = new THREE.WebGLRenderer({ antialias: true, preserveDrawingBuffer: true });
            renderer.setSize(c.clientWidth, 800);
            c.appendChild(renderer.domElement);
            
            const light1 = new THREE.AmbientLight(0xffffff, 0.6);
            const light2 = new THREE.DirectionalLight(0xffffff, 0.4);
            light2.position.set(1, 1, 1);
            scene.add(light1, light2);
            
            const axes = new THREE.AxesHelper(35);
            scene.add(axes);
            
            const canvas = renderer.domElement;
            canvas.addEventListener('mousedown', e => {
                mouseDown = true;
                prevMouse = { x: e.clientX, y: e.clientY };
            });
            canvas.addEventListener('mousemove', e => {
                if (mouseDown && !autoRotate) {
                    const dx = e.clientX - prevMouse.x;
                    const dy = e.clientY - prevMouse.y;
                    const rotSpeed = 0.005;
                    camera.position.applyAxisAngle(new THREE.Vector3(0, 1, 0), dx * rotSpeed);
                    const right = new THREE.Vector3(1, 0, 0).applyQuaternion(camera.quaternion);
                    camera.position.applyAxisAngle(right, dy * rotSpeed);
                    camera.lookAt(0, 0, 0);
                    prevMouse = { x: e.clientX, y: e.clientY };
                }
            });
            canvas.addEventListener('mouseup', () => mouseDown = false);
            canvas.addEventListener('mouseleave', () => mouseDown = false);
            
            draw3D();
            animate3D();
        }

        function set3DShape(shape) {
            shape3D = shape;
            document.querySelectorAll('#shape3DSphere, #shape3DCube').forEach(btn => btn.classList.remove('active'));
            document.getElementById(shape === 'sphere' ? 'shape3DSphere' : 'shape3DCube').classList.add('active');
            draw3D();
        }

        function set3DColorMode(mode) {
            colorMode3D = mode;
            document.querySelectorAll('#colorPrimitive, #colorGCD, #colorMod, #colorOctant, #colorDistance, #colorGCDOct, #colorGCDMod').forEach(btn => btn.classList.remove('active'));
            const btnIds = {
                'primitive': 'colorPrimitive',
                'gcd': 'colorGCD',
                'mod': 'colorMod',
                'octant': 'colorOctant',
                'distance': 'colorDistance',
                'gcdoct': 'colorGCDOct',
                'gcdmod': 'colorGCDMod'
            };
            document.getElementById(btnIds[mode]).classList.add('active');
            
            // Show/hide modulus controls
            document.getElementById('modControls3D').style.display = (mode === 'mod' || mode === 'gcdmod') ? 'block' : 'none';
            
            draw3D();
        }

        function draw3D() {
            if (!scene) return;
            while(scene.children.length > 3) scene.remove(scene.children[3]);
            
            const R = parseInt(document.getElementById('r3').value);
            const pointSize = parseFloat(document.getElementById('ps3').value);
            document.getElementById('r3v').textContent = R;
            document.getElementById('ps3v').textContent = pointSize;
            document.getElementById('warn3d').style.display = R > 30 ? 'block' : 'none';
            
            if (R > 25) document.getElementById('load3d').classList.add('active');
            
            setTimeout(() => {
                // Add boundary shape
                if (shape3D === 'sphere') {
                    const sg = new THREE.SphereGeometry(R, 32, 32);
                    const sm = new THREE.MeshBasicMaterial({ 
                        color: 0x6f42c1, wireframe: true, transparent: true, opacity: 0.15 
                    });
                    scene.add(new THREE.Mesh(sg, sm));
                } else {
                    const boxGeometry = new THREE.BoxGeometry(2*R, 2*R, 2*R);
                    const edges = new THREE.EdgesGeometry(boxGeometry);
                    const line = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ 
                        color: 0x6f42c1, transparent: true, opacity: 0.3 
                    }));
                    scene.add(line);
                }
                
                // Collect all points with their properties
                const allPoints = [];
                let prim = 0, tot = 0;
                const modulus = parseInt(document.getElementById('mod3D').value);
                
                for (let x = -R; x <= R; x++) {
                    for (let y = -R; y <= R; y++) {
                        for (let z = -R; z <= R; z++) {
                            const distSq = x*x + y*y + z*z;
                            const inBounds = shape3D === 'sphere' ? 
                                (distSq <= R*R) : 
                                (Math.abs(x) <= R && Math.abs(y) <= R && Math.abs(z) <= R);
                            
                            if (inBounds) {
                                tot++;
                                const g = gcdArray([Math.abs(x), Math.abs(y), Math.abs(z)]);
                                const isPrimitive = g === 1;
                                if (isPrimitive) prim++;
                                
                                // Determine octant (1-8)
                                let octant = 1;
                                if (x >= 0 && y >= 0 && z >= 0) octant = 1;
                                else if (x < 0 && y >= 0 && z >= 0) octant = 2;
                                else if (x < 0 && y < 0 && z >= 0) octant = 3;
                                else if (x >= 0 && y < 0 && z >= 0) octant = 4;
                                else if (x >= 0 && y >= 0 && z < 0) octant = 5;
                                else if (x < 0 && y >= 0 && z < 0) octant = 6;
                                else if (x < 0 && y < 0 && z < 0) octant = 7;
                                else octant = 8;
                                
                                allPoints.push({
                                    x, y, z,
                                    gcd: g,
                                    isPrimitive,
                                    distance: Math.sqrt(distSq),
                                    sum: x + y + z,
                                    octant
                                });
                            }
                        }
                    }
                }
                
                cache.points3D = { 
                    primitive: allPoints.filter(p => p.isPrimitive),
                    nonPrimitive: allPoints.filter(p => !p.isPrimitive),
                    R 
                };
                
                // Color points based on mode
                const pointsByColor = {};
                
                allPoints.forEach(pt => {
                    let colorKey;
                    
                    switch(colorMode3D) {
                        case 'primitive':
                            colorKey = pt.isPrimitive ? 'prim' : 'nonprim';
                            break;
                        case 'gcd':
                            colorKey = `gcd${Math.min(pt.gcd, 8)}`;
                            break;
                        case 'mod':
                            colorKey = `mod${((pt.sum % modulus) + modulus) % modulus}`;
                            break;
                        case 'octant':
                            colorKey = `oct${pt.octant}`;
                            break;
                        case 'distance':
                            const distBucket = Math.floor(pt.distance / (R / 5));
                            colorKey = `dist${Math.min(distBucket, 5)}`;
                            break;
                        case 'gcdoct':
                            colorKey = `gcd${Math.min(pt.gcd, 4)}_oct${pt.octant}`;
                            break;
                        case 'gcdmod':
                            const modVal = ((pt.sum % modulus) + modulus) % modulus;
                            colorKey = `gcd${Math.min(pt.gcd, 4)}_m${modVal}`;
                            break;
                    }
                    
                    if (!pointsByColor[colorKey]) pointsByColor[colorKey] = [];
                    pointsByColor[colorKey].push(pt.x, pt.y, pt.z);
                });
                
                // Define color schemes
                const colorMap = {
                    prim: 0x0066cc,
                    nonprim: 0xdc3545,
                    gcd1: 0x0066cc, gcd2: 0xdc3545, gcd3: 0x28a745, gcd4: 0xffc107,
                    gcd5: 0x6f42c1, gcd6: 0xfd7e14, gcd7: 0x00d4ff, gcd8: 0xff006e,
                    oct1: 0x0066cc, oct2: 0xdc3545, oct3: 0x28a745, oct4: 0xffc107,
                    oct5: 0x6f42c1, oct6: 0xfd7e14, oct7: 0x00d4ff, oct8: 0xff006e,
                    dist0: 0x0066cc, dist1: 0x00d4ff, dist2: 0x28a745, 
                    dist3: 0xffc107, dist4: 0xfd7e14, dist5: 0xdc3545,
                    mod0: 0x0066cc, mod1: 0xdc3545, mod2: 0x28a745, mod3: 0xffc107,
                    mod4: 0x6f42c1, mod5: 0xfd7e14, mod6: 0x00d4ff, mod7: 0xff006e,
                    mod8: 0x20c997, mod9: 0xe83e8c, mod10: 0x17a2b8, mod11: 0x6610f2
                };
                
                // Generate combined colors
                const baseColors = [0x0066cc, 0xdc3545, 0x28a745, 0xffc107, 0x6f42c1, 0xfd7e14, 0x00d4ff, 0xff006e];
                for (let g = 1; g <= 4; g++) {
                    for (let o = 1; o <= 8; o++) {
                        colorMap[`gcd${g}_oct${o}`] = baseColors[(g - 1 + o - 1) % 8];
                    }
                    for (let m = 0; m < 12; m++) {
                        colorMap[`gcd${g}_m${m}`] = baseColors[(g - 1 + m) % 8];
                    }
                }
                
                // Create point groups
                Object.entries(pointsByColor).forEach(([colorKey, positions]) => {
                    if (positions.length > 0) {
                        const geometry = new THREE.BufferGeometry();
                        geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
                        
                        const color = colorMap[colorKey] || 0x999999;
                        const material = new THREE.PointsMaterial({ color, size: pointSize });
                        scene.add(new THREE.Points(geometry, material));
                    }
                });
                
                const pred = Math.round(4 * Math.PI * R**3 / (3 * zeta(3)));
                const error = Math.abs(pred - prim);
                
                animateValue('p3', 0, prim);
                animateValue('t3', 0, tot);
                document.getElementById('d3').textContent = ((prim/tot)*100).toFixed(1) + '%';
                animateValue('e3', 0, error);
                
                document.getElementById('load3d').classList.remove('active');
            }, 100);
        }

        function animate3D() {
            requestAnimationFrame(animate3D);
            if (renderer && scene && camera) {
                if (autoRotate) {
                    camera.position.applyAxisAngle(new THREE.Vector3(0, 1, 0), 0.005);
                    camera.lookAt(0, 0, 0);
                }
                renderer.render(scene, camera);
            }
        }

        function reset3D() {
            if (camera) { 
                camera.position.set(50, 50, 50); 
                camera.lookAt(0, 0, 0); 
            }
        }

        function toggleRotation() {
            autoRotate = !autoRotate;
            event.target.textContent = autoRotate ? 'Stop Rotation' : 'Auto-Rotate';
        }

        function setComparisonMode(mode) {
            comparisonMode = mode;
            document.querySelectorAll('#modeFixed, #modeMulti').forEach(btn => btn.classList.remove('active'));
            document.getElementById(mode === 'fixed' ? 'modeFixed' : 'modeMulti').classList.add('active');
            
            if (mode === 'fixed') {
                document.getElementById('fixedRadiusControls').style.display = 'block';
                document.getElementById('multiRadiusControls').style.display = 'none';
            } else {
                document.getElementById('fixedRadiusControls').style.display = 'none';
                document.getElementById('multiRadiusControls').style.display = 'block';
            }
            updateComparison();
        }

        function updateComparisonRadius(value) {
            const R = parseInt(value);
            if (R < 1 || R > 200 || isNaN(R)) return;
            
            document.getElementById('crv').textContent = R;
            document.getElementById('cr').value = Math.min(R, 100);
            document.getElementById('crinput').value = R;
            updateComparison();
        }

        function updateComparison() {
            const grid = document.getElementById('compGrid');
            const showDensity = document.getElementById('showDensity').checked;
            const showVolume = document.getElementById('showVolume').checked;
            const showZeta = document.getElementById('showZeta').checked;
            const showChart = document.getElementById('showChart').checked;
            
            const dims = [];
            for (let k = 2; k <= 10; k++) {
                if (document.getElementById(`compk${k}`)?.checked) dims.push(k);
            }
            
            if (dims.length === 0) {
                grid.innerHTML = '<p style="color:var(--red);">Please select at least one dimension</p>';
                return;
            }
            
            grid.innerHTML = '';
            
            if (comparisonMode === 'fixed') {
                const R = parseInt(document.getElementById('crinput').value);
                
                dims.forEach(k => {
                    const z = zeta(k);
                    const vol = sphereVolume(k, R);
                    const pred = Math.round(vol / z);
                    const density = (1/z * 100).toFixed(2);
                    
                    let content = `
                        <div class="compare-item">
                            <h3 style="color:var(--blue); margin-bottom:15px;">Dimension k = ${k}</h3>
                            <div style="background:var(--bg); padding:10px; border-radius:6px; margin-bottom:10px;">
                                <p style="font-size:1.1em;"><b>Predicted Points:</b> ${pred.toLocaleString()}</p>
                            </div>
                    `;
                    
                    if (showZeta) {
                        content += `
                            <div style="background:var(--bg); padding:10px; border-radius:6px; margin-bottom:10px;">
                                <p><b>ζ(${k}):</b> ${z.toFixed(6)}</p>
                            </div>
                        `;
                    }
                    
                    if (showDensity) {
                        content += `
                            <div style="background:var(--bg); padding:10px; border-radius:6px; margin-bottom:10px;">
                                <p><b>Primitive Density:</b> ${density}%</p>
                                <p style="font-size:0.9em; color:var(--text2);">1/ζ(${k}) = ${(1/z).toFixed(6)}</p>
                            </div>
                        `;
                    }
                    
                    if (showVolume) {
                        content += `
                            <div style="background:var(--bg); padding:10px; border-radius:6px; margin-bottom:10px;">
                                <p><b>Sphere Volume:</b></p>
                                <p style="font-size:0.95em;">${vol.toExponential(4)}</p>
                            </div>
                        `;
                    }
                    
                    // Add growth rate info
                    content += `
                        <div style="background:var(--bg); padding:10px; border-radius:6px; margin-bottom:10px;">
                            <p><b>Growth Rate:</b> O(R^${k})</p>
                            <p style="font-size:0.9em; color:var(--text2);">Error: O(R^${k-1})</p>
                        </div>
                    `;
                    
                    content += `</div>`;
                    grid.innerHTML += content;
                });
            } else {
                // Multiple radii mode
                const radiiStr = document.getElementById('multiRadii').value;
                const radii = radiiStr.split(',').map(r => parseInt(r.trim())).filter(r => !isNaN(r) && r > 0);
                
                if (radii.length === 0) {
                    grid.innerHTML = '<p style="color:var(--red);">Please enter valid radii (e.g., 10, 20, 30)</p>';
                    return;
                }
                
                dims.forEach(k => {
                    let content = `
                        <div class="compare-item">
                            <h3 style="color:var(--blue); margin-bottom:15px;">Dimension k = ${k}</h3>
                    `;
                    
                    if (showZeta) {
                        const z = zeta(k);
                        content += `
                            <div style="background:var(--bg); padding:10px; border-radius:6px; margin-bottom:10px;">
                                <p><b>ζ(${k}):</b> ${z.toFixed(6)}</p>
                                <p><b>Density:</b> ${((1/z)*100).toFixed(2)}%</p>
                            </div>
                        `;
                    }
                    
                    content += '<table style="width:100%; font-size:0.9em;"><thead><tr><th>R</th><th>Predicted</th>';
                    if (showVolume) content += '<th>Volume</th>';
                    content += '</tr></thead><tbody>';
                    
                    radii.forEach(R => {
                        const vol = sphereVolume(k, R);
                        const pred = Math.round(vol / zeta(k));
                        content += `<tr><td>${R}</td><td>${pred.toLocaleString()}</td>`;
                        if (showVolume) content += `<td>${vol.toExponential(2)}</td>`;
                        content += '</tr>';
                    });
                    
                    content += '</tbody></table></div>';
                    grid.innerHTML += content;
                });
            }
            
            // Update chart
            if (showChart) {
                document.getElementById('comparisonChart').style.display = 'block';
                updateComparisonChart(dims);
            } else {
                document.getElementById('comparisonChart').style.display = 'none';
            }
        }

        function updateComparisonChart(dims) {
            const canvas = document.getElementById('compChart');
            const ctx = canvas.getContext('2d');
            
            if (comparisonChart) comparisonChart.destroy();
            
            const colors = ['#0066cc', '#ffc107', '#00d4ff', '#ff006e', '#28a745', '#6f42c1', '#fd7e14', '#dc3545', '#20c997'];
            
            if (comparisonMode === 'fixed') {
                const R = parseInt(document.getElementById('crinput').value);
                
                const data = dims.map(k => {
                    const vol = sphereVolume(k, R);
                    return Math.round(vol / zeta(k));
                });
                
                comparisonChart = new Chart(ctx, {
                    type: 'bar',
                    data: {
                        labels: dims.map(k => `k=${k}`),
                        datasets: [{
                            label: `Primitive Points (R=${R})`,
                            data: data,
                            backgroundColor: dims.map((k, i) => colors[i % colors.length]),
                            borderColor: dims.map((k, i) => colors[i % colors.length]),
                            borderWidth: 2
                        }]
                    },
                    options: {
                        responsive: true,
                        scales: {
                            y: {
                                type: 'logarithmic',
                                title: { display: true, text: 'Number of Primitive Points', font: { size: 14 } }
                            },
                            x: {
                                title: { display: true, text: 'Dimension', font: { size: 14 } }
                            }
                        },
                        plugins: {
                            title: {
                                display: true,
                                text: `Primitive Lattice Points Across Dimensions (R=${R})`,
                                font: { size: 16, weight: 'bold' }
                            },
                            legend: { display: true }
                        }
                    }
                });
            } else {
                // Multiple radii - show lines
                const radiiStr = document.getElementById('multiRadii').value;
                const radii = radiiStr.split(',').map(r => parseInt(r.trim())).filter(r => !isNaN(r) && r > 0);
                
                const datasets = dims.map((k, i) => {
                    const data = radii.map(R => {
                        const vol = sphereVolume(k, R);
                        return { x: R, y: Math.round(vol / zeta(k)) };
                    });
                    
                    return {
                        label: `k=${k}`,
                        data: data,
                        borderColor: colors[i % colors.length],
                        backgroundColor: colors[i % colors.length] + '33',
                        borderWidth: 2,
                        tension: 0.1,
                        fill: false
                    };
                });
                
                comparisonChart = new Chart(ctx, {
                    type: 'line',
                    data: { datasets },
                    options: {
                        responsive: true,
                        scales: {
                            y: {
                                type: 'logarithmic',
                                title: { display: true, text: 'Number of Primitive Points', font: { size: 14 } }
                            },
                            x: {
                                title: { display: true, text: 'Radius R', font: { size: 14 } }
                            }
                        },
                        plugins: {
                            title: {
                                display: true,
                                text: 'Primitive Lattice Points Growth Across Dimensions',
                                font: { size: 16, weight: 'bold' }
                            },
                            legend: { display: true }
                        }
                    }
                });
            }
        }

        function exportComparisonChart() {
            if (!comparisonChart) {
                alert('Please generate a comparison chart first');
                return;
            }
            exportCanvas('compChart', 'dimension-comparison-chart');
        }

        function updateComparison() {
            const grid = document.getElementById('compGrid');
            const showDensity = document.getElementById('showDensity').checked;
            const showVolume = document.getElementById('showVolume').checked;
            const showZeta = document.getElementById('showZeta').checked;
            const showChart = document.getElementById('showChart').checked;
            
            const dims = [];
            for (let k = 2; k <= 10; k++) {
                if (document.getElementById(`compk${k}`)?.checked) dims.push(k);
            }
            
            if (dims.length === 0) {
                grid.innerHTML = '<p style="color:var(--red);">Please select at least one dimension</p>';
                return;
            }
            
            grid.innerHTML = '';
            
            if (comparisonMode === 'fixed') {
                const R = parseInt(document.getElementById('crinput').value);
                
                dims.forEach(k => {
                    const z = zeta(k);
                    const vol = sphereVolume(k, R);
                    const pred = Math.round(vol / z);
                    const density = (1/z * 100).toFixed(2);
                    
                    let content = `
                        <div class="compare-item">
                            <h3 style="color:var(--blue); margin-bottom:15px;">Dimension k = ${k}</h3>
                            <div style="background:var(--bg); padding:10px; border-radius:6px; margin-bottom:10px;">
                                <p style="font-size:1.1em;"><b>Predicted Points:</b> ${pred.toLocaleString()}</p>
                            </div>
                    `;
                    
                    if (showZeta) {
                        content += `
                            <div style="background:var(--bg); padding:10px; border-radius:6px; margin-bottom:10px;">
                                <p><b>ζ(${k}):</b> ${z.toFixed(6)}</p>
                            </div>
                        `;
                    }
                    
                    if (showDensity) {
                        content += `
                            <div style="background:var(--bg); padding:10px; border-radius:6px; margin-bottom:10px;">
                                <p><b>Primitive Density:</b> ${density}%</p>
                                <p style="font-size:0.9em; color:var(--text2);">1/ζ(${k}) = ${(1/z).toFixed(6)}</p>
                            </div>
                        `;
                    }
                    
                    if (showVolume) {
                        content += `
                            <div style="background:var(--bg); padding:10px; border-radius:6px; margin-bottom:10px;">
                                <p><b>Sphere Volume:</b></p>
                                <p style="font-size:0.95em;">${vol.toExponential(4)}</p>
                            </div>
                        `;
                    }
                    
                    // Add growth rate info
                    content += `
                        <div style="background:var(--bg); padding:10px; border-radius:6px; margin-bottom:10px;">
                            <p><b>Growth Rate:</b> O(R^${k})</p>
                            <p style="font-size:0.9em; color:var(--text2);">Error: O(R^${k-1})</p>
                        </div>
                    `;
                    
                    content += `</div>`;
                    grid.innerHTML += content;
                });
            } else {
                // Multiple radii mode
                const radiiStr = document.getElementById('multiRadii').value;
                const radii = radiiStr.split(',').map(r => parseInt(r.trim())).filter(r => !isNaN(r) && r > 0);
                
                if (radii.length === 0) {
                    grid.innerHTML = '<p style="color:var(--red);">Please enter valid radii (e.g., 10, 20, 30)</p>';
                    return;
                }
                
                dims.forEach(k => {
                    let content = `
                        <div class="compare-item">
                            <h3 style="color:var(--blue); margin-bottom:15px;">Dimension k = ${k}</h3>
                    `;
                    
                    if (showZeta) {
                        const z = zeta(k);
                        content += `
                            <div style="background:var(--bg); padding:10px; border-radius:6px; margin-bottom:10px;">
                                <p><b>ζ(${k}):</b> ${z.toFixed(6)}</p>
                                <p><b>Density:</b> ${((1/z)*100).toFixed(2)}%</p>
                            </div>
                        `;
                    }
                    
                    content += '<table style="width:100%; font-size:0.9em;"><thead><tr><th>R</th><th>Predicted</th>';
                    if (showVolume) content += '<th>Volume</th>';
                    content += '</tr></thead><tbody>';
                    
                    radii.forEach(R => {
                        const vol = sphereVolume(k, R);
                        const pred = Math.round(vol / zeta(k));
                        content += `<tr><td>${R}</td><td>${pred.toLocaleString()}</td>`;
                        if (showVolume) content += `<td>${vol.toExponential(2)}</td>`;
                        content += '</tr>';
                    });
                    
                    content += '</tbody></table></div>';
                    grid.innerHTML += content;
                });
            }
            
            // Update chart
            if (showChart) {
                document.getElementById('comparisonChart').style.display = 'block';
                updateComparisonChart(dims);
            } else {
                document.getElementById('comparisonChart').style.display = 'none';
            }
        }

        function updateAnalysisRadius(value) {
            const R = parseInt(value);
            if (R < 10 || R > 300 || isNaN(R)) return;
            
            document.getElementById('mrv').textContent = R;
            document.getElementById('mr').value = Math.min(R, 200);
            document.getElementById('mrinput').value = R;
        }

        function runAnalysis() {
            const canvas = document.getElementById('ch');
            const ctx = canvas.getContext('2d');
            const k = parseInt(document.getElementById('analysisK').value);
            const maxR = parseInt(document.getElementById('mrinput').value);
            const minR = parseInt(document.getElementById('minr').value);
            
            const showAbsError = document.getElementById('showAbsError').checked;
            const showRelError = document.getElementById('showRelError').checked;
            const showBoundary = document.getElementById('showBoundary').checked;
            const showActualCount = document.getElementById('showActualCount').checked;
            
            document.getElementById('loadAnalysis').classList.add('active');
            
            setTimeout(() => {
                if (chart) chart.destroy();
                
                const labels = [];
                const absErrorData = [];
                const relErrorData = [];
                const boundaryData = [];
                const actualCountData = [];
                
                // Compute for each radius from minR to maxR
                for (let R = minR; R <= maxR; R++) {
                    labels.push(R);
                    
                    const vol = sphereVolume(k, R);
                    const pred = Math.round(vol / zeta(k));
                    
                    let actual = pred; // Use prediction for large values
                    
                    // Only compute actual count for small enough cases
                    if (k === 2 && R <= 100) {
                        actual = 0;
                        for (let x = -R; x <= R; x++)
                            for (let y = -R; y <= R; y++)
                                if (x*x + y*y <= R*R && gcd(Math.abs(x), Math.abs(y)) === 1) actual++;
                    } else if (k === 3 && R <= 30) {
                        actual = 0;
                        for (let x = -R; x <= R; x++)
                            for (let y = -R; y <= R; y++)
                                for (let z = -R; z <= R; z++)
                                    if (x*x + y*y + z*z <= R*R && gcdArray([Math.abs(x), Math.abs(y), Math.abs(z)]) === 1) actual++;
                    }
                    
                    const absError = Math.abs(pred - actual);
                    const relError = pred > 0 ? (absError / pred) * 100 : 0;
                    const boundary = Math.pow(R, k - 1);
                    
                    absErrorData.push(absError);
                    relErrorData.push(relError);
                    boundaryData.push(boundary);
                    actualCountData.push(actual);
                }
                
                const datasets = [];
                
                if (showActualCount) {
                    datasets.push({
                        label: `Actual Primitive Count (k=${k})`,
                        data: actualCountData,
                        backgroundColor: 'rgba(0, 102, 204, 0.5)',
                        borderColor: '#0066cc',
                        borderWidth: 1,
                        type: 'bar',
                        yAxisID: 'y1',
                        order: 4
                    });
                }
                
                if (showAbsError) {
                    datasets.push({
                        label: `Absolute Error |Pred - Actual| (k=${k})`,
                        data: absErrorData,
                        backgroundColor: 'rgba(220, 53, 69, 0.6)',
                        borderColor: '#dc3545',
                        borderWidth: 2,
                        type: 'bar',
                        yAxisID: 'y',
                        order: 3
                    });
                }
                
                if (showRelError) {
                    datasets.push({
                        label: `Relative Error % (k=${k})`,
                        data: relErrorData,
                        backgroundColor: 'rgba(255, 193, 7, 0.6)',
                        borderColor: '#ffc107',
                        borderWidth: 2,
                        pointRadius: 3,
                        pointHoverRadius: 5,
                        type: 'line',
                        yAxisID: 'y2',
                        order: 2,
                        fill: false
                    });
                }
                
                if (showBoundary) {
                    datasets.push({
                        label: `Theoretical Boundary R^${k-1}`,
                        data: boundaryData,
                        backgroundColor: 'rgba(111, 66, 193, 0.3)',
                        borderColor: '#6f42c1',
                        borderWidth: 2,
                        borderDash: [5, 5],
                        pointRadius: 2,
                        type: 'line',
                        yAxisID: 'y',
                        order: 1,
                        fill: false
                    });
                }
                
                const scales = {
                    x: { 
                        title: { display: true, text: 'Radius R', font: { size: 14 } }
                    },
                    y: {
                        type: 'logarithmic',
                        position: 'left',
                        title: { display: true, text: 'Count / Error', font: { size: 14 } },
                        display: showAbsError || showBoundary || showActualCount
                    }
                };
                
                if (showActualCount) {
                    scales.y1 = {
                        type: 'logarithmic',
                        position: 'right',
                        title: { display: true, text: 'Actual Count', font: { size: 14 } },
                        grid: { drawOnChartArea: false }
                    };
                }
                
                if (showRelError) {
                    scales.y2 = {
                        type: 'linear',
                        position: 'right',
                        title: { display: true, text: 'Relative Error %', font: { size: 14 } },
                        grid: { drawOnChartArea: false }
                    };
                }
                
                chart = new Chart(ctx, {
                    type: 'bar',
                    data: { labels, datasets },
                    options: { 
                        responsive: true,
                        maintainAspectRatio: true,
                        scales,
                        plugins: {
                            legend: { 
                                display: true,
                                position: 'top',
                                labels: { font: { size: 11 } }
                            },
                            title: {
                                display: true,
                                text: `Error Analysis per Radius (k=${k}, R=${minR} to ${maxR})`,
                                font: { size: 16, weight: 'bold' }
                            },
                            tooltip: { 
                                mode: 'index', 
                                intersect: false,
                                callbacks: {
                                    label: function(context) {
                                        let label = context.dataset.label || '';
                                        if (label) label += ': ';
                                        if (context.parsed.y !== null) {
                                            if (label.includes('%')) {
                                                label += context.parsed.y.toFixed(4) + '%';
                                            } else {
                                                label += context.parsed.y.toLocaleString(undefined, {
                                                    minimumFractionDigits: 0,
                                                    maximumFractionDigits: 2
                                                });
                                            }
                                        }
                                        return label;
                                    }
                                }
                            }
                        },
                        interaction: {
                            mode: 'index',
                            intersect: false
                        }
                    }
                });
                
                document.getElementById('loadAnalysis').classList.remove('active');
            }, 100);
        }

        function set2DPreset(preset) {
            const presets = {
                'small': 10,
                'medium': 50,
                'large': 100,
                'xlarge': 200
            };
            update2DRadius(presets[preset]);
        }

        function set3DPreset(preset) {
            const presets = {
                'tiny': 5,
                'small': 10,
                'medium': 20,
                'large': 30
            };
            document.getElementById('r3').value = presets[preset];
            document.getElementById('r3v').textContent = presets[preset];
            draw3D();
        }

        function setComparisonPreset(preset) {
            // Uncheck all dimensions first
            for (let k = 2; k <= 10; k++) {
                const checkbox = document.getElementById(`compk${k}`);
                if (checkbox) checkbox.checked = false;
            }
            
            if (preset === 'low') {
                [2, 3, 4].forEach(k => document.getElementById(`compk${k}`).checked = true);
            } else if (preset === 'mid') {
                [3, 4, 5, 6].forEach(k => document.getElementById(`compk${k}`).checked = true);
            } else if (preset === 'high') {
                [5, 6, 7, 8, 9, 10].forEach(k => document.getElementById(`compk${k}`).checked = true);
            } else if (preset === 'all') {
                for (let k = 2; k <= 10; k++) {
                    document.getElementById(`compk${k}`).checked = true;
                }
            } else if (preset === 'growth') {
                setComparisonMode('multi');
                [2, 3, 4, 5].forEach(k => document.getElementById(`compk${k}`).checked = true);
                document.getElementById('multiRadii').value = '5, 10, 15, 20, 25, 30';
            }
            
            updateComparison();
        }

        function setAnalysisPreset(preset) {
            if (preset === 'quick') {
                updateAnalysisRadius(50);
            } else if (preset === 'standard') {
                updateAnalysisRadius(100);
            } else if (preset === 'detailed') {
                updateAnalysisRadius(150);
            } else if (preset === 'absolute') {
                document.getElementById('showAbsError').checked = true;
                document.getElementById('showRelError').checked = false;
                document.getElementById('showBoundary').checked = false;
                document.getElementById('showActualCount').checked = false;
            } else if (preset === 'relative') {
                document.getElementById('showAbsError').checked = false;
                document.getElementById('showRelError').checked = true;
                document.getElementById('showBoundary').checked = false;
                document.getElementById('showActualCount').checked = false;
            } else if (preset === 'boundary') {
                document.getElementById('showAbsError').checked = false;
                document.getElementById('showRelError').checked = false;
                document.getElementById('showBoundary').checked = true;
                document.getElementById('showActualCount').checked = false;
            }
            
            runAnalysis();
        }

        function setGCDPreset(preset) {
            const presets = {
                'coprime': '15, 28',
                'common': '12, 18, 24',
                'large': '1024, 2048, 4096',
                'many': '60, 72, 90, 120, 150'
            };
            document.getElementById('gi').value = presets[preset];
            calcGCD();
        }

        function setMobiusPreset(preset) {
            const presets = {
                'squarefree': 30,
                'notsquarefree': 72,
                'prime': 17,
                'composite': 210
            };
            document.getElementById('mi').value = presets[preset];
            calcMobius();
        }

        function setPrimePreset(preset) {
            const presets = {
                'small': 60,
                'perfect': 28,
                'highly': 5040,
                'large': 65536,
                'power': 243
            };
            document.getElementById('pi').value = presets[preset];
            calcPrime();
        }

        function setCoprimePreset(preset) {
            const presets = {
                'coprime2': '35, 64',
                'notcoprime2': '24, 36',
                'coprime3': '7, 11, 13',
                'consecutive': '100, 101, 102'
            };
            document.getElementById('cci').value = presets[preset];
            checkCoprime();
        }

        function setPointPreset(preset) {
            const presets = {
                'pythagorean': '3, 4, 5',
                'primitive2d': '7, 9',
                'nonprimitive2d': '6, 8',
                'primitive3d': '1, 2, 3',
                'highd': '1, 1, 1, 1, 1'
            };
            document.getElementById('psi').value = presets[preset];
            searchPoint();
        }

        function calcGCD() {
            const inp = document.getElementById('gi').value;
            const nums = inp.split(',').map(n => parseInt(n.trim())).filter(n => !isNaN(n));
            if (nums.length < 2) {
                document.getElementById('gr').innerHTML = '<p style="color:var(--red)">Need 2+ numbers</p>';
                return;
            }
            const g = gcdArray(nums);
            const coprime = g === 1 ? '<span style="color:var(--green)">✓ Coprime</span>' : '<span style="color:var(--red)">✗ Not Coprime</span>';
            
            // Show step-by-step GCD calculation for pairs
            let steps = '<div style="background:var(--bg3); padding:15px; border-radius:8px; margin-top:10px;">';
            steps += '<b>Step-by-step calculation:</b><br>';
            let current = nums[0];
            for (let i = 1; i < nums.length; i++) {
                const prev = current;
                current = gcd(current, nums[i]);
                steps += `gcd(${prev}, ${nums[i]}) = ${current}<br>`;
            }
            steps += '</div>';
            
            // Prime factorizations
            let factorizations = '<div style="background:var(--bg3); padding:15px; border-radius:8px; margin-top:10px;">';
            factorizations += '<b>Prime factorizations:</b><br>';
            nums.forEach(n => {
                const f = primeFactors(Math.abs(n));
                const fc = {};
                f.forEach(p => fc[p] = (fc[p]||0) + 1);
                const fs = Object.entries(fc).map(([p,c]) => c>1 ? `${p}^${c}` : p).join(' × ');
                factorizations += `${n} = ${fs || '1'}<br>`;
            });
            
            // GCD factorization
            if (g > 1) {
                const gf = primeFactors(g);
                const gfc = {};
                gf.forEach(p => gfc[p] = (gfc[p]||0) + 1);
                const gfs = Object.entries(gfc).map(([p,c]) => c>1 ? `${p}^${c}` : p).join(' × ');
                factorizations += `<br><b>GCD = ${g} = ${gfs}</b>`;
            }
            factorizations += '</div>';
            
            document.getElementById('gr').innerHTML = `
                <p><b>Numbers:</b> ${nums.join(', ')}</p>
                <p><b>GCD:</b> ${g}</p>
                <p>${coprime}</p>
                ${steps}
                ${factorizations}
            `;
        }

        function calcMobius() {
            const n = parseInt(document.getElementById('mi').value);
            if (!n || n < 1) return;
            const mu = mobius(n), f = primeFactors(n);
            const u = [...new Set(f)];
            const sqfree = f.length === u.length;
            const interp = mu === 0 ? 'Not square-free (has repeated prime factors)' : mu === 1 ? 'Even number of distinct prime factors' : 'Odd number of distinct prime factors';
            
            // Build prime factorization display
            const fc = {};
            f.forEach(p => fc[p] = (fc[p]||0) + 1);
            const fs = Object.entries(fc).map(([p,c]) => c>1 ? `${p}^${c}` : p).join(' × ');
            const repeatedPrimes = Object.entries(fc).filter(([p,c]) => c > 1).map(([p,c]) => `${p} (appears ${c} times)`);
            
            let details = '<div style="background:var(--bg3); padding:15px; border-radius:8px; margin-top:10px;">';
            details += `<b>Prime factorization:</b> ${n} = ${fs || '1'}<br>`;
            details += `<b>Distinct primes:</b> {${u.join(', ')}}<br>`;
            details += `<b>Number of distinct primes:</b> ${u.length}<br>`;
            if (repeatedPrimes.length > 0) {
                details += `<b>Repeated primes:</b> ${repeatedPrimes.join(', ')}<br>`;
            }
            details += `<b>Square-free:</b> ${sqfree ? '✓ Yes' : '✗ No'}<br>`;
            details += '</div>';
            
            let formula = '<div style="background:var(--bg3); padding:15px; border-radius:8px; margin-top:10px;">';
            formula += '<b>Formula calculation:</b><br>';
            if (mu === 0) {
                formula += `μ(${n}) = 0 (not square-free)<br>`;
            } else {
                formula += `μ(${n}) = (-1)^${u.length} = (-1)^${u.length} = ${mu}<br>`;
            }
            formula += '</div>';
            
            document.getElementById('mr2').innerHTML = `
                <p style="font-size:1.3em;"><b>μ(${n}) = ${mu}</b></p>
                <p style="color:var(--blue);"><b>${interp}</b></p>
                ${details}
                ${formula}
            `;
        }

        function calcPrime() {
            const n = parseInt(document.getElementById('pi').value);
            if (!n || n < 2) return;
            const f = primeFactors(n);
            const fc = {};
            f.forEach(p => fc[p] = (fc[p]||0) + 1);
            const fs = Object.entries(fc).map(([p,c]) => c>1 ? `${p}^${c}` : p).join(' × ');
            
            let details = '<div style="background:var(--bg3); padding:15px; border-radius:8px; margin-top:10px;">';
            details += '<b>Detailed breakdown:</b><br>';
            details += `<b>All prime factors:</b> ${f.join(' × ')}<br>`;
            details += `<b>Distinct primes:</b> ${Object.keys(fc).join(', ')}<br>`;
            details += `<b>Number of distinct primes:</b> ${Object.keys(fc).length}<br>`;
            details += `<b>Total number of prime factors (with repetition):</b> ${f.length}<br>`;
            
            // Show exponent breakdown
            details += '<br><b>Exponent breakdown:</b><br>';
            Object.entries(fc).forEach(([p, c]) => {
                details += `${p} appears ${c} time${c > 1 ? 's' : ''}<br>`;
            });
            
            // Divisor information
            const numDivisors = Object.values(fc).reduce((prod, exp) => prod * (exp + 1), 1);
            details += `<br><b>Number of divisors:</b> ${numDivisors}<br>`;
            
            // Sum of divisors (for small numbers)
            if (n <= 1000) {
                let sumDiv = 0;
                for (let i = 1; i <= n; i++) {
                    if (n % i === 0) sumDiv += i;
                }
                details += `<b>Sum of divisors:</b> ${sumDiv}<br>`;
                const perfect = sumDiv === 2 * n;
                const abundant = sumDiv > 2 * n;
                const deficient = sumDiv < 2 * n;
                details += `<b>Number type:</b> ${perfect ? 'Perfect' : abundant ? 'Abundant' : 'Deficient'}<br>`;
            }
            
            details += '</div>';
            
            document.getElementById('pr').innerHTML = `
                <p style="font-size:1.3em;"><b>${n} = ${fs}</b></p>
                <p style="font-size:1.1em;">${isPrime(n) ? '<span style="color:var(--green)">✓ PRIME NUMBER</span>' : '<span style="color:var(--blue)">COMPOSITE NUMBER</span>'}</p>
                ${details}
            `;
        }

        function checkCoprime() {
            const inp = document.getElementById('cci').value;
            const nums = inp.split(',').map(n => parseInt(n.trim())).filter(n => !isNaN(n));
            if (nums.length < 2) {
                document.getElementById('ccr').innerHTML = '<p style="color:var(--red)">Need 2+ numbers</p>';
                return;
            }
            const g = gcdArray(nums);
            const coprime = g === 1;
            
            // Prime factorizations
            let factorInfo = '<div style="background:var(--bg3); padding:15px; border-radius:8px; margin-top:10px;">';
            factorInfo += '<b>Prime factorizations:</b><br>';
            nums.forEach(n => {
                const f = primeFactors(Math.abs(n));
                const fc = {};
                f.forEach(p => fc[p] = (fc[p]||0) + 1);
                const fs = Object.entries(fc).map(([p,c]) => c>1 ? `${p}^${c}` : p).join(' × ');
                factorInfo += `${n} = ${fs || '1'}<br>`;
            });
            factorInfo += '</div>';
            
            // Common factors
            let commonInfo = '<div style="background:var(--bg3); padding:15px; border-radius:8px; margin-top:10px;">';
            if (coprime) {
                commonInfo += '<b>Common factors:</b> Only 1 (coprime)<br>';
                commonInfo += 'These numbers share no prime factors.';
            } else {
                const gf = primeFactors(g);
                const gfc = {};
                gf.forEach(p => gfc[p] = (gfc[p]||0) + 1);
                const gfs = Object.entries(gfc).map(([p,c]) => c>1 ? `${p}^${c}` : p).join(' × ');
                commonInfo += `<b>Common factors:</b> Divisors of ${g}<br>`;
                commonInfo += `<b>GCD breakdown:</b> ${g} = ${gfs}<br>`;
                commonInfo += `<b>Shared primes:</b> ${Object.keys(gfc).join(', ')}`;
            }
            commonInfo += '</div>';
            
            document.getElementById('ccr').innerHTML = `
                <p><b>Numbers:</b> ${nums.join(', ')}</p>
                <p><b>GCD:</b> ${g}</p>
                <p style="font-size:1.2em; margin-top:10px">${coprime ? '<span style="color:var(--green)">✓ COPRIME (Primitive point)</span>' : '<span style="color:var(--red)">✗ NOT COPRIME (Non-primitive)</span>'}</p>
                ${factorInfo}
                ${commonInfo}
            `;
        }

        function searchPoint() {
            const inp = document.getElementById('psi').value;
            const coords = inp.split(',').map(n => parseInt(n.trim())).filter(n => !isNaN(n));
            if (coords.length < 2) {
                document.getElementById('psr').innerHTML = '<p style="color:var(--red)">Need 2+ coordinates</p>';
                return;
            }
            const g = gcdArray(coords);
            const isPrim = g === 1;
            const dist = Math.sqrt(coords.reduce((sum, x) => sum + x*x, 0));
            
            // Point factorization
            let pointInfo = '<div style="background:var(--bg3); padding:15px; border-radius:8px; margin-top:10px;">';
            pointInfo += '<b>Coordinate factorizations:</b><br>';
            coords.forEach((c, i) => {
                const label = ['x', 'y', 'z', 'w', 'v', 'u'][i] || `x${i}`;
                if (c === 0) {
                    pointInfo += `${label} = 0<br>`;
                } else {
                    const f = primeFactors(Math.abs(c));
                    const fc = {};
                    f.forEach(p => fc[p] = (fc[p]||0) + 1);
                    const fs = Object.entries(fc).map(([p,cnt]) => cnt>1 ? `${p}^${cnt}` : p).join(' × ');
                    const sign = c < 0 ? '-' : '';
                    pointInfo += `${label} = ${sign}${fs || '1'}<br>`;
                }
            });
            pointInfo += '</div>';
            
            // GCD analysis
            let gcdInfo = '<div style="background:var(--bg3); padding:15px; border-radius:8px; margin-top:10px;">';
            if (g === 1) {
                gcdInfo += '<b>GCD Analysis:</b><br>';
                gcdInfo += 'GCD = 1 → Coordinates are coprime<br>';
                gcdInfo += 'This point cannot be expressed as d·(simpler point) where d > 1';
            } else {
                const reduced = coords.map(c => c / g);
                const gf = primeFactors(g);
                const gfc = {};
                gf.forEach(p => gfc[p] = (gfc[p]||0) + 1);
                const gfs = Object.entries(gfc).map(([p,c]) => c>1 ? `${p}^${c}` : p).join(' × ');
                gcdInfo += '<b>GCD Analysis:</b><br>';
                gcdInfo += `GCD = ${g} = ${gfs}<br>`;
                gcdInfo += `<b>Reduced form:</b> (${reduced.join(', ')}) is the primitive point<br>`;
                gcdInfo += `<b>Relationship:</b> (${coords.join(', ')}) = ${g} × (${reduced.join(', ')})`;
            }
            gcdInfo += '</div>';
            
            // Geometric properties
            let geomInfo = '<div style="background:var(--bg3); padding:15px; border-radius:8px; margin-top:10px;">';
            geomInfo += '<b>Geometric Properties:</b><br>';
            geomInfo += `<b>Euclidean norm:</b> ||point|| = √(${coords.map(c => c + '²').join(' + ')}) = ${dist.toFixed(4)}<br>`;
            geomInfo += `<b>Manhattan distance:</b> ${coords.reduce((sum, c) => sum + Math.abs(c), 0)}<br>`;
            geomInfo += `<b>Max coordinate:</b> ${Math.max(...coords.map(Math.abs))}<br>`;
            const numZeros = coords.filter(c => c === 0).length;
            if (numZeros > 0) {
                geomInfo += `<b>Zero coordinates:</b> ${numZeros} (lies on ${coords.length - numZeros}D subspace)`;
            }
            geomInfo += '</div>';
            
            document.getElementById('psr').innerHTML = `
                <p><b>Point:</b> (${coords.join(', ')})</p>
                <p><b>Dimension:</b> ${coords.length}</p>
                <p><b>GCD of coordinates:</b> ${g}</p>
                <p style="font-size:1.2em; margin-top:10px">${isPrim ? '<span style="color:var(--green)">✓ PRIMITIVE LATTICE POINT</span>' : '<span style="color:var(--red)">✗ NON-PRIMITIVE LATTICE POINT</span>'}</p>
                ${pointInfo}
                ${gcdInfo}
                ${geomInfo}
            `;
        }

        function exportCanvas(canvasId, filename) {
            const canvas = document.getElementById(canvasId);
            const link = document.createElement('a');
            link.download = `${filename}.png`;
            link.href = canvas.toDataURL();
            link.click();
        }

        function exportPointData2D() {
            if (!cache.points2D) { alert('Generate 2D visualization first'); return; }
            const data = cache.points2D;
            let csv = 'x,y,type\n';
            data.primitive.forEach(p => csv += `${p.x},${p.y},primitive\n`);
            data.nonPrimitive.forEach(p => csv += `${p.x},${p.y},non-primitive\n`);
            downloadCSV(csv, '2d-lattice-points.csv');
        }

        function export3DData() {
            if (!cache.points3D) { alert('Generate 3D visualization first'); return; }
            const data = cache.points3D;
            let csv = 'x,y,z,type\n';
            data.primitive.forEach(p => csv += `${p.x},${p.y},${p.z},primitive\n`);
            data.nonPrimitive.forEach(p => csv += `${p.x},${p.y},${p.z},non-primitive\n`);
            downloadCSV(csv, '3d-lattice-points.csv');
        }

        function exportTheoryData() {
            const k = parseInt(document.getElementById('tks').value);
            const R = parseInt(document.getElementById('trs').value);
            const z = zeta(k);
            const vol = sphereVolume(k, R);
            const pred = Math.round(vol / z);
            
            let csv = 'dimension,radius,zeta,density,volume,predicted_points\n';
            csv += `${k},${R},${z},${1/z},${vol},${pred}\n`;
            downloadCSV(csv, 'theory-data.csv');
        }

        function exportChartData() {
            if (!chart) { alert('Run analysis first'); return; }
            const data = chart.data.datasets[0].data;
            let csv = 'radius,error\n';
            data.forEach(pt => csv += `${pt.x},${pt.y}\n`);
            downloadCSV(csv, 'error-analysis.csv');
        }

        function exportComparisonData() {
            const showDensity = document.getElementById('showDensity').checked;
            const showVolume = document.getElementById('showVolume').checked;
            const showZeta = document.getElementById('showZeta').checked;
            
            const dims = [];
            for (let k = 2; k <= 10; k++) {
                if (document.getElementById(`compk${k}`)?.checked) dims.push(k);
            }
            
            let csv = 'dimension,';
            if (comparisonMode === 'fixed') {
                csv += 'radius,';
            }
            if (showZeta) csv += 'zeta,';
            if (showDensity) csv += 'density,';
            csv += 'predicted_points';
            if (showVolume) csv += ',volume';
            csv += '\n';
            
            if (comparisonMode === 'fixed') {
                const R = parseInt(document.getElementById('crinput').value);
                dims.forEach(k => {
                    const z = zeta(k);
                    const vol = sphereVolume(k, R);
                    const pred = Math.round(vol / z);
                    csv += `${k},${R},`;
                    if (showZeta) csv += `${z},`;
                    if (showDensity) csv += `${1/z},`;
                    csv += `${pred}`;
                    if (showVolume) csv += `,${vol}`;
                    csv += '\n';
                });
            } else {
                const radiiStr = document.getElementById('multiRadii').value;
                const radii = radiiStr.split(',').map(r => parseInt(r.trim())).filter(r => !isNaN(r) && r > 0);
                
                dims.forEach(k => {
                    const z = zeta(k);
                    radii.forEach(R => {
                        const vol = sphereVolume(k, R);
                        const pred = Math.round(vol / z);
                        csv += `${k},${R},`;
                        if (showZeta) csv += `${z},`;
                        if (showDensity) csv += `${1/z},`;
                        csv += `${pred}`;
                        if (showVolume) csv += `,${vol}`;
                        csv += '\n';
                    });
                });
            }
            
            downloadCSV(csv, 'dimension-comparison.csv');
        }

        function downloadCSV(content, filename) {
            const blob = new Blob([content], { type: 'text/csv' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            link.download = filename;
            link.click();
            URL.revokeObjectURL(url);
        }

        function toggleDark() {
            document.body.classList.toggle('light');
            const btn = document.getElementById('darkBtn');
            btn.textContent = document.body.classList.contains('light') ? 'Dark Mode' : 'Light Mode';
            if (scene) scene.background = new THREE.Color(document.body.classList.contains('light') ? 0xffffff : 0x1a1a1a);
        }

        function showHelp() {
            document.getElementById('helpModal').classList.add('active');
        }

        function closeHelp() {
            document.getElementById('helpModal').classList.remove('active');
        }

        function showDerivationAnimation() {
            alert('Interactive animation coming soon! This would show step-by-step how Möbius inversion leads to the zeta function connection.');
        }

        function setPatternType(type) {
            patternType = type;
            document.querySelectorAll('#patternModular, #patternDensity, #patternAngular, #patternRadial').forEach(btn => btn.classList.remove('active'));
            const btnIds = {
                'modular': 'patternModular',
                'density': 'patternDensity',
                'angular': 'patternAngular',
                'radial': 'patternRadial'
            };
            document.getElementById(btnIds[type]).classList.add('active');
            
            // Show/hide appropriate controls
            document.getElementById('modularPatternControls').style.display = type === 'modular' ? 'block' : 'none';
            document.getElementById('densityPatternControls').style.display = type === 'density' ? 'block' : 'none';
            document.getElementById('angularPatternControls').style.display = type === 'angular' ? 'block' : 'none';
            document.getElementById('radialPatternControls').style.display = type === 'radial' ? 'block' : 'none';
            
            updatePatternViz();
        }

        function updatePatternViz() {
            if (patternType === 'modular') {
                const m = parseInt(document.getElementById('patternMod').value);
                const R = parseInt(document.getElementById('patternR').value);
                const showExpected = document.getElementById('showExpected').checked;
                
                document.getElementById('patternModv').textContent = m;
                document.getElementById('patternRv').textContent = R;
                
                // Count primitive points by residue class
                const counts = new Array(m).fill(0);
                let totalPrimitive = 0;
                
                for (let x = -R; x <= R; x++) {
                    for (let y = -R; y <= R; y++) {
                        if (x*x + y*y <= R*R && gcd(Math.abs(x), Math.abs(y)) === 1) {
                            const residue = ((x + y) % m + m) % m;
                            counts[residue]++;
                            totalPrimitive++;
                        }
                    }
                }
                
                // Expected uniform distribution
                const expected = totalPrimitive / m;
                
                // Display chart
                const canvas = document.getElementById('patternCanvas');
                const ctx = canvas.getContext('2d');
                
                if (patternChart) patternChart.destroy();
                
                const datasets = [{
                    label: 'Observed Count',
                    data: counts,
                    backgroundColor: 'rgba(0, 102, 204, 0.6)',
                    borderColor: '#0066cc',
                    borderWidth: 2
                }];
                
                if (showExpected) {
                    datasets.push({
                        label: 'Expected (Uniform)',
                        data: new Array(m).fill(expected),
                        type: 'line',
                        borderColor: '#dc3545',
                        borderWidth: 2,
                        borderDash: [5, 5],
                        pointRadius: 0,
                        fill: false
                    });
                }
                
                patternChart = new Chart(ctx, {
                    type: 'bar',
                    data: {
                        labels: Array.from({length: m}, (_, i) => i),
                        datasets
                    },
                    options: {
                        responsive: true,
                        scales: {
                            y: {
                                title: { display: true, text: 'Number of Primitive Points', font: { size: 14 } },
                                beginAtZero: true
                            },
                            x: {
                                title: { display: true, text: `Residue Class (x+y) mod ${m}`, font: { size: 14 } }
                            }
                        },
                        plugins: {
                            title: {
                                display: true,
                                text: `Modular Distribution: Primitive Points mod ${m} (R=${R})`,
                                font: { size: 16, weight: 'bold' }
                            },
                            legend: { display: true }
                        }
                    }
                });
                
                // Update stats
                const statsDiv = document.getElementById('patternStats');
                const maxCount = Math.max(...counts);
                const minCount = Math.min(...counts);
                const variance = counts.reduce((sum, c) => sum + Math.pow(c - expected, 2), 0) / m;
                const stdDev = Math.sqrt(variance);
                
                statsDiv.innerHTML = `
                    <div class="stat"><div class="val">${totalPrimitive}</div><div class="lbl">Total Primitive</div></div>
                    <div class="stat"><div class="val">${expected.toFixed(1)}</div><div class="lbl">Expected per Class</div></div>
                    <div class="stat"><div class="val">${maxCount}</div><div class="lbl">Max Count</div></div>
                    <div class="stat"><div class="val">${minCount}</div><div class="lbl">Min Count</div></div>
                    <div class="stat"><div class="val">${stdDev.toFixed(2)}</div><div class="lbl">Std Deviation</div></div>
                `;
                
            } else if (patternType === 'density') {
                const gridSize = parseInt(document.getElementById('gridSize').value);
                const R = parseInt(document.getElementById('densityR').value);
                
                document.getElementById('gridSizev').textContent = gridSize;
                document.getElementById('densityRv').textContent = R;
                
                const canvas = document.getElementById('densityCanvas');
                const ctx = canvas.getContext('2d');
                const cellSize = 800 / gridSize;
                
                ctx.clearRect(0, 0, 800, 800);
                
                // Compute density in each grid cell
                const cellR = R / gridSize;
                const densities = [];
                let maxDensity = 0;
                
                for (let i = 0; i < gridSize; i++) {
                    densities[i] = [];
                    for (let j = 0; j < gridSize; j++) {
                        const cx = (i - gridSize/2) * cellR;
                        const cy = (j - gridSize/2) * cellR;
                        
                        let primCount = 0, totalCount = 0;
                        
                        // Count points in this cell
                        for (let x = Math.floor(cx - cellR); x <= Math.ceil(cx + cellR); x++) {
                            for (let y = Math.floor(cy - cellR); y <= Math.ceil(cy + cellR); y++) {
                                const dx = x - cx, dy = y - cy;
                                if (dx*dx + dy*dy <= cellR*cellR) {
                                    totalCount++;
                                    if (gcd(Math.abs(x), Math.abs(y)) === 1) primCount++;
                                }
                            }
                        }
                        
                        const density = totalCount > 0 ? primCount / totalCount : 0;
                        densities[i][j] = density;
                        maxDensity = Math.max(maxDensity, density);
                    }
                }
                
                // Draw heatmap
                for (let i = 0; i < gridSize; i++) {
                    for (let j = 0; j < gridSize; j++) {
                        const density = densities[i][j];
                        const intensity = density / (maxDensity || 1);
                        const hue = 240 - intensity * 240; // Blue to red
                        ctx.fillStyle = `hsl(${hue}, 70%, 50%)`;
                        ctx.fillRect(i * cellSize, j * cellSize, cellSize, cellSize);
                        
                        // Draw border
                        ctx.strokeStyle = 'rgba(255,255,255,0.2)';
                        ctx.strokeRect(i * cellSize, j * cellSize, cellSize, cellSize);
                    }
                }
                
                // Add legend
                ctx.fillStyle = 'rgba(255,255,255,0.9)';
                ctx.fillRect(20, 720, 200, 60);
                ctx.fillStyle = '#000';
                ctx.font = '14px system-ui';
                ctx.fillText('Density Scale:', 30, 740);
                ctx.fillText(`0% → ${(maxDensity * 100).toFixed(1)}%`, 30, 760);
                
            } else if (patternType === 'angular') {
                const numSectors = parseInt(document.getElementById('numSectors').value);
                const R = parseInt(document.getElementById('angularR').value);
                
                document.getElementById('numSectorsv').textContent = numSectors;
                document.getElementById('angularRv').textContent = R;
                
                const sectorCounts = new Array(numSectors).fill(0);
                let totalPrimitive = 0;
                
                for (let x = -R; x <= R; x++) {
                    for (let y = -R; y <= R; y++) {
                        if (x*x + y*y <= R*R && gcd(Math.abs(x), Math.abs(y)) === 1) {
                            const angle = Math.atan2(y, x) + Math.PI; // 0 to 2π
                            const sector = Math.floor(angle / (2 * Math.PI / numSectors)) % numSectors;
                            sectorCounts[sector]++;
                            totalPrimitive++;
                        }
                    }
                }
                
                const expected = totalPrimitive / numSectors;
                
                const canvas = document.getElementById('angularCanvas');
                const ctx = canvas.getContext('2d');
                
                if (patternChart) patternChart.destroy();
                
                patternChart = new Chart(ctx, {
                    type: 'bar',
                    data: {
                        labels: Array.from({length: numSectors}, (_, i) => {
                            const startAngle = (i * 360 / numSectors).toFixed(0);
                            const endAngle = ((i + 1) * 360 / numSectors).toFixed(0);
                            return `${startAngle}°-${endAngle}°`;
                        }),
                        datasets: [{
                            label: 'Primitive Points',
                            data: sectorCounts,
                            backgroundColor: Array.from({length: numSectors}, (_, i) => {
                                const hue = (i / numSectors) * 360;
                                return `hsla(${hue}, 70%, 50%, 0.6)`;
                            }),
                            borderWidth: 2
                        }, {
                            label: 'Expected (Uniform)',
                            data: new Array(numSectors).fill(expected),
                            type: 'line',
                            borderColor: '#dc3545',
                            borderWidth: 2,
                            borderDash: [5, 5],
                            pointRadius: 0,
                            fill: false
                        }]
                    },
                    options: {
                        responsive: true,
                        scales: {
                            y: { title: { display: true, text: 'Count', font: { size: 14 } } },
                            x: { title: { display: true, text: 'Angular Sector', font: { size: 14 } } }
                        },
                        plugins: {
                            title: {
                                display: true,
                                text: `Angular Distribution (${numSectors} sectors, R=${R})`,
                                font: { size: 16, weight: 'bold' }
                            }
                        }
                    }
                });
                
            } else if (patternType === 'radial') {
                const shellThick = parseInt(document.getElementById('shellThick').value);
                const maxR = parseInt(document.getElementById('radialMaxR').value);
                
                document.getElementById('shellThickv').textContent = shellThick;
                document.getElementById('radialMaxRv').textContent = maxR;
                
                const numShells = Math.floor(maxR / shellThick);
                const shellCounts = [];
                const radii = [];
                
                for (let i = 0; i < numShells; i++) {
                    const innerR = i * shellThick;
                    const outerR = (i + 1) * shellThick;
                    radii.push(outerR);
                    
                    let count = 0;
                    for (let x = -outerR; x <= outerR; x++) {
                        for (let y = -outerR; y <= outerR; y++) {
                            const distSq = x*x + y*y;
                            if (distSq > innerR*innerR && distSq <= outerR*outerR && 
                                gcd(Math.abs(x), Math.abs(y)) === 1) {
                                count++;
                            }
                        }
                    }
                    shellCounts.push(count);
                }
                
                const canvas = document.getElementById('radialCanvas');
                const ctx = canvas.getContext('2d');
                
                if (patternChart) patternChart.destroy();
                
                patternChart = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: radii,
                        datasets: [{
                            label: 'Primitive Points in Shell',
                            data: shellCounts,
                            backgroundColor: 'rgba(0, 102, 204, 0.2)',
                            borderColor: '#0066cc',
                            borderWidth: 2,
                            fill: true,
                            tension: 0.3
                        }]
                    },
                    options: {
                        responsive: true,
                        scales: {
                            y: { 
                                title: { display: true, text: 'Count per Shell', font: { size: 14 } },
                                beginAtZero: true
                            },
                            x: { title: { display: true, text: 'Radius', font: { size: 14 } } }
                        },
                        plugins: {
                            title: {
                                display: true,
                                text: `Radial Shell Distribution (thickness=${shellThick})`,
                                font: { size: 16, weight: 'bold' }
                            }
                        }
                    }
                });
            }
        }

        function exportPatternData() {
            if (!patternChart) { alert('Generate a pattern visualization first'); return; }
            
            let csv = '';
            const data = patternChart.data;
            
            if (patternType === 'modular') {
                csv = 'residue_class,count\n';
                data.labels.forEach((label, i) => {
                    csv += `${label},${data.datasets[0].data[i]}\n`;
                });
            } else if (patternType === 'angular') {
                csv = 'sector,count\n';
                data.labels.forEach((label, i) => {
                    csv += `${label},${data.datasets[0].data[i]}\n`;
                });
            } else if (patternType === 'radial') {
                csv = 'radius,count\n';
                data.labels.forEach((label, i) => {
                    csv += `${label},${data.datasets[0].data[i]}\n`;
                });
            }
            
            downloadCSV(csv, `pattern-${patternType}.csv`);
        }

        function setGCDHeatmapPreset(preset) {
            const presets = { 'small': 15, 'medium': 30, 'large': 50 };
            const R = presets[preset];
            document.getElementById('heatmapR').value = R;
            document.getElementById('heatmapRinput').value = R;
            document.getElementById('heatmapRv').textContent = R;
            updateGCDHeatmap();
        }

        function setHeatmapMode(mode) {
            heatmapMode = mode;
            document.querySelectorAll('#heatmapGCD, #heatmapPrimitive, #heatmapGradient').forEach(btn => btn.classList.remove('active'));
            const btnIds = { 'gcd': 'heatmapGCD', 'primitive': 'heatmapPrimitive', 'gradient': 'heatmapGradient' };
            document.getElementById(btnIds[mode]).classList.add('active');
            updateGCDHeatmap();
        }

        function updateGCDHeatmap() {
            const R = parseInt(document.getElementById('heatmapRinput').value) || parseInt(document.getElementById('heatmapR').value);
            const pointSize = parseInt(document.getElementById('heatmapPS').value);
            
            document.getElementById('heatmapRv').textContent = R;
            document.getElementById('heatmapPSv').textContent = pointSize;
            document.getElementById('heatmapR').value = Math.min(R, 80);
            document.getElementById('heatmapRinput').value = R;
            
            const canvas = document.getElementById('heatmapCanvas');
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            const cx = canvas.width / 2, cy = canvas.height / 2;
            const scale = Math.min(canvas.width, canvas.height) / (2.2 * R);
            
            // Draw axes
            ctx.strokeStyle = getComputedStyle(document.body).getPropertyValue('--border');
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(0, cy); ctx.lineTo(canvas.width, cy);
            ctx.moveTo(cx, 0); ctx.lineTo(cx, canvas.height);
            ctx.stroke();
            
            // Draw circle boundary
            ctx.beginPath();
            ctx.arc(cx, cy, R * scale, 0, 2 * Math.PI);
            ctx.stroke();
            
            // Collect and categorize points
            heatmapPointsData = [];
            let counts = { total: 0, gcd1: 0, gcd2: 0, gcd3: 0, gcdOther: 0 };
            
            const filterGCD1 = document.getElementById('filterGCD1').checked;
            const filterGCD2 = document.getElementById('filterGCD2').checked;
            const filterGCD3 = document.getElementById('filterGCD3').checked;
            const filterGCDOther = document.getElementById('filterGCDOther').checked;
            
            for (let x = -R; x <= R; x++) {
                for (let y = -R; y <= R; y++) {
                    const distSq = x*x + y*y;
                    if (distSq <= R*R) {
                        counts.total++;
                        const g = gcd(Math.abs(x), Math.abs(y));
                        const dist = Math.sqrt(distSq);
                        
                        if (g === 1) counts.gcd1++;
                        else if (g === 2) counts.gcd2++;
                        else if (g === 3) counts.gcd3++;
                        else counts.gcdOther++;
                        
                        // Apply filters
                        let shouldDisplay = false;
                        if (g === 1 && filterGCD1) shouldDisplay = true;
                        if (g === 2 && filterGCD2) shouldDisplay = true;
                        if (g === 3 && filterGCD3) shouldDisplay = true;
                        if (g > 3 && filterGCDOther) shouldDisplay = true;
                        
                        if (shouldDisplay) {
                            heatmapPointsData.push({ x, y, gcd: g, dist, screenX: cx + x*scale, screenY: cy - y*scale });
                        }
                    }
                }
            }
            
            // Draw points based on mode
            heatmapPointsData.forEach(pt => {
                let color;
                
                if (heatmapMode === 'gcd') {
                    const gcdColors = {
                        1: '#0066cc', 2: '#dc3545', 3: '#28a745', 4: '#ffc107',
                        5: '#6f42c1', 6: '#fd7e14', 7: '#00d4ff', 8: '#ff006e'
                    };
                    color = gcdColors[Math.min(pt.gcd, 8)] || '#999';
                } else if (heatmapMode === 'primitive') {
                    color = pt.gcd === 1 ? '#0066cc' : '#e0e0e0';
                } else if (heatmapMode === 'gradient') {
                    const ratio = pt.dist / R;
                    const hue = 240 - ratio * 240; // Blue to red
                    color = `hsl(${hue}, 70%, 50%)`;
                }
                
                ctx.fillStyle = color;
                ctx.beginPath();
                ctx.arc(pt.screenX, pt.screenY, pointSize, 0, 2*Math.PI);
                ctx.fill();
            });
            
            // Update stats
            animateValue('heatmapTotal', 0, counts.total);
            animateValue('heatmapPrim', 0, counts.gcd1);
            animateValue('heatmapGCD2', 0, counts.gcd2);
            animateValue('heatmapGCD3', 0, counts.gcd3);
            animateValue('heatmapGCDOther', 0, counts.gcdOther);
        }

        function exportHeatmapData() {
            if (heatmapPointsData.length === 0) { alert('Generate heatmap first'); return; }
            let csv = 'x,y,gcd,distance\n';
            heatmapPointsData.forEach(pt => csv += `${pt.x},${pt.y},${pt.gcd},${pt.dist.toFixed(4)}\n`);
            downloadCSV(csv, 'gcd-heatmap-data.csv');
        }

        function setCriticalStripPreset(preset) {
            if (preset === 'standard') {
                document.getElementById('criticalMaxR').value = 100;
                document.getElementById('criticalStep').value = 2;
            } else if (preset === 'detailed') {
                document.getElementById('criticalMaxR').value = 150;
                document.getElementById('criticalStep').value = 1;
            } else if (preset === 'wide') {
                document.getElementById('criticalMaxR').value = 200;
                document.getElementById('criticalStep').value = 5;
            }
            updateCriticalStrip();
        }

        function updateCriticalStrip() {
            const maxR = parseInt(document.getElementById('criticalMaxRinput').value) || parseInt(document.getElementById('criticalMaxR').value);
            const step = parseInt(document.getElementById('criticalStep').value);
            const pointSize = parseInt(document.getElementById('criticalPS').value);
            
            document.getElementById('criticalMaxRv').textContent = maxR;
            document.getElementById('criticalStepv').textContent = step;
            document.getElementById('criticalPSv').textContent = pointSize;
            document.getElementById('criticalMaxR').value = Math.min(maxR, 200);
            document.getElementById('criticalMaxRinput').value = maxR;
            
            const showCriticalLine = document.getElementById('showCriticalLine').checked;
            const showStripBounds = document.getElementById('showStripBounds').checked;
            const colorByMagnitude = document.getElementById('colorByMagnitude').checked;
            
            document.getElementById('loadCritical').classList.add('active');
            
            setTimeout(() => {
                const canvas = document.getElementById('criticalCanvas');
                const ctx = canvas.getContext('2d');
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                // Setup coordinate system
                const padding = 80;
                const plotWidth = canvas.width - 2*padding;
                const plotHeight = canvas.height - 2*padding;
                
                // Real axis: 0 to 1, Imaginary axis: centered
                const reMin = 0, reMax = 1;
                
                // Collect error data
                const errorData = [];
                let maxAbsError = 0, sumAbsError = 0, positiveCount = 0, negativeCount = 0;
                
                for (let R = step; R <= maxR; R += step) {
                    // Calculate actual primitive count (approximate for large R)
                    let actualPrimitive = 0;
                    if (R <= 50) {
                        for (let x = -R; x <= R; x++) {
                            for (let y = -R; y <= R; y++) {
                                if (x*x + y*y <= R*R && gcd(Math.abs(x), Math.abs(y)) === 1) {
                                    actualPrimitive++;
                                }
                            }
                        }
                    } else {
                        // Use approximation for large R
                        actualPrimitive = Math.round(Math.PI * R * R / zeta(2));
                    }
                    
                    const predicted = Math.PI * R * R / zeta(2);
                    const error = actualPrimitive - predicted;
                    
                    maxAbsError = Math.max(maxAbsError, Math.abs(error));
                    sumAbsError += Math.abs(error);
                    if (error > 0) positiveCount++;
                    if (error < 0) negativeCount++;
                    
                    // Map to complex plane projection (simplified model)
                    // Real part: related to R^(1/2) oscillations
                    // Imaginary part: error normalized
                    const re = 0.5 + 0.3 * Math.sin(R / 10); // Oscillate around critical line
                    const im = error / (R * 0.5); // Normalize by sqrt(R) approximately
                    
                    errorData.push({ R, error, re, im, absError: Math.abs(error) });
                }
                
                // Find imaginary axis range
                const imValues = errorData.map(d => d.im);
                const imMin = Math.min(...imValues);
                const imMax = Math.max(...imValues);
                const imRange = Math.max(Math.abs(imMin), Math.abs(imMax));
                
                // Draw axes
                ctx.strokeStyle = getComputedStyle(document.body).getPropertyValue('--text2');
                ctx.lineWidth = 2;
                
                // Real axis (horizontal)
                ctx.beginPath();
                ctx.moveTo(padding, canvas.height/2);
                ctx.lineTo(canvas.width - padding, canvas.height/2);
                ctx.stroke();
                
                // Imaginary axis (vertical)
                ctx.beginPath();
                ctx.moveTo(padding + plotWidth/2, padding);
                ctx.lineTo(padding + plotWidth/2, canvas.height - padding);
                ctx.stroke();
                
                // Draw strip boundaries
                if (showStripBounds) {
                    ctx.strokeStyle = 'rgba(220, 53, 69, 0.5)';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([5, 5]);
                    
                    // Re = 0
                    const x0 = padding;
                    ctx.beginPath();
                    ctx.moveTo(x0, padding);
                    ctx.lineTo(x0, canvas.height - padding);
                    ctx.stroke();
                    
                    // Re = 1
                    const x1 = canvas.width - padding;
                    ctx.beginPath();
                    ctx.moveTo(x1, padding);
                    ctx.lineTo(x1, canvas.height - padding);
                    ctx.stroke();
                    
                    ctx.setLineDash([]);
                }
                
                // Draw critical line
                if (showCriticalLine) {
                    ctx.strokeStyle = 'rgba(111, 66, 193, 0.8)';
                    ctx.lineWidth = 3;
                    ctx.setLineDash([10, 5]);
                    
                    const xCritical = padding + plotWidth/2;
                    ctx.beginPath();
                    ctx.moveTo(xCritical, padding);
                    ctx.lineTo(xCritical, canvas.height - padding);
                    ctx.stroke();
                    
                    ctx.setLineDash([]);
                }
                
                // Draw error points
                errorData.forEach(d => {
                    const x = padding + (d.re - reMin) / (reMax - reMin) * plotWidth;
                    const y = canvas.height/2 - (d.im / (2*imRange)) * plotHeight;
                    
                    let color;
                    if (colorByMagnitude) {
                        const ratio = d.absError / maxAbsError;
                        const hue = 240 - ratio * 240; // Blue (low) to red (high)
                        color = `hsla(${hue}, 70%, 50%, 0.7)`;
                    } else {
                        color = d.error > 0 ? 'rgba(0, 102, 204, 0.6)' : 'rgba(220, 53, 69, 0.6)';
                    }
                    
                    ctx.fillStyle = color;
                    ctx.beginPath();
                    ctx.arc(x, y, pointSize, 0, 2*Math.PI);
                    ctx.fill();
                    
                    // Store for click detection
                    d.screenX = x;
                    d.screenY = y;
                });
                
                // Store data globally for click handling
                window.criticalStripData = errorData;
                
                // Labels
                ctx.fillStyle = getComputedStyle(document.body).getPropertyValue('--text');
                ctx.font = '14px system-ui';
                ctx.textAlign = 'center';
                
                // Real axis labels
                ctx.fillText('Re(s) = 0', padding, canvas.height - padding + 30);
                ctx.fillText('Re(s) = 1/2', canvas.width/2, canvas.height - padding + 30);
                ctx.fillText('Re(s) = 1', canvas.width - padding, canvas.height - padding + 30);
                
                // Imaginary axis labels
                ctx.save();
                ctx.translate(padding - 50, canvas.height/2);
                ctx.rotate(-Math.PI/2);
                ctx.fillText('Im (Error normalized)', 0, 0);
                ctx.restore();
                
                // Update stats
                const avgError = errorData.length > 0 ? sumAbsError / errorData.length : 0;
                document.getElementById('criticalPoints').textContent = errorData.length;
                animateValue('criticalMaxErr', 0, maxAbsError);
                animateValue('criticalAvgErr', 0, avgError);
                document.getElementById('criticalPositive').textContent = positiveCount;
                document.getElementById('criticalNegative').textContent = negativeCount;
                
                document.getElementById('loadCritical').classList.remove('active');
            }, 100);
        }

        function exportCriticalData() {
            if (!window.criticalStripData) { alert('Generate critical strip projection first'); return; }
            let csv = 'radius,error,real_part,imaginary_part,abs_error\n';
            window.criticalStripData.forEach(d => {
                csv += `${d.R},${d.error},${d.re},${d.im},${d.absError}\n`;
            });
            downloadCSV(csv, 'critical-strip-data.csv');
        }

        // Init
        updateTheory();
        const tb = document.getElementById('tbl');
        for (let k = 2; k <= 12; k++) {
            const z = zeta(k);
            const v = k % 2 === 0 ? 
                (Math.PI**(k/2) / factorial(k/2)).toFixed(4) :
                (2 * factorial((k-1)/2) * Math.PI**((k-1)/2) / factorial(k)).toFixed(4);
            tb.innerHTML += `<tr><td>${k}</td><td>${z.toFixed(4)}</td><td>${(1/z).toFixed(4)}</td><td>${v}</td></tr>`;
        }
        
        document.getElementById('helpModal').addEventListener('click', e => {
            if (e.target.id === 'helpModal') closeHelp();
        });
        
        // Add click handlers for interactive canvases
        document.getElementById('heatmapCanvas').addEventListener('click', function(e) {
            const rect = this.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            // Find closest point
            let closestPoint = null;
            let minDist = Infinity;
            
            heatmapPointsData.forEach(pt => {
                const dist = Math.sqrt((x - pt.screenX)**2 + (y - pt.screenY)**2);
                if (dist < minDist && dist < 15) {
                    minDist = dist;
                    closestPoint = pt;
                }
            });
            
            if (closestPoint) {
                const factors = primeFactors(closestPoint.gcd);
                const fc = {};
                factors.forEach(p => fc[p] = (fc[p]||0) + 1);
                const factorStr = Object.entries(fc).map(([p,c]) => c>1 ? `${p}^${c}` : p).join(' × ');
                
                const isPrimitive = closestPoint.gcd === 1;
                const reducedX = closestPoint.x / closestPoint.gcd;
                const reducedY = closestPoint.y / closestPoint.gcd;
                
                const infoDiv = document.getElementById('pointInfo');
                infoDiv.classList.add('point-info-active');
                setTimeout(() => infoDiv.classList.remove('point-info-active'), 500);
                
                infoDiv.innerHTML = `
                    <h3 style="color:var(--blue); margin-bottom:15px;">Point: (${closestPoint.x}, ${closestPoint.y})</h3>
                    <div style="display:grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap:15px;">
                        <div>
                            <p><b>GCD:</b> ${closestPoint.gcd}</p>
                            <p><b>Prime factorization:</b> ${factorStr || '1'}</p>
                            <p><b>Distance:</b> ${closestPoint.dist.toFixed(4)}</p>
                        </div>
                        <div>
                            <p><b>Type:</b> <span style="color:${isPrimitive ? 'var(--green)' : 'var(--red)'}">${isPrimitive ? '✓ Primitive' : '✗ Non-Primitive'}</span></p>
                            ${!isPrimitive ? `<p><b>Reduced form:</b> (${reducedX}, ${reducedY})</p>` : ''}
                            ${!isPrimitive ? `<p><b>Relationship:</b> ${closestPoint.gcd} × (${reducedX}, ${reducedY})</p>` : ''}
                        </div>
                    </div>
                `;
            }
        });
        
        document.getElementById('criticalCanvas').addEventListener('click', function(e) {
            if (!window.criticalStripData) return;
            
            const rect = this.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            // Find closest point
            let closestPoint = null;
            let minDist = Infinity;
            
            window.criticalStripData.forEach(d => {
                const dist = Math.sqrt((x - d.screenX)**2 + (y - d.screenY)**2);
                if (dist < minDist && dist < 20) {
                    minDist = dist;
                    closestPoint = d;
                }
            });
            
            if (closestPoint) {
                const predicted = (Math.PI * closestPoint.R * closestPoint.R / zeta(2)).toFixed(2);
                const actual = (parseFloat(predicted) + closestPoint.error).toFixed(2);
                const errorPercent = ((Math.abs(closestPoint.error) / parseFloat(predicted)) * 100).toFixed(4);
                
                const infoDiv = document.getElementById('criticalPointInfo');
                infoDiv.classList.add('point-info-active');
                setTimeout(() => infoDiv.classList.remove('point-info-active'), 500);
                
                infoDiv.innerHTML = `
                    <h3 style="color:var(--blue); margin-bottom:15px;">Radius R = ${closestPoint.R}</h3>
                    <div style="display:grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap:15px;">
                        <div>
                            <p><b>Predicted N(R):</b> ${predicted}</p>
                            <p><b>Actual N(R):</b> ${actual}</p>
                            <p><b>Error Δ(R):</b> <span style="color:${closestPoint.error > 0 ? 'var(--green)' : 'var(--red)'}">${closestPoint.error > 0 ? '+' : ''}${closestPoint.error.toFixed(2)}</span></p>
                        </div>
                        <div>
                            <p><b>Relative Error:</b> ${errorPercent}%</p>
                            <p><b>Complex projection:</b></p>
                            <p>Re(s) ≈ ${closestPoint.re.toFixed(4)}</p>
                            <p>Im (normalized) ≈ ${closestPoint.im.toFixed(4)}</p>
                        </div>
                    </div>
                    <div style="margin-top:15px; padding:10px; background:var(--bg); border-radius:6px;">
                        <p style="font-size:0.9em; color:var(--text2);">
                            <b>Note:</b> ${closestPoint.error > 0 ? 'Positive error indicates more primitive points than predicted.' : 'Negative error indicates fewer primitive points than predicted.'}
                            The error oscillates around zero as R increases, consistent with RH predictions.
                        </p>
                    </div>
                `;
            }
        });
    </script>
</body>
    </html>


<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Primitive Lattice Point Theory</title>
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        :root {
            --bg: #1a1a1a; --bg2: #2d2d2d; --bg3: #3a3a3a; --text: #e0e0e0; --text2: #b0b0b0;
            --border: #4a4a4a; --blue: #0066cc; --purple: #6f42c1; --green: #28a745; --red: #dc3545;
            --yellow: #ffc107; --orange: #fd7e14;
        }
        body.light { --bg: #fff; --bg2: #f8f9fa; --bg3: #e9ecef; --text: #212529; --text2: #495057; --border: #dee2e6; }
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: system-ui; background: var(--bg); color: var(--text); line-height: 1.6; }
        .container { max-width: 1400px; margin: 0 auto; padding: 20px; }
        .header { text-align: center; padding: 40px 20px; background: linear-gradient(135deg, var(--blue), var(--purple)); color: white; border-radius: 12px; margin-bottom: 30px; }
        .header h1 { font-size: 2.5rem; margin-bottom: 10px; }
        .tabs { display: flex; gap: 5px; margin-bottom: 30px; background: var(--bg2); padding: 10px; border-radius: 12px; flex-wrap: wrap; }
        .tab-btn { flex: 1; min-width: 120px; padding: 12px 20px; border: none; background: var(--bg3); color: var(--text); cursor: pointer; border-radius: 8px; font-weight: 600; transition: all 0.3s; }
        .tab-btn:hover, .tab-btn.active { background: var(--blue); color: white; }
        .controls button.active { background: var(--purple); }
        select, input[type="number"], input[type="text"] { font-size: 1em; padding: 8px; border-radius: 6px; border: 1px solid var(--border); background: var(--bg); color: var(--text); }
        .panel { display: none; }
        .panel.active { display: block; }
        .section { background: var(--bg2); padding: 30px; border-radius: 12px; margin-bottom: 30px; }
        .section h2 { color: var(--blue); margin-bottom: 20px; }
        .controls { margin: 20px 0; padding: 20px; background: var(--bg3); border-radius: 8px; }
        .controls label { display: block; margin: 10px 0; font-weight: 600; }
        .controls input[type="range"] { width: 100%; }
        .controls button { padding: 10px 20px; background: var(--blue); color: white; border: none; border-radius: 6px; cursor: pointer; margin: 5px; }
        .controls button:hover { background: var(--purple); }
        .slider-row { display: flex; gap: 10px; align-items: center; margin-bottom: 10px; }
        .slider-row input[type="range"] { flex: 1; }
        .slider-row input[type="number"] { width: 80px; }
        .stats { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; margin: 20px 0; }
        .stat { background: var(--bg3); padding: 20px; border-radius: 8px; text-align: center; }
        .stat .val { font-size: 2rem; font-weight: bold; color: var(--blue); }
        .stat .lbl { font-size: 0.9rem; color: var(--text2); }
        canvas { border: 2px solid var(--border); border-radius: 8px; display: block; margin: 20px auto; max-width: 100%; }
        #c3d { width: 100%; height: 800px; cursor: grab; }
        table { width: 100%; border-collapse: collapse; margin: 20px 0; overflow-x: auto; display: block; }
        th, td { padding: 12px; text-align: left; border-bottom: 1px solid var(--border); }
        th { background: var(--bg3); color: var(--blue); }
        .btn-fixed { position: fixed; bottom: 20px; padding: 12px 24px; border: none; border-radius: 25px; cursor: pointer; font-weight: 600; z-index: 1000; color: white; }
        #darkBtn { right: 20px; background: var(--blue); }
        #helpBtn { right: 140px; background: var(--green); }
        .formula { background: var(--bg3); padding: 20px; border-left: 4px solid var(--blue); border-radius: 8px; margin: 20px 0; }
        .warning { background: #3d3106; color: #ffc107; padding: 15px; border-left: 4px solid var(--yellow); border-radius: 8px; margin: 20px 0; }
        body.light .warning { background: #fff3cd; color: #856404; }
        .loading { display: none; text-align: center; padding: 20px; }
        .loading.active { display: block; }
        .spinner { border: 4px solid var(--border); border-top: 4px solid var(--blue); border-radius: 50%; width: 40px; height: 40px; animation: spin 1s linear infinite; margin: 20px auto; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        .compare-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 20px; }
        .compare-item { background: var(--bg3); padding: 15px; border-radius: 8px; }
        .modal { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); z-index: 2000; align-items: center; justify-content: center; }
        .modal.active { display: flex; }
        .modal-content { background: var(--bg); padding: 30px; border-radius: 12px; max-width: 600px; max-height: 80vh; overflow-y: auto; position: relative; }
        .modal-close { position: absolute; top: 10px; right: 10px; font-size: 24px; cursor: pointer; color: var(--text2); }
        .data-table-container { max-height: 400px; overflow-y: auto; }
        @media (max-width: 768px) {
            .header h1 { font-size: 1.8rem; }
            .tabs { flex-direction: column; }
            .tab-btn { min-width: 100%; }
            #c3d { height: 500px; }
        }
    </style>
</head>
<body>
    <div class="container">
        <header class="header">
            <h1>Primitive Lattice Point Theory</h1>
            <p>A Computational Framework for Boundary Cancellation Analysis</p>
            <p style="margin-top:10px; font-size:0.9rem">By Wessen Getachew | <a href="https://twitter.com/7dview" style="color:white">@7dview</a></p>
        </header>

        <nav class="tabs">
            <button class="tab-btn active" onclick="showTab('theory')">Theory</button>
            <button class="tab-btn" onclick="showTab('viz2d')">2D Viz</button>
            <button class="tab-btn" onclick="showTab('viz3d')">3D Viz</button>
            <button class="tab-btn" onclick="showTab('gcdheatmap')">GCD Heatmap</button>
            <button class="tab-btn" onclick="showTab('gcdtable')">GCD Table</button>
            <button class="tab-btn" onclick="showTab('patterns')">Patterns</button>
            <button class="tab-btn" onclick="showTab('criticalstrip')">Critical Strip</button>
            <button class="tab-btn" onclick="showTab('comparison')">Compare</button>
            <button class="tab-btn" onclick="showTab('analysis')">Analysis</button>
            <button class="tab-btn" onclick="showTab('animation')">Animation</button>
            <button class="tab-btn" onclick="showTab('tools')">Tools</button>
            <button class="tab-btn" onclick="showTab('export')">Export</button>
        </nav>

        <!-- THEORY TAB -->
        <div id="theory" class="panel active">
            <div class="section">
                <h2>Core Formula</h2>
                <div class="formula" style="font-size:1.2em; text-align:center;">
                    $$N_k(R) = \frac{V_k R^k}{\zeta(k)} + O(R^{k-1})$$
                </div>
                <p>This connects geometry (sphere volume V_k), analysis (zeta function ζ(k)), and number theory (primitive lattice points).</p>
            </div>
            
            <div class="section">
                <h2>Interactive Explorer</h2>
                <div class="controls">
                    <label>Dimension k: <span id="tk">3</span></label>
                    <div class="slider-row">
                        <input type="range" id="tks" min="2" max="12" value="3" oninput="syncSlider('tks','tksInput','tk');updateTheory()">
                        <input type="number" id="tksInput" min="2" max="20" value="3" oninput="syncInput('tksInput','tks','tk');updateTheory()">
                    </div>
                    <label>Radius R: <span id="tr">50</span></label>
                    <div class="slider-row">
                        <input type="range" id="trs" min="10" max="500" value="50" step="10" oninput="syncSlider('trs','trsInput','tr');updateTheory()">
                        <input type="number" id="trsInput" min="1" max="1000" value="50" oninput="syncInput('trsInput','trs','tr');updateTheory()">
                    </div>
                </div>
                <div class="stats">
                    <div class="stat"><div class="val" id="sz">1.202</div><div class="lbl">ζ(k)</div></div>
                    <div class="stat"><div class="val" id="sp">4186</div><div class="lbl">Predicted N_k(R)</div></div>
                    <div class="stat"><div class="val" id="sd">0.832</div><div class="lbl">Density (1/ζ(k))</div></div>
                    <div class="stat"><div class="val" id="svol">523.6</div><div class="lbl">Sphere Volume</div></div>
                </div>
                <div class="data-table-container">
                    <table><thead><tr><th>k</th><th>ζ(k)</th><th>1/ζ(k)</th><th>V_k (unit)</th></tr></thead><tbody id="tbl"></tbody></table>
                </div>
            </div>
        </div>

        <!-- 2D VIZ TAB -->
        <div id="viz2d" class="panel">
            <div class="section">
                <h2>2D Lattice Visualization</h2>
                <div class="controls">
                    <label>Radius: <span id="r2v">20</span></label>
                    <div class="slider-row">
                        <input type="range" id="r2" min="1" max="200" value="20" oninput="syncSlider('r2','r2input','r2v');draw2D()">
                        <input type="number" id="r2input" min="1" max="1000" value="20" oninput="syncInput('r2input','r2','r2v');draw2D()">
                    </div>
                    <label>Point Size: <span id="psv">3</span></label>
                    <div class="slider-row">
                        <input type="range" id="ps" min="1" max="20" value="3" oninput="syncSlider('ps','psInput','psv');draw2D()">
                        <input type="number" id="psInput" min="1" max="30" value="3" oninput="syncInput('psInput','ps','psv');draw2D()">
                    </div>
                    <label>Zoom: <span id="zoom2Dv">100</span>%</label>
                    <div class="slider-row">
                        <input type="range" id="zoom2D" min="50" max="200" value="100" step="5" oninput="syncSlider('zoom2D','zoom2DInput','zoom2Dv');draw2D()">
                        <input type="number" id="zoom2DInput" min="25" max="400" value="100" oninput="syncInput('zoom2DInput','zoom2D','zoom2Dv');draw2D()">
                    </div>
                    <label>Modulus m (for mod coloring): <span id="mod2Dv">3</span></label>
                    <div class="slider-row">
                        <input type="range" id="mod2D" min="2" max="12" value="3" oninput="syncSlider('mod2D','mod2DInput','mod2Dv');draw2D()">
                        <input type="number" id="mod2DInput" min="2" max="100" value="3" oninput="syncInput('mod2DInput','mod2D','mod2Dv');draw2D()">
                    </div>
                    <div style="margin:15px 0;">
                        <button id="color2DPrimitive" class="active" onclick="setColorMode2D('primitive')">GCD=1 vs GCD>1</button>
                        <button id="color2DGCD" onclick="setColorMode2D('gcd')">By GCD</button>
                        <button id="color2DMod" onclick="setColorMode2D('mod')">By Mod m</button>
                    </div>
                    <button onclick="exportCanvas('c2d','2d-lattice')">Export Image</button>
                </div>
                <div class="loading" id="load2d"><div class="spinner"></div></div>
                <canvas id="c2d" width="1000" height="1000"></canvas>
                <div class="stats">
                    <div class="stat"><div class="val" id="p2">0</div><div class="lbl">Primitive Points</div></div>
                    <div class="stat"><div class="val" id="t2">0</div><div class="lbl">Total Points</div></div>
                    <div class="stat"><div class="val" id="d2">0%</div><div class="lbl">Density</div></div>
                    <div class="stat"><div class="val" id="e2">0</div><div class="lbl">|Pred - Actual|</div></div>
                </div>
            </div>
        </div>

        <!-- 3D VIZ TAB -->
        <div id="viz3d" class="panel">
            <div class="section">
                <h2>3D Lattice Visualization</h2>
                <div class="controls">
                    <label>Radius: <span id="r3v">10</span></label>
                    <div class="slider-row">
                        <input type="range" id="r3" min="1" max="30" value="10" oninput="syncSlider('r3','r3input','r3v');draw3D()">
                        <input type="number" id="r3input" min="1" max="50" value="10" oninput="syncInput('r3input','r3','r3v');draw3D()">
                    </div>
                    <label>Point Size: <span id="ps3v">0.6</span></label>
                    <div class="slider-row">
                        <input type="range" id="ps3" min="0.2" max="2" value="0.6" step="0.1" oninput="syncSlider('ps3','ps3Input','ps3v');draw3D()">
                        <input type="number" id="ps3Input" min="0.1" max="5" value="0.6" step="0.1" oninput="syncInput('ps3Input','ps3','ps3v');draw3D()">
                    </div>
                    <label>Camera Distance: <span id="zoom3Dv">86</span></label>
                    <div class="slider-row">
                        <input type="range" id="zoom3D" min="30" max="150" value="86" oninput="syncSlider('zoom3D','zoom3DInput','zoom3Dv');update3DZoom()">
                        <input type="number" id="zoom3DInput" min="20" max="300" value="86" oninput="syncInput('zoom3DInput','zoom3D','zoom3Dv');update3DZoom()">
                    </div>
                    <label>Modulus m: <span id="mod3Dv">3</span></label>
                    <div class="slider-row">
                        <input type="range" id="mod3D" min="2" max="12" value="3" oninput="syncSlider('mod3D','mod3DInput','mod3Dv');draw3D()">
                        <input type="number" id="mod3DInput" min="2" max="50" value="3" oninput="syncInput('mod3DInput','mod3D','mod3Dv');draw3D()">
                    </div>
                    <div style="margin:15px 0;">
                        <button id="colorPrimitive" class="active" onclick="setColorMode3D('primitive')">GCD=1 vs GCD>1</button>
                        <button id="colorGCD" onclick="setColorMode3D('gcd')">By GCD</button>
                        <button id="colorMod" onclick="setColorMode3D('mod')">By Mod m</button>
                        <button id="colorDistance" onclick="setColorMode3D('distance')">By Distance</button>
                    </div>
                    <button onclick="reset3D()">Reset View</button>
                    <button onclick="toggleRotation()">Auto-Rotate</button>
                </div>
                <div class="loading" id="load3d"><div class="spinner"></div></div>
                <div id="c3d"></div>
                <div class="stats">
                    <div class="stat"><div class="val" id="p3">0</div><div class="lbl">Primitive Points</div></div>
                    <div class="stat"><div class="val" id="t3">0</div><div class="lbl">Total Points</div></div>
                    <div class="stat"><div class="val" id="d3">0%</div><div class="lbl">Density</div></div>
                    <div class="stat"><div class="val" id="e3">0</div><div class="lbl">Error</div></div>
                </div>
            </div>
        </div>

        <!-- GCD HEATMAP TAB -->
        <div id="gcdheatmap" class="panel">
            <div class="section">
                <h2>GCD Heatmap</h2>
                <div class="controls">
                    <label>Radius: <span id="heatmapRv">25</span></label>
                    <div class="slider-row">
                        <input type="range" id="heatmapR" min="5" max="100" value="25" oninput="syncSlider('heatmapR','heatmapRinput','heatmapRv');updateGCDHeatmap()">
                        <input type="number" id="heatmapRinput" min="5" max="300" value="25" oninput="syncInput('heatmapRinput','heatmapR','heatmapRv');updateGCDHeatmap()">
                    </div>
                    <label>Point Size: <span id="heatmapPSv">4</span></label>
                    <div class="slider-row">
                        <input type="range" id="heatmapPS" min="2" max="10" value="4" oninput="syncSlider('heatmapPS','heatmapPSInput','heatmapPSv');updateGCDHeatmap()">
                        <input type="number" id="heatmapPSInput" min="1" max="20" value="4" oninput="syncInput('heatmapPSInput','heatmapPS','heatmapPSv');updateGCDHeatmap()">
                    </div>
                    <div style="margin:15px 0;">
                        <button id="heatmapGCD" class="active" onclick="setHeatmapMode('gcd')">By GCD</button>
                        <button id="heatmapPrimitive" onclick="setHeatmapMode('primitive')">Primitive Only</button>
                        <button id="heatmapGradient" onclick="setHeatmapMode('gradient')">Distance</button>
                    </div>
                    <button onclick="updateGCDHeatmap()">Refresh</button>
                    <button onclick="exportCanvas('heatmapCanvas','gcd-heatmap')">Export</button>
                </div>
                <canvas id="heatmapCanvas" width="1000" height="1000"></canvas>
                <div class="stats">
                    <div class="stat"><div class="val" id="heatmapTotal">0</div><div class="lbl">Total</div></div>
                    <div class="stat"><div class="val" id="heatmapPrim">0</div><div class="lbl">GCD=1</div></div>
                    <div class="stat"><div class="val" id="heatmapGCD2">0</div><div class="lbl">GCD=2</div></div>
                    <div class="stat"><div class="val" id="heatmapGCD3">0</div><div class="lbl">GCD=3</div></div>
                </div>
            </div>
        </div>

        <!-- GCD TABLE TAB -->
        <div id="gcdtable" class="panel">
            <div class="section">
                <h2>GCD Multiplication Table</h2>
                <div class="controls">
                    <label>Grid Size: <span id="gcdTableSizev">30</span></label>
                    <div class="slider-row">
                        <input type="range" id="gcdTableSize" min="5" max="100" value="30" oninput="syncSlider('gcdTableSize','gcdTableSizeInput','gcdTableSizev');updateGCDTable()">
                        <input type="number" id="gcdTableSizeInput" min="5" max="500" value="30" oninput="syncInput('gcdTableSizeInput','gcdTableSize','gcdTableSizev');updateGCDTable()">
                    </div>
                    <div style="margin:15px 0;">
                        <button id="gcdTableHeat" class="active" onclick="setGCDTableColor('heat')">Heat Map</button>
                        <button id="gcdTableDiscrete" onclick="setGCDTableColor('discrete')">Discrete</button>
                        <button id="gcdTablePrime" onclick="setGCDTableColor('prime')">Prime</button>
                    </div>
                    <label><input type="checkbox" id="showGCDValues" checked onchange="updateGCDTable()"> Show Values</label>
                    <label><input type="checkbox" id="highlightDiagonal" checked onchange="updateGCDTable()"> Highlight Diagonal</label>
                    <button onclick="updateGCDTable()">Refresh</button>
                    <button onclick="exportCanvas('gcdTableCanvas','gcd-table')">Export</button>
                </div>
                <canvas id="gcdTableCanvas" width="1000" height="1000"></canvas>
            </div>
        </div>

        <!-- PATTERNS TAB -->
        <div id="patterns" class="panel">
            <div class="section">
                <h2>Pattern Explorer</h2>
                <div class="controls">
                    <div style="margin-bottom:15px;">
                        <button id="patternModular" class="active" onclick="setPatternType('modular')">Modular</button>
                        <button id="patternAngular" onclick="setPatternType('angular')">Angular</button>
                        <button id="patternRadial" onclick="setPatternType('radial')">Radial</button>
                    </div>
                    
                    <div id="modularControls">
                        <label>Modulus m: <span id="patternModv">7</span></label>
                        <div class="slider-row">
                            <input type="range" id="patternMod" min="2" max="20" value="7" oninput="syncSlider('patternMod','patternModInput','patternModv');updatePatternViz()">
                            <input type="number" id="patternModInput" min="2" max="100" value="7" oninput="syncInput('patternModInput','patternMod','patternModv');updatePatternViz()">
                        </div>
                        <label>Radius: <span id="patternRv">30</span></label>
                        <div class="slider-row">
                            <input type="range" id="patternR" min="10" max="100" value="30" oninput="syncSlider('patternR','patternRInput','patternRv');updatePatternViz()">
                            <input type="number" id="patternRInput" min="10" max="300" value="30" oninput="syncInput('patternRInput','patternR','patternRv');updatePatternViz()">
                        </div>
                    </div>
                    
                    <div id="angularControls" style="display:none;">
                        <label>Sectors: <span id="numSectorsv">16</span></label>
                        <div class="slider-row">
                            <input type="range" id="numSectors" min="4" max="32" value="16" oninput="syncSlider('numSectors','numSectorsInput','numSectorsv');updatePatternViz()">
                            <input type="number" id="numSectorsInput" min="2" max="64" value="16" oninput="syncInput('numSectorsInput','numSectors','numSectorsv');updatePatternViz()">
                        </div>
                        <label>Radius: <span id="angularRv">40</span></label>
                        <div class="slider-row">
                            <input type="range" id="angularR" min="10" max="100" value="40" oninput="syncSlider('angularR','angularRInput','angularRv');updatePatternViz()">
                            <input type="number" id="angularRInput" min="10" max="300" value="40" oninput="syncInput('angularRInput','angularR','angularRv');updatePatternViz()">
                        </div>
                    </div>
                    
                    <div id="radialControls" style="display:none;">
                        <label>Shell Thickness: <span id="shellThickv">2</span></label>
                        <div class="slider-row">
                            <input type="range" id="shellThick" min="1" max="10" value="2" oninput="syncSlider('shellThick','shellThickInput','shellThickv');updatePatternViz()">
                            <input type="number" id="shellThickInput" min="1" max="20" value="2" oninput="syncInput('shellThickInput','shellThick','shellThickv');updatePatternViz()">
                        </div>
                        <label>Max Radius: <span id="radialMaxRv">60</span></label>
                        <div class="slider-row">
                            <input type="range" id="radialMaxR" min="20" max="100" value="60" oninput="syncSlider('radialMaxR','radialMaxRInput','radialMaxRv');updatePatternViz()">
                            <input type="number" id="radialMaxRInput" min="20" max="300" value="60" oninput="syncInput('radialMaxRInput','radialMaxR','radialMaxRv');updatePatternViz()">
                        </div>
                    </div>
                    
                    <button onclick="updatePatternViz()">Compute</button>
                </div>
                <canvas id="patternCanvas" width="1000" height="600"></canvas>
            </div>
        </div>

        <!-- CRITICAL STRIP TAB -->
        <div id="criticalstrip" class="panel">
            <div class="section">
                <h2>Critical Strip & Error Analysis</h2>
                <div class="controls">
                    <label>Max Radius: <span id="criticalMaxRv">100</span></label>
                    <div class="slider-row">
                        <input type="range" id="criticalMaxR" min="20" max="300" value="100" step="10" oninput="syncSlider('criticalMaxR','criticalMaxRinput','criticalMaxRv')">
                        <input type="number" id="criticalMaxRinput" min="20" max="500" value="100" oninput="syncInput('criticalMaxRinput','criticalMaxR','criticalMaxRv')">
                    </div>
                    <label>Step: <span id="criticalStepv">1</span></label>
                    <div class="slider-row">
                        <input type="range" id="criticalStep" min="1" max="10" value="1" oninput="syncSlider('criticalStep','criticalStepInput','criticalStepv')">
                        <input type="number" id="criticalStepInput" min="1" max="20" value="1" oninput="syncInput('criticalStepInput','criticalStep','criticalStepv')">
                    </div>
                    <div style="margin:15px 0;">
                        <button id="criticalAllPoints" class="active" onclick="setCriticalProblem('all')">All Points</button>
                        <button id="criticalPrimitive" onclick="setCriticalProblem('primitive')">Primitive Only</button>
                    </div>
                    <div style="margin:15px 0;">
                        <button id="criticalVizError" class="active" onclick="setCriticalViz('error')">Error</button>
                        <button id="criticalVizNormalized" onclick="setCriticalViz('normalized')">Normalized</button>
                        <button id="criticalVizBounds" onclick="setCriticalViz('bounds')">Bounds</button>
                    </div>
                    <label><input type="checkbox" id="showZeroLine" checked onchange="updateCriticalStrip()"> Zero Line</label>
                    <label><input type="checkbox" id="showRHBound" checked onchange="updateCriticalStrip()"> RH Bound</label>
                    <button onclick="updateCriticalStrip()">Compute</button>
                    <button onclick="exportCanvas('criticalCanvas','critical-strip')">Export</button>
                </div>
                <div class="loading" id="loadCritical"><div class="spinner"></div></div>
                <canvas id="criticalCanvas" width="1200" height="800"></canvas>
                <div class="stats">
                    <div class="stat"><div class="val" id="criticalPoints">0</div><div class="lbl">Data Points</div></div>
                    <div class="stat"><div class="val" id="criticalMaxErr">0</div><div class="lbl">Max |Δ(R)|</div></div>
                    <div class="stat"><div class="val" id="criticalAvgErr">0</div><div class="lbl">Avg |Δ(R)|</div></div>
                </div>
            </div>
        </div>

        <!-- COMPARISON TAB -->
        <div id="comparison" class="panel">
            <div class="section">
                <h2>Dimension Comparison</h2>
                <div class="controls">
                    <label>Radius: <span id="crv">15</span></label>
                    <div class="slider-row">
                        <input type="range" id="cr" min="1" max="100" value="15" oninput="syncSlider('cr','crinput','crv');updateComparison()">
                        <input type="number" id="crinput" min="1" max="500" value="15" oninput="syncInput('crinput','cr','crv');updateComparison()">
                    </div>
                    <p style="margin:15px 0;"><b>Dimensions:</b></p>
                    <div style="display:flex; gap:10px; flex-wrap:wrap;">
                        <label><input type="checkbox" id="compk2" checked onchange="updateComparison()"> k=2</label>
                        <label><input type="checkbox" id="compk3" checked onchange="updateComparison()"> k=3</label>
                        <label><input type="checkbox" id="compk4" checked onchange="updateComparison()"> k=4</label>
                        <label><input type="checkbox" id="compk5" checked onchange="updateComparison()"> k=5</label>
                        <label><input type="checkbox" id="compk6" onchange="updateComparison()"> k=6</label>
                    </div>
                    <button onclick="updateComparison()">Refresh</button>
                </div>
                <div class="compare-grid" id="compGrid"></div>
                <canvas id="compChart" width="800" height="400"></canvas>
            </div>
        </div>

        <!-- ANALYSIS TAB -->
        <div id="analysis" class="panel">
            <div class="section">
                <h2>Error Analysis</h2>
                <div class="controls">
                    <label>Dimension k: <span id="analysisKv">2</span></label>
                    <div class="slider-row">
                        <input type="range" id="analysisK" min="2" max="5" value="2" oninput="syncSlider('analysisK','analysisKInput','analysisKv')">
                        <input type="number" id="analysisKInput" min="2" max="10" value="2" oninput="syncInput('analysisKInput','analysisK','analysisKv')">
                    </div>
                    <label>Max Radius: <span id="mrv">100</span></label>
                    <div class="slider-row">
                        <input type="range" id="mr" min="10" max="300" value="100" step="5" oninput="syncSlider('mr','mrinput','mrv')">
                        <input type="number" id="mrinput" min="10" max="500" value="100" oninput="syncInput('mrinput','mr','mrv')">
                    </div>
                    <label>Min Radius: <span id="minrv">1</span></label>
                    <div class="slider-row">
                        <input type="range" id="minr" min="1" max="50" value="1" oninput="syncSlider('minr','minrInput','minrv')">
                        <input type="number" id="minrInput" min="1" max="100" value="1" oninput="syncInput('minrInput','minr','minrv')">
                    </div>
                    <div style="margin:15px 0;">
                        <label><input type="checkbox" id="showAbsError" checked> Absolute Error</label>
                        <label><input type="checkbox" id="showRelError" checked> Relative Error</label>
                        <label><input type="checkbox" id="showBoundary"> Boundary O(R^(k-1))</label>
                    </div>
                    <button onclick="runAnalysis()">Compute</button>
                </div>
                <div class="loading" id="loadAnalysis"><div class="spinner"></div></div>
                <canvas id="ch" width="1200" height="800"></canvas>
            </div>
        </div>

        <!-- ANIMATION TAB -->
        <div id="animation" class="panel">
            <div class="section">
                <h2>Animation Player</h2>
                <div class="controls">
                    <div style="margin-bottom:15px;">
                        <button id="animRadius" class="active" onclick="setAnimType('radius')">Radius Sweep</button>
                        <button id="animDimension" onclick="setAnimType('dimension')">Dimension Sweep</button>
                    </div>
                    
                    <div id="radiusAnimControls">
                        <label>Start R: <span id="animStartRv">5</span></label>
                        <div class="slider-row">
                            <input type="range" id="animStartR" min="1" max="100" value="5" oninput="syncSlider('animStartR','animStartRInput','animStartRv')">
                            <input type="number" id="animStartRInput" min="1" max="200" value="5" oninput="syncInput('animStartRInput','animStartR','animStartRv')">
                        </div>
                        <label>End R: <span id="animEndRv">50</span></label>
                        <div class="slider-row">
                            <input type="range" id="animEndR" min="5" max="200" value="50" oninput="syncSlider('animEndR','animEndRInput','animEndRv')">
                            <input type="number" id="animEndRInput" min="5" max="500" value="50" oninput="syncInput('animEndRInput','animEndR','animEndRv')">
                        </div>
                        <label>Dimension k: <span id="animKv">2</span></label>
                        <div class="slider-row">
                            <input type="range" id="animK" min="2" max="5" value="2" oninput="syncSlider('animK','animKInput','animKv')">
                            <input type="number" id="animKInput" min="2" max="10" value="2" oninput="syncInput('animKInput','animK','animKv')">
                        </div>
                    </div>
                    
                    <div id="dimensionAnimControls" style="display:none;">
                        <label>Start k: <span id="animStartDv">2</span></label>
                        <div class="slider-row">
                            <input type="range" id="animStartD" min="2" max="10" value="2" oninput="syncSlider('animStartD','animStartDInput','animStartDv')">
                            <input type="number" id="animStartDInput" min="2" max="12" value="2" oninput="syncInput('animStartDInput','animStartD','animStartDv')">
                        </div>
                        <label>End k: <span id="animEndDv">8</span></label>
                        <div class="slider-row">
                            <input type="range" id="animEndD" min="2" max="12" value="8" oninput="syncSlider('animEndD','animEndDInput','animEndDv')">
                            <input type="number" id="animEndDInput" min="2" max="15" value="8" oninput="syncInput('animEndDInput','animEndD','animEndDv')">
                        </div>
                        <label>Fixed R: <span id="animFixedRv">30</span></label>
                        <div class="slider-row">
                            <input type="range" id="animFixedR" min="10" max="100" value="30" oninput="syncSlider('animFixedR','animFixedRInput','animFixedRv')">
                            <input type="number" id="animFixedRInput" min="5" max="200" value="30" oninput="syncInput('animFixedRInput','animFixedR','animFixedRv')">
                        </div>
                    </div>
                    
                    <label>Speed (ms): <span id="animSpeedv">500</span></label>
                    <div class="slider-row">
                        <input type="range" id="animSpeed" min="50" max="2000" value="500" step="50" oninput="syncSlider('animSpeed','animSpeedInput','animSpeedv')">
                        <input type="number" id="animSpeedInput" min="50" max="5000" value="500" step="50" oninput="syncInput('animSpeedInput','animSpeed','animSpeedv')">
                    </div>
                    
                    <div style="text-align:center; margin:20px 0;">
                        <button id="playBtn" onclick="playAnimation()" style="background:var(--green);">▶ Play</button>
                        <button id="pauseBtn" onclick="pauseAnimation()" style="background:var(--yellow); display:none;">⏸ Pause</button>
                        <button id="stopBtn" onclick="stopAnimation()" style="background:var(--red); display:none;">⏹ Stop</button>
                    </div>
                    
                    <div id="animProgress" style="display:none;">
                        <div style="background:var(--bg); height:20px; border-radius:10px; overflow:hidden;">
                            <div id="animProgressBar" style="background:var(--blue); height:100%; width:0%;"></div>
                        </div>
                        <p style="text-align:center;"><span id="animCurrentStep">0</span> / <span id="animTotalSteps">0</span></p>
                    </div>
                </div>
                <canvas id="animCanvas" width="800" height="800"></canvas>
                <div class="stats" id="animStats">
                    <div class="stat"><div class="val" id="animParamVal">-</div><div class="lbl" id="animParamLabel">Value</div></div>
                    <div class="stat"><div class="val" id="animPrimCount">0</div><div class="lbl">Primitive</div></div>
                    <div class="stat"><div class="val" id="animTotalCount">0</div><div class="lbl">Total</div></div>
                    <div class="stat"><div class="val" id="animDensity">0%</div><div class="lbl">Density</div></div>
                </div>
            </div>
        </div>

        <!-- TOOLS TAB -->
        <div id="tools" class="panel">
            <div class="section">
                <h2>Mathematical Tools</h2>
                
                <h3>GCD Calculator</h3>
                <div class="controls">
                    <input type="text" id="gi" placeholder="12, 18, 24" style="width:100%; padding:10px; margin-bottom:10px;">
                    <button onclick="calcGCD()">Calculate</button>
                    <div id="gr" style="margin-top:15px;"></div>
                </div>

                <h3>Möbius Function μ(n)</h3>
                <div class="controls">
                    <input type="number" id="mi" placeholder="30" style="width:100%; padding:10px; margin-bottom:10px;" min="1">
                    <button onclick="calcMobius()">Calculate</button>
                    <div id="mr2" style="margin-top:15px;"></div>
                </div>

                <h3>Prime Factorization</h3>
                <div class="controls">
                    <input type="number" id="pi" placeholder="360" style="width:100%; padding:10px; margin-bottom:10px;" min="2">
                    <button onclick="calcPrime()">Factorize</button>
                    <div id="pr" style="margin-top:15px;"></div>
                </div>

                <h3>Point Search</h3>
                <div class="controls">
                    <input type="text" id="psi" placeholder="3, 4" style="width:100%; padding:10px; margin-bottom:10px;">
                    <button onclick="searchPoint()">Search</button>
                    <div id="psr" style="margin-top:15px;"></div>
                </div>
            </div>
        </div>

        <!-- EXPORT TAB -->
        <div id="export" class="panel">
            <div class="section">
                <h2>Export Center</h2>
                <div class="controls">
                    <label><b>Canvas:</b></label>
                    <select id="exportCanvas" style="width:100%; padding:10px; margin:10px 0;">
                        <option value="c2d">2D Lattice</option>
                        <option value="heatmapCanvas">GCD Heatmap</option>
                        <option value="gcdTableCanvas">GCD Table</option>
                        <option value="criticalCanvas">Critical Strip</option>
                        <option value="patternCanvas">Patterns</option>
                        <option value="ch">Error Analysis</option>
                        <option value="animCanvas">Animation</option>
                    </select>
                    
                    <label><b>Resolution:</b></label>
                    <div style="margin:10px 0;">
                        <button id="res2k" onclick="setExportRes('2k')">2K</button>
                        <button id="res4k" class="active" onclick="setExportRes('4k')">4K</button>
                        <button id="res8k" onclick="setExportRes('8k')">8K</button>
                    </div>
                    
                    <label><b>Title:</b></label>
                    <input type="text" id="exportTitle" placeholder="Primitive Lattice Points" style="width:100%; padding:10px; margin:5px 0;">
                    
                    <label><b>Subtitle:</b></label>
                    <input type="text" id="exportSubtitle" placeholder="R=100, k=2" style="width:100%; padding:10px; margin:5px 0;">
                    
                    <div style="margin:15px 0;">
                        <label><input type="checkbox" id="includeMetadata" checked> Include Metadata</label>
                        <label><input type="checkbox" id="includeTimestamp" checked> Timestamp</label>
                        <label><input type="checkbox" id="includeWatermark" checked> Watermark</label>
                    </div>
                    
                    <button onclick="performAdvancedExport()" style="background:var(--green);">Export with Metadata</button>
                </div>
            </div>
        </div>
    </div>

    <button class="btn-fixed" id="helpBtn" onclick="showHelp()">Help</button>
    <button class="btn-fixed" id="darkBtn" onclick="toggleDark()">Light</button>

    <div class="modal" id="helpModal">
        <div class="modal-content">
            <span class="modal-close" onclick="closeHelp()">&times;</span>
            <h2>Help</h2>
            <p>This platform visualizes primitive lattice points - points with coprime coordinates.</p>
            <h3>Key Formula</h3>
            <p>N_k(R) = V_k·R^k/ζ(k) + O(R^(k-1))</p>
            <h3>Features</h3>
            <ul>
                <li>2D/3D visualization with multiple coloring modes</li>
                <li>GCD heatmaps and multiplication tables</li>
                <li>Critical strip error analysis</li>
                <li>Dimension comparison tools</li>
                <li>Animation player for parameter sweeps</li>
                <li>High-resolution export up to 8K</li>
            </ul>
            <h3>Tips</h3>
            <ul>
                <li>All sliders have input boxes for precise values</li>
                <li>Click and drag to rotate 3D view</li>
                <li>Use Export tab for publication-quality images</li>
            </ul>
        </div>
    </div>

    <script>
        // Global state
        let scene, camera, renderer, chart, autoRotate = false;
        let colorMode2D = 'primitive', colorMode3D = 'primitive';
        let heatmapMode = 'gcd', gcdTableColorMode = 'heat';
        let patternType = 'modular', patternChart = null;
        let criticalProblem = 'all', criticalViz = 'error';
        let animationType = 'radius', animationRunning = false, animationPaused = false;
        let animationTimer = null, currentAnimStep = 0;
        let exportResolution = '4k';
        let comparisonChart = null;
        let heatmapPointsData = [];

        // Sync functions for slider-input pairs
        function syncSlider(sliderId, inputId, displayId) {
            const val = document.getElementById(sliderId).value;
            document.getElementById(inputId).value = val;
            document.getElementById(displayId).textContent = val;
        }
        
        function syncInput(inputId, sliderId, displayId) {
            const val = document.getElementById(inputId).value;
            const slider = document.getElementById(sliderId);
            slider.value = Math.min(Math.max(val, slider.min), slider.max);
            document.getElementById(displayId).textContent = val;
        }

        // Math functions
        function gcd(a, b) { a = Math.abs(a); b = Math.abs(b); while (b) [a, b] = [b, a % b]; return a; }
        function gcdArray(arr) { return arr.reduce((a, b) => gcd(a, b)); }
        function isPrime(n) { if (n < 2) return false; if (n === 2) return true; if (n % 2 === 0) return false; for (let i = 3; i <= Math.sqrt(n); i += 2) if (n % i === 0) return false; return true; }
        function primeFactors(n) { const f = []; let d = 2; while (n > 1) { while (n % d === 0) { f.push(d); n /= d; } d++; if (d * d > n && n > 1) { f.push(n); break; } } return f; }
        function mobius(n) { if (n === 1) return 1; const f = primeFactors(n), u = [...new Set(f)]; return f.length !== u.length ? 0 : Math.pow(-1, f.length); }
        function factorial(n) { if (n <= 1) return 1; let r = 1; for (let i = 2; i <= n; i++) r *= i; return r; }
        
        function zeta(k) {
            const vals = { 2: 1.6449340668, 3: 1.2020569032, 4: 1.0823232337, 5: 1.0369277551, 6: 1.0173430620, 7: 1.0083492774, 8: 1.0040773562, 9: 1.0020083928, 10: 1.0009945751, 11: 1.0004941886, 12: 1.0002460866 };
            return vals[k] || (1 + Math.pow(2, -k));
        }
        
        function sphereVolume(k, R) {
            if (k % 2 === 0) return Math.pow(Math.PI, k/2) / factorial(k/2) * Math.pow(R, k);
            let df = 1; for (let i = k; i >= 1; i -= 2) df *= i;
            return Math.pow(2, (k+1)/2) * Math.pow(Math.PI, (k-1)/2) / df * Math.pow(R, k);
        }

        // Tab navigation
        function showTab(id) {
            document.querySelectorAll('.panel').forEach(p => p.classList.remove('active'));
            document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
            document.getElementById(id).classList.add('active');
            event.target.classList.add('active');
            if (id === 'viz2d') draw2D();
            if (id === 'viz3d' && !scene) init3D();
            if (id === 'gcdheatmap') updateGCDHeatmap();
            if (id === 'gcdtable') updateGCDTable();
            if (id === 'patterns') updatePatternViz();
            if (id === 'criticalstrip') updateCriticalStrip();
            if (id === 'comparison') updateComparison();
        }

        // Theory tab
        function updateTheory() {
            const k = parseInt(document.getElementById('tksInput').value);
            const R = parseInt(document.getElementById('trsInput').value);
            const z = zeta(k), d = 1/z, vol = sphereVolume(k, R), pred = Math.round(vol / z);
            document.getElementById('sz').textContent = z.toFixed(6);
            document.getElementById('sd').textContent = d.toFixed(6);
            document.getElementById('sp').textContent = pred.toLocaleString();
            document.getElementById('svol').textContent = vol.toFixed(2);
        }

        // 2D Visualization
        function setColorMode2D(mode) {
            colorMode2D = mode;
            document.querySelectorAll('#color2DPrimitive, #color2DGCD, #color2DMod').forEach(b => b.classList.remove('active'));
            document.getElementById({primitive:'color2DPrimitive', gcd:'color2DGCD', mod:'color2DMod'}[mode]).classList.add('active');
            draw2D();
        }

        function draw2D() {
            const canvas = document.getElementById('c2d'), ctx = canvas.getContext('2d');
            const R = parseInt(document.getElementById('r2input').value);
            const sz = parseInt(document.getElementById('psInput').value);
            const zoom = parseInt(document.getElementById('zoom2DInput').value) / 100;
            const m = parseInt(document.getElementById('mod2DInput').value);
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            const cx = canvas.width/2, cy = canvas.height/2;
            const scale = (450/R) * zoom;
            
            ctx.strokeStyle = getComputedStyle(document.body).getPropertyValue('--border');
            ctx.lineWidth = 2;
            ctx.beginPath(); ctx.arc(cx, cy, R*scale, 0, 2*Math.PI); ctx.stroke();
            
            let prim = 0, tot = 0;
            const gcdColors = ['#0066cc','#dc3545','#28a745','#ffc107','#6f42c1','#fd7e14','#00d4ff','#ff006e'];
            
            for (let x = -R; x <= R; x++) {
                for (let y = -R; y <= R; y++) {
                    if (x*x + y*y <= R*R) {
                        tot++;
                        const g = gcd(Math.abs(x), Math.abs(y));
                        if (g === 1) prim++;
                        
                        let color;
                        if (colorMode2D === 'primitive') color = g === 1 ? '#0066cc' : '#dc3545';
                        else if (colorMode2D === 'gcd') color = gcdColors[Math.min(g-1, 7)];
                        else color = `hsl(${((x+y)%m+m)%m / m * 360}, 70%, 50%)`;
                        
                        ctx.fillStyle = color;
                        ctx.beginPath();
                        ctx.arc(cx + x*scale, cy - y*scale, sz, 0, 2*Math.PI);
                        ctx.fill();
                    }
                }
            }
            
            const pred = Math.round(Math.PI * R * R / zeta(2));
            document.getElementById('p2').textContent = prim.toLocaleString();
            document.getElementById('t2').textContent = tot.toLocaleString();
            document.getElementById('d2').textContent = ((prim/tot)*100).toFixed(1) + '%';
            document.getElementById('e2').textContent = Math.abs(pred - prim);
        }

        // 3D Visualization
        function init3D() {
            const c = document.getElementById('c3d');
            scene = new THREE.Scene();
            scene.background = new THREE.Color(document.body.classList.contains('light') ? 0xffffff : 0x1a1a1a);
            camera = new THREE.PerspectiveCamera(75, c.clientWidth/800, 0.1, 1000);
            camera.position.set(50, 50, 50);
            camera.lookAt(0, 0, 0);
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(c.clientWidth, 800);
            c.appendChild(renderer.domElement);
            
            scene.add(new THREE.AmbientLight(0xffffff, 0.6));
            const dl = new THREE.DirectionalLight(0xffffff, 0.4);
            dl.position.set(1, 1, 1);
            scene.add(dl);
            scene.add(new THREE.AxesHelper(35));
            
            let mouseDown = false, prevMouse = {x:0, y:0};
            renderer.domElement.addEventListener('mousedown', e => { mouseDown = true; prevMouse = {x:e.clientX, y:e.clientY}; });
            renderer.domElement.addEventListener('mousemove', e => {
                if (mouseDown && !autoRotate) {
                    const dx = e.clientX - prevMouse.x, dy = e.clientY - prevMouse.y;
                    camera.position.applyAxisAngle(new THREE.Vector3(0,1,0), dx*0.005);
                    camera.position.applyAxisAngle(new THREE.Vector3(1,0,0).applyQuaternion(camera.quaternion), dy*0.005);
                    camera.lookAt(0,0,0);
                    prevMouse = {x:e.clientX, y:e.clientY};
                }
            });
            renderer.domElement.addEventListener('mouseup', () => mouseDown = false);
            renderer.domElement.addEventListener('mouseleave', () => mouseDown = false);
            
            draw3D();
            animate3D();
        }

        function setColorMode3D(mode) {
            colorMode3D = mode;
            document.querySelectorAll('#colorPrimitive, #colorGCD, #colorMod, #colorDistance').forEach(b => b.classList.remove('active'));
            document.getElementById({primitive:'colorPrimitive', gcd:'colorGCD', mod:'colorMod', distance:'colorDistance'}[mode]).classList.add('active');
            draw3D();
        }

        function draw3D() {
            if (!scene) return;
            while(scene.children.length > 3) scene.remove(scene.children[3]);
            
            const R = parseInt(document.getElementById('r3input').value);
            const pointSize = parseFloat(document.getElementById('ps3Input').value);
            const m = parseInt(document.getElementById('mod3DInput').value);
            
            const sg = new THREE.SphereGeometry(R, 32, 32);
            const sm = new THREE.MeshBasicMaterial({ color: 0x6f42c1, wireframe: true, transparent: true, opacity: 0.15 });
            scene.add(new THREE.Mesh(sg, sm));
            
            const pointsByColor = {};
            let prim = 0, tot = 0;
            const gcdColors = {1:0x0066cc, 2:0xdc3545, 3:0x28a745, 4:0xffc107, 5:0x6f42c1, 6:0xfd7e14, 7:0x00d4ff, 8:0xff006e};
            
            for (let x = -R; x <= R; x++) {
                for (let y = -R; y <= R; y++) {
                    for (let z = -R; z <= R; z++) {
                        if (x*x + y*y + z*z <= R*R) {
                            tot++;
                            const g = gcdArray([Math.abs(x), Math.abs(y), Math.abs(z)]);
                            if (g === 1) prim++;
                            
                            let colorKey;
                            if (colorMode3D === 'primitive') colorKey = g === 1 ? 'prim' : 'nonprim';
                            else if (colorMode3D === 'gcd') colorKey = `gcd${Math.min(g, 8)}`;
                            else if (colorMode3D === 'mod') colorKey = `mod${((x+y+z)%m+m)%m}`;
                            else colorKey = `dist${Math.floor(Math.sqrt(x*x+y*y+z*z)/(R/5))}`;
                            
                            if (!pointsByColor[colorKey]) pointsByColor[colorKey] = [];
                            pointsByColor[colorKey].push(x, y, z);
                        }
                    }
                }
            }
            
            const colorMap = {prim:0x0066cc, nonprim:0xdc3545, ...gcdColors};
            for (let i = 0; i < 12; i++) colorMap[`mod${i}`] = parseInt(`${(i*30).toString(16).padStart(2,'0')}66cc`, 16);
            for (let i = 0; i < 6; i++) colorMap[`dist${i}`] = [0x0066cc, 0x00d4ff, 0x28a745, 0xffc107, 0xfd7e14, 0xdc3545][i];
            
            Object.entries(pointsByColor).forEach(([key, positions]) => {
                if (positions.length > 0) {
                    const geometry = new THREE.BufferGeometry();
                    geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
                    const material = new THREE.PointsMaterial({ color: colorMap[key] || 0x999999, size: pointSize });
                    scene.add(new THREE.Points(geometry, material));
                }
            });
            
            const pred = Math.round(4 * Math.PI * R**3 / (3 * zeta(3)));
            document.getElementById('p3').textContent = prim.toLocaleString();
            document.getElementById('t3').textContent = tot.toLocaleString();
            document.getElementById('d3').textContent = ((prim/tot)*100).toFixed(1) + '%';
            document.getElementById('e3').textContent = Math.abs(pred - prim);
        }

        function animate3D() {
            requestAnimationFrame(animate3D);
            if (renderer && scene && camera) {
                if (autoRotate) { camera.position.applyAxisAngle(new THREE.Vector3(0,1,0), 0.005); camera.lookAt(0,0,0); }
                renderer.render(scene, camera);
            }
        }

        function reset3D() { if (camera) { camera.position.set(50, 50, 50); camera.lookAt(0, 0, 0); } }
        function toggleRotation() { autoRotate = !autoRotate; event.target.textContent = autoRotate ? 'Stop Rotation' : 'Auto-Rotate'; }
        function update3DZoom() {
            if (!camera) return;
            const zoom = parseInt(document.getElementById('zoom3DInput').value);
            const dir = camera.position.clone().normalize();
            camera.position.copy(dir.multiplyScalar(zoom));
            camera.lookAt(0, 0, 0);
        }

        // GCD Heatmap
        function setHeatmapMode(mode) {
            heatmapMode = mode;
            document.querySelectorAll('#heatmapGCD, #heatmapPrimitive, #heatmapGradient').forEach(b => b.classList.remove('active'));
            document.getElementById({gcd:'heatmapGCD', primitive:'heatmapPrimitive', gradient:'heatmapGradient'}[mode]).classList.add('active');
            updateGCDHeatmap();
        }

        function updateGCDHeatmap() {
            const R = parseInt(document.getElementById('heatmapRinput').value);
            const pointSize = parseInt(document.getElementById('heatmapPSInput').value);
            const canvas = document.getElementById('heatmapCanvas'), ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            const cx = canvas.width/2, cy = canvas.height/2, scale = 450/R;
            ctx.strokeStyle = getComputedStyle(document.body).getPropertyValue('--border');
            ctx.beginPath(); ctx.arc(cx, cy, R*scale, 0, 2*Math.PI); ctx.stroke();
            
            heatmapPointsData = [];
            let counts = {total:0, gcd1:0, gcd2:0, gcd3:0};
            const gcdColors = {1:'#0066cc', 2:'#dc3545', 3:'#28a745', 4:'#ffc107', 5:'#6f42c1', 6:'#fd7e14'};
            
            for (let x = -R; x <= R; x++) {
                for (let y = -R; y <= R; y++) {
                    if (x*x + y*y <= R*R) {
                        counts.total++;
                        const g = gcd(Math.abs(x), Math.abs(y));
                        const dist = Math.sqrt(x*x + y*y);
                        if (g === 1) counts.gcd1++;
                        else if (g === 2) counts.gcd2++;
                        else if (g === 3) counts.gcd3++;
                        
                        let color;
                        if (heatmapMode === 'gcd') color = gcdColors[Math.min(g, 6)] || '#999';
                        else if (heatmapMode === 'primitive') color = g === 1 ? '#0066cc' : '#e0e0e0';
                        else color = `hsl(${240 - dist/R * 240}, 70%, 50%)`;
                        
                        ctx.fillStyle = color;
                        ctx.beginPath();
                        ctx.arc(cx + x*scale, cy - y*scale, pointSize, 0, 2*Math.PI);
                        ctx.fill();
                        
                        heatmapPointsData.push({x, y, gcd: g, dist, screenX: cx + x*scale, screenY: cy - y*scale});
                    }
                }
            }
            
            document.getElementById('heatmapTotal').textContent = counts.total.toLocaleString();
            document.getElementById('heatmapPrim').textContent = counts.gcd1.toLocaleString();
            document.getElementById('heatmapGCD2').textContent = counts.gcd2.toLocaleString();
            document.getElementById('heatmapGCD3').textContent = counts.gcd3.toLocaleString();
        }

        // GCD Table
        function setGCDTableColor(mode) {
            gcdTableColorMode = mode;
            document.querySelectorAll('#gcdTableHeat, #gcdTableDiscrete, #gcdTablePrime').forEach(b => b.classList.remove('active'));
            document.getElementById({heat:'gcdTableHeat', discrete:'gcdTableDiscrete', prime:'gcdTablePrime'}[mode]).classList.add('active');
            updateGCDTable();
        }

        function updateGCDTable() {
            const size = parseInt(document.getElementById('gcdTableSizeInput').value);
            const showValues = document.getElementById('showGCDValues').checked;
            const highlightDiag = document.getElementById('highlightDiagonal').checked;
            const canvas = document.getElementById('gcdTableCanvas'), ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            const cellSize = Math.min((canvas.width - 40) / size, 30);
            const startX = 40, startY = 40;
            
            for (let i = 1; i <= size; i++) {
                for (let j = 1; j <= size; j++) {
                    const val = gcd(i, j);
                    const x = startX + (j-1)*cellSize, y = startY + (i-1)*cellSize;
                    
                    let color;
                    if (gcdTableColorMode === 'heat') { const h = 240 - (val/size)*240; color = `hsl(${h}, 70%, 50%)`; }
                    else if (gcdTableColorMode === 'discrete') { const colors = ['#0066cc','#dc3545','#28a745','#ffc107','#6f42c1','#fd7e14','#00d4ff','#ff006e']; color = colors[Math.min(val-1, 7)]; }
                    else color = isPrime(val) ? '#6f42c1' : (val === 1 ? '#0066cc' : '#dc3545');
                    
                    ctx.fillStyle = color;
                    ctx.fillRect(x, y, cellSize, cellSize);
                    
                    if (highlightDiag && i === j) { ctx.strokeStyle = '#fff'; ctx.lineWidth = 2; ctx.strokeRect(x, y, cellSize, cellSize); }
                    ctx.strokeStyle = 'rgba(255,255,255,0.1)'; ctx.lineWidth = 1; ctx.strokeRect(x, y, cellSize, cellSize);
                    
                    if (showValues && cellSize > 12) {
                        ctx.fillStyle = '#fff';
                        ctx.font = `${Math.min(cellSize*0.4, 12)}px system-ui`;
                        ctx.textAlign = 'center';
                        ctx.fillText(val, x + cellSize/2, y + cellSize/2 + 4);
                    }
                }
            }
        }

        // Pattern Explorer
        function setPatternType(type) {
            patternType = type;
            document.querySelectorAll('#patternModular, #patternAngular, #patternRadial').forEach(b => b.classList.remove('active'));
            document.getElementById({modular:'patternModular', angular:'patternAngular', radial:'patternRadial'}[type]).classList.add('active');
            document.getElementById('modularControls').style.display = type === 'modular' ? 'block' : 'none';
            document.getElementById('angularControls').style.display = type === 'angular' ? 'block' : 'none';
            document.getElementById('radialControls').style.display = type === 'radial' ? 'block' : 'none';
            updatePatternViz();
        }

        function updatePatternViz() {
            const canvas = document.getElementById('patternCanvas'), ctx = canvas.getContext('2d');
            if (patternChart) patternChart.destroy();
            
            if (patternType === 'modular') {
                const m = parseInt(document.getElementById('patternModInput').value);
                const R = parseInt(document.getElementById('patternRInput').value);
                const counts = new Array(m).fill(0);
                let total = 0;
                
                for (let x = -R; x <= R; x++) {
                    for (let y = -R; y <= R; y++) {
                        if (x*x + y*y <= R*R && gcd(Math.abs(x), Math.abs(y)) === 1) {
                            counts[((x+y)%m+m)%m]++;
                            total++;
                        }
                    }
                }
                
                patternChart = new Chart(ctx, {
                    type: 'bar',
                    data: { labels: Array.from({length:m}, (_,i) => i), datasets: [{label: 'Count', data: counts, backgroundColor: 'rgba(0,102,204,0.6)'}] },
                    options: { responsive: true, plugins: { title: { display: true, text: `Modular Distribution mod ${m}` } } }
                });
            } else if (patternType === 'angular') {
                const sectors = parseInt(document.getElementById('numSectorsInput').value);
                const R = parseInt(document.getElementById('angularRInput').value);
                const counts = new Array(sectors).fill(0);
                
                for (let x = -R; x <= R; x++) {
                    for (let y = -R; y <= R; y++) {
                        if (x*x + y*y <= R*R && gcd(Math.abs(x), Math.abs(y)) === 1) {
                            const angle = Math.atan2(y, x) + Math.PI;
                            counts[Math.floor(angle / (2*Math.PI/sectors)) % sectors]++;
                        }
                    }
                }
                
                patternChart = new Chart(ctx, {
                    type: 'bar',
                    data: { labels: Array.from({length:sectors}, (_,i) => `${(i*360/sectors).toFixed(0)}°`), datasets: [{label: 'Count', data: counts, backgroundColor: Array.from({length:sectors}, (_,i) => `hsl(${i*360/sectors}, 70%, 50%)`)}] },
                    options: { responsive: true, plugins: { title: { display: true, text: 'Angular Distribution' } } }
                });
            } else {
                const thick = parseInt(document.getElementById('shellThickInput').value);
                const maxR = parseInt(document.getElementById('radialMaxRInput').value);
                const numShells = Math.floor(maxR / thick);
                const counts = [], radii = [];
                
                for (let i = 0; i < numShells; i++) {
                    radii.push((i+1)*thick);
                    let count = 0;
                    for (let x = -(i+1)*thick; x <= (i+1)*thick; x++) {
                        for (let y = -(i+1)*thick; y <= (i+1)*thick; y++) {
                            const d = x*x + y*y;
                            if (d > (i*thick)**2 && d <= ((i+1)*thick)**2 && gcd(Math.abs(x), Math.abs(y)) === 1) count++;
                        }
                    }
                    counts.push(count);
                }
                
                patternChart = new Chart(ctx, {
                    type: 'line',
                    data: { labels: radii, datasets: [{label: 'Primitive Points', data: counts, borderColor: '#0066cc', fill: true, backgroundColor: 'rgba(0,102,204,0.2)'}] },
                    options: { responsive: true, plugins: { title: { display: true, text: 'Radial Shell Distribution' } } }
                });
            }
        }

        // Critical Strip
        function setCriticalProblem(type) {
            criticalProblem = type;
            document.querySelectorAll('#criticalAllPoints, #criticalPrimitive').forEach(b => b.classList.remove('active'));
            document.getElementById(type === 'all' ? 'criticalAllPoints' : 'criticalPrimitive').classList.add('active');
            updateCriticalStrip();
        }

        function setCriticalViz(type) {
            criticalViz = type;
            document.querySelectorAll('#criticalVizError, #criticalVizNormalized, #criticalVizBounds').forEach(b => b.classList.remove('active'));
            document.getElementById({error:'criticalVizError', normalized:'criticalVizNormalized', bounds:'criticalVizBounds'}[type]).classList.add('active');
            updateCriticalStrip();
        }

        function updateCriticalStrip() {
            const maxR = parseInt(document.getElementById('criticalMaxRinput').value);
            const step = parseInt(document.getElementById('criticalStepInput').value);
            const showZero = document.getElementById('showZeroLine').checked;
            const showRH = document.getElementById('showRHBound').checked;
            
            document.getElementById('loadCritical').classList.add('active');
            
            setTimeout(() => {
                const canvas = document.getElementById('criticalCanvas'), ctx = canvas.getContext('2d');
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = document.body.classList.contains('light') ? '#fff' : '#1a1a1a';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                const data = [];
                let maxErr = 0, sumErr = 0;
                
                for (let R = step; R <= maxR; R += step) {
                    let actual = 0;
                    if (criticalProblem === 'all') {
                        if (R <= 150) { for (let x = -R; x <= R; x++) for (let y = -R; y <= R; y++) if (x*x + y*y <= R*R) actual++; }
                        else actual = Math.round(Math.PI * R * R);
                    } else {
                        if (R <= 80) { for (let x = -R; x <= R; x++) for (let y = -R; y <= R; y++) if (x*x + y*y <= R*R && gcd(Math.abs(x), Math.abs(y)) === 1) actual++; }
                        else actual = Math.round(Math.PI * R * R / zeta(2));
                    }
                    
                    const pred = criticalProblem === 'all' ? Math.PI * R * R : Math.PI * R * R / zeta(2);
                    const error = actual - pred;
                    maxErr = Math.max(maxErr, Math.abs(error));
                    sumErr += Math.abs(error);
                    data.push({R, error, absError: Math.abs(error), normalized: Math.abs(error)/Math.sqrt(R)});
                }
                
                const padding = {left: 80, right: 40, top: 60, bottom: 60};
                const plotW = canvas.width - padding.left - padding.right;
                const plotH = canvas.height - padding.top - padding.bottom;
                
                const mapX = R => padding.left + (R/maxR) * plotW;
                const yMax = criticalViz === 'bounds' ? maxErr * 1.2 : maxErr * 1.2;
                const yMin = criticalViz === 'error' ? -yMax : 0;
                const mapY = v => padding.top + plotH - ((v - yMin)/(yMax - yMin)) * plotH;
                
                // Grid
                ctx.strokeStyle = 'rgba(128,128,128,0.2)';
                for (let i = 0; i <= 10; i++) {
                    ctx.beginPath(); ctx.moveTo(padding.left, padding.top + i*plotH/10); ctx.lineTo(canvas.width - padding.right, padding.top + i*plotH/10); ctx.stroke();
                    ctx.beginPath(); ctx.moveTo(padding.left + i*plotW/10, padding.top); ctx.lineTo(padding.left + i*plotW/10, canvas.height - padding.bottom); ctx.stroke();
                }
                
                // Zero line
                if (showZero && criticalViz === 'error') {
                    ctx.strokeStyle = 'rgba(128,128,128,0.5)';
                    ctx.setLineDash([5,5]);
                    ctx.beginPath(); ctx.moveTo(padding.left, mapY(0)); ctx.lineTo(canvas.width - padding.right, mapY(0)); ctx.stroke();
                    ctx.setLineDash([]);
                }
                
                // RH bound
                if (showRH && criticalViz === 'bounds') {
                    ctx.strokeStyle = 'rgba(111,66,193,0.7)';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([10,5]);
                    ctx.beginPath();
                    for (let R = step; R <= maxR; R += step) {
                        const y = mapY(Math.sqrt(R) * 5);
                        if (R === step) ctx.moveTo(mapX(R), y);
                        else ctx.lineTo(mapX(R), y);
                    }
                    ctx.stroke();
                    ctx.setLineDash([]);
                }
                
                // Data points
                data.forEach(d => {
                    const x = mapX(d.R);
                    let y, color;
                    
                    if (criticalViz === 'error') { y = mapY(d.error); color = d.error > 0 ? 'rgba(0,102,204,0.7)' : 'rgba(220,53,69,0.7)'; }
                    else if (criticalViz === 'normalized') { y = mapY(d.normalized); color = 'rgba(0,102,204,0.7)'; }
                    else { y = mapY(d.absError); color = `hsl(${240 - d.absError/maxErr * 240}, 70%, 50%)`; }
                    
                    ctx.fillStyle = color;
                    ctx.beginPath(); ctx.arc(x, y, 4, 0, 2*Math.PI); ctx.fill();
                });
                
                // Axes labels
                ctx.fillStyle = getComputedStyle(document.body).getPropertyValue('--text');
                ctx.font = '14px system-ui';
                ctx.textAlign = 'center';
                ctx.fillText('Radius R', canvas.width/2, canvas.height - 15);
                ctx.save();
                ctx.translate(20, canvas.height/2);
                ctx.rotate(-Math.PI/2);
                ctx.fillText(criticalViz === 'error' ? 'Error Δ(R)' : criticalViz === 'normalized' ? 'Δ(R)/√R' : '|Δ(R)|', 0, 0);
                ctx.restore();
                
                // Title
                ctx.font = 'bold 18px system-ui';
                ctx.fillText(criticalProblem === 'all' ? 'Gauss Circle Problem' : 'Primitive Points Error', canvas.width/2, 30);
                
                document.getElementById('criticalPoints').textContent = data.length;
                document.getElementById('criticalMaxErr').textContent = maxErr.toFixed(2);
                document.getElementById('criticalAvgErr').textContent = (sumErr/data.length).toFixed(2);
                document.getElementById('loadCritical').classList.remove('active');
            }, 100);
        }

        // Comparison
        function updateComparison() {
            const R = parseInt(document.getElementById('crinput').value);
            const dims = [];
            for (let k = 2; k <= 6; k++) if (document.getElementById(`compk${k}`)?.checked) dims.push(k);
            
            const grid = document.getElementById('compGrid');
            grid.innerHTML = '';
            
            dims.forEach(k => {
                const z = zeta(k), vol = sphereVolume(k, R), pred = Math.round(vol / z);
                grid.innerHTML += `
                    <div class="compare-item">
                        <h3 style="color:var(--blue);">k = ${k}</h3>
                        <p><b>ζ(${k}):</b> ${z.toFixed(6)}</p>
                        <p><b>Density:</b> ${(100/z).toFixed(2)}%</p>
                        <p><b>Predicted:</b> ${pred.toLocaleString()}</p>
                        <p><b>Volume:</b> ${vol.toExponential(3)}</p>
                    </div>
                `;
            });
            
            // Update chart
            const canvas = document.getElementById('compChart'), ctx = canvas.getContext('2d');
            if (comparisonChart) comparisonChart.destroy();
            
            const data = dims.map(k => Math.round(sphereVolume(k, R) / zeta(k)));
            comparisonChart = new Chart(ctx, {
                type: 'bar',
                data: { labels: dims.map(k => `k=${k}`), datasets: [{label: `Primitive Points (R=${R})`, data, backgroundColor: dims.map((_, i) => `hsl(${i*60}, 70%, 50%)`)}] },
                options: { responsive: true, scales: { y: { type: 'logarithmic' } }, plugins: { title: { display: true, text: 'Dimension Comparison' } } }
            });
        }

        // Analysis
        function runAnalysis() {
            const k = parseInt(document.getElementById('analysisKInput').value);
            const maxR = parseInt(document.getElementById('mrinput').value);
            const minR = parseInt(document.getElementById('minrInput').value);
            const showAbs = document.getElementById('showAbsError').checked;
            const showRel = document.getElementById('showRelError').checked;
            const showBound = document.getElementById('showBoundary').checked;
            
            document.getElementById('loadAnalysis').classList.add('active');
            
            setTimeout(() => {
                const canvas = document.getElementById('ch'), ctx = canvas.getContext('2d');
                if (chart) chart.destroy();
                
                const labels = [], absErr = [], relErr = [], boundary = [];
                
                for (let R = minR; R <= maxR; R++) {
                    labels.push(R);
                    const vol = sphereVolume(k, R), pred = vol / zeta(k);
                    let actual = Math.round(pred); // Approximation for speed
                    
                    if (k === 2 && R <= 100) {
                        actual = 0;
                        for (let x = -R; x <= R; x++) for (let y = -R; y <= R; y++) if (x*x + y*y <= R*R && gcd(Math.abs(x), Math.abs(y)) === 1) actual++;
                    }
                    
                    const err = Math.abs(actual - pred);
                    absErr.push(err);
                    relErr.push(pred > 0 ? (err/pred)*100 : 0);
                    boundary.push(Math.pow(R, k-1));
                }
                
                const datasets = [];
                if (showAbs) datasets.push({label: 'Absolute Error', data: absErr, backgroundColor: 'rgba(220,53,69,0.6)', type: 'bar'});
                if (showRel) datasets.push({label: 'Relative Error %', data: relErr, borderColor: '#ffc107', type: 'line', yAxisID: 'y2'});
                if (showBound) datasets.push({label: `O(R^${k-1})`, data: boundary, borderColor: '#6f42c1', borderDash: [5,5], type: 'line'});
                
                chart = new Chart(ctx, {
                    type: 'bar',
                    data: { labels, datasets },
                    options: {
                        responsive: true,
                        scales: { y: { type: 'logarithmic' }, y2: { position: 'right', display: showRel } },
                        plugins: { title: { display: true, text: `Error Analysis (k=${k})` } }
                    }
                });
                
                document.getElementById('loadAnalysis').classList.remove('active');
            }, 100);
        }

        // Animation
        function setAnimType(type) {
            animationType = type;
            document.querySelectorAll('#animRadius, #animDimension').forEach(b => b.classList.remove('active'));
            document.getElementById(type === 'radius' ? 'animRadius' : 'animDimension').classList.add('active');
            document.getElementById('radiusAnimControls').style.display = type === 'radius' ? 'block' : 'none';
            document.getElementById('dimensionAnimControls').style.display = type === 'dimension' ? 'block' : 'none';
        }

        function playAnimation() {
            if (animationPaused) { animationPaused = false; continueAnimation(); return; }
            
            animationRunning = true;
            animationPaused = false;
            currentAnimStep = 0;
            
            document.getElementById('playBtn').style.display = 'none';
            document.getElementById('pauseBtn').style.display = 'inline-block';
            document.getElementById('stopBtn').style.display = 'inline-block';
            document.getElementById('animProgress').style.display = 'block';
            
            let start, end;
            if (animationType === 'radius') { start = parseInt(document.getElementById('animStartRInput').value); end = parseInt(document.getElementById('animEndRInput').value); }
            else { start = parseInt(document.getElementById('animStartDInput').value); end = parseInt(document.getElementById('animEndDInput').value); }
            
            document.getElementById('animTotalSteps').textContent = end - start + 1;
            runAnimationStep(start, end, 0);
        }

        function runAnimationStep(start, end, step) {
            if (!animationRunning || animationPaused) return;
            const current = start + step;
            if (current > end) { stopAnimation(); return; }
            
            drawAnimationFrame(current);
            
            const total = end - start + 1;
            document.getElementById('animProgressBar').style.width = ((step+1)/total*100) + '%';
            document.getElementById('animCurrentStep').textContent = step + 1;
            
            currentAnimStep = step + 1;
            const speed = parseInt(document.getElementById('animSpeedInput').value);
            animationTimer = setTimeout(() => runAnimationStep(start, end, step + 1), speed);
        }

        function drawAnimationFrame(val) {
            const canvas = document.getElementById('animCanvas'), ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = document.body.classList.contains('light') ? '#fff' : '#1a1a1a';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            const cx = canvas.width/2, cy = canvas.height/2;
            
            if (animationType === 'radius') {
                const R = val, k = parseInt(document.getElementById('animKInput').value);
                const scale = 350 / Math.max(R, 10);
                
                ctx.strokeStyle = getComputedStyle(document.body).getPropertyValue('--border');
                ctx.beginPath(); ctx.arc(cx, cy, R*scale, 0, 2*Math.PI); ctx.stroke();
                
                let prim = 0, tot = 0;
                for (let x = -R; x <= R; x++) {
                    for (let y = -R; y <= R; y++) {
                        if (x*x + y*y <= R*R) {
                            tot++;
                            const isPrim = gcd(Math.abs(x), Math.abs(y)) === 1;
                            if (isPrim) prim++;
                            ctx.fillStyle = isPrim ? '#0066cc' : '#dc3545';
                            ctx.beginPath(); ctx.arc(cx + x*scale, cy - y*scale, Math.max(2, 4-R/30), 0, 2*Math.PI); ctx.fill();
                        }
                    }
                }
                
                document.getElementById('animParamLabel').textContent = 'Radius R';
                document.getElementById('animParamVal').textContent = R;
                document.getElementById('animPrimCount').textContent = prim.toLocaleString();
                document.getElementById('animTotalCount').textContent = tot.toLocaleString();
                document.getElementById('animDensity').textContent = ((prim/tot)*100).toFixed(2) + '%';
                
                ctx.fillStyle = getComputedStyle(document.body).getPropertyValue('--text');
                ctx.font = 'bold 24px system-ui';
                ctx.textAlign = 'center';
                ctx.fillText(`R = ${R}`, cx, 40);
            } else {
                const k = val, R = parseInt(document.getElementById('animFixedRInput').value);
                const z = zeta(k), density = 1/z;
                
                // Draw bar chart
                const barW = 50, maxH = 400, baseY = 550;
                for (let d = 2; d <= val; d++) {
                    const h = (1/zeta(d)) * maxH;
                    const x = 100 + (d-2) * (barW + 20);
                    ctx.fillStyle = d === val ? '#0066cc' : `hsl(${(d-2)*40}, 60%, 50%)`;
                    ctx.fillRect(x, baseY - h, barW, h);
                    ctx.fillStyle = getComputedStyle(document.body).getPropertyValue('--text');
                    ctx.font = '14px system-ui';
                    ctx.textAlign = 'center';
                    ctx.fillText(`k=${d}`, x + barW/2, baseY + 20);
                    ctx.fillText(`${(100/zeta(d)).toFixed(1)}%`, x + barW/2, baseY - h - 10);
                }
                
                document.getElementById('animParamLabel').textContent = 'Dimension k';
                document.getElementById('animParamVal').textContent = k;
                document.getElementById('animPrimCount').textContent = Math.round(sphereVolume(k, R)/z).toLocaleString();
                document.getElementById('animTotalCount').textContent = Math.round(sphereVolume(k, R)).toLocaleString();
                document.getElementById('animDensity').textContent = (density*100).toFixed(2) + '%';
                
                ctx.fillStyle = getComputedStyle(document.body).getPropertyValue('--text');
                ctx.font = 'bold 24px system-ui';
                ctx.textAlign = 'center';
                ctx.fillText(`Dimension k = ${k}`, cx, 40);
            }
        }

        function continueAnimation() {
            let start, end;
            if (animationType === 'radius') { start = parseInt(document.getElementById('animStartRInput').value); end = parseInt(document.getElementById('animEndRInput').value); }
            else { start = parseInt(document.getElementById('animStartDInput').value); end = parseInt(document.getElementById('animEndDInput').value); }
            runAnimationStep(start, end, currentAnimStep);
        }

        function pauseAnimation() {
            animationPaused = true;
            if (animationTimer) clearTimeout(animationTimer);
            document.getElementById('pauseBtn').style.display = 'none';
            document.getElementById('playBtn').style.display = 'inline-block';
        }

        function stopAnimation() {
            animationRunning = false;
            animationPaused = false;
            if (animationTimer) clearTimeout(animationTimer);
            document.getElementById('playBtn').style.display = 'inline-block';
            document.getElementById('pauseBtn').style.display = 'none';
            document.getElementById('stopBtn').style.display = 'none';
            document.getElementById('animProgress').style.display = 'none';
        }

        // Tools
        function calcGCD() {
            const nums = document.getElementById('gi').value.split(',').map(n => parseInt(n.trim())).filter(n => !isNaN(n));
            if (nums.length < 2) { document.getElementById('gr').innerHTML = '<p style="color:var(--red)">Need 2+ numbers</p>'; return; }
            const g = gcdArray(nums);
            document.getElementById('gr').innerHTML = `<p><b>GCD(${nums.join(', ')}) = ${g}</b></p><p>${g === 1 ? '✓ Coprime' : '✗ Not Coprime'}</p>`;
        }

        function calcMobius() {
            const n = parseInt(document.getElementById('mi').value);
            if (!n || n < 1) return;
            const mu = mobius(n);
            const interp = mu === 0 ? 'Not square-free' : mu === 1 ? 'Even # of prime factors' : 'Odd # of prime factors';
            document.getElementById('mr2').innerHTML = `<p><b>μ(${n}) = ${mu}</b></p><p>${interp}</p>`;
        }

        function calcPrime() {
            const n = parseInt(document.getElementById('pi').value);
            if (!n || n < 2) return;
            const f = primeFactors(n);
            const fc = {}; f.forEach(p => fc[p] = (fc[p]||0) + 1);
            const fs = Object.entries(fc).map(([p,c]) => c > 1 ? `${p}^${c}` : p).join(' × ');
            document.getElementById('pr').innerHTML = `<p><b>${n} = ${fs}</b></p><p>${isPrime(n) ? '✓ Prime' : 'Composite'}</p>`;
        }

        function searchPoint() {
            const coords = document.getElementById('psi').value.split(',').map(n => parseInt(n.trim())).filter(n => !isNaN(n));
            if (coords.length < 2) { document.getElementById('psr').innerHTML = '<p style="color:var(--red)">Need 2+ coordinates</p>'; return; }
            const g = gcdArray(coords);
            document.getElementById('psr').innerHTML = `<p><b>Point: (${coords.join(', ')})</b></p><p>GCD = ${g}</p><p>${g === 1 ? '✓ Primitive' : '✗ Not Primitive'}</p>`;
        }

        // Export
        function setExportRes(res) {
            exportResolution = res;
            document.querySelectorAll('#res2k, #res4k, #res8k').forEach(b => b.classList.remove('active'));
            document.getElementById(`res${res}`).classList.add('active');
        }

        function exportCanvas(id, name) {
            const canvas = document.getElementById(id);
            const link = document.createElement('a');
            link.download = `${name}.png`;
            link.href = canvas.toDataURL();
            link.click();
        }

        function performAdvancedExport() {
            const canvasId = document.getElementById('exportCanvas').value;
            const source = document.getElementById(canvasId);
            if (!source) { alert('Generate visualization first'); return; }
            
            const dims = {2048: '2k', 3840: '4k', 7680: '8k'};
            const size = {2: 2048, 4: 3840, 8: 7680}[exportResolution[0]] || 3840;
            
            const exp = document.createElement('canvas');
            exp.width = size; exp.height = size;
            const ctx = exp.getContext('2d');
            
            ctx.fillStyle = document.body.classList.contains('light') ? '#fff' : '#1a1a1a';
            ctx.fillRect(0, 0, size, size);
            
            const title = document.getElementById('exportTitle').value || 'Primitive Lattice Points';
            const subtitle = document.getElementById('exportSubtitle').value;
            const includeTitle = document.getElementById('includeMetadata').checked;
            const includeTime = document.getElementById('includeTimestamp').checked;
            const includeWater = document.getElementById('includeWatermark').checked;
            
            const padding = size * 0.03;
            const titleH = includeTitle ? size * 0.1 : 0;
            
            // Draw source
            const scale = Math.min((size - 2*padding) / source.width, (size - titleH - 2*padding) / source.height);
            const sw = source.width * scale, sh = source.height * scale;
            ctx.drawImage(source, (size - sw)/2, titleH + padding, sw, sh);
            
            // Title
            if (includeTitle) {
                ctx.fillStyle = document.body.classList.contains('light') ? '#212529' : '#e0e0e0';
                ctx.font = `bold ${size * 0.035}px system-ui`;
                ctx.textAlign = 'center';
                ctx.fillText(title, size/2, size * 0.05);
                if (subtitle) {
                    ctx.font = `${size * 0.02}px system-ui`;
                    ctx.fillText(subtitle, size/2, size * 0.08);
                }
            }
            
            // Footer
            ctx.font = `${size * 0.015}px system-ui`;
            if (includeWater) { ctx.textAlign = 'left'; ctx.fillText('By Wessen Getachew | @7dview', padding, size - padding); }
            if (includeTime) { ctx.textAlign = 'right'; ctx.fillText(new Date().toLocaleString(), size - padding, size - padding); }
            
            const link = document.createElement('a');
            link.download = `${title.replace(/\s+/g, '-')}-${exportResolution}.png`;
            link.href = exp.toDataURL();
            link.click();
        }

        // UI
        function toggleDark() {
            document.body.classList.toggle('light');
            document.getElementById('darkBtn').textContent = document.body.classList.contains('light') ? 'Dark' : 'Light';
            if (scene) scene.background = new THREE.Color(document.body.classList.contains('light') ? 0xffffff : 0x1a1a1a);
        }

        function showHelp() { document.getElementById('helpModal').classList.add('active'); }
        function closeHelp() { document.getElementById('helpModal').classList.remove('active'); }

        // Init
        updateTheory();
        const tb = document.getElementById('tbl');
        for (let k = 2; k <= 12; k++) {
            const z = zeta(k), v = sphereVolume(k, 1);
            tb.innerHTML += `<tr><td>${k}</td><td>${z.toFixed(10)}</td><td>${(1/z).toFixed(10)}</td><td>${v.toFixed(6)}</td></tr>`;
        }
        document.getElementById('helpModal').addEventListener('click', e => { if (e.target.id === 'helpModal') closeHelp(); });
    </script>
</body>
    </html>

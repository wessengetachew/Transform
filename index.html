
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Primitive Lattice Point Theory</title>
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        :root {
            --bg: #1a1a1a; --bg2: #2d2d2d; --bg3: #3a3a3a; --text: #e0e0e0; --text2: #b0b0b0;
            --border: #4a4a4a; --blue: #0066cc; --purple: #6f42c1; --green: #28a745; --red: #dc3545;
            --yellow: #ffc107; --orange: #fd7e14;
        }
        body.light { --bg: #fff; --bg2: #f8f9fa; --bg3: #e9ecef; --text: #212529; --text2: #495057; --border: #dee2e6; }
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: system-ui; background: var(--bg); color: var(--text); line-height: 1.6; transition: background 0.3s, color 0.3s; }
        .container { max-width: 1400px; margin: 0 auto; padding: 20px; }
        .header { text-align: center; padding: 40px 20px; background: linear-gradient(135deg, var(--blue), var(--purple));
            color: white; border-radius: 12px; margin-bottom: 30px; position: relative; overflow: hidden; }
        .header::before { content: ''; position: absolute; top: -50%; left: -50%; width: 200%; height: 200%;
            background: radial-gradient(circle, rgba(255,255,255,0.1) 0%, transparent 70%); animation: pulse 4s infinite; }
        @keyframes pulse { 0%, 100% { transform: scale(1); } 50% { transform: scale(1.1); } }
        .header h1 { font-size: 2.5rem; margin-bottom: 10px; position: relative; z-index: 1; }
        .header p { position: relative; z-index: 1; }
        .tabs { display: flex; gap: 5px; margin-bottom: 30px; background: var(--bg2); padding: 10px; border-radius: 12px; flex-wrap: wrap; }
        .tab-btn { flex: 1; min-width: 120px; padding: 12px 20px; border: none; background: var(--bg3); color: var(--text);
            cursor: pointer; border-radius: 8px; font-weight: 600; transition: all 0.3s; }
        .tab-btn:hover { background: var(--blue); color: white; transform: translateY(-2px); }
        .tab-btn.active { background: var(--blue); color: white; box-shadow: 0 4px 12px rgba(0,102,204,0.3); }
        .controls button.active { background: var(--purple); }
        select { font-size: 1em; }
        .panel { display: none; animation: fadeIn 0.5s; }
        .panel.active { display: block; }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }
        .section { background: var(--bg2); padding: 30px; border-radius: 12px; margin-bottom: 30px; transition: all 0.3s; }
        .section:hover { box-shadow: 0 4px 20px rgba(0,0,0,0.1); }
        .section h2 { color: var(--blue); margin-bottom: 20px; display: flex; align-items: center; gap: 10px; }
        .help-icon { display: inline-block; width: 20px; height: 20px; background: var(--blue); color: white;
            border-radius: 50%; text-align: center; line-height: 20px; font-size: 12px; cursor: help; }
        .tooltip { position: relative; }
        .tooltip:hover::after { content: attr(data-tip); position: absolute; bottom: 125%; left: 50%;
            transform: translateX(-50%); padding: 8px 12px; background: var(--text); color: var(--bg);
            border-radius: 6px; white-space: nowrap; z-index: 1000; font-size: 12px; }
        .controls { margin: 20px 0; padding: 20px; background: var(--bg3); border-radius: 8px; }
        .controls label { display: block; margin: 10px 0; font-weight: 600; }
        .controls input[type="range"] { width: 100%; }
        .controls button { padding: 10px 20px; background: var(--blue); color: white; border: none;
            border-radius: 6px; cursor: pointer; margin: 5px; transition: all 0.3s; }
        .controls button:hover { background: var(--purple); transform: scale(1.05); }
        .controls button:disabled { background: var(--text2); cursor: not-allowed; transform: none; }
        .stats { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; margin: 20px 0; }
        .stat { background: var(--bg3); padding: 20px; border-radius: 8px; text-align: center; transition: all 0.3s; }
        .stat:hover { transform: translateY(-5px); box-shadow: 0 4px 12px rgba(0,0,0,0.15); }
        .stat .val { font-size: 2rem; font-weight: bold; color: var(--blue); transition: all 0.5s; }
        .stat .lbl { font-size: 0.9rem; color: var(--text2); }
        canvas { border: 2px solid var(--border); border-radius: 8px; display: block; margin: 20px auto; max-width: 100%; }
        #canvas3d, #c3d { width: 100%; height: 800px; cursor: grab; }
        #canvas3d:active, #c3d:active { cursor: grabbing; }
        table { width: 100%; border-collapse: collapse; margin: 20px 0; overflow-x: auto; display: block; }
        th, td { padding: 12px; text-align: left; border-bottom: 1px solid var(--border); }
        th { background: var(--bg3); color: var(--blue); font-weight: 600; position: sticky; top: 0; }
        .btn-fixed { position: fixed; bottom: 20px; padding: 12px 24px; border: none; border-radius: 25px;
            cursor: pointer; font-weight: 600; z-index: 1000; color: white; transition: all 0.3s; }
        .btn-fixed:hover { transform: translateY(-3px); box-shadow: 0 6px 20px rgba(0,0,0,0.3); }
        #darkBtn { right: 20px; background: var(--blue); }
        #helpBtn { right: 140px; background: var(--green); }
        .formula { background: var(--bg3); padding: 20px; border-left: 4px solid var(--blue); border-radius: 8px; margin: 20px 0; }
        .warning { background: #3d3106; color: #ffc107; padding: 15px; border-left: 4px solid var(--yellow); border-radius: 8px; margin: 20px 0; }
        body.light .warning { background: #fff3cd; color: #856404; }
        .loading { display: none; text-align: center; padding: 20px; }
        .loading.active { display: block; }
        .spinner { border: 4px solid var(--border); border-top: 4px solid var(--blue); border-radius: 50%;
            width: 40px; height: 40px; animation: spin 1s linear infinite; margin: 20px auto; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        .compare-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 20px; }
        .compare-item { background: var(--bg3); padding: 15px; border-radius: 8px; }
        .modal { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7);
            z-index: 2000; align-items: center; justify-content: center; }
        .modal.active { display: flex; }
        .modal-content { background: var(--bg); padding: 30px; border-radius: 12px; max-width: 600px; max-height: 80vh;
            overflow-y: auto; position: relative; }
        .modal-close { position: absolute; top: 10px; right: 10px; font-size: 24px; cursor: pointer; color: var(--text2); }
        .export-buttons { display: flex; gap: 10px; flex-wrap: wrap; }
        .data-table-container { max-height: 400px; overflow-y: auto; }
        .point-info-active { background: var(--bg3) !important; border: 2px solid var(--blue); animation: highlightPulse 0.5s ease; }
        @keyframes highlightPulse { 0%, 100% { transform: scale(1); } 50% { transform: scale(1.02); } }
        @media (max-width: 768px) {
            .header h1 { font-size: 1.8rem; }
            .tabs { flex-direction: column; }
            .tab-btn { min-width: 100%; }
            #canvas3d, #c3d { height: 500px; }
            .btn-fixed { padding: 10px 16px; font-size: 14px; }
            #helpBtn { right: 20px; bottom: 70px; }
        }
    </style>
</head>
<body>
    <div class="container">
        <header class="header">
            <h1>Primitive Lattice Point Theory</h1>
            <p>A Computational Framework for Boundary Cancellation Analysis</p>
            <p style="margin-top:10px; font-size:0.9rem">By Wessen Getachew | <a href="https://twitter.com/7dview" style="color:white">@7dview</a></p>
        </header>

        <nav class="tabs">
            <button class="tab-btn active" onclick="showTab('theory')">Theory</button>
            <button class="tab-btn" onclick="showTab('patterns')">Pattern Explorer</button>
            <button class="tab-btn" onclick="showTab('gcdheatmap')">GCD Heatmap</button>
            <button class="tab-btn" onclick="showTab('gcdtable')">GCD Table</button>
            <button class="tab-btn" onclick="showTab('criticalstrip')">Critical Strip</button>
            <button class="tab-btn" onclick="showTab('viz2d')">2D Viz</button>
            <button class="tab-btn" onclick="showTab('viz3d')">3D Viz</button>
            <button class="tab-btn" onclick="showTab('comparison')">Compare</button>
            <button class="tab-btn" onclick="showTab('analysis')">Analysis</button>
            <button class="tab-btn" onclick="showTab('tools')">Tools</button>
            <button class="tab-btn" onclick="showTab('explore')">Explore More</button>
            <button class="tab-btn" onclick="showTab('export')">Export</button>
            <button class="tab-btn" onclick="showTab('roadmap')">Roadmap</button>
            <button class="tab-btn" onclick="showTab('derivation')">Derivation</button>
        </nav>

        <div id="theory" class="panel active">
            <div class="section">
                <h2>Abstract</h2>
                <p>We develop a comprehensive study of primitive lattice points in Z^n, generalizing the classical 2-dimensional coprime lattice problem. Using geometric decomposition into primitive rays and the Möbius inversion formula, we rigorously derive the asymptotic density of coprime points in any dimension. The framework connects number theory, geometry of numbers, and classical constants like the Riemann zeta function, providing both intuition and formal proofs.</p>
            </div>
            
            <div class="section">
                <h2>Introduction</h2>
                <p>Counting lattice points inside a ball is a classical problem in number theory. Restricting to <i>primitive points</i>, i.e., points with coordinates coprime, leads to deep insights in analytic number theory and the geometry of numbers. In two dimensions, this relates to the Basel problem (ζ(2) = π²/6) and visible points from the origin. We extend the problem to arbitrary dimensions, n ≥ 2, developing both geometric intuition and rigorous algebraic derivation.</p>
            </div>
            
            <div class="section">
                <h2>Primitive Vectors and Rays in Z^n</h2>
                
                <div class="formula">
                    <h3 style="color:var(--blue); margin-bottom:10px;">Definition (Primitive Vector)</h3>
                    <p>A vector <b>v</b> = (a₁, ..., aₙ) ∈ Z^n \ {0} is called <i>primitive</i> if</p>
                    $$\gcd(a_1, \dots, a_n) = 1$$
                </div>
                
                <div class="formula">
                    <h3 style="color:var(--blue); margin-bottom:10px;">Lemma (Unique Ray Decomposition)</h3>
                    <p>Every nonzero lattice point <b>v</b> ∈ Z^n lies on a unique primitive ray:</p>
                    $$\mathbf{v} = k \mathbf{u}, \quad k \in \mathbb{N}, \ \mathbf{u} \text{ primitive}$$
                </div>
                
                <div class="formula">
                    <h3 style="color:var(--blue); margin-bottom:10px;">Proof</h3>
                    <p>Let d = gcd(a₁, ..., aₙ). Then <b>v</b> = d<b>u</b>, where <b>u</b> is primitive. Uniqueness follows from the uniqueness of the gcd.</p>
                    <p style="margin-top:10px; font-style:italic;">Each primitive vector acts as the "gatekeeper" for the entire ray of lattice points extending from the origin.</p>
                </div>
            </div>
            
            <div class="section">
                <h2>Counting Coprime Lattice Points</h2>
                <p>Let C_n(R) denote the number of primitive points inside the n-dimensional ball of radius R:</p>
                <div class="formula">$$C_n(R) = \#\{\mathbf{v} \in \mathbb{Z}^n : \|\mathbf{v}\|_2 \le R, \ \gcd(v_1,\dots,v_n)=1\}$$</div>
                
                <h3>Geometric Consideration</h3>
                <p>For a primitive vector <b>u</b>, the lattice points along its ray are</p>
                <div class="formula">$$\mathbf{v} = k \mathbf{u}, \quad 1 \le k \le \left\lfloor \frac{R}{\|\mathbf{u}\|_2} \right\rfloor$$</div>
                <p>Counting only the first point on each ray yields exactly C_n(R).</p>
                
                <h3>Asymptotic Density</h3>
                <p>The density of primitive points in Z^n equals the probability that n integers are coprime:</p>
                <div class="formula">$$\mathbb{P}(\gcd(a_1,\dots,a_n) = 1) = \frac{1}{\zeta(n)}$$</div>
                <p>Thus, the leading term for C_n(R) is</p>
                <div class="formula">$$C_n(R) \sim \frac{\operatorname{Vol}(B_n(R))}{\zeta(n)}$$</div>
                <p>where</p>
                <div class="formula">$$\operatorname{Vol}(B_n(R)) = \frac{\pi^{n/2}}{\Gamma(n/2+1)} R^n$$</div>
                <p>is the n-dimensional ball volume. The error term arises from the boundary: O(R^(n-1)).</p>
            </div>
            
            <div class="section">
                <h2>Boundary Cancellation Principle</h2>
                <p>The key insight is that non-primitive points (those sharing a common factor d > 1) can be expressed as d·(primitive point). Through Möbius inversion, we show that boundary contributions from non-primitive points cancel systematically, leaving only the volume term divided by ζ(k).</p>
                <div class="formula">$$N_k(R) = \sum_{d=1}^{R} \mu(d) \cdot |\{(x_1,...,x_k) : \sum x_i^2 \leq (R/d)^2\}|$$</div>
                <p style="margin-top:15px">The Möbius function μ(d) = (-1)^ω(d) for square-free d (where ω counts distinct prime factors) ensures alternating cancellation of boundary terms.</p>
            </div>
            
            <div class="section" style="background:linear-gradient(135deg, rgba(0,102,204,0.1), rgba(111,66,193,0.1)); border:3px solid var(--blue);">
                <h2 style="text-align:center; color:var(--blue);">Grand Result</h2>
                <div class="formula" style="font-size:1.2em; text-align:center; padding:20px;">
                    $$C_n(R) = \frac{\operatorname{Vol}(B_n(R))}{\zeta(n)} + O(R^{n-1}), \quad n \ge 2$$
                </div>
                <p style="text-align:center; font-style:italic; margin-top:15px;">This combines geometric intuition, rigorous number theory, and multi-dimensional generalization. It provides a unified framework for analyzing primitive lattice points in any dimension.</p>
            </div>
            
            <div class="section">
                <h2>Special Cases</h2>
                <div class="formula">
                    <p><b>Case n=1:</b> Only primitive points are ±1. ζ(1) diverges; density is zero.</p>
                </div>
                <div class="formula">
                    <p><b>2D Case (Classical):</b> Density: 1/ζ(2) = 6/π² ≈ 0.6079. Corresponds to "visible" points in the plane.</p>
                </div>
                <div class="formula">
                    <p><b>3D Case:</b> Density: 1/ζ(3) ≈ 0.832. Visualization: "particles in space," approximately 83% visible from the origin.</p>
                </div>
                <div class="formula">
                    <p><b>High Dimensions:</b> As n → ∞, ζ(n) → 1, so almost all points are primitive.</p>
                </div>
            </div>
            
            <div class="section">
                <h2>Geometric Interpretation</h2>
                <ul style="list-style-position: inside; margin-left:20px;">
                    <li>Primitive points correspond to points "visible" from the origin.</li>
                    <li>Non-primitive points are hidden behind their corresponding primitive vector.</li>
                    <li>This generalizes the 2D "light ray" visualization to higher dimensions.</li>
                    <li>Each primitive vector acts as a "gatekeeper" for its entire ray of multiples.</li>
                </ul>
            </div>

            <div class="section">
                <h2>Interactive Explorer <span class="help-icon tooltip" data-tip="Adjust parameters to see predictions">?</span></h2>
                <div class="controls">
                    <label>Dimension k: <span id="tk">3</span></label>
                    <input type="range" id="tks" min="2" max="12" value="3" oninput="updateTheory()">
                    <label>Radius R: <span id="tr">50</span></label>
                    <input type="range" id="trs" min="10" max="200" value="50" step="10" oninput="updateTheory()">
                    <button onclick="exportTheoryData()">Export Data</button>
                </div>
                <div class="stats">
                    <div class="stat"><div class="val" id="sz">1.202</div><div class="lbl">ζ(k)</div></div>
                    <div class="stat"><div class="val" id="sp">4186</div><div class="lbl">Predicted N_k(R)</div></div>
                    <div class="stat"><div class="val" id="sd">0.832</div><div class="lbl">Density (1/ζ(k))</div></div>
                    <div class="stat"><div class="val" id="svol">523.6</div><div class="lbl">Sphere Volume</div></div>
                </div>
                <div style="background:var(--bg3); padding:10px; border-radius:6px; margin:10px 0; text-align:center;">
                    <p style="font-size:0.9em; color:var(--text2);">
                        <b>Precision:</b> <span id="currentPrecision">6</span> decimal places (k > 6 shows up to 17 decimals)
                    </p>
                </div>
                <div class="data-table-container">
                    <table><thead><tr><th>k</th><th>ζ(k)</th><th>1/ζ(k)</th><th>V_k (unit sphere)</th></tr></thead><tbody id="tbl"></tbody></table>
                </div>
            </div>
            
            <div class="section">
                <h2>Connections to Classical Problems</h2>
                
                <h3>Basel Problem</h3>
                <div class="formula">
                    <p>The 2D case directly connects to Euler's solution of the Basel problem:</p>
                    $$\zeta(2) = 1 + \frac{1}{4} + \frac{1}{9} + \frac{1}{16} + \cdots = \frac{\pi^2}{6}$$
                    <p style="margin-top:10px;">Thus the density of primitive points in Z² is exactly 6/π².</p>
                </div>
                
                <h3>Visible Lattice Points</h3>
                <div class="formula">
                    <p>A lattice point (a, b) is visible from the origin if and only if gcd(a,b) = 1. The number of visible points in a circle of radius R is asymptotically:</p>
                    $$V(R) \sim \frac{6}{\pi^2} \cdot \pi R^2 = \frac{6R^2}{\pi}$$
                </div>
                
                <h3>Farey Sequences</h3>
                <div class="formula">
                    <p>Primitive lattice points in 2D correspond to reduced fractions. The Farey sequence F_n contains all fractions p/q in lowest terms with 0 ≤ p ≤ q ≤ n. The number of terms in F_n is:</p>
                    $$|F_n| = 1 + \sum_{k=1}^{n} \phi(k)$$
                    <p style="margin-top:10px;">where φ(k) is Euler's totient function, which counts integers coprime to k.</p>
                </div>
            </div>
            
            <div class="section">
                <h2>Advanced Topics</h2>
                
                <h3>Möbius Inversion Formula</h3>
                <div class="formula">
                    <p>The Möbius function μ(n) is defined as:</p>
                    $$\mu(n) = \begin{cases} 
                    1 & \text{if } n = 1 \\
                    (-1)^k & \text{if } n \text{ is a product of } k \text{ distinct primes} \\
                    0 & \text{if } n \text{ has a squared prime factor}
                    \end{cases}$$
                    <p style="margin-top:10px;">The key property for our application:</p>
                    $$\sum_{d|n} \mu(d) = \begin{cases} 1 & \text{if } n=1 \\ 0 & \text{if } n>1 \end{cases}$$
                </div>
                
                <h3>Error Term Analysis</h3>
                <div class="formula">
                    <p>The error term O(R^(n-1)) can be understood as arising from the boundary of the ball. More precisely:</p>
                    $$C_n(R) = \frac{\operatorname{Vol}(B_n(R))}{\zeta(n)} + E_n(R)$$
                    <p style="margin-top:10px;">where |E_n(R)| ≤ C · R^(n-1) for some constant C depending on n.</p>
                    <p style="margin-top:10px;">This error reflects the discrete nature of the lattice versus the continuous ball boundary.</p>
                </div>
            </div>
        </div>

        <div id="patterns" class="panel">
            <div class="section">
                <h2>Pattern Explorer <span class="help-icon tooltip" data-tip="Discover patterns in primitive lattice points">?</span></h2>
                <p>Explore mathematical patterns and structures within primitive lattice point distributions. Interactive tools reveal modular patterns, density variations, and symmetry properties.</p>
                
                <div class="controls">
                    <label><b>Select Pattern Type:</b></label>
                    <div style="display:grid; grid-template-columns: repeat(auto-fit, minmax(180px, 1fr)); gap:10px; margin:15px 0;">
                        <button id="patternModular" class="active" onclick="setPatternType('modular')" style="padding:12px;">Modular Residue Classes</button>
                        <button id="patternDensity" onclick="setPatternType('density')" style="padding:12px;">Density Distribution</button>
                        <button id="patternAngular" onclick="setPatternType('angular')" style="padding:12px;">Angular Distribution</button>
                        <button id="patternRadial" onclick="setPatternType('radial')" style="padding:12px;">Radial Shells</button>
                    </div>
                    
                    <div id="modularPatternControls">
                        <div style="background:var(--bg3); padding:20px; border-radius:8px; margin:15px 0;">
                            <h3 style="color:var(--blue); margin-bottom:15px;">Modular Arithmetic Patterns</h3>
                            <p style="margin-bottom:15px;">Analyze how primitive points distribute across residue classes modulo m. This reveals deep connections between coprimality and modular arithmetic.</p>
                            
                            <label>Modulus m: <span id="patternModv">7</span></label>
                            <input type="range" id="patternMod" min="2" max="20" value="7" step="1" oninput="updatePatternViz()">
                            
                            <label style="margin-top:15px;">Radius R: <span id="patternRv">30</span></label>
                            <input type="range" id="patternR" min="10" max="100" value="30" step="5" oninput="updatePatternViz()">
                            
                            <div style="margin-top:15px;">
                                <label><input type="checkbox" id="showExpected" checked onchange="updatePatternViz()"> Show Expected Distribution</label>
                            </div>
                        </div>
                        
                        <div style="margin:20px 0;">
                            <button onclick="updatePatternViz()" style="padding:12px 24px;">Compute Pattern</button>
                            <button onclick="exportPatternData()" style="padding:12px 24px;">Export Data</button>
                        </div>
                        
                        <canvas id="patternCanvas" width="1000" height="600" style="max-width:100%;"></canvas>
                        
                        <div class="stats" id="patternStats" style="margin-top:20px;"></div>
                        
                        <div class="formula" style="margin-top:20px;">
                            <p><b>Theoretical Background:</b></p>
                            <p>For modulus m and primitive points with gcd(x,y) = 1, the distribution across residue classes (x+y) mod m reveals patterns related to Euler's totient function φ(m). Residue classes coprime to m tend to have higher concentrations of primitive points.</p>
                        </div>
                    </div>
                    
                    <div id="densityPatternControls" style="display:none;">
                        <div style="background:var(--bg3); padding:20px; border-radius:8px; margin:15px 0;">
                            <h3 style="color:var(--blue); margin-bottom:15px;">Density Distribution Analysis</h3>
                            <p style="margin-bottom:15px;">Examine how the density of primitive points varies across different regions of the lattice.</p>
                            
                            <label>Grid Size: <span id="gridSizev">10</span></label>
                            <div style="display:flex; gap:10px; align-items:center; margin-bottom:15px;">
                                <input type="range" id="gridSize" min="5" max="50" value="10" step="1" oninput="updateGridSize()" style="flex:1;">
                                <input type="number" id="gridSizeInput" min="5" max="100" value="10" style="width:100px; padding:8px;" oninput="updateGridSize()">
                            </div>
                            
                            <label style="margin-top:15px;">Max Radius: <span id="densityRv">50</span></label>
                            <div style="display:flex; gap:10px; align-items:center; margin-bottom:15px;">
                                <input type="range" id="densityR" min="20" max="200" value="50" step="5" oninput="updateDensityR()" style="flex:1;">
                                <input type="number" id="densityRInput" min="20" max="500" value="50" step="5" style="width:100px; padding:8px;" oninput="updateDensityR()">
                            </div>
                        </div>
                        
                        <button onclick="updatePatternViz()" style="padding:12px 24px; margin:10px 0;">Compute Density Map</button>
                        
                        <canvas id="densityCanvas" width="800" height="800" style="max-width:100%;"></canvas>
                        
                        <div class="formula" style="margin-top:20px;">
                            <p><b>Observation:</b> Density approaches 1/ζ(2) ≈ 60.79% uniformly as radius increases, confirming the asymptotic formula.</p>
                        </div>
                    </div>
                    
                    <div id="angularPatternControls" style="display:none;">
                        <div style="background:var(--bg3); padding:20px; border-radius:8px; margin:15px 0;">
                            <h3 style="color:var(--blue); margin-bottom:15px;">Angular Distribution</h3>
                            <p style="margin-bottom:15px;">How are primitive points distributed by angle around the origin?</p>
                            
                            <label>Number of Sectors: <span id="numSectorsv">16</span></label>
                            <input type="range" id="numSectors" min="4" max="32" value="16" step="1" oninput="updatePatternViz()">
                            
                            <label style="margin-top:15px;">Radius: <span id="angularRv">40</span></label>
                            <input type="range" id="angularR" min="10" max="100" value="40" step="5" oninput="updatePatternViz()">
                        </div>
                        
                        <button onclick="updatePatternViz()" style="padding:12px 24px; margin:10px 0;">Analyze Angular Distribution</button>
                        
                        <canvas id="angularCanvas" width="1000" height="600" style="max-width:100%;"></canvas>
                        
                        <div class="formula" style="margin-top:20px;">
                            <p><b>Expected Result:</b> For large R, angular distribution should be approximately uniform, with each sector containing roughly (total primitive points) / (number of sectors).</p>
                        </div>
                    </div>
                    
                    <div id="radialPatternControls" style="display:none;">
                        <div style="background:var(--bg3); padding:20px; border-radius:8px; margin:15px 0;">
                            <h3 style="color:var(--blue); margin-bottom:15px;">Radial Shell Analysis</h3>
                            <p style="margin-bottom:15px;">Count primitive points in concentric shells to observe growth patterns.</p>
                            
                            <label>Shell Thickness: <span id="shellThickv">2</span></label>
                            <input type="range" id="shellThick" min="1" max="10" value="2" step="1" oninput="updatePatternViz()">
                            
                            <label style="margin-top:15px;">Maximum Radius: <span id="radialMaxRv">60</span></label>
                            <input type="range" id="radialMaxR" min="20" max="100" value="60" step="5" oninput="updatePatternViz()">
                        </div>
                        
                        <button onclick="updatePatternViz()" style="padding:12px 24px; margin:10px 0;">Compute Radial Distribution</button>
                        
                        <canvas id="radialCanvas" width="1000" height="600" style="max-width:100%;"></canvas>
                        
                        <div class="formula" style="margin-top:20px;">
                            <p><b>Growth Pattern:</b> The number of primitive points in shell [r, r+Δr] grows approximately as 2πrΔr/ζ(2), reflecting the density theorem.</p>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div id="gcdheatmap" class="panel">
            <div class="section">
                <h2>Interactive GCD Heatmap <span class="help-icon tooltip" data-tip="Click on points to see details">?</span></h2>
                <p>Explore GCD patterns in the lattice. Click on any point to see detailed information about its coordinates and GCD value.</p>
                
                <div class="controls">
                    <div style="margin-bottom:10px;">
                        <label><b>Presets:</b></label>
                        <div style="display:flex; gap:8px; flex-wrap:wrap; margin-top:5px;">
                            <button onclick="setGCDHeatmapPreset('small')" style="padding:6px 12px; font-size:0.9em;">Small (R=15)</button>
                            <button onclick="setGCDHeatmapPreset('medium')" style="padding:6px 12px; font-size:0.9em;">Medium (R=30)</button>
                            <button onclick="setGCDHeatmapPreset('large')" style="padding:6px 12px; font-size:0.9em;">Large (R=50)</button>
                        </div>
                    </div>
                    
                    <label>Radius: <span id="heatmapRv">25</span></label>
                    <div style="display:flex; gap:10px; align-items:center; margin-bottom:15px;">
                        <input type="range" id="heatmapR" min="5" max="100" value="25" step="1" oninput="updateHeatmapR()" style="flex:1;">
                        <input type="number" id="heatmapRinput" min="5" max="1000" value="25" style="width:100px; padding:8px;" oninput="updateHeatmapR()">
                    </div>
                    
                    <div style="background:var(--bg3); padding:15px; border-radius:8px; margin-bottom:15px;">
                        <label style="font-size:1.1em; color:var(--blue); margin-bottom:10px; display:block;"><b>Display Mode:</b></label>
                        <div style="display:grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap:8px;">
                            <button id="heatmapGCD" class="active" onclick="setHeatmapMode('gcd')" style="padding:10px;">By GCD Value</button>
                            <button id="heatmapPrimitive" onclick="setHeatmapMode('primitive')" style="padding:10px;">Primitive Only</button>
                            <button id="heatmapGradient" onclick="setHeatmapMode('gradient')" style="padding:10px;">Distance Gradient</button>
                        </div>
                    </div>
                    
                    <div style="background:var(--bg3); padding:15px; border-radius:8px; margin-bottom:15px;">
                        <label style="font-size:1.1em; color:var(--blue); margin-bottom:10px; display:block;"><b>Filter Options:</b></label>
                        <label style="display:flex; align-items:center; gap:8px; margin:8px 0;">
                            <input type="checkbox" id="filterGCD1" checked onchange="updateGCDHeatmap()"> Show GCD = 1 (Primitive)
                        </label>
                        <label style="display:flex; align-items:center; gap:8px; margin:8px 0;">
                            <input type="checkbox" id="filterGCD2" checked onchange="updateGCDHeatmap()"> Show GCD = 2
                        </label>
                        <label style="display:flex; align-items:center; gap:8px; margin:8px 0;">
                            <input type="checkbox" id="filterGCD3" checked onchange="updateGCDHeatmap()"> Show GCD = 3
                        </label>
                        <label style="display:flex; align-items:center; gap:8px; margin:8px 0;">
                            <input type="checkbox" id="filterGCDOther" checked onchange="updateGCDHeatmap()"> Show GCD > 3
                        </label>
                    </div>
                    
                    <label>Point Size: <span id="heatmapPSv">4</span></label>
                    <input type="range" id="heatmapPS" min="2" max="10" value="4" oninput="updateGCDHeatmap()">
                    
                    <div style="margin-top:15px;">
                        <button onclick="updateGCDHeatmap()">Refresh Heatmap</button>
                        <button onclick="exportCanvas('heatmapCanvas', 'gcd-heatmap')">Export Image</button>
                        <button onclick="exportHeatmapData()">Export Data</button>
                    </div>
                </div>
                
                <canvas id="heatmapCanvas" width="1200" height="1200" style="max-width:100%; cursor:crosshair;"></canvas>
                
                <div id="pointInfo" style="background:var(--bg3); padding:20px; border-radius:8px; margin-top:20px; min-height:100px;">
                    <p style="color:var(--text2); font-style:italic;">Click on a point to see details</p>
                </div>
                
                <div class="stats">
                    <div class="stat"><div class="val" id="heatmapTotal">0</div><div class="lbl">Total Points</div></div>
                    <div class="stat"><div class="val" id="heatmapPrim">0</div><div class="lbl">Primitive (GCD=1)</div></div>
                    <div class="stat"><div class="val" id="heatmapGCD2">0</div><div class="lbl">GCD = 2</div></div>
                    <div class="stat"><div class="val" id="heatmapGCD3">0</div><div class="lbl">GCD = 3</div></div>
                    <div class="stat"><div class="val" id="heatmapGCDOther">0</div><div class="lbl">GCD > 3</div></div>
                </div>
                
                <div class="formula" style="margin-top:20px;">
                    <p><b>GCD Patterns:</b></p>
                    <p>- Points with GCD = d form a scaled copy of the primitive lattice, scaled by factor d</p>
                    <p>- The number of points with GCD = d in radius R is approximately N₁(R/d) where N₁ is the primitive count</p>
                    <p>- GCD values reveal the arithmetic structure of the lattice - patterns repeat at each GCD level</p>
                </div>
            </div>
        </div>

        <div id="gcdtable" class="panel">
            <div class="section">
                <h2>GCD Multiplication Table <span class="help-icon tooltip" data-tip="Interactive GCD grid visualization">?</span></h2>
                <p>Explore GCD patterns in a multiplication table format. Each cell shows gcd(row, column) with color-coding by value.</p>
                
                <div class="controls">
                    <div style="margin-bottom:10px;">
                        <label><b>Presets:</b></label>
                        <div style="display:flex; gap:8px; flex-wrap:wrap; margin-top:5px;">
                            <button onclick="setGCDTablePreset('small')" style="padding:6px 12px; font-size:0.9em;">Small (20×20)</button>
                            <button onclick="setGCDTablePreset('medium')" style="padding:6px 12px; font-size:0.9em;">Medium (50×50)</button>
                            <button onclick="setGCDTablePreset('large')" style="padding:6px 12px; font-size:0.9em;">Large (100×100)</button>
                        </div>
                    </div>
                    
                    <label>Grid Size: <span id="gcdTableSizev">30</span></label>
                    <div style="display:flex; gap:10px; align-items:center; margin-bottom:15px;">
                        <input type="range" id="gcdTableSize" min="5" max="150" value="30" step="1" oninput="updateGCDTable()" style="flex:1;">
                        <input type="number" id="gcdTableSizeInput" min="5" max="200" value="30" style="width:100px; padding:8px;" oninput="updateGCDTable()">
                    </div>
                    
                    <div style="background:var(--bg3); padding:15px; border-radius:8px; margin-bottom:15px;">
                        <label style="font-size:1.1em; color:var(--blue); margin-bottom:10px; display:block;"><b>Color Scheme:</b></label>
                        <div style="display:grid; grid-template-columns: repeat(auto-fit, minmax(140px, 1fr)); gap:8px;">
                            <button id="gcdTableHeat" class="active" onclick="setGCDTableColor('heat')" style="padding:10px;">Heat Map</button>
                            <button id="gcdTableDiscrete" onclick="setGCDTableColor('discrete')" style="padding:10px;">Discrete GCD</button>
                            <button id="gcdTablePrime" onclick="setGCDTableColor('prime')" style="padding:10px;">Prime Powers</button>
                        </div>
                    </div>
                    
                    <label style="display:flex; align-items:center; gap:8px; margin:10px 0;">
                        <input type="checkbox" id="showGCDValues" checked onchange="updateGCDTable()"> Show GCD Values
                    </label>
                    
                    <label style="display:flex; align-items:center; gap:8px; margin:10px 0;">
                        <input type="checkbox" id="highlightDiagonal" checked onchange="updateGCDTable()"> Highlight Diagonal
                    </label>
                    
                    <div style="margin-top:15px;">
                        <button onclick="updateGCDTable()">Refresh Table</button>
                        <button onclick="exportCanvas('gcdTableCanvas', 'gcd-table')">Export Image</button>
                        <button onclick="exportGCDTableData()">Export Data</button>
                    </div>
                </div>
                
                <canvas id="gcdTableCanvas" width="1200" height="1200" style="max-width:100%; cursor:crosshair;"></canvas>
                
                <div id="gcdTableInfo" style="background:var(--bg3); padding:20px; border-radius:8px; margin-top:20px; min-height:100px;">
                    <p style="color:var(--text2); font-style:italic;">Click on a cell to see GCD(row, col) details</p>
                </div>
                
                <div class="formula" style="margin-top:20px;">
                    <p><b>Patterns to Observe:</b></p>
                    <p>• Diagonal elements: gcd(n, n) = n (perfect squares in intensity)</p>
                    <p>• Symmetry: gcd(a, b) = gcd(b, a) - table is symmetric</p>
                    <p>• Rows/columns of primes: mostly 1s except at multiples</p>
                    <p>• Coprimality appears as value 1 (darkest cells in heat map)</p>
                    <p>• Patterns reveal divisibility relationships at a glance</p>
                </div>
            </div>
        </div>

        <div id="criticalstrip" class="panel">
            <div class="section">
                <h2>Critical Strip & Error Analysis <span class="help-icon tooltip" data-tip="Gauss Circle Problem & RH Connection">?</span></h2>
                <p>Analyzes the error term Δ(R) from the Gauss Circle Problem and its connection to the Riemann Hypothesis. The growth rate of |Δ(R)| is deeply connected to the distribution of zeros of the Riemann zeta function.</p>
                
                <div class="controls">
                    <div style="background:var(--bg3); padding:15px; border-radius:8px; margin-bottom:15px;">
                        <label style="font-size:1.1em; color:var(--blue); margin-bottom:10px; display:block;"><b>Problem Type:</b></label>
                        <div style="display:flex; gap:10px; flex-wrap:wrap;">
                            <button id="criticalAllPoints" class="active" onclick="setCriticalProblem('all')" style="flex:1; min-width:150px; padding:12px;">Gauss Circle (All Points)</button>
                            <button id="criticalPrimitive" onclick="setCriticalProblem('primitive')" style="flex:1; min-width:150px; padding:12px;">Primitive Points Only</button>
                        </div>
                    </div>
                    
                    <div style="background:var(--bg3); padding:15px; border-radius:8px; margin-bottom:15px;">
                        <label style="font-size:1.1em; color:var(--blue); margin-bottom:10px; display:block;"><b>Visualization Type:</b></label>
                        <div style="display:grid; grid-template-columns: repeat(auto-fit, minmax(160px, 1fr)); gap:8px;">
                            <button id="criticalVizError" class="active" onclick="setCriticalViz('error')" style="padding:10px;">Error vs Radius</button>
                            <button id="criticalVizNormalized" onclick="setCriticalViz('normalized')" style="padding:10px;">Δ(R)/R^(1/2)</button>
                            <button id="criticalVizLog" onclick="setCriticalViz('loglog')" style="padding:10px;">Log-Log Plot</button>
                            <button id="criticalVizBounds" onclick="setCriticalViz('bounds')" style="padding:10px;">With Bounds</button>
                        </div>
                    </div>
                    
                    <div style="margin-bottom:10px;">
                        <label><b>Presets:</b></label>
                        <div style="display:flex; gap:8px; flex-wrap:wrap; margin-top:5px;">
                            <button onclick="setCriticalStripPreset('standard')" style="padding:6px 12px; font-size:0.9em;">Standard (R≤100)</button>
                            <button onclick="setCriticalStripPreset('detailed')" style="padding:6px 12px; font-size:0.9em;">Detailed (R≤200)</button>
                            <button onclick="setCriticalStripPreset('extended')" style="padding:6px 12px; font-size:0.9em;">Extended (R≤300)</button>
                        </div>
                    </div>
                    
                    <label>Max Radius: <span id="criticalMaxRv">100</span></label>
                    <div style="display:flex; gap:10px; align-items:center; margin-bottom:15px;">
                        <input type="range" id="criticalMaxR" min="20" max="500" value="100" step="10" oninput="updateCriticalMaxR()" style="flex:1;">
                        <input type="number" id="criticalMaxRinput" min="20" max="1000" value="100" step="10" style="width:100px; padding:8px;" oninput="updateCriticalMaxR()">
                    </div>
                    
                    <label>Step Size: <span id="criticalStepv">1</span></label>
                    <div style="display:flex; gap:10px; align-items:center; margin-bottom:15px;">
                        <input type="range" id="criticalStep" min="1" max="10" value="1" step="1" oninput="updateCriticalStep()" style="flex:1;">
                        <input type="number" id="criticalStepInput" min="1" max="20" value="1" style="width:100px; padding:8px;" oninput="updateCriticalStep()">
                    </div>
                    
                    <div style="background:var(--bg3); padding:15px; border-radius:8px; margin:15px 0;">
                        <label style="font-size:1.1em; color:var(--blue); margin-bottom:10px; display:block;"><b>Display Options:</b></label>
                        <label style="display:flex; align-items:center; gap:8px; margin:8px 0;">
                            <input type="checkbox" id="showZeroLine" checked onchange="updateCriticalStrip()"> Show Zero Line
                        </label>
                        <label style="display:flex; align-items:center; gap:8px; margin:8px 0;">
                            <input type="checkbox" id="showRHBound" checked onchange="updateCriticalStrip()"> Show RH Bound (R^(1/2))
                        </label>
                        <label style="display:flex; align-items:center; gap:8px; margin:8px 0;">
                            <input type="checkbox" id="showClassicalBound" onchange="updateCriticalStrip()"> Show Classical Bound (R^(2/3))
                        </label>
                        <label style="display:flex; align-items:center; gap:8px; margin:8px 0;">
                            <input type="checkbox" id="colorBySign" checked onchange="updateCriticalStrip()"> Color by Error Sign
                        </label>
                    </div>
                    
                    <div style="margin-top:15px;">
                        <button onclick="updateCriticalStrip()">Compute Analysis</button>
                        <button onclick="exportCanvas('criticalCanvas', 'critical-strip')">Export Image</button>
                        <button onclick="exportCriticalData()">Export Data</button>
                    </div>
                </div>
                
                <div class="loading" id="loadCritical"><div class="spinner"></div><p>Computing error analysis...</p></div>
                
                <canvas id="criticalCanvas" width="1400" height="1000" style="max-width:100%; cursor:crosshair;"></canvas>
                
                <div id="criticalPointInfo" style="background:var(--bg3); padding:20px; border-radius:8px; margin-top:20px; min-height:100px;">
                    <p style="color:var(--text2); font-style:italic;">Click on a point to see detailed error information</p>
                </div>
                
                <div class="stats">
                    <div class="stat"><div class="val" id="criticalPoints">0</div><div class="lbl">Data Points</div></div>
                    <div class="stat"><div class="val" id="criticalMaxErr">0</div><div class="lbl">Max |Δ(R)|</div></div>
                    <div class="stat"><div class="val" id="criticalAvgErr">0</div><div class="lbl">Avg |Δ(R)|</div></div>
                    <div class="stat"><div class="val" id="criticalRMSErr">0</div><div class="lbl">RMS Error</div></div>
                    <div class="stat"><div class="val" id="criticalMaxNorm">0</div><div class="lbl">Max |Δ(R)/R^(1/2)|</div></div>
                </div>
                
                <div class="formula" style="margin-top:20px;">
                    <p><b>Gauss Circle Problem:</b></p>
                    <p>Let N(R) = |{(x,y) ∈ ℤ² : x² + y² ≤ R²}| be the number of lattice points in a circle of radius R.</p>
                    <p style="margin-top:10px;">We have N(R) = πR² + Δ(R), where Δ(R) is the error term.</p>
                    
                    <p style="margin-top:15px;"><b>Connection to Riemann Hypothesis:</b></p>
                    <p>- <b>Known:</b> |Δ(R)| = O(R^(2/3)) (classical result by van der Corput, 1923)</p>
                    <p>- <b>Conjectured (Hardy, 1915):</b> |Δ(R)| = O(R^(1/2 + ε)) for any ε > 0</p>
                    <p>- <b>If RH is true:</b> This bound is expected to hold, though not yet proven</p>
                    <p>- <b>Lower bound:</b> |Δ(R)| = Ω(R^(1/4)) (Sierpiński, 1906)</p>
                    
                    <p style="margin-top:15px;"><b>For Primitive Points:</b></p>
                    <p>N_prim(R) = πR²/ζ(2) + Δ_prim(R), with similar error behavior scaled by 1/ζ(2) ≈ 0.608</p>
                    
                    <p style="margin-top:15px;"><b>Key Observations:</b></p>
                    <p>- The error oscillates around zero with increasing amplitude</p>
                    <p>- Normalized error Δ(R)/R^(1/2) should be bounded if RH is true</p>
                    <p>- The oscillation frequency relates to the imaginary parts of zeta zeros</p>
                </div>
            </div>
        </div>

        <div id="viz2d" class="panel">
            <div class="section">
                <h2>2D Lattice Visualization <span class="help-icon tooltip" data-tip="Explore primitive lattice points">?</span></h2>
                <div class="controls">
                    <div style="background: var(--bg3); padding: 15px; border-radius: 8px; margin-bottom: 15px;">
                        <label style="font-size: 1.1em; color: var(--blue); margin-bottom: 10px; display: block;"><b>View Mode:</b></label>
                        <div style="display:flex; gap:10px; flex-wrap:wrap;">
                            <button id="viewPrimitive" class="active" onclick="set2DView('primitive')" style="flex:1; min-width:150px; padding: 12px;">Colored by Mode</button>
                            <button id="viewGauss" onclick="set2DView('gauss')" style="flex:1; min-width:150px; padding: 12px;">Circle Problem (All Points)</button>
                        </div>
                    </div>
                    
                    <div style="background: var(--bg3); padding: 15px; border-radius: 8px; margin-bottom: 15px;">
                        <label style="font-size: 1.1em; color: var(--blue); margin-bottom: 10px; display: block;"><b>Coloring Mode:</b></label>
                        <div style="display:grid; grid-template-columns: repeat(auto-fit, minmax(160px, 1fr)); gap:8px;">
                            <button id="color2DPrimitive" class="active" onclick="set2DColorMode('primitive')" style="padding:10px 12px; font-size:0.85em;">GCD=1 vs GCD>1</button>
                            <button id="color2DGCD" onclick="set2DColorMode('gcd')" style="padding:10px 12px; font-size:0.85em;">By GCD Value</button>
                            <button id="color2DMod" onclick="set2DColorMode('mod')" style="padding:10px 12px; font-size:0.85em;">By Mod m</button>
                            <button id="color2DQuadrant" onclick="set2DColorMode('quadrant')" style="padding:10px 12px; font-size:0.85em;">By Quadrant</button>
                            <button id="color2DAngular" onclick="set2DColorMode('angular')" style="padding:10px 12px; font-size:0.85em;">By Angular Sector</button>
                            <button id="color2DGCDQuad" onclick="set2DColorMode('gcdquad')" style="padding:10px 12px; font-size:0.85em;">GCD × Quadrant</button>
                            <button id="color2DGCDMod" onclick="set2DColorMode('gcdmod')" style="padding:10px 12px; font-size:0.85em;">GCD × Mod</button>
                        </div>
                        <div id="modControls2D" style="display:none; margin-top:10px;">
                            <label>Modulus m: <span id="mod2Dv">3</span></label>
                            <input type="range" id="mod2D" min="2" max="12" value="3" step="1" oninput="document.getElementById('mod2Dv').textContent=this.value; draw2D()">
                        </div>
                        <div id="sectorControls2D" style="display:none; margin-top:10px;">
                            <label>Angular Sectors: <span id="sectors2Dv">8</span></label>
                            <input type="range" id="sectors2D" min="4" max="16" value="8" step="1" oninput="document.getElementById('sectors2Dv').textContent=this.value; draw2D()">
                        </div>
                    </div>
                    <div style="margin-bottom:10px;">
                        <label><b>Presets:</b></label>
                        <div style="display:flex; gap:8px; flex-wrap:wrap; margin-top:5px;">
                            <button onclick="set2DPreset('small')" style="padding:6px 12px; font-size:0.9em;">Small (R=10)</button>
                            <button onclick="set2DPreset('medium')" style="padding:6px 12px; font-size:0.9em;">Medium (R=50)</button>
                            <button onclick="set2DPreset('large')" style="padding:6px 12px; font-size:0.9em;">Large (R=100)</button>
                            <button onclick="set2DPreset('xlarge')" style="padding:6px 12px; font-size:0.9em;">X-Large (R=200)</button>
                        </div>
                    </div>
                    <label>Radius: <span id="r2v">20</span></label>
                    <div style="display:flex; gap:10px; align-items:center; margin-bottom:10px;">
                        <input type="range" id="r2" min="1" max="500" value="20" step="1" oninput="update2DRadius(this.value)" style="flex:1;">
                        <input type="number" id="r2input" min="1" max="2000" value="20" style="width:100px; padding:8px;" oninput="update2DRadius(this.value)">
                    </div>
                    
                    <label>Canvas Zoom: <span id="zoom2Dv">100</span>%</label>
                    <input type="range" id="zoom2D" min="50" max="200" value="100" step="5" oninput="update2DZoom()">
                    
                    <label>Point Size: <span id="psv">3</span></label>
                    <input type="range" id="ps" min="1" max="20" value="3" oninput="draw2D()">
                    
                    <div style="background: var(--bg3); padding: 15px; border-radius: 8px; margin: 15px 0;">
                        <label style="font-size: 1.1em; color: var(--blue); margin-bottom: 10px; display: block;"><b>Point Labels:</b></label>
                        <div style="display:grid; grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); gap:8px; margin-bottom:10px;">
                            <button id="label2DNone" class="active" onclick="set2DLabelMode('none')" style="padding:8px; font-size:0.85em;">No Labels</button>
                            <button id="label2DGCD" onclick="set2DLabelMode('gcd')" style="padding:8px; font-size:0.85em;">By GCD</button>
                            <button id="label2DCoords" onclick="set2DLabelMode('coords')" style="padding:8px; font-size:0.85em;">Coordinates</button>
                            <button id="label2DAngle" onclick="set2DLabelMode('angle')" style="padding:8px; font-size:0.85em;">By Angle</button>
                        </div>
                        <div id="labelControls2D" style="display:none;">
                            <label>Label Font Size: <span id="labelSize2Dv">8</span>px</label>
                            <input type="range" id="labelSize2D" min="6" max="16" value="8" step="1" oninput="draw2D()">
                            <label style="margin-top:10px;">Max Points to Label: <span id="maxLabels2Dv">50</span></label>
                            <input type="range" id="maxLabels2D" min="10" max="500" value="50" step="10" oninput="draw2D()">
                            <p style="font-size:0.85em; color:var(--text2); margin-top:8px;">Labels shown for points closest to origin</p>
                        </div>
                    </div>
                    
                    <button onclick="exportCanvas('c2d', '2d-lattice')">Export Image</button>
                    <button onclick="exportPointData2D()">Export Points</button>
                </div>
                <div class="warning" id="warn2d" style="display:none;">
                    Warning: Large radius values may slow performance. Consider using R ≤ 200 for smooth rendering.
                </div>
                <div class="loading" id="load2d"><div class="spinner"></div><p>Computing lattice points...</p></div>
                <canvas id="c2d" width="1200" height="1200" style="max-width:100%;"></canvas>
                <div class="stats">
                    <div class="stat"><div class="val" id="p2">0</div><div class="lbl">Primitive Points</div></div>
                    <div class="stat"><div class="val" id="t2">0</div><div class="lbl">Total Points</div></div>
                    <div class="stat"><div class="val" id="d2">0%</div><div class="lbl">Density</div></div>
                    <div class="stat"><div class="val" id="e2">0</div><div class="lbl">|Predicted - Actual|</div></div>
                </div>
            </div>
        </div>

        <div id="viz3d" class="panel">
            <div class="section">
                <h2>3D Lattice Visualization <span class="help-icon tooltip" data-tip="Click and drag to rotate">?</span></h2>
                <div class="controls">
                    <div style="background: var(--bg3); padding: 15px; border-radius: 8px; margin-bottom: 15px;">
                        <label style="font-size: 1.1em; color: var(--blue); margin-bottom: 10px; display: block;"><b>Boundary Shape:</b></label>
                        <div style="display:flex; gap:10px; flex-wrap:wrap;">
                            <button id="shape3DSphere" class="active" onclick="set3DShape('sphere')" style="flex:1; min-width:120px; padding: 12px;">Sphere (x²+y²+z² ≤ R²)</button>
                            <button id="shape3DCube" onclick="set3DShape('cube')" style="flex:1; min-width:120px; padding: 12px;">Cube (|x|,|y|,|z| ≤ R)</button>
                        </div>
                    </div>
                    
                    <div style="background: var(--bg3); padding: 15px; border-radius: 8px; margin-bottom: 15px;">
                        <label style="font-size: 1.1em; color: var(--blue); margin-bottom: 10px; display: block;"><b>Coloring Mode:</b></label>
                        <div style="display:grid; grid-template-columns: repeat(auto-fit, minmax(160px, 1fr)); gap:8px;">
                            <button id="colorPrimitive" class="active" onclick="set3DColorMode('primitive')" style="padding:10px 12px; font-size:0.85em;">GCD=1 vs GCD>1</button>
                            <button id="colorGCD" onclick="set3DColorMode('gcd')" style="padding:10px 12px; font-size:0.85em;">By GCD Value</button>
                            <button id="colorMod" onclick="set3DColorMode('mod')" style="padding:10px 12px; font-size:0.85em;">By Mod m</button>
                            <button id="colorOctant" onclick="set3DColorMode('octant')" style="padding:10px 12px; font-size:0.85em;">By Octant</button>
                            <button id="colorDistance" onclick="set3DColorMode('distance')" style="padding:10px 12px; font-size:0.85em;">By Distance</button>
                            <button id="colorGCDOct" onclick="set3DColorMode('gcdoct')" style="padding:10px 12px; font-size:0.85em;">GCD × Octant</button>
                            <button id="colorGCDMod" onclick="set3DColorMode('gcdmod')" style="padding:10px 12px; font-size:0.85em;">GCD × Mod</button>
                        </div>
                        <div id="modControls3D" style="display:none; margin-top:10px;">
                            <label>Modulus m: <span id="mod3Dv">3</span></label>
                            <input type="range" id="mod3D" min="2" max="12" value="3" step="1" oninput="document.getElementById('mod3Dv').textContent=this.value; draw3D()">
                        </div>
                    </div>
                    
                    <div style="margin-bottom:10px;">
                        <label><b>Presets:</b></label>
                        <div style="display:flex; gap:8px; flex-wrap:wrap; margin-top:5px;">
                            <button onclick="set3DPreset('tiny')" style="padding:6px 12px; font-size:0.9em;">Tiny (R=5)</button>
                            <button onclick="set3DPreset('small')" style="padding:6px 12px; font-size:0.9em;">Small (R=10)</button>
                            <button onclick="set3DPreset('medium')" style="padding:6px 12px; font-size:0.9em;">Medium (R=20)</button>
                            <button onclick="set3DPreset('large')" style="padding:6px 12px; font-size:0.9em;">Large (R=30)</button>
                        </div>
                    </div>
                    <label>Radius: <span id="r3v">10</span></label>
                    <input type="range" id="r3" min="1" max="40" value="10" step="1" oninput="draw3D()">
                    
                    <label>Point Size: <span id="ps3v">0.6</span></label>
                    <input type="range" id="ps3" min="0.2" max="2.0" value="0.6" step="0.1" oninput="draw3D()">
                    
                    <label>Camera Distance (Zoom): <span id="zoom3Dv">86</span></label>
                    <input type="range" id="zoom3D" min="30" max="150" value="86" step="1" oninput="update3DZoom()">
                    
                    <div style="background: var(--bg3); padding: 15px; border-radius: 8px; margin: 15px 0;">
                        <label style="font-size: 1.1em; color: var(--blue); margin-bottom: 10px; display: block;"><b>Point Labels:</b></label>
                        <div style="display:grid; grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); gap:8px; margin-bottom:10px;">
                            <button id="label3DNone" class="active" onclick="set3DLabelMode('none')" style="padding:8px; font-size:0.85em;">No Labels</button>
                            <button id="label3DGCD" onclick="set3DLabelMode('gcd')" style="padding:8px; font-size:0.85em;">By GCD</button>
                            <button id="label3DCoords" onclick="set3DLabelMode('coords')" style="padding:8px; font-size:0.85em;">Coordinates</button>
                        </div>
                        <div id="labelControls3D" style="display:none;">
                            <label>Max Points to Label: <span id="maxLabels3Dv">30</span></label>
                            <input type="range" id="maxLabels3D" min="10" max="200" value="30" step="10" oninput="draw3D()">
                            <p style="font-size:0.85em; color:var(--text2); margin-top:8px;">Labels shown for points closest to origin</p>
                        </div>
                    </div>
                    
                    <button onclick="reset3D()">Reset View</button>
                    <button onclick="toggleRotation()">Auto-Rotate</button>
                    <button onclick="export3DData()">Export Points</button>
                </div>
                <div class="warning" id="warn3d" style="display:none;">
                    Warning: Radius > 30 generates many points and may impact performance.
                </div>
                <div class="loading" id="load3d"><div class="spinner"></div><p>Generating 3D lattice...</p></div>
                <div id="c3d" style="width:100%; height:800px;"></div>
                <div class="stats">
                    <div class="stat"><div class="val" id="p3">0</div><div class="lbl">Primitive Points</div></div>
                    <div class="stat"><div class="val" id="t3">0</div><div class="lbl">Total Points</div></div>
                    <div class="stat"><div class="val" id="d3">0%</div><div class="lbl">Density</div></div>
                    <div class="stat"><div class="val" id="e3">0</div><div class="lbl">Error</div></div>
                </div>
            </div>
        </div>

        <div id="comparison" class="panel">
            <div class="section">
                <h2>Dimension Comparison <span class="help-icon tooltip" data-tip="Compare different dimensions">?</span></h2>
                <p>Compare how primitive lattice point counts change across dimensions for a fixed radius, or analyze how different radii affect each dimension.</p>
                
                <div class="controls">
                    <label>Comparison Mode:</label>
                    <div style="display:flex; gap:10px; margin-bottom:15px; flex-wrap:wrap;">
                        <button id="modeFixed" class="active" onclick="setComparisonMode('fixed')" style="flex:1; min-width:150px;">Fixed Radius</button>
                        <button id="modeMulti" onclick="setComparisonMode('multi')" style="flex:1; min-width:150px;">Multiple Radii</button>
                    </div>
                    
                    <div style="margin-bottom:10px;">
                        <label><b>Presets:</b></label>
                        <div style="display:flex; gap:8px; flex-wrap:wrap; margin-top:5px;">
                            <button onclick="setComparisonPreset('low')" style="padding:6px 12px; font-size:0.9em;">Low Dimensions (2-4)</button>
                            <button onclick="setComparisonPreset('mid')" style="padding:6px 12px; font-size:0.9em;">Mid Dimensions (3-6)</button>
                            <button onclick="setComparisonPreset('high')" style="padding:6px 12px; font-size:0.9em;">High Dimensions (5-10)</button>
                            <button onclick="setComparisonPreset('all')" style="padding:6px 12px; font-size:0.9em;">All Dimensions (2-10)</button>
                            <button onclick="setComparisonPreset('growth')" style="padding:6px 12px; font-size:0.9em;">Growth Analysis</button>
                        </div>
                    </div>
                    
                    <div id="fixedRadiusControls">
                        <label>Radius: <span id="crv">15</span></label>
                        <div style="display:flex; gap:10px; align-items:center; margin-bottom:15px;">
                            <input type="range" id="cr" min="1" max="100" value="15" step="1" oninput="updateComparisonRadius(this.value)" style="flex:1;">
                            <input type="number" id="crinput" min="1" max="200" value="15" style="width:100px; padding:8px;" oninput="updateComparisonRadius(this.value)">
                        </div>
                    </div>
                    
                    <div id="multiRadiusControls" style="display:none;">
                        <label>Radii to compare (comma-separated): </label>
                        <input type="text" id="multiRadii" value="10, 20, 30, 40, 50" style="width:100%; padding:10px; margin-bottom:15px;" oninput="updateComparison()">
                    </div>
                    
                    <div style="margin-bottom:15px;">
                        <p><b>Dimensions to compare:</b></p>
                        <div style="display:grid; grid-template-columns: repeat(auto-fit, minmax(80px, 1fr)); gap:10px; margin-top:10px;">
                            <label style="display:flex; align-items:center; gap:8px;">
                                <input type="checkbox" id="compk2" checked onchange="updateComparison()"> k=2
                            </label>
                            <label style="display:flex; align-items:center; gap:8px;">
                                <input type="checkbox" id="compk3" checked onchange="updateComparison()"> k=3
                            </label>
                            <label style="display:flex; align-items:center; gap:8px;">
                                <input type="checkbox" id="compk4" checked onchange="updateComparison()"> k=4
                            </label>
                            <label style="display:flex; align-items:center; gap:8px;">
                                <input type="checkbox" id="compk5" checked onchange="updateComparison()"> k=5
                            </label>
                            <label style="display:flex; align-items:center; gap:8px;">
                                <input type="checkbox" id="compk6" checked onchange="updateComparison()"> k=6
                            </label>
                            <label style="display:flex; align-items:center; gap:8px;">
                                <input type="checkbox" id="compk7" onchange="updateComparison()"> k=7
                            </label>
                            <label style="display:flex; align-items:center; gap:8px;">
                                <input type="checkbox" id="compk8" onchange="updateComparison()"> k=8
                            </label>
                            <label style="display:flex; align-items:center; gap:8px;">
                                <input type="checkbox" id="compk9" onchange="updateComparison()"> k=9
                            </label>
                            <label style="display:flex; align-items:center; gap:8px;">
                                <input type="checkbox" id="compk10" onchange="updateComparison()"> k=10
                            </label>
                        </div>
                    </div>
                    
                    <div style="margin-bottom:15px;">
                        <p><b>Display options:</b></p>
                        <label style="display:flex; align-items:center; gap:8px; margin:8px 0;">
                            <input type="checkbox" id="showDensity" checked onchange="updateComparison()"> Show Density (1/ζ(k))
                        </label>
                        <label style="display:flex; align-items:center; gap:8px; margin:8px 0;">
                            <input type="checkbox" id="showVolume" checked onchange="updateComparison()"> Show Sphere Volume
                        </label>
                        <label style="display:flex; align-items:center; gap:8px; margin:8px 0;">
                            <input type="checkbox" id="showZeta" checked onchange="updateComparison()"> Show ζ(k) Values
                        </label>
                        <label style="display:flex; align-items:center; gap:8px; margin:8px 0;">
                            <input type="checkbox" id="showChart" checked onchange="updateComparison()"> Show Comparison Chart
                        </label>
                    </div>
                    
                    <button onclick="updateComparison()">Refresh Comparison</button>
                    <button onclick="exportComparisonData()">Export Data</button>
                    <button onclick="exportComparisonChart()">Export Chart</button>
                </div>
                
                <div class="compare-grid" id="compGrid"></div>
                
                <div id="comparisonChart" style="margin-top:30px;">
                    <canvas id="compChart" width="800" height="400"></canvas>
                </div>
                
                <div class="formula" style="margin-top:20px;">
                    <p><b>Key Observations:</b></p>
                    <p>- As dimension k increases, ζ(k) approaches 1, meaning the density 1/ζ(k) approaches 100%</p>
                    <p>- Higher dimensions have exponentially more lattice points (grows as R^k)</p>
                    <p>- The ratio of primitive to total points stabilizes at 1/ζ(k) for each dimension</p>
                    <p>- Sphere volume grows dramatically with dimension, following the gamma function pattern</p>
                </div>
                
                <div style="margin-top:30px;">
                    <h3 style="color:var(--blue);">Dimensional Scaling Analysis</h3>
                    <p>Explore how the boundary term R^(k-1) becomes negligible compared to the main term R^k as dimension increases.</p>
                    
                    <div class="controls" style="background:var(--bg3); padding:20px; border-radius:8px; margin:20px 0;">
                        <label>Dimension k: <span id="dimScaleK">3</span></label>
                        <input type="range" id="dimScaleKSlider" min="2" max="12" value="3" step="1" oninput="updateDimScale()">
                        
                        <label style="margin-top:15px;">Radius R: <span id="dimScaleR">100</span></label>
                        <input type="range" id="dimScaleRSlider" min="10" max="1000" value="100" step="10" oninput="updateDimScale()">
                    </div>
                    
                    <div class="stats" id="dimScaleStats">
                        <div class="stat"><div class="val" id="mainTerm">1000000</div><div class="lbl">Main Term (R^k)</div></div>
                        <div class="stat"><div class="val" id="boundaryTerm">10000</div><div class="lbl">Boundary Term (R^(k-1))</div></div>
                        <div class="stat"><div class="val" id="relativeError">1.00%</div><div class="lbl">Relative Error</div></div>
                        <div class="stat"><div class="val" id="densityVal">0.8319</div><div class="lbl">Density (1/ζ(k))</div></div>
                    </div>
                    
                    <div class="data-table-container" style="margin-top:20px;">
                        <h4 style="margin-bottom:10px;">Dimensional Scaling Table</h4>
                        <table>
                            <thead>
                                <tr>
                                    <th>k</th>
                                    <th>Boundary Geometry</th>
                                    <th>Density 1/ζ(k)</th>
                                    <th>Stability</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr><td>2</td><td>Perimeter (R¹)</td><td>0.6079</td><td>Baseline</td></tr>
                                <tr><td>3</td><td>Surface Area (R²)</td><td>0.8319</td><td>High</td></tr>
                                <tr><td>4</td><td>3D Hypersurface (R³)</td><td>0.9239</td><td>Very High</td></tr>
                                <tr><td>5</td><td>4D Hypersurface (R⁴)</td><td>0.9644</td><td>Extreme</td></tr>
                                <tr><td>6</td><td>5D Hypersurface (R⁵)</td><td>0.9829</td><td>Extreme</td></tr>
                                <tr><td>8</td><td>7D Hypersurface (R⁷)</td><td>0.9959</td><td>Extreme+</td></tr>
                                <tr><td>10</td><td>9D Hypersurface (R⁹)</td><td>0.9990</td><td>Approaching 1</td></tr>
                                <tr><td>12</td><td>11D Hypersurface (R¹¹)</td><td>0.9998</td><td>Nearly 1</td></tr>
                            </tbody>
                        </table>
                    </div>
                    
                    <div class="formula" style="margin-top:20px;">
                        <p><b>Key Insight:</b> As k increases, the relative error (Boundary/Main) = R^(k-1)/R^k = 1/R decreases.</p>
                        <p>For fixed R, higher dimensions have proportionally smaller boundary effects, leading to more stable density convergence to 1/ζ(k).</p>
                    </div>
                </div>
            </div>
        </div>

        <div id="analysis" class="panel">
            <div class="section">
                <h2>Error Analysis <span class="help-icon tooltip" data-tip="Study O(R^(k-1)) error term for ALL radius values">?</span></h2>
                <p>Visualization of the error term Δ(R) = N(R) - R^k/ζ(k) for every single radius value. The chart shows how actual counts differ from predictions.</p>
                <div class="controls">
                    <div style="margin-bottom:10px;">
                        <label><b>Presets:</b></label>
                        <div style="display:flex; gap:8px; flex-wrap:wrap; margin-top:5px;">
                            <button onclick="setAnalysisPreset('quick')" style="padding:6px 12px; font-size:0.9em;">Quick (R≤50, all values)</button>
                            <button onclick="setAnalysisPreset('standard')" style="padding:6px 12px; font-size:0.9em;">Standard (R≤100, all values)</button>
                            <button onclick="setAnalysisPreset('detailed')" style="padding:6px 12px; font-size:0.9em;">Detailed (R≤200, all values)</button>
                            <button onclick="setAnalysisPreset('extended')" style="padding:6px 12px; font-size:0.9em;">Extended (R≤500, all values)</button>
                        </div>
                    </div>
                    
                    <label>Dimension k: <span id="analysisKv">2</span></label>
                    <input type="range" id="analysisK" min="2" max="5" value="2" step="1" oninput="document.getElementById('analysisKv').textContent=this.value">
                    
                    <label>Max Radius: <span id="mrv">100</span></label>
                    <div style="display:flex; gap:10px; align-items:center; margin-bottom:10px;">
                        <input type="range" id="mr" min="10" max="500" value="100" step="5" oninput="updateAnalysisRadius(this.value)" style="flex:1;">
                        <input type="number" id="mrinput" min="10" max="1000" value="100" step="5" style="width:100px; padding:8px;" oninput="updateAnalysisRadius(this.value)">
                    </div>
                    
                    <label>Start from Radius: <span id="minrv">1</span></label>
                    <input type="range" id="minr" min="1" max="50" value="1" step="1" oninput="document.getElementById('minrv').textContent=this.value">
                    
                    <div style="background:var(--bg3); padding:15px; border-radius:8px; margin:15px 0;">
                        <p style="color:var(--blue); font-weight:bold; margin-bottom:10px;">Computation Info:</p>
                        <p style="font-size:0.9em; margin-bottom:5px;">- <b>k=2:</b> Exact computation up to R=200, then uses prediction</p>
                        <p style="font-size:0.9em; margin-bottom:5px;">- <b>k=3:</b> Exact computation up to R=40, then uses prediction</p>
                        <p style="font-size:0.9em; margin-bottom:5px;">- <b>k=4:</b> Exact computation up to R=15, then uses prediction</p>
                        <p style="font-size:0.9em;">- <b>k=5:</b> Uses prediction (computational limit)</p>
                        <p style="font-size:0.85em; color:var(--text2); margin-top:10px;">Note: Computes for <b>every single R value</b> (no skipping)</p>
                    </div>
                    
                    <div style="margin-top:20px;">
                        <label style="display:flex; align-items:center; gap:8px; margin:8px 0;">
                            <input type="checkbox" id="showAbsError" checked onchange="runAnalysis()"> Show Absolute Error
                        </label>
                        <label style="display:flex; align-items:center; gap:8px; margin:8px 0;">
                            <input type="checkbox" id="showRelError" checked onchange="runAnalysis()"> Show Relative Error (%)
                        </label>
                        <label style="display:flex; align-items:center; gap:8px; margin:8px 0;">
                            <input type="checkbox" id="showRunningAvg" onchange="runAnalysis()"> Show Running Average
                        </label>
                        <label style="display:flex; align-items:center; gap:8px; margin:8px 0;">
                            <input type="checkbox" id="showBoundary" onchange="runAnalysis()"> Show Theoretical Boundary O(R^(k-1))
                        </label>
                        <label style="display:flex; align-items:center; gap:8px; margin:8px 0;">
                            <input type="checkbox" id="showActualCount" onchange="runAnalysis()"> Show Actual Primitive Count
                        </label>
                    </div>
                    
                    <button onclick="runAnalysis()" style="margin-top:15px;">Compute Analysis</button>
                    <button onclick="exportChartData()">Export Chart Data</button>
                    <button onclick="analyzeSpecificPoint()">Analyze Specific R</button>
                </div>
                <div class="loading" id="loadAnalysis"><div class="spinner"></div><p>Computing error analysis for all R values...</p></div>
                <canvas id="ch" width="1600" height="1000" style="max-width: 100%; cursor:crosshair;"></canvas>
                
                <div id="pointAnalysisResult" style="background:var(--bg3); padding:20px; border-radius:8px; margin-top:20px; min-height:100px;">
                    <p style="color:var(--text2); font-style:italic;">Click on chart points or use "Analyze Specific R" button to see detailed analysis</p>
                </div>
                <div class="formula" style="margin-top: 20px;">
                    <p><b>Error Bound Theory:</b></p>
                    <p>The error term O(R^(k-1)) arises from boundary effects. For k=2, the error is O(R), corresponding to points near the circle boundary. As k increases, the error term becomes relatively smaller compared to the main term R^k.</p>
                    <p style="margin-top:10px;"><b>Relative Error:</b> Shows |Predicted - Actual| / Predicted as a percentage. This decreases as R grows, confirming the asymptotic accuracy.</p>
                    <p style="margin-top:10px;"><b>Running Average:</b> The cumulative average of absolute errors up to each R. Shows convergence behavior.</p>
                    <p style="margin-top:10px;"><b>Boundary Term:</b> The theoretical O(R^(k-1)) term, showing the expected growth rate of the error.</p>
                    <p style="margin-top:15px;"><b>Key Feature:</b> This analysis computes for <b>every single R value</b> from start to max (no skipping), giving you the complete error landscape.</p>
                </div>
                
                <div style="margin-top:30px;">
                    <h3 style="color:var(--blue);">Empirical Validation Table (k=2)</h3>
                    <p>Computational verification of the theoretical predictions for dimension k=2:</p>
                    
                    <div class="data-table-container" style="margin-top:15px;">
                        <table>
                            <thead>
                                <tr>
                                    <th>R</th>
                                    <th>N(R) Actual</th>
                                    <th>R²/ζ(2) Predicted</th>
                                    <th>Δ(R) Error</th>
                                    <th>Δ(R)/(R log R)</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr><td>10</td><td>63</td><td>60.79</td><td>2.21</td><td>0.096</td></tr>
                                <tr><td>50</td><td>1,519</td><td>1,519.7</td><td>-0.7</td><td>-0.008</td></tr>
                                <tr><td>100</td><td>6,087</td><td>6,079.3</td><td>7.7</td><td>0.017</td></tr>
                                <tr><td>500</td><td>151,983</td><td>151,982.5</td><td>0.5</td><td>0.0002</td></tr>
                                <tr><td>1000</td><td>607,926</td><td>607,927.0</td><td>-1.0</td><td>-0.0001</td></tr>
                            </tbody>
                        </table>
                    </div>
                    
                    <div class="formula" style="margin-top:15px;">
                        <p><b>Observations:</b></p>
                        <p>- The error Δ(R) oscillates around zero, confirming the prediction is unbiased</p>
                        <p>- The normalized error Δ(R)/(R log R) decreases as R increases</p>
                        <p>- Even at R=1000, the error is less than 0.0002% of the predicted value</p>
                        <p>- This validates the asymptotic formula N(R) = R²/ζ(2) + O(R log R) for k=2</p>
                    </div>
                </div>
            </div>
        </div>

        <div id="explore" class="panel">
            <div class="section">
                <h2>Related Mathematical Visualizations</h2>
                <p>Explore the complete collection of interactive number theory and lattice point visualizations by Wessen Getachew. Each project focuses on a specific mathematical concept with deep interactive exploration.</p>
                
                <h3 style="color:var(--blue); margin-top:30px;">Core Lattice & Coprimality Theory</h3>
                <div class="compare-grid">
                    <div class="compare-item">
                        <h4 style="color:var(--blue);">Boundary Cancellation (Main)</h4>
                        <p style="margin:10px 0;">Analysis of arithmetic lattice residues and the Möbius inversion principle.</p>
                        <a href="https://wessengetachew.github.io/R/" target="_blank" style="display:inline-block; padding:8px 16px; background:var(--blue); color:white; text-decoration:none; border-radius:6px; margin-top:10px;">Visit Project</a>
                    </div>
                    
                    <div class="compare-item">
                        <h4 style="color:var(--blue);">GCD & 2πr</h4>
                        <p style="margin:10px 0;">Complete discovery engine for GCD patterns and boundary cancellation principles.</p>
                        <a href="https://wessengetachew.github.io/GCD/" target="_blank" style="display:inline-block; padding:8px 16px; background:var(--blue); color:white; text-decoration:none; border-radius:6px; margin-top:10px;">Visit Project</a>
                    </div>
                    
                    <div class="compare-item">
                        <h4 style="color:var(--blue);">Finite Fields</h4>
                        <p style="margin:10px 0;">Exploration of finite field structures and modular arithmetic patterns.</p>
                        <a href="https://wessengetachew.github.io/finite/" target="_blank" style="display:inline-block; padding:8px 16px; background:var(--blue); color:white; text-decoration:none; border-radius:6px; margin-top:10px;">Visit Project</a>
                    </div>
                </div>
                
                <h3 style="color:var(--green); margin-top:30px;">Prime Number Visualizations</h3>
                <div class="compare-grid">
                    <div class="compare-item">
                        <h4 style="color:var(--green);">Prime Patterns</h4>
                        <p style="margin:10px 0;">Interactive visualization of prime number distribution and patterns.</p>
                        <a href="https://wessengetachew.github.io/Primes/" target="_blank" style="display:inline-block; padding:8px 16px; background:var(--green); color:white; text-decoration:none; border-radius:6px; margin-top:10px;">Visit Project</a>
                    </div>
                    
                    <div class="compare-item">
                        <h4 style="color:var(--green);">Composite Numbers</h4>
                        <p style="margin:10px 0;">Analysis of composite number structures and factorization patterns.</p>
                        <a href="https://wessengetachew.github.io/Composite/" target="_blank" style="display:inline-block; padding:8px 16px; background:var(--green); color:white; text-decoration:none; border-radius:6px; margin-top:10px;">Visit Project</a>
                    </div>
                    
                    <div class="compare-item">
                        <h4 style="color:var(--green);">Goldbach Conjecture</h4>
                        <p style="margin:10px 0;">Interactive exploration of Goldbach's conjecture and twin prime patterns.</p>
                        <a href="https://wessengetachew.github.io/Goldbach/" target="_blank" style="display:inline-block; padding:8px 16px; background:var(--green); color:white; text-decoration:none; border-radius:6px; margin-top:10px;">Visit Project</a>
                    </div>
                </div>
                
                <h3 style="color:var(--purple); margin-top:30px;">Rational Numbers & Fractions</h3>
                <div class="compare-grid">
                    <div class="compare-item">
                        <h4 style="color:var(--purple);">Farey Sequences</h4>
                        <p style="margin:10px 0;">Visualization of Farey sequences, Ford circles, and Stern-Brocot trees.</p>
                        <a href="https://wessengetachew.github.io/Farey/" target="_blank" style="display:inline-block; padding:8px 16px; background:var(--purple); color:white; text-decoration:none; border-radius:6px; margin-top:10px;">Visit Project</a>
                    </div>
                    
                    <div class="compare-item">
                        <h4 style="color:var(--purple);">Rational Numbers</h4>
                        <p style="margin:10px 0;">Deep dive into rational number theory and continued fractions.</p>
                        <a href="https://wessengetachew.github.io/Rational-/" target="_blank" style="display:inline-block; padding:8px 16px; background:var(--purple); color:white; text-decoration:none; border-radius:6px; margin-top:10px;">Visit Project</a>
                    </div>
                    
                    <div class="compare-item">
                        <h4 style="color:var(--purple);">1/2 Density</h4>
                        <p style="margin:10px 0;">Analysis of half-density phenomena in number theory.</p>
                        <a href="https://wessengetachew.github.io/1-2/" target="_blank" style="display:inline-block; padding:8px 16px; background:var(--purple); color:white; text-decoration:none; border-radius:6px; margin-top:10px;">Visit Project</a>
                    </div>
                </div>
                
                <h3 style="color:var(--orange); margin-top:30px;">Geometric Number Theory</h3>
                <div class="compare-grid">
                    <div class="compare-item">
                        <h4 style="color:var(--orange);">Pythagorean Triples</h4>
                        <p style="margin:10px 0;">Complete analysis of Pythagorean triples and right triangle geometry.</p>
                        <a href="https://wessengetachew.github.io/Pythagorean-/" target="_blank" style="display:inline-block; padding:8px 16px; background:var(--orange); color:white; text-decoration:none; border-radius:6px; margin-top:10px;">Visit Project</a>
                    </div>
                    
                    <div class="compare-item">
                        <h4 style="color:var(--orange);">Ethiopian Multiplication</h4>
                        <p style="margin:10px 0;">Ancient multiplication algorithms and binary number patterns.</p>
                        <a href="https://wessengetachew.github.io/Ethiopian/" target="_blank" style="display:inline-block; padding:8px 16px; background:var(--orange); color:white; text-decoration:none; border-radius:6px; margin-top:10px;">Visit Project</a>
                    </div>
                </div>
                
                <h3 style="color:var(--red); margin-top:30px;">Advanced Topics & Transforms</h3>
                <div class="compare-grid">
                    <div class="compare-item">
                        <h4 style="color:var(--red);">Infinite Moduli</h4>
                        <p style="margin:10px 0;">Exploration of infinite modular arithmetic systems and patterns.</p>
                        <a href="https://wessengetachew.github.io/Infinitemoduli/" target="_blank" style="display:inline-block; padding:8px 16px; background:var(--red); color:white; text-decoration:none; border-radius:6px; margin-top:10px;">Visit Project</a>
                    </div>
                    
                    <div class="compare-item">
                        <h4 style="color:var(--red);">Transform Analysis</h4>
                        <p style="margin:10px 0;">Mathematical transforms and their applications to number theory.</p>
                        <a href="https://wessengetachew.github.io/Transform/" target="_blank" style="display:inline-block; padding:8px 16px; background:var(--red); color:white; text-decoration:none; border-radius:6px; margin-top:10px;">Visit Project</a>
                    </div>
                    
                    <div class="compare-item">
                        <h4 style="color:var(--red);">Phase Visualization</h4>
                        <p style="margin:10px 0;">Phase space analysis of arithmetic functions and sequences.</p>
                        <a href="https://wessengetachew.github.io/Phase/" target="_blank" style="display:inline-block; padding:8px 16px; background:var(--red); color:white; text-decoration:none; border-radius:6px; margin-top:10px;">Visit Project</a>
                    </div>
                    
                    <div class="compare-item">
                        <h4 style="color:var(--red);">Gemini Patterns</h4>
                        <p style="margin:10px 0;">Twin and dual structures in number theory.</p>
                        <a href="https://wessengetachew.github.io/Gemini/" target="_blank" style="display:inline-block; padding:8px 16px; background:var(--red); color:white; text-decoration:none; border-radius:6px; margin-top:10px;">Visit Project</a>
                    </div>
                    
                    <div class="compare-item">
                        <h4 style="color:var(--red);">Rebuild Framework</h4>
                        <p style="margin:10px 0;">Reconstruction and synthesis of mathematical structures.</p>
                        <a href="https://wessengetachew.github.io/Rebuild/" target="_blank" style="display:inline-block; padding:8px 16px; background:var(--red); color:white; text-decoration:none; border-radius:6px; margin-top:10px;">Visit Project</a>
                    </div>
                </div>
                
                <div class="formula" style="margin-top:40px; background:linear-gradient(135deg, rgba(0,102,204,0.1), rgba(111,66,193,0.1)); border-left:4px solid var(--blue);">
                    <h3 style="color:var(--blue);">About These Projects</h3>
                    <p>All visualizations are created by <b>Wessen Getachew</b> (<a href="https://twitter.com/7dview" target="_blank" style="color:var(--blue);">@7dview</a>) as part of an ongoing research initiative into the geometric and visual aspects of number theory.</p>
                    <p style="margin-top:10px;">Each project combines:</p>
                    <p>- Rigorous mathematical theory</p>
                    <p>- Interactive web-based visualizations</p>
                    <p>- High-performance computational algorithms</p>
                    <p>- Educational accessibility</p>
                    <p>- Professional-grade export capabilities</p>
                    
                    <p style="margin-top:15px; font-style:italic;">These tools are designed for mathematicians, researchers, educators, and anyone curious about the hidden patterns in numbers.</p>
                </div>
                
                <div class="section" style="margin-top:30px; text-align:center;">
                    <h3>Quick Navigation</h3>
                    <p style="margin:15px 0;">Jump to any visualization category:</p>
                    <div style="display:flex; gap:10px; justify-content:center; flex-wrap:wrap; margin-top:20px;">
                        <button onclick="window.open('https://wessengetachew.github.io/GCD/', '_blank')" style="padding:10px 20px; background:var(--blue); color:white; border:none; border-radius:6px; cursor:pointer;">GCD Explorer</button>
                        <button onclick="window.open('https://wessengetachew.github.io/Farey/', '_blank')" style="padding:10px 20px; background:var(--purple); color:white; border:none; border-radius:6px; cursor:pointer;">Farey Sequences</button>
                        <button onclick="window.open('https://wessengetachew.github.io/Primes/', '_blank')" style="padding:10px 20px; background:var(--green); color:white; border:none; border-radius:6px; cursor:pointer;">Prime Patterns</button>
                        <button onclick="window.open('https://wessengetachew.github.io/Pythagorean-/', '_blank')" style="padding:10px 20px; background:var(--orange); color:white; border:none; border-radius:6px; cursor:pointer;">Pythagorean Triples</button>
                        <button onclick="window.open('https://wessengetachew.github.io/Goldbach/', '_blank')" style="padding:10px 20px; background:var(--red); color:white; border:none; border-radius:6px; cursor:pointer;">Goldbach Conjecture</button>
                    </div>
                </div>
            </div>
        </div>

        <div id="tools" class="panel">
            <div class="section">
                <h2>Mathematical Tools <span class="help-icon tooltip" data-tip="Number theory utilities">?</span></h2>
                
                <h3>GCD Calculator</h3>
                <div class="controls">
                    <div style="display:flex; gap:8px; margin-bottom:10px; flex-wrap:wrap;">
                        <button onclick="setGCDPreset('coprime')" style="padding:6px 12px; font-size:0.9em;">Coprime Example</button>
                        <button onclick="setGCDPreset('common')" style="padding:6px 12px; font-size:0.9em;">Common Factor</button>
                        <button onclick="setGCDPreset('large')" style="padding:6px 12px; font-size:0.9em;">Large Numbers</button>
                        <button onclick="setGCDPreset('many')" style="padding:6px 12px; font-size:0.9em;">Many Numbers</button>
                    </div>
                    <input type="text" id="gi" placeholder="12, 18, 24" style="width:100%; padding:10px">
                    <button onclick="calcGCD()">Calculate</button>
                    <div id="gr" style="margin-top:15px"></div>
                </div>

                <h3>Möbius Function μ(n)</h3>
                <div class="controls">
                    <div style="display:flex; gap:8px; margin-bottom:10px; flex-wrap:wrap;">
                        <button onclick="setMobiusPreset('squarefree')" style="padding:6px 12px; font-size:0.9em;">Square-free</button>
                        <button onclick="setMobiusPreset('notsquarefree')" style="padding:6px 12px; font-size:0.9em;">Not Square-free</button>
                        <button onclick="setMobiusPreset('prime')" style="padding:6px 12px; font-size:0.9em;">Prime Number</button>
                        <button onclick="setMobiusPreset('composite')" style="padding:6px 12px; font-size:0.9em;">Large Composite</button>
                    </div>
                    <input type="number" id="mi" placeholder="30" style="width:100%; padding:10px" min="1">
                    <button onclick="calcMobius()">Calculate</button>
                    <div id="mr2" style="margin-top:15px"></div>
                </div>

                <h3>Prime Factorization</h3>
                <div class="controls">
                    <div style="display:flex; gap:8px; margin-bottom:10px; flex-wrap:wrap;">
                        <button onclick="setPrimePreset('small')" style="padding:6px 12px; font-size:0.9em;">Small Number</button>
                        <button onclick="setPrimePreset('perfect')" style="padding:6px 12px; font-size:0.9em;">Perfect Number</button>
                        <button onclick="setPrimePreset('highly')" style="padding:6px 12px; font-size:0.9em;">Highly Composite</button>
                        <button onclick="setPrimePreset('large')" style="padding:6px 12px; font-size:0.9em;">Large Number</button>
                        <button onclick="setPrimePreset('power')" style="padding:6px 12px; font-size:0.9em;">Prime Power</button>
                    </div>
                    <input type="number" id="pi" placeholder="360" style="width:100%; padding:10px" min="2">
                    <button onclick="calcPrime()">Factorize</button>
                    <div id="pr" style="margin-top:15px"></div>
                </div>

                <h3>Coprimality Checker</h3>
                <div class="controls">
                    <div style="display:flex; gap:8px; margin-bottom:10px; flex-wrap:wrap;">
                        <button onclick="setCoprimePreset('coprime2')" style="padding:6px 12px; font-size:0.9em;">Coprime Pair</button>
                        <button onclick="setCoprimePreset('notcoprime2')" style="padding:6px 12px; font-size:0.9em;">Non-Coprime Pair</button>
                        <button onclick="setCoprimePreset('coprime3')" style="padding:6px 12px; font-size:0.9em;">Coprime Triple</button>
                        <button onclick="setCoprimePreset('consecutive')" style="padding:6px 12px; font-size:0.9em;">Consecutive Numbers</button>
                    </div>
                    <input type="text" id="cci" placeholder="15, 28" style="width:100%; padding:10px">
                    <button onclick="checkCoprime()">Check</button>
                    <div id="ccr" style="margin-top:15px"></div>
                </div>

                <h3>Point Search</h3>
                <div class="controls">
                    <div style="display:flex; gap:8px; margin-bottom:10px; flex-wrap:wrap;">
                        <button onclick="setPointPreset('pythagorean')" style="padding:6px 12px; font-size:0.9em;">Pythagorean Triple</button>
                        <button onclick="setPointPreset('primitive2d')" style="padding:6px 12px; font-size:0.9em;">Primitive 2D</button>
                        <button onclick="setPointPreset('nonprimitive2d')" style="padding:6px 12px; font-size:0.9em;">Non-Primitive 2D</button>
                        <button onclick="setPointPreset('primitive3d')" style="padding:6px 12px; font-size:0.9em;">Primitive 3D</button>
                        <button onclick="setPointPreset('highd')" style="padding:6px 12px; font-size:0.9em;">High-D Point</button>
                    </div>
                    <input type="text" id="psi" placeholder="3, 4 (finds if primitive)" style="width:100%; padding:10px">
                    <button onclick="searchPoint()">Search</button>
                    <div id="psr" style="margin-top:15px"></div>
                </div>
            </div>
        </div>

        <div id="export" class="panel">
            <div class="section">
                <h2>Advanced Export Center <span class="help-icon tooltip" data-tip="Professional export with titles and legends">?</span></h2>
                <p>Export high-resolution images with custom titles, subtitles, and legends. Choose resolution and canvas to export.</p>
                
                <div class="controls">
                    <div style="background:var(--bg3); padding:20px; border-radius:8px; margin-bottom:20px;">
                        <h3 style="color:var(--blue); margin-bottom:15px;">Export Settings</h3>
                        
                        <label><b>Canvas to Export:</b></label>
                        <select id="exportCanvas" style="width:100%; padding:10px; margin:10px 0; border-radius:6px; background:var(--bg); color:var(--text); border:1px solid var(--border);">
                            <option value="c2d">2D Lattice Visualization</option>
                            <option value="heatmapCanvas">GCD Heatmap</option>
                            <option value="gcdTableCanvas">GCD Multiplication Table</option>
                            <option value="criticalCanvas">Critical Strip Analysis</option>
                            <option value="patternCanvas">Pattern Visualization</option>
                            <option value="densityCanvas">Density Distribution</option>
                            <option value="angularCanvas">Angular Distribution</option>
                            <option value="radialCanvas">Radial Shell Analysis</option>
                            <option value="compChart">Dimension Comparison Chart</option>
                            <option value="ch">Error Analysis Chart</option>
                        </select>
                        
                        <label style="margin-top:15px;"><b>Resolution:</b></label>
                        <div style="display:grid; grid-template-columns: repeat(auto-fit, minmax(100px, 1fr)); gap:10px; margin:10px 0;">
                            <button id="res1k" class="active" onclick="setExportRes('1k')" style="padding:10px;">1K (1920×1080)</button>
                            <button id="res2k" onclick="setExportRes('2k')" style="padding:10px;">2K (2560×1440)</button>
                            <button id="res4k" onclick="setExportRes('4k')" style="padding:10px;">4K (3840×2160)</button>
                            <button id="res8k" onclick="setExportRes('8k')" style="padding:10px;">8K (7680×4320)</button>
                        </div>
                        
                        <label style="margin-top:15px;"><b>Title:</b></label>
                        <input type="text" id="exportTitle" placeholder="e.g., Primitive Lattice Point Distribution" style="width:100%; padding:10px; margin:5px 0; border-radius:6px; background:var(--bg); color:var(--text); border:1px solid var(--border);">
                        
                        <label style="margin-top:10px;"><b>Subtitle:</b></label>
                        <input type="text" id="exportSubtitle" placeholder="e.g., R=100, k=2, showing GCD patterns" style="width:100%; padding:10px; margin:5px 0; border-radius:6px; background:var(--bg); color:var(--text); border:1px solid var(--border);">
                        
                        <label style="margin-top:10px;"><b>Legend/Description:</b></label>
                        <textarea id="exportLegend" placeholder="Blue: Primitive (GCD=1)
Red: Non-Primitive (GCD>1)
Total Points: 12,345
Density: 60.79%" style="width:100%; padding:10px; margin:5px 0; border-radius:6px; background:var(--bg); color:var(--text); border:1px solid var(--border); min-height:100px; font-family:monospace;"></textarea>
                        
                        <label style="margin-top:10px;"><b>Decimal Precision:</b></label>
                        <div style="display:flex; gap:10px; align-items:center; margin:10px 0;">
                            <input type="range" id="exportPrecision" min="2" max="17" value="6" step="1" oninput="document.getElementById('exportPrecisionv').textContent=this.value" style="flex:1;">
                            <span id="exportPrecisionv" style="min-width:30px;">6</span>
                            <span style="font-size:0.9em; color:var(--text2);">decimal places</span>
                        </div>
                        
                        <div style="margin-top:15px;">
                            <label style="display:flex; align-items:center; gap:8px;">
                                <input type="checkbox" id="includeMetadata" checked> Include Title & Legend
                            </label>
                            <label style="display:flex; align-items:center; gap:8px; margin-top:8px;">
                                <input type="checkbox" id="includeTimestamp" checked> Include Timestamp
                            </label>
                            <label style="display:flex; align-items:center; gap:8px; margin-top:8px;">
                                <input type="checkbox" id="includeWatermark" checked> Include "By Wessen Getachew | @7dview"
                            </label>
                            <label style="display:flex; align-items:center; gap:8px; margin-top:8px;">
                                <input type="checkbox" id="includeFullPrecision" checked> Include Full Precision Values
                            </label>
                        </div>
                    </div>
                    
                    <div style="background:var(--bg3); padding:20px; border-radius:8px; margin-bottom:20px;">
                        <h3 style="color:var(--blue); margin-bottom:15px;">Quick Export Presets</h3>
                        <div style="display:grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap:10px;">
                            <button onclick="quickExport2D()" style="padding:12px;">Export Current 2D View</button>
                            <button onclick="quickExport3D()" style="padding:12px;">Export Current 3D View</button>
                            <button onclick="quickExportHeatmap()" style="padding:12px;">Export GCD Heatmap</button>
                            <button onclick="quickExportCritical()" style="padding:12px;">Export Critical Strip</button>
                            <button onclick="quickExportTable()" style="padding:12px;">Export GCD Table</button>
                            <button onclick="quickExportAnalysis()" style="padding:12px;">Export Error Analysis</button>
                        </div>
                    </div>
                    
                    <div style="text-align:center; margin-top:20px;">
                        <button onclick="performAdvancedExport()" style="padding:15px 40px; font-size:1.1em; background:var(--green); color:white;">
                            Export with Metadata
                        </button>
                    </div>
                </div>
                
                <div id="exportPreview" style="background:var(--bg3); padding:20px; border-radius:8px; margin-top:20px; min-height:200px; text-align:center;">
                    <p style="color:var(--text2); font-style:italic;">Export preview will appear here</p>
                    <canvas id="exportPreviewCanvas" style="max-width:100%; margin-top:20px; display:none; border:2px solid var(--border); border-radius:8px;"></canvas>
                </div>
                
                <div class="formula" style="margin-top:20px;">
                    <p><b>Export Features:</b></p>
                    <p>- High-resolution output (up to 8K: 7680×4320)</p>
                    <p>- Custom titles, subtitles, and legends</p>
                    <p>- Automatic parameter documentation</p>
                    <p>- Clean layout without overlap</p>
                    <p>- Professional formatting for publications</p>
                    <p>- Timestamp and attribution options</p>
                    <p>- Configurable decimal precision (2-17 places)</p>
                    <p>- Full precision data preservation</p>
                    
                    <p style="margin-top:15px;"><b>CSV Export Features:</b></p>
                    <p>- Descriptive headers with metadata</p>
                    <p>- ISO 8601 timestamps</p>
                    <p>- Full attribution and licensing info</p>
                    <p>- Up to 17 decimal places for high-k dimensions</p>
                    <p>- Comment lines (# prefix) for documentation</p>
                    <p>- Automatic precision selection based on dimension</p>
                </div>
            </div>
        </div>

        <div id="roadmap" class="panel">
            <div class="section">
                <h2>Research Roadmap & Missing Features</h2>
                <p>This platform is comprehensive, but mathematical research is infinite. Here's what could enhance this work:</p>
                
                <h3 style="color:var(--blue); margin-top:30px;">High Priority - Core Mathematics</h3>
                <div class="formula">
                    <p><b>1. Farey Sequences & Ford Circles</b></p>
                    <p>• Visualization of Farey fractions F_n = {a/b : 0 ≤ a ≤ b ≤ n, gcd(a,b)=1}</p>
                    <p>• Ford circles tangent to primitive fractions</p>
                    <p>• Connection to continued fractions and Stern-Brocot tree</p>
                    <p>• Cayley transform mapping to hyperbolic geometry</p>
                    
                    <p style="margin-top:15px;"><b>2. Visible Lattice Points (Visibility Graph)</b></p>
                    <p>• Points visible from origin (exactly the primitive points)</p>
                    <p>• Angular gap distribution between visible points</p>
                    <p>• Connection to coprime probability</p>
                    
                    <p style="margin-top:15px;"><b>3. Diophantine Approximation</b></p>
                    <p>• Best rational approximations to irrationals</p>
                    <p>• Continued fraction convergents</p>
                    <p>• Dirichlet's approximation theorem visualization</p>
                    
                    <p style="margin-top:15px;"><b>4. Pick's Theorem & Lattice Polygons</b></p>
                    <p>• Area = Interior + Boundary/2 - 1</p>
                    <p>• Interactive polygon builder on lattice</p>
                    <p>• Connection to Euler's formula</p>
                </div>
                
                <h3 style="color:var(--green); margin-top:30px;">Advanced Visualizations</h3>
                <div class="formula">
                    <p><b>5. Voronoi Diagrams & Delaunay Triangulation</b></p>
                    <p>• Voronoi cells around primitive points</p>
                    <p>• Dual Delaunay triangulation</p>
                    <p>• Nearest primitive point queries</p>
                    
                    <p style="margin-top:15px;"><b>6. Minkowski's Theorem Visualization</b></p>
                    <p>• Convex symmetric regions containing lattice points</p>
                    <p>• Volume threshold: V > 2^k guarantees interior point</p>
                    <p>• Applications to algebraic number theory</p>
                    
                    <p style="margin-top:15px;"><b>7. Lattice Reduction Algorithms</b></p>
                    <p>• LLL algorithm animation</p>
                    <p>• Gaussian lattice reduction (2D)</p>
                    <p>• Shortest vector problem visualization</p>
                </div>
                
                <h3 style="color:var(--purple); margin-top:30px;">Deep Number Theory Connections</h3>
                <div class="formula">
                    <p><b>8. Explicit Formulas Using Zeta Zeros</b></p>
                    <p>• N(R) = Main Term + Σ (contribution from each zeta zero)</p>
                    <p>• Visualize oscillations from imaginary parts of zeros</p>
                    <p>• Connection between zero spacing and error term</p>
                    
                    <p style="margin-top:15px;"><b>9. Prime Number Connections</b></p>
                    <p>• Lattice points with prime coordinates</p>
                    <p>• Distribution of primes in lattice</p>
                    <p>• Connection to prime number theorem</p>
                    
                    <p style="margin-top:15px;"><b>10. Modular Forms & L-functions</b></p>
                    <p>• Theta functions counting lattice points</p>
                    <p>• Connection to elliptic curves</p>
                    <p>• Modular symmetry visualization</p>
                    
                    <p style="margin-top:15px;"><b>11. Euler Products & Multiplicative Functions</b></p>
                    <p>• ζ(s) = Π (1 - p^(-s))^(-1) visualization</p>
                    <p>• Connection between prime factors and GCD patterns</p>
                    <p>• Dirichlet series for various arithmetic functions</p>
                </div>
                
                <h3 style="color:var(--orange); margin-top:30px;">Platform Enhancements</h3>
                <div class="formula">
                    <p><b>12. Research Session Management</b></p>
                    <p>• Save/load current state and parameters</p>
                    <p>• Bookmark interesting configurations</p>
                    <p>• Research notes and annotations</p>
                    <p>• Export complete research sessions</p>
                    
                    <p style="margin-top:15px;"><b>13. Batch Processing & Parameter Sweeps</b></p>
                    <p>• Automated exploration of parameter space</p>
                    <p>• Generate data for multiple (k, R) combinations</p>
                    <p>• Statistical analysis across parameter ranges</p>
                    <p>• Parallel computation for large datasets</p>
                    
                    <p style="margin-top:15px;"><b>14. Advanced Statistical Tools</b></p>
                    <p>• Correlation analysis between metrics</p>
                    <p>• Hypothesis testing framework</p>
                    <p>• Regression analysis for error bounds</p>
                    <p>• Monte Carlo simulations</p>
                    
                    <p style="margin-top:15px;"><b>15. Educational Features</b></p>
                    <p>• Step-by-step guided tours</p>
                    <p>• Interactive tutorials for each concept</p>
                    <p>• Problem sets with solutions</p>
                    <p>• Historical context and references</p>
                </div>
                
                <h3 style="color:var(--red); margin-top:30px;">Advanced Topics</h3>
                <div class="formula">
                    <p><b>16. Quaternion & Octonion Lattices</b></p>
                    <p>• Generalization beyond integer lattices</p>
                    <p>• Hurwitz quaternions and E₈ lattice</p>
                    <p>• Sphere packing connections</p>
                    
                    <p style="margin-top:15px;"><b>17. Algebraic Number Theory</b></p>
                    <p>• Lattices in number fields</p>
                    <p>• Units and class groups</p>
                    <p>• Ideal lattices</p>
                    
                    <p style="margin-top:15px;"><b>18. Computational Complexity</b></p>
                    <p>• Algorithm efficiency analysis</p>
                    <p>• Optimization techniques</p>
                    <p>• GPU acceleration for large R</p>
                    
                    <p style="margin-top:15px;"><b>19. Machine Learning Integration</b></p>
                    <p>• Pattern recognition in lattice structures</p>
                    <p>• Predicting error term behavior</p>
                    <p>• Neural networks for lattice problems</p>
                    
                    <p style="margin-top:15px;"><b>20. Collaborative Research Features</b></p>
                    <p>• Share configurations via URL</p>
                    <p>• Real-time collaboration mode</p>
                    <p>• Community contributions database</p>
                    <p>• Discussion forums for specific phenomena</p>
                </div>
                
                <div style="background:var(--bg3); padding:20px; border-radius:8px; margin-top:30px;">
                    <h3 style="color:var(--blue);">What This Platform Currently Has</h3>
                    <p>- Complete primitive lattice point theory (k=2 to 12)</p>
                    <p>- 2D/3D interactive visualizations with multiple coloring modes</p>
                    <p>- GCD heatmaps and multiplication tables</p>
                    <p>- Critical strip error analysis (Gauss Circle Problem)</p>
                    <p>- Pattern explorer (modular, angular, radial, density)</p>
                    <p>- Dimension comparison tools</p>
                    <p>- Professional export system (up to 8K resolution)</p>
                    <p>- Point labeling and zoom controls</p>
                    <p>- High-precision calculations (up to 17 decimals)</p>
                    <p>- Comprehensive mathematical tools (GCD, Möbius, primes)</p>
                    <p>- Full derivation and theoretical framework</p>
                    <p>- Extensive parameter controls (R up to 2000 in 2D)</p>
                </div>
                
                <div style="background:var(--bg2); padding:20px; border-radius:8px; margin-top:20px; border-left:4px solid var(--blue);">
                    <h3>Suggestions for Next Steps</h3>
                    <p><b>Immediate:</b> Farey sequences, Ford circles, visible points</p>
                    <p><b>Short-term:</b> Voronoi diagrams, lattice reduction, Pick's theorem</p>
                    <p><b>Long-term:</b> Explicit formulas with zeros, modular forms, collaborative features</p>
                </div>
            </div>
        </div>

        <div id="derivation" class="panel">
            <div class="section">
                <h2>Interactive Derivation</h2>
                
                <h3>Step 1: Counting Lattice Points</h3>
                <p>Start with all lattice points in a k-dimensional sphere of radius R:</p>
                <div class="formula">$$L_k(R) = |\{(x_1,...,x_k) \in \mathbb{Z}^k : x_1^2 + ... + x_k^2 \leq R^2\}|$$</div>
                <p>Asymptotically, this equals the volume: L_k(R) ~ V_k R^k</p>

                <h3>Step 2: Separating by GCD</h3>
                <p>Partition points by their greatest common divisor d:</p>
                <div class="formula">$$L_k(R) = \sum_{d=1}^{R} N_k(R/d)$$</div>
                <p>Where N_k(R/d) counts primitive points in a sphere of radius R/d.</p>

                <h3>Step 3: Möbius Inversion</h3>
                <p>Inverting the previous relation using Möbius function:</p>
                <div class="formula">$$N_k(R) = \sum_{d=1}^{R} \mu(d) L_k(R/d)$$</div>
                
                <h3>Step 4: Asymptotic Expansion</h3>
                <p>Substituting L_k(R/d) ~ V_k (R/d)^k:</p>
                <div class="formula">$$N_k(R) = V_k R^k \sum_{d=1}^{\infty} \frac{\mu(d)}{d^k} + O(R^{k-1})$$</div>

                <h3>Step 5: Zeta Connection</h3>
                <p>The sum equals the reciprocal of the zeta function:</p>
                <div class="formula">$$\sum_{d=1}^{\infty} \frac{\mu(d)}{d^k} = \frac{1}{\zeta(k)}$$</div>
                
                <h3>Final Result</h3>
                <div class="formula">$$N_k(R) = \frac{V_k R^k}{\zeta(k)} + O(R^{k-1})$$</div>
                <p>This elegant formula connects geometry (V_k), analysis (ζ(k)), and number theory (primitive points)!</p>
                
                <div class="controls" style="margin-top: 30px;">
                    <button onclick="showDerivationAnimation()">Animate Derivation</button>
                </div>
                
                <div style="margin-top:40px;">
                    <h3 style="color:var(--blue);">Bibliography & References</h3>
                    
                    <div class="formula">
                        <p><b>Hardy, G. H., & Wright, E. M.</b> (1979). <i>An Introduction to the Theory of Numbers</i>. Oxford University Press.</p>
                        <p style="margin-left:20px; font-size:0.9em; color:var(--text2);">Classical proofs for 6/π² density and fundamental results in coprimality.</p>
                    </div>
                    
                    <div class="formula">
                        <p><b>Dirichlet, G. L.</b> (1849). <i>Über die Bestimmung der mittleren Werthe in der Zahlentheorie</i>.</p>
                        <p style="margin-left:20px; font-size:0.9em; color:var(--text2);">Foundational work on lattice point problems and average values in number theory.</p>
                    </div>
                    
                    <div class="formula">
                        <p><b>Mertens, F.</b> (1874). <i>Über einige asymptotische Gesetze der Zahlentheorie</i>.</p>
                        <p style="margin-left:20px; font-size:0.9em; color:var(--text2);">Refinement of error bounds in arithmetic sums and the Mertens function.</p>
                    </div>
                    
                    <div class="formula">
                        <p><b>Titchmarsh, E. C.</b> (1986). <i>The Theory of the Riemann Zeta-Function</i>. Oxford Science Publications.</p>
                        <p style="margin-left:20px; font-size:0.9em; color:var(--text2);">Connection between error terms and the Riemann Hypothesis.</p>
                    </div>
                    
                    <div class="formula">
                        <p><b>Cesàro, E.</b> (1883). <i>Probabilité de certains faits arithmétiques</i>.</p>
                        <p style="margin-left:20px; font-size:0.9em; color:var(--text2);">Early work on the probability interpretation of 6/π².</p>
                    </div>
                    
                    <div class="formula">
                        <p><b>Pillai, S. S., & Chowla, S.</b> (1930). <i>On the Error Terms in Some Asymptotic Formulae</i>.</p>
                        <p style="margin-left:20px; font-size:0.9em; color:var(--text2);">Analysis of k=2 error bounds and refinements.</p>
                    </div>
                    
                    <div class="formula">
                        <p><b>van der Corput, J. G.</b> (1923). <i>Zahlentheoretische Abschätzungen</i>.</p>
                        <p style="margin-left:20px; font-size:0.9em; color:var(--text2);">Classical O(R^(2/3)) bound for the Gauss circle problem.</p>
                    </div>
                    
                    <div class="formula" style="margin-top:20px; background:linear-gradient(135deg, rgba(0,102,204,0.1), rgba(111,66,193,0.1));">
                        <p><b>Further Reading:</b></p>
                        <p>- Apostol, T. M. (1976). <i>Introduction to Analytic Number Theory</i>. Springer-Verlag.</p>
                        <p>- Nathanson, M. B. (1996). <i>Additive Number Theory: The Classical Bases</i>. Springer.</p>
                        <p>- Iwaniec, H., & Kowalski, E. (2004). <i>Analytic Number Theory</i>. American Mathematical Society.</p>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <button class="btn-fixed" id="helpBtn" onclick="showHelp()">Help</button>
    <button class="btn-fixed" id="darkBtn" onclick="toggleDark()">Light Mode</button>

    <div class="modal" id="helpModal">
        <div class="modal-content">
            <span class="modal-close" onclick="closeHelp()">&times;</span>
            <h2>Platform Guide</h2>
            <h3>Navigation</h3>
            <p>Use the tabs to explore different aspects of primitive lattice points.</p>
            
            <h3>GCD Heatmap</h3>
            <p><b>Interactive Features:</b></p>
            <p>- Click on any point to see detailed GCD information</p>
            <p>- Three display modes: by GCD value, primitive only, or distance gradient</p>
            <p>- Filter points by specific GCD values (1, 2, 3, or >3)</p>
            <p>- View statistics for each GCD category</p>
            <p>- Export point data for further analysis</p>
            <p>- Supports radius up to 1000 (use input box for large values)</p>
            
            <h3>GCD Table</h3>
            <p><b>Multiplication table showing GCD(row, col):</b></p>
            <p>- Click any cell to see GCD calculation details</p>
            <p>- Three color schemes: heat map, discrete GCD, prime powers</p>
            <p>- Toggle value display and diagonal highlighting</p>
            <p>- Observe symmetry and patterns in divisibility</p>
            <p>- Grid sizes from 5×5 up to 200×200</p>
            
            <h3>2D Visualizations</h3>
            <p><b>Point Labeling Options:</b></p>
            <p>- <b>No Labels:</b> Clean visualization without text</p>
            <p>- <b>By GCD:</b> Shows GCD value for each point</p>
            <p>- <b>Coordinates:</b> Displays (x,y) for each point</p>
            <p>- <b>By Angle:</b> Shows angle in degrees from x-axis</p>
            <p>- Control font size (6-16px) and max labels (10-500)</p>
            <p>- Labels shown for points closest to origin</p>
            <p>- Supports radius up to 1000</p>
            
            <h3>Critical Strip Projection</h3>
            <p><b>Gauss Circle Problem & Riemann Hypothesis:</b></p>
            <p>- Choose between all lattice points or primitive points only</p>
            <p>- Four visualization types:</p>
            <p>&nbsp;&nbsp;- Error vs Radius: Shows Δ(R) oscillating around zero</p>
            <p>&nbsp;&nbsp;- Normalized: Δ(R)/R^(1/2) tests RH bound conjecture</p>
            <p>&nbsp;&nbsp;- Log-Log: Reveals power law relationships</p>
            <p>&nbsp;&nbsp;- With Bounds: Compares against theoretical bounds</p>
            <p>- Click on points to see detailed error analysis</p>
            <p>- RH bound (purple): O(R^(1/2)) - conjectured if RH is true</p>
            <p>- Classical bound (red): O(R^(2/3)) - proven result</p>
            <p>- Error sign indicates over/under counting vs prediction</p>
            
            <h3>2D Visualizations</h3>
            <p><b>View Modes:</b></p>
            <p>- <b>Colored by Mode:</b> Points colored according to selected coloring mode</p>
            <p>- <b>Gauss Circle Problem:</b> All lattice points in purple, comparing against πR²</p>
            
            <p style="margin-top:15px;"><b>Coloring Modes (2D):</b></p>
            <p>- <b>GCD=1 vs GCD>1:</b> Blue for primitive (coprime), red for non-primitive</p>
            <p>- <b>By GCD Value:</b> Different color for each GCD (1=blue, 2=red, 3=green, 4=yellow, etc.)</p>
            <p>- <b>By Mod m:</b> Colors based on (x+y) mod m - reveals modular patterns</p>
            <p>- <b>By Quadrant:</b> Four colors for four quadrants (I=blue, II=green, III=yellow, IV=red)</p>
            <p>- <b>By Angular Sector:</b> Rainbow colors dividing circle into sectors</p>
            <p>- <b>GCD × Quadrant:</b> Combined coloring showing both GCD structure and spatial position</p>
            <p>- <b>GCD × Mod:</b> Combined coloring revealing GCD and modular arithmetic patterns</p>
            
            <p style="margin-top:15px;"><b>View Modes:</b></p>
            <p>• <b>Colored by Mode:</b> Points colored according to selected coloring mode</p>
            <p>• <b>Gauss Circle Problem:</b> All lattice points in purple, comparing against πR²</p>
            <p>• <b>GCD=1 vs GCD>1:</b> Blue for primitive (coprime), red for non-primitive</p>
            <p>• <b>By GCD Value:</b> Different color for each GCD (1=blue, 2=red, 3=green, 4=yellow, etc.)</p>
            <p>• <b>By Mod m:</b> Colors based on (x+y) mod m - reveals modular patterns</p>
            <p>• <b>By Quadrant:</b> Four colors for four quadrants (I=blue, II=green, III=yellow, IV=red)</p>
            <p>• <b>By Angular Sector:</b> Rainbow colors dividing circle into sectors</p>
            <p>• <b>GCD × Quadrant:</b> Combined coloring showing both GCD structure and spatial position</p>
            <p>• <b>GCD × Mod:</b> Combined coloring revealing GCD and modular arithmetic patterns</p>
            
            <h3>3D Visualizations</h3>
            <p><b>Camera Controls:</b></p>
            <p>- Click and drag to rotate view</p>
            <p>- Use zoom slider (30-150) to adjust camera distance</p>
            <p>- Reset button returns to default view</p>
            <p>- Auto-rotate button for continuous rotation</p>
            
            <p style="margin-top:10px;"><b>Point Labeling:</b></p>
            <p>- <b>No Labels:</b> Clean 3D view</p>
            <p>- <b>By GCD:</b> Shows GCD value on sprites</p>
            <p>- <b>Coordinates:</b> Displays (x,y,z) for each labeled point</p>
            <p>- Control max labels (10-200) to avoid clutter</p>
            <p>- Labels shown for points closest to origin</p>
            
            <p style="margin-top:10px;"><b>Boundary Shapes:</b></p>
            <p>- Sphere: Points within distance R (x²+y²+z² ≤ R²)</p>
            <p>- Cube: Points within cube of side 2R (|x|,|y|,|z| ≤ R)</p>
            
            <p style="margin-top:15px;"><b>Coloring Modes (3D):</b></p>
            <p>- <b>GCD=1 vs GCD>1:</b> Blue for primitive, red for non-primitive</p>
            <p>- <b>By GCD Value:</b> Different colors for different GCD values</p>
            <p>- <b>By Mod m:</b> Colors based on (x+y+z) mod m</p>
            <p>- <b>By Octant:</b> Eight colors for eight octants in 3D space</p>
            <p>- <b>By Distance:</b> Gradient from center (blue) to boundary (red)</p>
            <p>- <b>GCD × Octant:</b> Combined coloring showing GCD and spatial structure</p>
            <p>- <b>GCD × Mod:</b> Combined GCD and modular arithmetic visualization</p>
            
            <p style="margin-top:10px;">Click and drag to rotate the view. Adjust point size for clarity.</p>
            
            <h3>Error Analysis</h3>
            <p>Shows error per radius value from start to max radius:</p>
            <p>- <b>Computes for EVERY single R value</b> (no skipping!) - this is the key improvement</p>
            <p>- <b>Absolute Error:</b> |Predicted - Actual| count of points</p>
            <p>- <b>Relative Error:</b> Percentage error relative to prediction</p>
            <p>- <b>Running Average:</b> Cumulative average of errors, shows convergence</p>
            <p>- <b>Boundary Term:</b> Theoretical O(R^(k-1)) error bound</p>
            <p>- <b>Actual Count:</b> The true primitive point count at each radius</p>
            <p>- <b>Click on chart points</b> to see detailed analysis for that radius</p>
            <p>- <b>Computation ranges:</b> k=2 exact up to R=200, k=3 up to R=40, k=4 up to R=15</p>
            
            <h3>Performance Tips</h3>
            <p>- Keep radius ≤ 200 in 2D, ≤ 30 in 3D for smooth performance</p>
            <p>- Use zoom slider in 2D to focus on specific regions</p>
            <p>- Limit number of labels for large radius values</p>
            <p>- Use Export tab for high-resolution outputs</p>
            <p>- Compare mode shows multiple dimensions simultaneously</p>
            
            <h3>Export Features</h3>
            <p><b>Advanced Export Center:</b></p>
            <p>- Export at 1K, 2K, 4K, or 8K resolution</p>
            <p>- Add custom titles, subtitles, and legends</p>
            <p>- Include timestamps and attribution</p>
            <p>- Clean layout optimized for publications</p>
            <p>- Quick export presets for each visualization</p>
            <p>- Preview before downloading</p>
            
            <h3>Explore More Tab</h3>
            <p><b>Related Mathematical Visualizations:</b></p>
            <p>- Links to 15+ related number theory visualization projects</p>
            <p>- Organized by category: Core Lattice Theory, Primes, Rationals, Geometry, Advanced Topics</p>
            <p>- Includes: Farey Sequences, Prime Patterns, Pythagorean Triples, Goldbach Conjecture, and more</p>
            <p>- Quick navigation buttons for popular projects</p>
            <p>- All projects by Wessen Getachew (@7dview)</p>
            
            <h3>Precision Display</h3>
            <p>- Higher dimensions (k>6) automatically show up to 17 decimal places</p>
            <p>- All CSV exports include full precision values (12-17 decimals)</p>
            <p>- Theory table shows maximum precision for each dimension</p>
            <p>- Export Center allows custom precision control (2-17 decimals)</p>
            <p>- All statistical values use appropriate precision</p>
            <p>- formatPrecise() removes trailing zeros for clean display</p>
            
            <h3>CSV Export Headers</h3>
            <p><b>All CSV files now include:</b></p>
            <p>- Descriptive header with parameters</p>
            <p>- Generation timestamp (ISO format)</p>
            <p>- Attribution line (Wessen Getachew | @7dview)</p>
            <p>- Column descriptions and formulas</p>
            <p>- Full precision numerical values</p>
            <p>- Metadata comments (lines starting with #)</p>
            
            <h3>Tools Section</h3>
            <p>Calculate GCD, Möbius function, prime factorizations, and search for specific lattice points.</p>
        </div>
    </div>

    <script>
        let scene, camera, renderer, chart, autoRotate = false;
        const cache = { mobius: new Map(), gcd: new Map(), points2D: null, points3D: null };
        let mouseDown = false, prevMouse = { x: 0, y: 0 };
        let view2D = 'primitive'; // 'primitive' or 'gauss'
        let comparisonMode = 'fixed'; // 'fixed' or 'multi'
        let comparisonChart = null;
        let shape3D = 'sphere'; // 'sphere' or 'cube'
        let colorMode3D = 'primitive'; // 'primitive', 'gcd', 'mod', 'octant', 'distance', 'gcdoct', 'gcdmod'
        let colorMode2D = 'primitive'; // 'primitive', 'gcd', 'mod', 'quadrant', 'angular', 'gcdquad', 'gcdmod'
        let patternType = 'modular'; // 'modular', 'density', 'angular', 'radial'
        let patternChart = null;
        let heatmapMode = 'gcd'; // 'gcd', 'primitive', 'gradient'
        let heatmapPointsData = [];
        let criticalProblem = 'all'; // 'all' or 'primitive'
        let criticalViz = 'error'; // 'error', 'normalized', 'loglog', 'bounds'
        let labelMode2D = 'none'; // 'none', 'gcd', 'coords', 'angle'
        let labelMode3D = 'none'; // 'none', 'gcd', 'coords'
        let zoom2D = 100; // percentage

        function gcd(a, b) {
            a = Math.abs(a); b = Math.abs(b);
            while (b) [a, b] = [b, a % b];
            return a;
        }

        function gcdArray(arr) { return arr.reduce((a, b) => gcd(a, b)); }

        function isPrime(n) {
            if (n < 2) return false;
            if (n === 2) return true;
            if (n % 2 === 0) return false;
            for (let i = 3; i <= Math.sqrt(n); i += 2)
                if (n % i === 0) return false;
            return true;
        }

        function primeFactors(n) {
            const f = []; let d = 2;
            while (n > 1) {
                while (n % d === 0) { f.push(d); n /= d; }
                d++; if (d * d > n && n > 1) { f.push(n); break; }
            }
            return f;
        }

        function mobius(n) {
            if (cache.mobius.has(n)) return cache.mobius.get(n);
            if (n === 1) return 1;
            const f = primeFactors(n), u = [...new Set(f)];
            const r = f.length !== u.length ? 0 : Math.pow(-1, f.length);
            cache.mobius.set(n, r);
            return r;
        }

        function zeta(k) {
            // High-precision values of Riemann zeta function
            // Values computed to 17+ significant digits for accuracy
            const zetaValues = {
                2: 1.6449340668482264364724151666460251892189499012067984377355582293700074704032008, // π²/6
                3: 1.2020569031595942853997381615114499907649862923404988817922715553418382057863130, // Apéry's constant
                4: 1.0823232337111381915160036965203424602670358005245652215687744977325193292562626, // π⁴/90
                5: 1.0369277551433699263313654864570341680570930368059547801691618005453021345702497,
                6: 1.0173430619844491397145179297909205279018308170593810024936035944827810422974380, // π⁶/945
                7: 1.0083492773819228268397975498927010152708887038172326474908044957211762572377413,
                8: 1.0040773561979443393786852385086524652589112775723573726453156820341030294683245, // π⁸/9450
                9: 1.0020083928260822144178527692324120604207065913078842989761076837454184103963039,
                10: 1.0009945751278180853371459589003190170060195315644005132132960339870433067119427,
                11: 1.0004941886041194645587022825264699365289285294032152077349046639354051175474382,
                12: 1.0002460865533080482986379980477396709829901813802687684994526934234004984493218 // π¹²/...
            };
            
            if (zetaValues[k]) {
                return zetaValues[k];
            }
            
            // For k > 12, use approximation ζ(k) ≈ 1 + 2^(-k)
            return 1 + Math.pow(2, -k);
        }
        
        function getPiHighPrecision() {
            // π to 50 decimal places
            return 3.14159265358979323846264338327950288419716939937510;
        }

        function sphereVolume(k, R) {
            const pi = getPiHighPrecision();
            
            // Use exact formulas with high-precision π
            if (k % 2 === 0) {
                // Even dimensions: V_k = π^(k/2) / (k/2)!
                const halfK = k / 2;
                return Math.pow(pi, halfK) / factorial(halfK) * Math.pow(R, k);
            } else {
                // Odd dimensions: V_k = 2^k * π^((k-1)/2) * ((k-1)/2)! / k!
                const halfKMinus = (k - 1) / 2;
                return 2 * factorial(halfKMinus) * Math.pow(pi, halfKMinus) / factorial(k) * Math.pow(R, k);
            }
        }

        function factorial(n) {
            if (n <= 1) return 1;
            let res = 1;
            for (let i = 2; i <= n; i++) res *= i;
            return res;
        }

        function animateValue(id, start, end, duration = 500) {
            const el = document.getElementById(id);
            const range = end - start;
            const increment = range / (duration / 16);
            let current = start;
            const timer = setInterval(() => {
                current += increment;
                if ((increment > 0 && current >= end) || (increment < 0 && current <= end)) {
                    el.textContent = typeof end === 'number' && end % 1 !== 0 ? end.toFixed(3) : Math.round(end).toLocaleString();
                    clearInterval(timer);
                } else {
                    el.textContent = typeof current === 'number' && current % 1 !== 0 ? current.toFixed(3) : Math.round(current).toLocaleString();
                }
            }, 16);
        }

        function showTab(id) {
            document.querySelectorAll('.panel').forEach(p => p.classList.remove('active'));
            document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
            document.getElementById(id).classList.add('active');
            event.target.classList.add('active');
            if (id === 'viz2d') draw2D();
            if (id === 'viz3d' && !scene) init3D();
            if (id === 'comparison') updateComparison();
            if (id === 'patterns') {
                setPatternType('modular');
                updatePatternViz();
            }
            if (id === 'gcdheatmap') {
                updateGCDHeatmap();
            }
            if (id === 'gcdtable') {
                updateGCDTable();
            }
            if (id === 'criticalstrip') {
                updateCriticalStrip();
            }
            if (id === 'export') {
                // Populate export options based on current visualizations
                document.getElementById('exportPreviewCanvas').style.display = 'none';
                document.getElementById('exportPreview').querySelector('p').style.display = 'block';
            }
            if (id === 'roadmap') {
                // Roadmap is static content, no initialization needed
            }
        }

        function updateTheory() {
            const k = parseInt(document.getElementById('tks').value);
            const R = parseInt(document.getElementById('trs').value);
            document.getElementById('tk').textContent = k;
            document.getElementById('tr').textContent = R;
            const z = zeta(k), d = 1/z;
            const vol = sphereVolume(k, R);
            const pred = Math.round(vol / z);
            
            // Use high precision for k > 6
            const precision = k > 6 ? 17 : 6;
            document.getElementById('currentPrecision').textContent = precision;
            
            document.getElementById('sz').textContent = formatPrecise(z, precision);
            document.getElementById('sd').textContent = formatPrecise(d, precision);
            animateValue('sp', parseInt(document.getElementById('sp').textContent.replace(/,/g, '')) || pred, pred);
            document.getElementById('svol').textContent = formatPrecise(vol, precision);
        }

        function set2DView(mode) {
            view2D = mode;
            document.querySelectorAll('#viewPrimitive, #viewGauss').forEach(btn => btn.classList.remove('active'));
            document.getElementById(mode === 'primitive' ? 'viewPrimitive' : 'viewGauss').classList.add('active');
            draw2D();
        }

        function set2DColorMode(mode) {
            colorMode2D = mode;
            document.querySelectorAll('#color2DPrimitive, #color2DGCD, #color2DMod, #color2DQuadrant, #color2DAngular, #color2DGCDQuad, #color2DGCDMod').forEach(btn => btn.classList.remove('active'));
            const btnIds = {
                'primitive': 'color2DPrimitive',
                'gcd': 'color2DGCD',
                'mod': 'color2DMod',
                'quadrant': 'color2DQuadrant',
                'angular': 'color2DAngular',
                'gcdquad': 'color2DGCDQuad',
                'gcdmod': 'color2DGCDMod'
            };
            document.getElementById(btnIds[mode]).classList.add('active');
            
            // Show/hide modulus controls
            document.getElementById('modControls2D').style.display = (mode === 'mod' || mode === 'gcdmod') ? 'block' : 'none';
            document.getElementById('sectorControls2D').style.display = (mode === 'angular') ? 'block' : 'none';
            
            draw2D();
        }

        function update2DRadius(value) {
            const R = parseInt(value);
            if (R < 1 || R > 1000 || isNaN(R)) return;
            
            document.getElementById('r2v').textContent = R;
            document.getElementById('r2').value = Math.min(R, 500);
            document.getElementById('r2input').value = R;
            
            // Show performance warning
            document.getElementById('warn2d').style.display = R > 200 ? 'block' : 'none';
            
            draw2D();
        }

        function draw2D() {
            const canvas = document.getElementById('c2d'), ctx = canvas.getContext('2d');
            const R = parseInt(document.getElementById('r2input').value);
            const sz = parseInt(document.getElementById('ps').value);
            document.getElementById('r2v').textContent = R;
            document.getElementById('psv').textContent = sz;
            
            document.getElementById('warn2d').style.display = R > 200 ? 'block' : 'none';
            if (R > 250) {
                document.getElementById('load2d').classList.add('active');
            }
            
            setTimeout(() => {
                ctx.clearRect(0, 0, 1200, 1200);
                const cx = 600, cy = 600;
                const baseScale = 550/R;
                const sc = baseScale * (zoom2D / 100);
                ctx.strokeStyle = getComputedStyle(document.body).getPropertyValue('--border');
                ctx.lineWidth = 2;
                ctx.beginPath(); ctx.arc(cx, cy, R*sc, 0, 2*Math.PI); ctx.stroke();
                
                const allPoints = [];
                let prim = 0, tot = 0;
                
                // Collect all points with properties
                for (let x = -R; x <= R; x++) {
                    for (let y = -R; y <= R; y++) {
                        if (x*x + y*y <= R*R) {
                            tot++;
                            const g = gcd(Math.abs(x), Math.abs(y));
                            const isPrimitive = g === 1;
                            if (isPrimitive) prim++;
                            
                            // Calculate quadrant
                            let quadrant;
                            if (x >= 0 && y >= 0) quadrant = 1;
                            else if (x < 0 && y >= 0) quadrant = 2;
                            else if (x < 0 && y < 0) quadrant = 3;
                            else quadrant = 4;
                            
                            // Calculate angle (0 to 2π)
                            const angle = Math.atan2(y, x) + Math.PI; // 0 to 2π
                            
                            allPoints.push({
                                x, y, gcd: g, isPrimitive, quadrant, angle,
                                sum: x + y
                            });
                        }
                    }
                }
                
                // Group points by color based on mode
                const pointsByColor = {};
                const modulus = parseInt(document.getElementById('mod2D').value);
                const numSectors = parseInt(document.getElementById('sectors2D').value);
                
                allPoints.forEach(pt => {
                    let colorKey;
                    
                    if (view2D === 'gauss') {
                        colorKey = 'all';
                    } else {
                        switch(colorMode2D) {
                            case 'primitive':
                                colorKey = pt.isPrimitive ? 'prim' : 'nonprim';
                                break;
                            case 'gcd':
                                colorKey = `gcd${Math.min(pt.gcd, 8)}`;
                                break;
                            case 'mod':
                                colorKey = `mod${((pt.x + pt.y) % modulus + modulus) % modulus}`;
                                break;
                            case 'quadrant':
                                colorKey = `quad${pt.quadrant}`;
                                break;
                            case 'angular':
                                const sector = Math.floor(pt.angle / (2 * Math.PI / numSectors));
                                colorKey = `sector${sector}`;
                                break;
                            case 'gcdquad':
                                colorKey = `gcd${Math.min(pt.gcd, 4)}_q${pt.quadrant}`;
                                break;
                            case 'gcdmod':
                                const modVal = ((pt.x + pt.y) % modulus + modulus) % modulus;
                                colorKey = `gcd${Math.min(pt.gcd, 4)}_m${modVal}`;
                                break;
                        }
                    }
                    
                    if (!pointsByColor[colorKey]) pointsByColor[colorKey] = [];
                    pointsByColor[colorKey].push(pt);
                });
                
                // Define color palettes
                const colors = {
                    all: '#6f42c1',
                    prim: '#0066cc',
                    nonprim: '#dc3545',
                    gcd1: '#0066cc', gcd2: '#dc3545', gcd3: '#28a745', gcd4: '#ffc107',
                    gcd5: '#6f42c1', gcd6: '#fd7e14', gcd7: '#00d4ff', gcd8: '#ff006e',
                    quad1: '#0066cc', quad2: '#28a745', quad3: '#ffc107', quad4: '#dc3545',
                    mod0: '#0066cc', mod1: '#dc3545', mod2: '#28a745', mod3: '#ffc107',
                    mod4: '#6f42c1', mod5: '#fd7e14', mod6: '#00d4ff', mod7: '#ff006e',
                    mod8: '#20c997', mod9: '#e83e8c', mod10: '#17a2b8', mod11: '#6610f2'
                };
                
                // Generate sector colors (rainbow)
                for (let i = 0; i < 16; i++) {
                    const hue = (i / 16) * 360;
                    colors[`sector${i}`] = `hsl(${hue}, 70%, 50%)`;
                }
                
                // Generate combined colors
                const baseColors = ['#0066cc', '#dc3545', '#28a745', '#ffc107'];
                for (let g = 1; g <= 4; g++) {
                    for (let q = 1; q <= 4; q++) {
                        colors[`gcd${g}_q${q}`] = baseColors[(g - 1 + q - 1) % 4];
                    }
                    for (let m = 0; m < 12; m++) {
                        const hue = ((g - 1) * 90 + m * 30) % 360;
                        colors[`gcd${g}_m${m}`] = `hsl(${hue}, 65%, 50%)`;
                    }
                }
                
                // Draw points
                Object.entries(pointsByColor).forEach(([colorKey, points]) => {
                    ctx.fillStyle = colors[colorKey] || '#999';
                    points.forEach(pt => {
                        ctx.beginPath();
                        ctx.arc(cx + pt.x*sc, cy - pt.y*sc, sz, 0, 2*Math.PI);
                        ctx.fill();
                    });
                });
                
                cache.points2D = { primitive: allPoints.filter(p => p.isPrimitive), 
                                   nonPrimitive: allPoints.filter(p => !p.isPrimitive), R };
                
                // Draw labels if enabled
                if (labelMode2D !== 'none') {
                    const labelSize = parseInt(document.getElementById('labelSize2D').value);
                    const maxLabels = parseInt(document.getElementById('maxLabels2D').value);
                    document.getElementById('labelSize2Dv').textContent = labelSize;
                    document.getElementById('maxLabels2Dv').textContent = maxLabels;
                    
                    // Sort points by distance from origin
                    const sortedPoints = [...allPoints].sort((a, b) => 
                        (a.x*a.x + a.y*a.y) - (b.x*b.x + b.y*b.y)
                    ).slice(0, maxLabels);
                    
                    ctx.fillStyle = getComputedStyle(document.body).getPropertyValue('--text');
                    ctx.font = `${labelSize}px system-ui`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    
                    sortedPoints.forEach(pt => {
                        let label;
                        if (labelMode2D === 'gcd') {
                            label = pt.gcd.toString();
                        } else if (labelMode2D === 'coords') {
                            label = `(${pt.x},${pt.y})`;
                        } else if (labelMode2D === 'angle') {
                            const angle = Math.atan2(pt.y, pt.x) * 180 / Math.PI;
                            label = `${angle.toFixed(0)}°`;
                        }
                        
                        const screenX = cx + pt.x*sc;
                        const screenY = cy - pt.y*sc;
                        
                        // Draw background for label
                        const metrics = ctx.measureText(label);
                        const labelWidth = metrics.width + 4;
                        const labelHeight = labelSize + 2;
                        ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                        ctx.fillRect(screenX - labelWidth/2, screenY - labelHeight/2, labelWidth, labelHeight);
                        
                        // Draw label text
                        ctx.fillStyle = '#fff';
                        ctx.fillText(label, screenX, screenY);
                    });
                }
                
                const pred = Math.round(Math.PI * R * R / zeta(2));
                const error = Math.abs(pred - prim);
                
                // Update stats based on view mode
                if (view2D === 'gauss') {
                    document.getElementById('p2').parentElement.querySelector('.lbl').textContent = 'Total Lattice Points';
                    animateValue('p2', 0, tot);
                    document.getElementById('t2').parentElement.querySelector('.lbl').textContent = 'Expected (πR²)';
                    animateValue('t2', 0, Math.round(Math.PI * R * R));
                    document.getElementById('d2').parentElement.querySelector('.lbl').textContent = 'Error';
                    document.getElementById('d2').textContent = Math.abs(tot - Math.PI * R * R).toFixed(1);
                    document.getElementById('e2').parentElement.querySelector('.lbl').textContent = '% of Expected';
                    document.getElementById('e2').textContent = ((tot / (Math.PI * R * R)) * 100).toFixed(2) + '%';
                } else {
                    document.getElementById('p2').parentElement.querySelector('.lbl').textContent = 'Primitive Points';
                    animateValue('p2', 0, prim);
                    document.getElementById('t2').parentElement.querySelector('.lbl').textContent = 'Total Points';
                    animateValue('t2', 0, tot);
                    document.getElementById('d2').parentElement.querySelector('.lbl').textContent = 'Density';
                    document.getElementById('d2').textContent = ((prim/tot)*100).toFixed(1) + '%';
                    document.getElementById('e2').parentElement.querySelector('.lbl').textContent = '|Predicted - Actual|';
                    animateValue('e2', 0, error);
                }
                
                document.getElementById('load2d').classList.remove('active');
            }, 100);
        }

        function init3D() {
            const c = document.getElementById('c3d');
            scene = new THREE.Scene();
            scene.background = new THREE.Color(document.body.classList.contains('light') ? 0xffffff : 0x1a1a1a);
            camera = new THREE.PerspectiveCamera(75, c.clientWidth/800, 0.1, 1000);
            camera.position.set(50, 50, 50);
            camera.lookAt(0, 0, 0);
            renderer = new THREE.WebGLRenderer({ antialias: true, preserveDrawingBuffer: true });
            renderer.setSize(c.clientWidth, 800);
            c.appendChild(renderer.domElement);
            
            const light1 = new THREE.AmbientLight(0xffffff, 0.6);
            const light2 = new THREE.DirectionalLight(0xffffff, 0.4);
            light2.position.set(1, 1, 1);
            scene.add(light1, light2);
            
            const axes = new THREE.AxesHelper(35);
            scene.add(axes);
            
            const canvas = renderer.domElement;
            canvas.addEventListener('mousedown', e => {
                mouseDown = true;
                prevMouse = { x: e.clientX, y: e.clientY };
            });
            canvas.addEventListener('mousemove', e => {
                if (mouseDown && !autoRotate) {
                    const dx = e.clientX - prevMouse.x;
                    const dy = e.clientY - prevMouse.y;
                    const rotSpeed = 0.005;
                    camera.position.applyAxisAngle(new THREE.Vector3(0, 1, 0), dx * rotSpeed);
                    const right = new THREE.Vector3(1, 0, 0).applyQuaternion(camera.quaternion);
                    camera.position.applyAxisAngle(right, dy * rotSpeed);
                    camera.lookAt(0, 0, 0);
                    prevMouse = { x: e.clientX, y: e.clientY };
                }
            });
            canvas.addEventListener('mouseup', () => mouseDown = false);
            canvas.addEventListener('mouseleave', () => mouseDown = false);
            
            draw3D();
            animate3D();
        }

        function set3DShape(shape) {
            shape3D = shape;
            document.querySelectorAll('#shape3DSphere, #shape3DCube').forEach(btn => btn.classList.remove('active'));
            document.getElementById(shape === 'sphere' ? 'shape3DSphere' : 'shape3DCube').classList.add('active');
            draw3D();
        }

        function set3DColorMode(mode) {
            colorMode3D = mode;
            document.querySelectorAll('#colorPrimitive, #colorGCD, #colorMod, #colorOctant, #colorDistance, #colorGCDOct, #colorGCDMod').forEach(btn => btn.classList.remove('active'));
            const btnIds = {
                'primitive': 'colorPrimitive',
                'gcd': 'colorGCD',
                'mod': 'colorMod',
                'octant': 'colorOctant',
                'distance': 'colorDistance',
                'gcdoct': 'colorGCDOct',
                'gcdmod': 'colorGCDMod'
            };
            document.getElementById(btnIds[mode]).classList.add('active');
            
            // Show/hide modulus controls
            document.getElementById('modControls3D').style.display = (mode === 'mod' || mode === 'gcdmod') ? 'block' : 'none';
            
            draw3D();
        }

        function draw3D() {
            if (!scene) return;
            while(scene.children.length > 3) scene.remove(scene.children[3]);
            
            const R = parseInt(document.getElementById('r3').value);
            const pointSize = parseFloat(document.getElementById('ps3').value);
            document.getElementById('r3v').textContent = R;
            document.getElementById('ps3v').textContent = pointSize;
            document.getElementById('warn3d').style.display = R > 30 ? 'block' : 'none';
            
            if (R > 25) document.getElementById('load3d').classList.add('active');
            
            setTimeout(() => {
                // Add boundary shape
                if (shape3D === 'sphere') {
                    const sg = new THREE.SphereGeometry(R, 32, 32);
                    const sm = new THREE.MeshBasicMaterial({ 
                        color: 0x6f42c1, wireframe: true, transparent: true, opacity: 0.15 
                    });
                    scene.add(new THREE.Mesh(sg, sm));
                } else {
                    const boxGeometry = new THREE.BoxGeometry(2*R, 2*R, 2*R);
                    const edges = new THREE.EdgesGeometry(boxGeometry);
                    const line = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ 
                        color: 0x6f42c1, transparent: true, opacity: 0.3 
                    }));
                    scene.add(line);
                }
                
                // Collect all points with their properties
                const allPoints = [];
                let prim = 0, tot = 0;
                const modulus = parseInt(document.getElementById('mod3D').value);
                
                for (let x = -R; x <= R; x++) {
                    for (let y = -R; y <= R; y++) {
                        for (let z = -R; z <= R; z++) {
                            const distSq = x*x + y*y + z*z;
                            const inBounds = shape3D === 'sphere' ? 
                                (distSq <= R*R) : 
                                (Math.abs(x) <= R && Math.abs(y) <= R && Math.abs(z) <= R);
                            
                            if (inBounds) {
                                tot++;
                                const g = gcdArray([Math.abs(x), Math.abs(y), Math.abs(z)]);
                                const isPrimitive = g === 1;
                                if (isPrimitive) prim++;
                                
                                // Determine octant (1-8)
                                let octant = 1;
                                if (x >= 0 && y >= 0 && z >= 0) octant = 1;
                                else if (x < 0 && y >= 0 && z >= 0) octant = 2;
                                else if (x < 0 && y < 0 && z >= 0) octant = 3;
                                else if (x >= 0 && y < 0 && z >= 0) octant = 4;
                                else if (x >= 0 && y >= 0 && z < 0) octant = 5;
                                else if (x < 0 && y >= 0 && z < 0) octant = 6;
                                else if (x < 0 && y < 0 && z < 0) octant = 7;
                                else octant = 8;
                                
                                allPoints.push({
                                    x, y, z,
                                    gcd: g,
                                    isPrimitive,
                                    distance: Math.sqrt(distSq),
                                    sum: x + y + z,
                                    octant
                                });
                            }
                        }
                    }
                }
                
                cache.points3D = { 
                    primitive: allPoints.filter(p => p.isPrimitive),
                    nonPrimitive: allPoints.filter(p => !p.isPrimitive),
                    R 
                };
                
                // Color points based on mode
                const pointsByColor = {};
                
                allPoints.forEach(pt => {
                    let colorKey;
                    
                    switch(colorMode3D) {
                        case 'primitive':
                            colorKey = pt.isPrimitive ? 'prim' : 'nonprim';
                            break;
                        case 'gcd':
                            colorKey = `gcd${Math.min(pt.gcd, 8)}`;
                            break;
                        case 'mod':
                            colorKey = `mod${((pt.sum % modulus) + modulus) % modulus}`;
                            break;
                        case 'octant':
                            colorKey = `oct${pt.octant}`;
                            break;
                        case 'distance':
                            const distBucket = Math.floor(pt.distance / (R / 5));
                            colorKey = `dist${Math.min(distBucket, 5)}`;
                            break;
                        case 'gcdoct':
                            colorKey = `gcd${Math.min(pt.gcd, 4)}_oct${pt.octant}`;
                            break;
                        case 'gcdmod':
                            const modVal = ((pt.sum % modulus) + modulus) % modulus;
                            colorKey = `gcd${Math.min(pt.gcd, 4)}_m${modVal}`;
                            break;
                    }
                    
                    if (!pointsByColor[colorKey]) pointsByColor[colorKey] = [];
                    pointsByColor[colorKey].push(pt.x, pt.y, pt.z);
                });
                
                // Define color schemes
                const colorMap = {
                    prim: 0x0066cc,
                    nonprim: 0xdc3545,
                    gcd1: 0x0066cc, gcd2: 0xdc3545, gcd3: 0x28a745, gcd4: 0xffc107,
                    gcd5: 0x6f42c1, gcd6: 0xfd7e14, gcd7: 0x00d4ff, gcd8: 0xff006e,
                    oct1: 0x0066cc, oct2: 0xdc3545, oct3: 0x28a745, oct4: 0xffc107,
                    oct5: 0x6f42c1, oct6: 0xfd7e14, oct7: 0x00d4ff, oct8: 0xff006e,
                    dist0: 0x0066cc, dist1: 0x00d4ff, dist2: 0x28a745, 
                    dist3: 0xffc107, dist4: 0xfd7e14, dist5: 0xdc3545,
                    mod0: 0x0066cc, mod1: 0xdc3545, mod2: 0x28a745, mod3: 0xffc107,
                    mod4: 0x6f42c1, mod5: 0xfd7e14, mod6: 0x00d4ff, mod7: 0xff006e,
                    mod8: 0x20c997, mod9: 0xe83e8c, mod10: 0x17a2b8, mod11: 0x6610f2
                };
                
                // Generate combined colors
                const baseColors = [0x0066cc, 0xdc3545, 0x28a745, 0xffc107, 0x6f42c1, 0xfd7e14, 0x00d4ff, 0xff006e];
                for (let g = 1; g <= 4; g++) {
                    for (let o = 1; o <= 8; o++) {
                        colorMap[`gcd${g}_oct${o}`] = baseColors[(g - 1 + o - 1) % 8];
                    }
                    for (let m = 0; m < 12; m++) {
                        colorMap[`gcd${g}_m${m}`] = baseColors[(g - 1 + m) % 8];
                    }
                }
                
                // Create point groups
                Object.entries(pointsByColor).forEach(([colorKey, positions]) => {
                    if (positions.length > 0) {
                        const geometry = new THREE.BufferGeometry();
                        geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
                        
                        const color = colorMap[colorKey] || 0x999999;
                        const material = new THREE.PointsMaterial({ color, size: pointSize });
                        scene.add(new THREE.Points(geometry, material));
                    }
                });
                
                // Add labels if enabled
                if (labelMode3D !== 'none') {
                    const maxLabels = parseInt(document.getElementById('maxLabels3D').value);
                    document.getElementById('maxLabels3Dv').textContent = maxLabels;
                    
                    // Sort by distance and take closest points
                    const sortedPoints = [...allPoints].sort((a, b) => a.distance - b.distance).slice(0, maxLabels);
                    
                    sortedPoints.forEach(pt => {
                        let labelText;
                        if (labelMode3D === 'gcd') {
                            labelText = pt.gcd.toString();
                        } else if (labelMode3D === 'coords') {
                            labelText = `(${pt.x},${pt.y},${pt.z})`;
                        }
                        
                        // Create sprite for label
                        const canvas = document.createElement('canvas');
                        const context = canvas.getContext('2d');
                        canvas.width = 128;
                        canvas.height = 64;
                        
                        context.fillStyle = 'rgba(0, 0, 0, 0.8)';
                        context.fillRect(0, 0, canvas.width, canvas.height);
                        
                        context.font = 'Bold 24px Arial';
                        context.fillStyle = 'white';
                        context.textAlign = 'center';
                        context.textBaseline = 'middle';
                        context.fillText(labelText, canvas.width/2, canvas.height/2);
                        
                        const texture = new THREE.CanvasTexture(canvas);
                        const spriteMaterial = new THREE.SpriteMaterial({ map: texture });
                        const sprite = new THREE.Sprite(spriteMaterial);
                        sprite.position.set(pt.x, pt.y, pt.z);
                        sprite.scale.set(4, 2, 1);
                        scene.add(sprite);
                    });
                }
                
                const pred = Math.round(4 * Math.PI * R**3 / (3 * zeta(3)));
                const error = Math.abs(pred - prim);
                
                animateValue('p3', 0, prim);
                animateValue('t3', 0, tot);
                document.getElementById('d3').textContent = ((prim/tot)*100).toFixed(1) + '%';
                animateValue('e3', 0, error);
                
                document.getElementById('load3d').classList.remove('active');
            }, 100);
        }

        function animate3D() {
            requestAnimationFrame(animate3D);
            if (renderer && scene && camera) {
                if (autoRotate) {
                    camera.position.applyAxisAngle(new THREE.Vector3(0, 1, 0), 0.005);
                    camera.lookAt(0, 0, 0);
                }
                renderer.render(scene, camera);
            }
        }

        function reset3D() {
            if (camera) { 
                camera.position.set(50, 50, 50); 
                camera.lookAt(0, 0, 0); 
            }
        }

        function toggleRotation() {
            autoRotate = !autoRotate;
            event.target.textContent = autoRotate ? 'Stop Rotation' : 'Auto-Rotate';
        }

        function setComparisonMode(mode) {
            comparisonMode = mode;
            document.querySelectorAll('#modeFixed, #modeMulti').forEach(btn => btn.classList.remove('active'));
            document.getElementById(mode === 'fixed' ? 'modeFixed' : 'modeMulti').classList.add('active');
            
            if (mode === 'fixed') {
                document.getElementById('fixedRadiusControls').style.display = 'block';
                document.getElementById('multiRadiusControls').style.display = 'none';
            } else {
                document.getElementById('fixedRadiusControls').style.display = 'none';
                document.getElementById('multiRadiusControls').style.display = 'block';
            }
            updateComparison();
        }

        function updateComparisonRadius(value) {
            const R = parseInt(value);
            if (R < 1 || R > 200 || isNaN(R)) return;
            
            document.getElementById('crv').textContent = R;
            document.getElementById('cr').value = Math.min(R, 100);
            document.getElementById('crinput').value = R;
            updateComparison();
        }

        function updateComparison() {
            const grid = document.getElementById('compGrid');
            const showDensity = document.getElementById('showDensity').checked;
            const showVolume = document.getElementById('showVolume').checked;
            const showZeta = document.getElementById('showZeta').checked;
            const showChart = document.getElementById('showChart').checked;
            
            const dims = [];
            for (let k = 2; k <= 10; k++) {
                if (document.getElementById(`compk${k}`)?.checked) dims.push(k);
            }
            
            if (dims.length === 0) {
                grid.innerHTML = '<p style="color:var(--red);">Please select at least one dimension</p>';
                return;
            }
            
            grid.innerHTML = '';
            
            if (comparisonMode === 'fixed') {
                const R = parseInt(document.getElementById('crinput').value);
                
                dims.forEach(k => {
                    const z = zeta(k);
                    const vol = sphereVolume(k, R);
                    const pred = Math.round(vol / z);
                    const density = (1/z * 100).toFixed(2);
                    
                    let content = `
                        <div class="compare-item">
                            <h3 style="color:var(--blue); margin-bottom:15px;">Dimension k = ${k}</h3>
                            <div style="background:var(--bg); padding:10px; border-radius:6px; margin-bottom:10px;">
                                <p style="font-size:1.1em;"><b>Predicted Points:</b> ${pred.toLocaleString()}</p>
                            </div>
                    `;
                    
                    if (showZeta) {
                        content += `
                            <div style="background:var(--bg); padding:10px; border-radius:6px; margin-bottom:10px;">
                                <p><b>ζ(${k}):</b> ${z.toFixed(6)}</p>
                            </div>
                        `;
                    }
                    
                    if (showDensity) {
                        content += `
                            <div style="background:var(--bg); padding:10px; border-radius:6px; margin-bottom:10px;">
                                <p><b>Primitive Density:</b> ${density}%</p>
                                <p style="font-size:0.9em; color:var(--text2);">1/ζ(${k}) = ${(1/z).toFixed(6)}</p>
                            </div>
                        `;
                    }
                    
                    if (showVolume) {
                        content += `
                            <div style="background:var(--bg); padding:10px; border-radius:6px; margin-bottom:10px;">
                                <p><b>Sphere Volume:</b></p>
                                <p style="font-size:0.95em;">${vol.toExponential(4)}</p>
                            </div>
                        `;
                    }
                    
                    // Add growth rate info
                    content += `
                        <div style="background:var(--bg); padding:10px; border-radius:6px; margin-bottom:10px;">
                            <p><b>Growth Rate:</b> O(R^${k})</p>
                            <p style="font-size:0.9em; color:var(--text2);">Error: O(R^${k-1})</p>
                        </div>
                    `;
                    
                    content += `</div>`;
                    grid.innerHTML += content;
                });
            } else {
                // Multiple radii mode
                const radiiStr = document.getElementById('multiRadii').value;
                const radii = radiiStr.split(',').map(r => parseInt(r.trim())).filter(r => !isNaN(r) && r > 0);
                
                if (radii.length === 0) {
                    grid.innerHTML = '<p style="color:var(--red);">Please enter valid radii (e.g., 10, 20, 30)</p>';
                    return;
                }
                
                dims.forEach(k => {
                    const precision = k > 6 ? 17 : 6;
                    let content = `
                        <div class="compare-item">
                            <h3 style="color:var(--blue); margin-bottom:15px;">Dimension k = ${k}</h3>
                    `;
                    
                    if (showZeta) {
                        const z = zeta(k);
                        content += `
                            <div style="background:var(--bg); padding:10px; border-radius:6px; margin-bottom:10px;">
                                <p><b>ζ(${k}):</b> ${formatPrecise(z, precision)}</p>
                                <p><b>Density:</b> ${((1/z)*100).toFixed(2)}%</p>
                                <p style="font-size:0.9em; color:var(--text2);">1/ζ(${k}) = ${formatPrecise(1/z, precision)}</p>
                            </div>
                        `;
                    }
                    
                    content += '<table style="width:100%; font-size:0.9em;"><thead><tr><th>R</th><th>Predicted</th>';
                    if (showVolume) content += '<th>Volume</th>';
                    content += '</tr></thead><tbody>';
                    
                    radii.forEach(R => {
                        const vol = sphereVolume(k, R);
                        const pred = Math.round(vol / zeta(k));
                        content += `<tr><td>${R}</td><td>${pred.toLocaleString()}</td>`;
                        if (showVolume) content += `<td>${formatPrecise(vol, Math.min(precision, 6))}</td>`;
                        content += '</tr>';
                    });
                    
                    content += '</tbody></table></div>';
                    grid.innerHTML += content;
                });
            }
            
            // Update chart
            if (showChart) {
                document.getElementById('comparisonChart').style.display = 'block';
                updateComparisonChart(dims);
            } else {
                document.getElementById('comparisonChart').style.display = 'none';
            }
        }

        function updateComparisonChart(dims) {
            const canvas = document.getElementById('compChart');
            const ctx = canvas.getContext('2d');
            
            if (comparisonChart) comparisonChart.destroy();
            
            const colors = ['#0066cc', '#ffc107', '#00d4ff', '#ff006e', '#28a745', '#6f42c1', '#fd7e14', '#dc3545', '#20c997'];
            
            if (comparisonMode === 'fixed') {
                const R = parseInt(document.getElementById('crinput').value);
                
                const data = dims.map(k => {
                    const vol = sphereVolume(k, R);
                    return Math.round(vol / zeta(k));
                });
                
                comparisonChart = new Chart(ctx, {
                    type: 'bar',
                    data: {
                        labels: dims.map(k => `k=${k}`),
                        datasets: [{
                            label: `Primitive Points (R=${R})`,
                            data: data,
                            backgroundColor: dims.map((k, i) => colors[i % colors.length]),
                            borderColor: dims.map((k, i) => colors[i % colors.length]),
                            borderWidth: 2
                        }]
                    },
                    options: {
                        responsive: true,
                        scales: {
                            y: {
                                type: 'logarithmic',
                                title: { display: true, text: 'Number of Primitive Points', font: { size: 14 } }
                            },
                            x: {
                                title: { display: true, text: 'Dimension', font: { size: 14 } }
                            }
                        },
                        plugins: {
                            title: {
                                display: true,
                                text: `Primitive Lattice Points Across Dimensions (R=${R})`,
                                font: { size: 16, weight: 'bold' }
                            },
                            legend: { display: true }
                        }
                    }
                });
            } else {
                // Multiple radii - show lines
                const radiiStr = document.getElementById('multiRadii').value;
                const radii = radiiStr.split(',').map(r => parseInt(r.trim())).filter(r => !isNaN(r) && r > 0);
                
                const datasets = dims.map((k, i) => {
                    const data = radii.map(R => {
                        const vol = sphereVolume(k, R);
                        return { x: R, y: Math.round(vol / zeta(k)) };
                    });
                    
                    return {
                        label: `k=${k}`,
                        data: data,
                        borderColor: colors[i % colors.length],
                        backgroundColor: colors[i % colors.length] + '33',
                        borderWidth: 2,
                        tension: 0.1,
                        fill: false
                    };
                });
                
                comparisonChart = new Chart(ctx, {
                    type: 'line',
                    data: { datasets },
                    options: {
                        responsive: true,
                        scales: {
                            y: {
                                type: 'logarithmic',
                                title: { display: true, text: 'Number of Primitive Points', font: { size: 14 } }
                            },
                            x: {
                                title: { display: true, text: 'Radius R', font: { size: 14 } }
                            }
                        },
                        plugins: {
                            title: {
                                display: true,
                                text: 'Primitive Lattice Points Growth Across Dimensions',
                                font: { size: 16, weight: 'bold' }
                            },
                            legend: { display: true }
                        }
                    }
                });
            }
        }

        function exportComparisonChart() {
            if (!comparisonChart) {
                alert('Please generate a comparison chart first');
                return;
            }
            exportCanvas('compChart', 'dimension-comparison-chart');
        }

        function updateComparison() {
            const grid = document.getElementById('compGrid');
            const showDensity = document.getElementById('showDensity').checked;
            const showVolume = document.getElementById('showVolume').checked;
            const showZeta = document.getElementById('showZeta').checked;
            const showChart = document.getElementById('showChart').checked;
            
            const dims = [];
            for (let k = 2; k <= 10; k++) {
                if (document.getElementById(`compk${k}`)?.checked) dims.push(k);
            }
            
            if (dims.length === 0) {
                grid.innerHTML = '<p style="color:var(--red);">Please select at least one dimension</p>';
                return;
            }
            
            grid.innerHTML = '';
            
            if (comparisonMode === 'fixed') {
                const R = parseInt(document.getElementById('crinput').value);
                
                dims.forEach(k => {
                    const z = zeta(k);
                    const vol = sphereVolume(k, R);
                    const pred = Math.round(vol / z);
                    const density = (1/z * 100).toFixed(2);
                    
                    let content = `
                        <div class="compare-item">
                            <h3 style="color:var(--blue); margin-bottom:15px;">Dimension k = ${k}</h3>
                            <div style="background:var(--bg); padding:10px; border-radius:6px; margin-bottom:10px;">
                                <p style="font-size:1.1em;"><b>Predicted Points:</b> ${pred.toLocaleString()}</p>
                            </div>
                    `;
                    
                    if (showZeta) {
                        content += `
                            <div style="background:var(--bg); padding:10px; border-radius:6px; margin-bottom:10px;">
                                <p><b>ζ(${k}):</b> ${z.toFixed(6)}</p>
                            </div>
                        `;
                    }
                    
                    if (showDensity) {
                        content += `
                            <div style="background:var(--bg); padding:10px; border-radius:6px; margin-bottom:10px;">
                                <p><b>Primitive Density:</b> ${density}%</p>
                                <p style="font-size:0.9em; color:var(--text2);">1/ζ(${k}) = ${(1/z).toFixed(6)}</p>
                            </div>
                        `;
                    }
                    
                    if (showVolume) {
                        content += `
                            <div style="background:var(--bg); padding:10px; border-radius:6px; margin-bottom:10px;">
                                <p><b>Sphere Volume:</b></p>
                                <p style="font-size:0.95em;">${vol.toExponential(4)}</p>
                            </div>
                        `;
                    }
                    
                    // Add growth rate info
                    content += `
                        <div style="background:var(--bg); padding:10px; border-radius:6px; margin-bottom:10px;">
                            <p><b>Growth Rate:</b> O(R^${k})</p>
                            <p style="font-size:0.9em; color:var(--text2);">Error: O(R^${k-1})</p>
                        </div>
                    `;
                    
                    content += `</div>`;
                    grid.innerHTML += content;
                });
            } else {
                // Multiple radii mode
                const radiiStr = document.getElementById('multiRadii').value;
                const radii = radiiStr.split(',').map(r => parseInt(r.trim())).filter(r => !isNaN(r) && r > 0);
                
                if (radii.length === 0) {
                    grid.innerHTML = '<p style="color:var(--red);">Please enter valid radii (e.g., 10, 20, 30)</p>';
                    return;
                }
                
                dims.forEach(k => {
                    let content = `
                        <div class="compare-item">
                            <h3 style="color:var(--blue); margin-bottom:15px;">Dimension k = ${k}</h3>
                    `;
                    
                    if (showZeta) {
                        const z = zeta(k);
                        content += `
                            <div style="background:var(--bg); padding:10px; border-radius:6px; margin-bottom:10px;">
                                <p><b>ζ(${k}):</b> ${z.toFixed(6)}</p>
                                <p><b>Density:</b> ${((1/z)*100).toFixed(2)}%</p>
                            </div>
                        `;
                    }
                    
                    content += '<table style="width:100%; font-size:0.9em;"><thead><tr><th>R</th><th>Predicted</th>';
                    if (showVolume) content += '<th>Volume</th>';
                    content += '</tr></thead><tbody>';
                    
                    radii.forEach(R => {
                        const vol = sphereVolume(k, R);
                        const pred = Math.round(vol / zeta(k));
                        content += `<tr><td>${R}</td><td>${pred.toLocaleString()}</td>`;
                        if (showVolume) content += `<td>${vol.toExponential(2)}</td>`;
                        content += '</tr>';
                    });
                    
                    content += '</tbody></table></div>';
                    grid.innerHTML += content;
                });
            }
            
            // Update chart
            if (showChart) {
                document.getElementById('comparisonChart').style.display = 'block';
                updateComparisonChart(dims);
            } else {
                document.getElementById('comparisonChart').style.display = 'none';
            }
        }

        function updateAnalysisRadius(value) {
            const R = parseInt(value);
            if (R < 10 || R > 1000 || isNaN(R)) return;
            
            document.getElementById('mrv').textContent = R;
            document.getElementById('mr').value = Math.min(R, 200);
            document.getElementById('mrinput').value = R;
        }

        function runAnalysis() {
            const canvas = document.getElementById('ch');
            const ctx = canvas.getContext('2d');
            const k = parseInt(document.getElementById('analysisK').value);
            const maxR = parseInt(document.getElementById('mrinput').value);
            const minR = parseInt(document.getElementById('minr').value);
            
            const showAbsError = document.getElementById('showAbsError').checked;
            const showRelError = document.getElementById('showRelError').checked;
            const showBoundary = document.getElementById('showBoundary').checked;
            const showActualCount = document.getElementById('showActualCount').checked;
            const showRunningAvg = document.getElementById('showRunningAvg')?.checked || false;
            
            document.getElementById('loadAnalysis').classList.add('active');
            
            setTimeout(() => {
                if (chart) chart.destroy();
                
                const labels = [];
                const absErrorData = [];
                const relErrorData = [];
                const boundaryData = [];
                const actualCountData = [];
                const runningAvgData = [];
                
                let sumError = 0;
                
                // Compute for EVERY SINGLE radius from minR to maxR (no stepping)
                for (let R = minR; R <= maxR; R++) {
                    labels.push(R);
                    
                    const vol = sphereVolume(k, R);
                    const pred = vol / zeta(k);
                    
                    let actual = 0;
                    
                    // Compute actual count based on dimension and feasibility
                    if (k === 2) {
                        // 2D: Can compute exactly up to R=200
                        if (R <= 200) {
                            for (let x = -R; x <= R; x++) {
                                for (let y = -R; y <= R; y++) {
                                    if (x*x + y*y <= R*R && gcd(Math.abs(x), Math.abs(y)) === 1) {
                                        actual++;
                                    }
                                }
                            }
                        } else {
                            actual = Math.round(pred); // Use prediction for very large R
                        }
                    } else if (k === 3) {
                        // 3D: Can compute exactly up to R=40
                        if (R <= 40) {
                            for (let x = -R; x <= R; x++) {
                                for (let y = -R; y <= R; y++) {
                                    for (let z = -R; z <= R; z++) {
                                        if (x*x + y*y + z*z <= R*R && gcdArray([Math.abs(x), Math.abs(y), Math.abs(z)]) === 1) {
                                            actual++;
                                        }
                                    }
                                }
                            }
                        } else {
                            actual = Math.round(pred);
                        }
                    } else if (k === 4) {
                        // 4D: Can compute exactly up to R=15
                        if (R <= 15) {
                            for (let x = -R; x <= R; x++) {
                                for (let y = -R; y <= R; y++) {
                                    for (let z = -R; z <= R; z++) {
                                        for (let w = -R; w <= R; w++) {
                                            if (x*x + y*y + z*z + w*w <= R*R && gcdArray([Math.abs(x), Math.abs(y), Math.abs(z), Math.abs(w)]) === 1) {
                                                actual++;
                                            }
                                        }
                                    }
                                }
                            }
                        } else {
                            actual = Math.round(pred);
                        }
                    } else {
                        // Higher dimensions: use prediction
                        actual = Math.round(pred);
                    }
                    
                    const error = actual - pred;
                    const absError = Math.abs(error);
                    const relError = pred > 0 ? (absError / pred) * 100 : 0;
                    const boundary = Math.pow(R, k - 1);
                    
                    sumError += absError;
                    const runningAvg = sumError / (R - minR + 1);
                    
                    absErrorData.push(absError);
                    relErrorData.push(relError);
                    boundaryData.push(boundary);
                    actualCountData.push(actual);
                    runningAvgData.push(runningAvg);
                }
                
                const datasets = [];
                
                if (showActualCount) {
                    datasets.push({
                        label: `Actual Primitive Count (k=${k})`,
                        data: actualCountData,
                        backgroundColor: 'rgba(0, 102, 204, 0.5)',
                        borderColor: '#0066cc',
                        borderWidth: 1,
                        type: 'bar',
                        yAxisID: 'y1',
                        order: 5
                    });
                }
                
                if (showAbsError) {
                    datasets.push({
                        label: `Absolute Error |Actual - Pred| (k=${k})`,
                        data: absErrorData,
                        backgroundColor: 'rgba(220, 53, 69, 0.6)',
                        borderColor: '#dc3545',
                        borderWidth: 2,
                        type: 'bar',
                        yAxisID: 'y',
                        order: 4
                    });
                }
                
                if (showRunningAvg) {
                    datasets.push({
                        label: `Running Average of |Error| (k=${k})`,
                        data: runningAvgData,
                        backgroundColor: 'rgba(40, 167, 69, 0.2)',
                        borderColor: '#28a745',
                        borderWidth: 3,
                        pointRadius: 0,
                        type: 'line',
                        yAxisID: 'y',
                        order: 2,
                        fill: true,
                        tension: 0.4
                    });
                }
                
                if (showRelError) {
                    datasets.push({
                        label: `Relative Error % (k=${k})`,
                        data: relErrorData,
                        backgroundColor: 'rgba(255, 193, 7, 0.6)',
                        borderColor: '#ffc107',
                        borderWidth: 2,
                        pointRadius: 1,
                        pointHoverRadius: 5,
                        type: 'line',
                        yAxisID: 'y2',
                        order: 3,
                        fill: false
                    });
                }
                
                if (showBoundary) {
                    datasets.push({
                        label: `Theoretical Boundary O(R^${k-1})`,
                        data: boundaryData,
                        backgroundColor: 'rgba(111, 66, 193, 0.3)',
                        borderColor: '#6f42c1',
                        borderWidth: 2,
                        borderDash: [5, 5],
                        pointRadius: 0,
                        type: 'line',
                        yAxisID: 'y',
                        order: 1,
                        fill: false
                    });
                }
                
                const scales = {
                    x: { 
                        title: { display: true, text: 'Radius R', font: { size: 14 } }
                    },
                    y: {
                        type: 'logarithmic',
                        position: 'left',
                        title: { display: true, text: 'Count / Error', font: { size: 14 } },
                        display: showAbsError || showBoundary || showActualCount
                    }
                };
                
                if (showActualCount) {
                    scales.y1 = {
                        type: 'logarithmic',
                        position: 'right',
                        title: { display: true, text: 'Actual Count', font: { size: 14 } },
                        grid: { drawOnChartArea: false }
                    };
                }
                
                if (showRelError) {
                    scales.y2 = {
                        type: 'linear',
                        position: 'right',
                        title: { display: true, text: 'Relative Error %', font: { size: 14 } },
                        grid: { drawOnChartArea: false }
                    };
                }
                
                chart = new Chart(ctx, {
                    type: 'bar',
                    data: { labels, datasets },
                    options: { 
                        responsive: true,
                        maintainAspectRatio: true,
                        onClick: (event, elements) => {
                            if (elements.length > 0) {
                                const index = elements[0].index;
                                const R = labels[index];
                                displayPointAnalysis(R, actualCountData[index], absErrorData[index], relErrorData[index]);
                            }
                        },
                        scales,
                        plugins: {
                            legend: { 
                                display: true,
                                position: 'top',
                                labels: { font: { size: 11 } }
                            },
                            title: {
                                display: true,
                                text: `Error Analysis: Δ(R) for ALL radius values (k=${k}, R=${minR} to ${maxR})`,
                                font: { size: 16, weight: 'bold' }
                            },
                            tooltip: { 
                                mode: 'index', 
                                intersect: false,
                                callbacks: {
                                    label: function(context) {
                                        let label = context.dataset.label || '';
                                        if (label) label += ': ';
                                        if (context.parsed.y !== null) {
                                            if (label.includes('%')) {
                                                label += context.parsed.y.toFixed(4) + '%';
                                            } else {
                                                label += context.parsed.y.toLocaleString(undefined, {
                                                    minimumFractionDigits: 0,
                                                    maximumFractionDigits: 2
                                                });
                                            }
                                        }
                                        return label;
                                    }
                                }
                            }
                        },
                        interaction: {
                            mode: 'index',
                            intersect: false
                        }
                    }
                });
                
                // Store data globally for point analysis
                window.errorAnalysisData = {
                    k, minR, maxR,
                    labels, actualCountData, absErrorData, relErrorData, boundaryData, runningAvgData
                };
                
                document.getElementById('loadAnalysis').classList.remove('active');
            }, 100);
        }

        function displayPointAnalysis(R, actualCount, absError, relError) {
            const k = window.errorAnalysisData?.k || 2;
            const vol = sphereVolume(k, R);
            const predicted = vol / zeta(k);
            const error = actualCount - predicted;
            const boundary = Math.pow(R, k - 1);
            const errorRatio = (absError / boundary * 100).toFixed(2);
            
            const infoDiv = document.getElementById('pointAnalysisResult');
            infoDiv.classList.add('point-info-active');
            setTimeout(() => infoDiv.classList.remove('point-info-active'), 500);
            
            infoDiv.innerHTML = `
                <h3 style="color:var(--blue); margin-bottom:15px;">Analysis for R = ${R}, k = ${k}</h3>
                <div style="display:grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap:15px;">
                    <div>
                        <p><b>Predicted N(R):</b> ${formatPrecise(predicted, 6)}</p>
                        <p><b>Actual N(R):</b> ${actualCount}</p>
                        <p><b>Error Δ(R):</b> <span style="color:${error > 0 ? 'var(--green)' : 'var(--red)'}">${error > 0 ? '+' : ''}${formatPrecise(error, 6)}</span></p>
                        <p><b>Absolute Error:</b> ${formatPrecise(absError, 6)}</p>
                    </div>
                    <div>
                        <p><b>Relative Error:</b> ${formatPrecise(relError, 4)}%</p>
                        <p><b>Boundary O(R^${k-1}):</b> ${formatPrecise(boundary, 6)}</p>
                        <p><b>Error/Boundary:</b> ${errorRatio}%</p>
                        <p><b>Growth Rate:</b> O(R^${k})</p>
                    </div>
                </div>
                <div style="margin-top:15px; padding:10px; background:var(--bg); border-radius:6px;">
                    <p style="font-size:0.9em; color:var(--text2);">
                        ${error > 0 ? 'Positive error: More primitive points than predicted' : 'Negative error: Fewer primitive points than predicted'}
                    </p>
                    <p style="font-size:0.9em; color:var(--text2); margin-top:5px;">
                        The error is ${errorRatio}% of the theoretical boundary term R^${k-1}
                    </p>
                </div>
            `;
        }

        function analyzeSpecificPoint() {
            const R = prompt('Enter radius R to analyze:', '100');
            if (!R || isNaN(R)) return;
            
            const data = window.errorAnalysisData;
            if (!data) {
                alert('Please run the analysis first');
                return;
            }
            
            const Rval = parseInt(R);
            const index = data.labels.indexOf(Rval);
            
            if (index === -1 || Rval < data.minR || Rval > data.maxR) {
                alert(`R=${Rval} is outside the analyzed range [${data.minR}, ${data.maxR}]`);
                return;
            }
            
            displayPointAnalysis(Rval, data.actualCountData[index], data.absErrorData[index], data.relErrorData[index]);
        }

        function updateDimScale() {
            const k = parseInt(document.getElementById('dimScaleKSlider').value);
            const R = parseInt(document.getElementById('dimScaleRSlider').value);
            
            document.getElementById('dimScaleK').textContent = k;
            document.getElementById('dimScaleR').textContent = R;
            
            const mainTerm = Math.pow(R, k);
            const boundaryTerm = Math.pow(R, k - 1);
            const relativeError = (boundaryTerm / mainTerm * 100).toFixed(2);
            const density = 1 / zeta(k);
            
            document.getElementById('mainTerm').textContent = mainTerm.toLocaleString();
            document.getElementById('boundaryTerm').textContent = boundaryTerm.toLocaleString();
            document.getElementById('relativeError').textContent = relativeError + '%';
            document.getElementById('densityVal').textContent = density.toFixed(4);
        }

        function set2DPreset(preset) {
            const presets = {
                'small': 10,
                'medium': 50,
                'large': 100,
                'xlarge': 200
            };
            update2DRadius(presets[preset]);
        }

        function set3DPreset(preset) {
            const presets = {
                'tiny': 5,
                'small': 10,
                'medium': 20,
                'large': 30
            };
            document.getElementById('r3').value = presets[preset];
            document.getElementById('r3v').textContent = presets[preset];
            draw3D();
        }

        function setComparisonPreset(preset) {
            // Uncheck all dimensions first
            for (let k = 2; k <= 10; k++) {
                const checkbox = document.getElementById(`compk${k}`);
                if (checkbox) checkbox.checked = false;
            }
            
            if (preset === 'low') {
                [2, 3, 4].forEach(k => document.getElementById(`compk${k}`).checked = true);
            } else if (preset === 'mid') {
                [3, 4, 5, 6].forEach(k => document.getElementById(`compk${k}`).checked = true);
            } else if (preset === 'high') {
                [5, 6, 7, 8, 9, 10].forEach(k => document.getElementById(`compk${k}`).checked = true);
            } else if (preset === 'all') {
                for (let k = 2; k <= 10; k++) {
                    document.getElementById(`compk${k}`).checked = true;
                }
            } else if (preset === 'growth') {
                setComparisonMode('multi');
                [2, 3, 4, 5].forEach(k => document.getElementById(`compk${k}`).checked = true);
                document.getElementById('multiRadii').value = '5, 10, 15, 20, 25, 30';
            }
            
            updateComparison();
        }

        function setAnalysisPreset(preset) {
            if (preset === 'quick') {
                updateAnalysisRadius(50);
            } else if (preset === 'standard') {
                updateAnalysisRadius(100);
            } else if (preset === 'detailed') {
                updateAnalysisRadius(200);
            } else if (preset === 'extended') {
                updateAnalysisRadius(500);
            }
            
            runAnalysis();
        }

        function setGCDPreset(preset) {
            const presets = {
                'coprime': '15, 28',
                'common': '12, 18, 24',
                'large': '1024, 2048, 4096',
                'many': '60, 72, 90, 120, 150'
            };
            document.getElementById('gi').value = presets[preset];
            calcGCD();
        }

        function setMobiusPreset(preset) {
            const presets = {
                'squarefree': 30,
                'notsquarefree': 72,
                'prime': 17,
                'composite': 210
            };
            document.getElementById('mi').value = presets[preset];
            calcMobius();
        }

        function setPrimePreset(preset) {
            const presets = {
                'small': 60,
                'perfect': 28,
                'highly': 5040,
                'large': 65536,
                'power': 243
            };
            document.getElementById('pi').value = presets[preset];
            calcPrime();
        }

        function setCoprimePreset(preset) {
            const presets = {
                'coprime2': '35, 64',
                'notcoprime2': '24, 36',
                'coprime3': '7, 11, 13',
                'consecutive': '100, 101, 102'
            };
            document.getElementById('cci').value = presets[preset];
            checkCoprime();
        }

        function setPointPreset(preset) {
            const presets = {
                'pythagorean': '3, 4, 5',
                'primitive2d': '7, 9',
                'nonprimitive2d': '6, 8',
                'primitive3d': '1, 2, 3',
                'highd': '1, 1, 1, 1, 1'
            };
            document.getElementById('psi').value = presets[preset];
            searchPoint();
        }

        function calcGCD() {
            const inp = document.getElementById('gi').value;
            const nums = inp.split(',').map(n => parseInt(n.trim())).filter(n => !isNaN(n));
            if (nums.length < 2) {
                document.getElementById('gr').innerHTML = '<p style="color:var(--red)">Need 2+ numbers</p>';
                return;
            }
            const g = gcdArray(nums);
            const coprime = g === 1 ? '<span style="color:var(--green)">Yes - Coprime</span>' : '<span style="color:var(--red)">No - Not Coprime</span>';
            
            // Show step-by-step GCD calculation for pairs
            let steps = '<div style="background:var(--bg3); padding:15px; border-radius:8px; margin-top:10px;">';
            steps += '<b>Step-by-step calculation:</b><br>';
            let current = nums[0];
            for (let i = 1; i < nums.length; i++) {
                const prev = current;
                current = gcd(current, nums[i]);
                steps += `gcd(${prev}, ${nums[i]}) = ${current}<br>`;
            }
            steps += '</div>';
            
            // Prime factorizations
            let factorizations = '<div style="background:var(--bg3); padding:15px; border-radius:8px; margin-top:10px;">';
            factorizations += '<b>Prime factorizations:</b><br>';
            nums.forEach(n => {
                const f = primeFactors(Math.abs(n));
                const fc = {};
                f.forEach(p => fc[p] = (fc[p]||0) + 1);
                const fs = Object.entries(fc).map(([p,c]) => c>1 ? `${p}^${c}` : p).join(' × ');
                factorizations += `${n} = ${fs || '1'}<br>`;
            });
            
            // GCD factorization
            if (g > 1) {
                const gf = primeFactors(g);
                const gfc = {};
                gf.forEach(p => gfc[p] = (gfc[p]||0) + 1);
                const gfs = Object.entries(gfc).map(([p,c]) => c>1 ? `${p}^${c}` : p).join(' × ');
                factorizations += `<br><b>GCD = ${g} = ${gfs}</b>`;
            }
            factorizations += '</div>';
            
            document.getElementById('gr').innerHTML = `
                <p><b>Numbers:</b> ${nums.join(', ')}</p>
                <p><b>GCD:</b> ${g}</p>
                <p>${coprime}</p>
                ${steps}
                ${factorizations}
            `;
        }

        function calcMobius() {
            const n = parseInt(document.getElementById('mi').value);
            if (!n || n < 1) return;
            const mu = mobius(n), f = primeFactors(n);
            const u = [...new Set(f)];
            const sqfree = f.length === u.length;
            const interp = mu === 0 ? 'Not square-free (has repeated prime factors)' : mu === 1 ? 'Even number of distinct prime factors' : 'Odd number of distinct prime factors';
            
            // Build prime factorization display
            const fc = {};
            f.forEach(p => fc[p] = (fc[p]||0) + 1);
            const fs = Object.entries(fc).map(([p,c]) => c>1 ? `${p}^${c}` : p).join(' × ');
            const repeatedPrimes = Object.entries(fc).filter(([p,c]) => c > 1).map(([p,c]) => `${p} (appears ${c} times)`);
            
            let details = '<div style="background:var(--bg3); padding:15px; border-radius:8px; margin-top:10px;">';
            details += `<b>Prime factorization:</b> ${n} = ${fs || '1'}<br>`;
            details += `<b>Distinct primes:</b> {${u.join(', ')}}<br>`;
            details += `<b>Number of distinct primes:</b> ${u.length}<br>`;
            if (repeatedPrimes.length > 0) {
                details += `<b>Repeated primes:</b> ${repeatedPrimes.join(', ')}<br>`;
            }
            details += `<b>Square-free:</b> ${sqfree ? '✓ Yes' : '✗ No'}<br>`;
            details += '</div>';
            
            let formula = '<div style="background:var(--bg3); padding:15px; border-radius:8px; margin-top:10px;">';
            formula += '<b>Formula calculation:</b><br>';
            if (mu === 0) {
                formula += `μ(${n}) = 0 (not square-free)<br>`;
            } else {
                formula += `μ(${n}) = (-1)^${u.length} = (-1)^${u.length} = ${mu}<br>`;
            }
            formula += '</div>';
            
            document.getElementById('mr2').innerHTML = `
                <p style="font-size:1.3em;"><b>μ(${n}) = ${mu}</b></p>
                <p style="color:var(--blue);"><b>${interp}</b></p>
                ${details}
                ${formula}
            `;
        }

        function calcPrime() {
            const n = parseInt(document.getElementById('pi').value);
            if (!n || n < 2) return;
            const f = primeFactors(n);
            const fc = {};
            f.forEach(p => fc[p] = (fc[p]||0) + 1);
            const fs = Object.entries(fc).map(([p,c]) => c>1 ? `${p}^${c}` : p).join(' × ');
            
            let details = '<div style="background:var(--bg3); padding:15px; border-radius:8px; margin-top:10px;">';
            details += '<b>Detailed breakdown:</b><br>';
            details += `<b>All prime factors:</b> ${f.join(' × ')}<br>`;
            details += `<b>Distinct primes:</b> ${Object.keys(fc).join(', ')}<br>`;
            details += `<b>Number of distinct primes:</b> ${Object.keys(fc).length}<br>`;
            details += `<b>Total number of prime factors (with repetition):</b> ${f.length}<br>`;
            
            // Show exponent breakdown
            details += '<br><b>Exponent breakdown:</b><br>';
            Object.entries(fc).forEach(([p, c]) => {
                details += `${p} appears ${c} time${c > 1 ? 's' : ''}<br>`;
            });
            
            // Divisor information
            const numDivisors = Object.values(fc).reduce((prod, exp) => prod * (exp + 1), 1);
            details += `<br><b>Number of divisors:</b> ${numDivisors}<br>`;
            
            // Sum of divisors (for small numbers)
            if (n <= 1000) {
                let sumDiv = 0;
                for (let i = 1; i <= n; i++) {
                    if (n % i === 0) sumDiv += i;
                }
                details += `<b>Sum of divisors:</b> ${sumDiv}<br>`;
                const perfect = sumDiv === 2 * n;
                const abundant = sumDiv > 2 * n;
                const deficient = sumDiv < 2 * n;
                details += `<b>Number type:</b> ${perfect ? 'Perfect' : abundant ? 'Abundant' : 'Deficient'}<br>`;
            }
            
            details += '</div>';
            
            document.getElementById('pr').innerHTML = `
                <p style="font-size:1.3em;"><b>${n} = ${fs}</b></p>
                <p style="font-size:1.1em;">${isPrime(n) ? '<span style="color:var(--green)">PRIME NUMBER</span>' : '<span style="color:var(--blue)">COMPOSITE NUMBER</span>'}</p>
                ${details}
            `;
        }

        function checkCoprime() {
            const inp = document.getElementById('cci').value;
            const nums = inp.split(',').map(n => parseInt(n.trim())).filter(n => !isNaN(n));
            if (nums.length < 2) {
                document.getElementById('ccr').innerHTML = '<p style="color:var(--red)">Need 2+ numbers</p>';
                return;
            }
            const g = gcdArray(nums);
            const coprime = g === 1;
            
            // Prime factorizations
            let factorInfo = '<div style="background:var(--bg3); padding:15px; border-radius:8px; margin-top:10px;">';
            factorInfo += '<b>Prime factorizations:</b><br>';
            nums.forEach(n => {
                const f = primeFactors(Math.abs(n));
                const fc = {};
                f.forEach(p => fc[p] = (fc[p]||0) + 1);
                const fs = Object.entries(fc).map(([p,c]) => c>1 ? `${p}^${c}` : p).join(' × ');
                factorInfo += `${n} = ${fs || '1'}<br>`;
            });
            factorInfo += '</div>';
            
            // Common factors
            let commonInfo = '<div style="background:var(--bg3); padding:15px; border-radius:8px; margin-top:10px;">';
            if (coprime) {
                commonInfo += '<b>Common factors:</b> Only 1 (coprime)<br>';
                commonInfo += 'These numbers share no prime factors.';
            } else {
                const gf = primeFactors(g);
                const gfc = {};
                gf.forEach(p => gfc[p] = (gfc[p]||0) + 1);
                const gfs = Object.entries(gfc).map(([p,c]) => c>1 ? `${p}^${c}` : p).join(' × ');
                commonInfo += `<b>Common factors:</b> Divisors of ${g}<br>`;
                commonInfo += `<b>GCD breakdown:</b> ${g} = ${gfs}<br>`;
                commonInfo += `<b>Shared primes:</b> ${Object.keys(gfc).join(', ')}`;
            }
            commonInfo += '</div>';
            
            document.getElementById('ccr').innerHTML = `
                <p><b>Numbers:</b> ${nums.join(', ')}</p>
                <p><b>GCD:</b> ${g}</p>
                <p style="font-size:1.2em; margin-top:10px">${coprime ? '<span style="color:var(--green)">COPRIME (Primitive point)</span>' : '<span style="color:var(--red)">NOT COPRIME (Non-primitive)</span>'}</p>
                ${factorInfo}
                ${commonInfo}
            `;
        }

        function searchPoint() {
            const inp = document.getElementById('psi').value;
            const coords = inp.split(',').map(n => parseInt(n.trim())).filter(n => !isNaN(n));
            if (coords.length < 2) {
                document.getElementById('psr').innerHTML = '<p style="color:var(--red)">Need 2+ coordinates</p>';
                return;
            }
            const g = gcdArray(coords);
            const isPrim = g === 1;
            const dist = Math.sqrt(coords.reduce((sum, x) => sum + x*x, 0));
            
            // Point factorization
            let pointInfo = '<div style="background:var(--bg3); padding:15px; border-radius:8px; margin-top:10px;">';
            pointInfo += '<b>Coordinate factorizations:</b><br>';
            coords.forEach((c, i) => {
                const label = ['x', 'y', 'z', 'w', 'v', 'u'][i] || `x${i}`;
                if (c === 0) {
                    pointInfo += `${label} = 0<br>`;
                } else {
                    const f = primeFactors(Math.abs(c));
                    const fc = {};
                    f.forEach(p => fc[p] = (fc[p]||0) + 1);
                    const fs = Object.entries(fc).map(([p,cnt]) => cnt>1 ? `${p}^${cnt}` : p).join(' × ');
                    const sign = c < 0 ? '-' : '';
                    pointInfo += `${label} = ${sign}${fs || '1'}<br>`;
                }
            });
            pointInfo += '</div>';
            
            // GCD analysis
            let gcdInfo = '<div style="background:var(--bg3); padding:15px; border-radius:8px; margin-top:10px;">';
            if (g === 1) {
                gcdInfo += '<b>GCD Analysis:</b><br>';
                gcdInfo += 'GCD = 1 → Coordinates are coprime<br>';
                gcdInfo += 'This point cannot be expressed as d·(simpler point) where d > 1';
            } else {
                const reduced = coords.map(c => c / g);
                const gf = primeFactors(g);
                const gfc = {};
                gf.forEach(p => gfc[p] = (gfc[p]||0) + 1);
                const gfs = Object.entries(gfc).map(([p,c]) => c>1 ? `${p}^${c}` : p).join(' × ');
                gcdInfo += '<b>GCD Analysis:</b><br>';
                gcdInfo += `GCD = ${g} = ${gfs}<br>`;
                gcdInfo += `<b>Reduced form:</b> (${reduced.join(', ')}) is the primitive point<br>`;
                gcdInfo += `<b>Relationship:</b> (${coords.join(', ')}) = ${g} × (${reduced.join(', ')})`;
            }
            gcdInfo += '</div>';
            
            // Geometric properties
            let geomInfo = '<div style="background:var(--bg3); padding:15px; border-radius:8px; margin-top:10px;">';
            geomInfo += '<b>Geometric Properties:</b><br>';
            geomInfo += `<b>Euclidean norm:</b> ||point|| = √(${coords.map(c => c + '²').join(' + ')}) = ${dist.toFixed(4)}<br>`;
            geomInfo += `<b>Manhattan distance:</b> ${coords.reduce((sum, c) => sum + Math.abs(c), 0)}<br>`;
            geomInfo += `<b>Max coordinate:</b> ${Math.max(...coords.map(Math.abs))}<br>`;
            const numZeros = coords.filter(c => c === 0).length;
            if (numZeros > 0) {
                geomInfo += `<b>Zero coordinates:</b> ${numZeros} (lies on ${coords.length - numZeros}D subspace)`;
            }
            geomInfo += '</div>';
            
            document.getElementById('psr').innerHTML = `
                <p><b>Point:</b> (${coords.join(', ')})</p>
                <p><b>Dimension:</b> ${coords.length}</p>
                <p><b>GCD of coordinates:</b> ${g}</p>
                <p style="font-size:1.2em; margin-top:10px">${isPrim ? '<span style="color:var(--green)">PRIMITIVE LATTICE POINT</span>' : '<span style="color:var(--red)">NON-PRIMITIVE LATTICE POINT</span>'}</p>
                ${pointInfo}
                ${gcdInfo}
                ${geomInfo}
            `;
        }

        function exportCanvas(canvasId, filename) {
            const canvas = document.getElementById(canvasId);
            const link = document.createElement('a');
            link.download = `${filename}.png`;
            link.href = canvas.toDataURL();
            link.click();
        }

        function exportPointData2D() {
            if (!cache.points2D) { alert('Generate 2D visualization first'); return; }
            const data = cache.points2D;
            let csv = 'x,y,type\n';
            data.primitive.forEach(p => csv += `${p.x},${p.y},primitive\n`);
            data.nonPrimitive.forEach(p => csv += `${p.x},${p.y},non-primitive\n`);
            downloadCSV(csv, '2d-lattice-points.csv');
        }

        function export3DData() {
            if (!cache.points3D) { alert('Generate 3D visualization first'); return; }
            const data = cache.points3D;
            let csv = 'x,y,z,type\n';
            data.primitive.forEach(p => csv += `${p.x},${p.y},${p.z},primitive\n`);
            data.nonPrimitive.forEach(p => csv += `${p.x},${p.y},${p.z},non-primitive\n`);
            downloadCSV(csv, '3d-lattice-points.csv');
        }

        function exportTheoryData() {
            const k = parseInt(document.getElementById('tks').value);
            const R = parseInt(document.getElementById('trs').value);
            const z = zeta(k);
            const vol = sphereVolume(k, R);
            const pred = vol / z;
            const precision = k > 6 ? 17 : 12;
            
            let csv = `# Primitive Lattice Point Theory - Complete Data\n`;
            csv += `# Generated: ${new Date().toISOString()}\n`;
            csv += `# By Wessen Getachew | @7dview | wessengetachew.github.io\n`;
            csv += `#\n`;
            csv += `# Current parameters: k=${k}, R=${R}\n`;
            csv += `# Formula: N_k(R) = V_k·R^k/ζ(k) + O(R^(k-1))\n`;
            csv += `#\n`;
            csv += `dimension_k,radius_R,zeta_k,density_1_over_zeta,sphere_volume_Vk,predicted_primitive_points\n`;
            csv += `${k},${R},${formatPrecise(z, precision)},${formatPrecise(1/z, precision)},${formatPrecise(vol, precision)},${formatPrecise(pred, precision)}\n`;
            csv += `#\n`;
            csv += `# Complete table for all dimensions 2-12:\n`;
            csv += `dimension_k,zeta_k,density_1_over_zeta,unit_sphere_volume\n`;
            
            for (let dim = 2; dim <= 12; dim++) {
                const zd = zeta(dim);
                const dimPrecision = dim > 6 ? 17 : 12;
                const vd = dim % 2 === 0 ? 
                    (Math.pow(Math.PI, dim/2) / factorial(dim/2)) :
                    (2 * factorial((dim-1)/2) * Math.pow(Math.PI, (dim-1)/2) / factorial(dim));
                csv += `${dim},${formatPrecise(zd, dimPrecision)},${formatPrecise(1/zd, dimPrecision)},${formatPrecise(vd, dimPrecision)}\n`;
            }
            
            downloadCSV(csv, `theory-complete-k${k}-r${R}.csv`);
        }

        function exportChartData() {
            if (!window.errorAnalysisData) { 
                alert('Run error analysis first'); 
                return; 
            }
            
            const data = window.errorAnalysisData;
            const precision = data.k > 6 ? 17 : 12;
            
            let csv = `# Error Analysis Data - Dimension k=${data.k}\n`;
            csv += `# Generated: ${new Date().toISOString()}\n`;
            csv += `# By Wessen Getachew | @7dview | wessengetachew.github.io\n`;
            csv += `#\n`;
            csv += `# This dataset contains error analysis for EVERY radius from ${data.minR} to ${data.maxR}\n`;
            csv += `# Formula: N(R) = R^k/ζ(k) + Δ(R), where Δ(R) = O(R^(k-1))\n`;
            csv += `# ζ(${data.k}) = ${formatPrecise(zeta(data.k), precision)}\n`;
            csv += `#\n`;
            csv += `radius,actual_count,predicted_count,error_delta,abs_error,relative_error_pct,boundary_term,running_avg_error\n`;
            
            for (let i = 0; i < data.labels.length; i++) {
                const R = data.labels[i];
                const actual = data.actualCountData[i];
                const vol = sphereVolume(data.k, R);
                const predicted = vol / zeta(data.k);
                const error = actual - predicted;
                const absErr = data.absErrorData[i];
                const relErr = data.relErrorData[i];
                const boundary = data.boundaryData[i];
                const runningAvg = data.runningAvgData[i];
                
                csv += `${R},${actual},${formatPrecise(predicted, precision)},${formatPrecise(error, precision)},${formatPrecise(absErr, precision)},${formatPrecise(relErr, precision)},${formatPrecise(boundary, precision)},${formatPrecise(runningAvg, precision)}\n`;
            }
            
            downloadCSV(csv, `error-analysis-k${data.k}-r${data.minR}-${data.maxR}.csv`);
        }

        function exportComparisonData() {
            const showDensity = document.getElementById('showDensity').checked;
            const showVolume = document.getElementById('showVolume').checked;
            const showZeta = document.getElementById('showZeta').checked;
            
            const dims = [];
            for (let k = 2; k <= 10; k++) {
                if (document.getElementById(`compk${k}`)?.checked) dims.push(k);
            }
            
            if (dims.length === 0) {
                alert('Please select at least one dimension');
                return;
            }
            
            let csv = `# Dimension Comparison Analysis\n`;
            csv += `# Generated: ${new Date().toISOString()}\n`;
            csv += `# By Wessen Getachew | @7dview | wessengetachew.github.io\n`;
            csv += `#\n`;
            csv += `# Comparing dimensions: ${dims.join(', ')}\n`;
            csv += `# Mode: ${comparisonMode === 'fixed' ? 'Fixed Radius' : 'Multiple Radii'}\n`;
            csv += `#\n`;
            
            csv += 'dimension_k,';
            if (comparisonMode === 'fixed') {
                csv += 'radius_R,';
            }
            if (showZeta) csv += 'zeta_k,';
            if (showDensity) csv += 'density_1_over_zeta,';
            csv += 'predicted_primitive_points';
            if (showVolume) csv += ',sphere_volume';
            csv += '\n';
            
            if (comparisonMode === 'fixed') {
                const R = parseInt(document.getElementById('crinput').value);
                dims.forEach(k => {
                    const z = zeta(k);
                    const precision = k > 6 ? 17 : 12;
                    const vol = sphereVolume(k, R);
                    const pred = vol / z;
                    csv += `${k},${R},`;
                    if (showZeta) csv += `${formatPrecise(z, precision)},`;
                    if (showDensity) csv += `${formatPrecise(1/z, precision)},`;
                    csv += `${formatPrecise(pred, precision)}`;
                    if (showVolume) csv += `,${formatPrecise(vol, precision)}`;
                    csv += '\n';
                });
            } else {
                const radiiStr = document.getElementById('multiRadii').value;
                const radii = radiiStr.split(',').map(r => parseInt(r.trim())).filter(r => !isNaN(r) && r > 0);
                
                dims.forEach(k => {
                    const z = zeta(k);
                    const precision = k > 6 ? 17 : 12;
                    radii.forEach(R => {
                        const vol = sphereVolume(k, R);
                        const pred = vol / z;
                        csv += `${k},${R},`;
                        if (showZeta) csv += `${formatPrecise(z, precision)},`;
                        if (showDensity) csv += `${formatPrecise(1/z, precision)},`;
                        csv += `${formatPrecise(pred, precision)}`;
                        if (showVolume) csv += `,${formatPrecise(vol, precision)}`;
                        csv += '\n';
                    });
                });
            }
            
            downloadCSV(csv, `dimension-comparison-${comparisonMode}.csv`);
        }

        function downloadCSV(content, filename) {
            const blob = new Blob([content], { type: 'text/csv' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            link.download = filename;
            link.click();
            URL.revokeObjectURL(url);
        }

        function toggleDark() {
            document.body.classList.toggle('light');
            const btn = document.getElementById('darkBtn');
            btn.textContent = document.body.classList.contains('light') ? 'Dark Mode' : 'Light Mode';
            if (scene) scene.background = new THREE.Color(document.body.classList.contains('light') ? 0xffffff : 0x1a1a1a);
        }

        function showHelp() {
            document.getElementById('helpModal').classList.add('active');
        }

        function closeHelp() {
            document.getElementById('helpModal').classList.remove('active');
        }

        function showDerivationAnimation() {
            alert('Interactive animation coming soon! This would show step-by-step how Möbius inversion leads to the zeta function connection.');
        }

        function setPatternType(type) {
            patternType = type;
            document.querySelectorAll('#patternModular, #patternDensity, #patternAngular, #patternRadial').forEach(btn => btn.classList.remove('active'));
            const btnIds = {
                'modular': 'patternModular',
                'density': 'patternDensity',
                'angular': 'patternAngular',
                'radial': 'patternRadial'
            };
            document.getElementById(btnIds[type]).classList.add('active');
            
            // Show/hide appropriate controls
            document.getElementById('modularPatternControls').style.display = type === 'modular' ? 'block' : 'none';
            document.getElementById('densityPatternControls').style.display = type === 'density' ? 'block' : 'none';
            document.getElementById('angularPatternControls').style.display = type === 'angular' ? 'block' : 'none';
            document.getElementById('radialPatternControls').style.display = type === 'radial' ? 'block' : 'none';
            
            updatePatternViz();
        }

        function updatePatternViz() {
            if (patternType === 'modular') {
                const m = parseInt(document.getElementById('patternMod').value);
                const R = parseInt(document.getElementById('patternR').value);
                const showExpected = document.getElementById('showExpected').checked;
                
                document.getElementById('patternModv').textContent = m;
                document.getElementById('patternRv').textContent = R;
                
                // Count primitive points by residue class
                const counts = new Array(m).fill(0);
                let totalPrimitive = 0;
                
                for (let x = -R; x <= R; x++) {
                    for (let y = -R; y <= R; y++) {
                        if (x*x + y*y <= R*R && gcd(Math.abs(x), Math.abs(y)) === 1) {
                            const residue = ((x + y) % m + m) % m;
                            counts[residue]++;
                            totalPrimitive++;
                        }
                    }
                }
                
                // Expected uniform distribution
                const expected = totalPrimitive / m;
                
                // Display chart
                const canvas = document.getElementById('patternCanvas');
                const ctx = canvas.getContext('2d');
                
                if (patternChart) patternChart.destroy();
                
                const datasets = [{
                    label: 'Observed Count',
                    data: counts,
                    backgroundColor: 'rgba(0, 102, 204, 0.6)',
                    borderColor: '#0066cc',
                    borderWidth: 2
                }];
                
                if (showExpected) {
                    datasets.push({
                        label: 'Expected (Uniform)',
                        data: new Array(m).fill(expected),
                        type: 'line',
                        borderColor: '#dc3545',
                        borderWidth: 2,
                        borderDash: [5, 5],
                        pointRadius: 0,
                        fill: false
                    });
                }
                
                patternChart = new Chart(ctx, {
                    type: 'bar',
                    data: {
                        labels: Array.from({length: m}, (_, i) => i),
                        datasets
                    },
                    options: {
                        responsive: true,
                        scales: {
                            y: {
                                title: { display: true, text: 'Number of Primitive Points', font: { size: 14 } },
                                beginAtZero: true
                            },
                            x: {
                                title: { display: true, text: `Residue Class (x+y) mod ${m}`, font: { size: 14 } }
                            }
                        },
                        plugins: {
                            title: {
                                display: true,
                                text: `Modular Distribution: Primitive Points mod ${m} (R=${R})`,
                                font: { size: 16, weight: 'bold' }
                            },
                            legend: { display: true }
                        }
                    }
                });
                
                // Update stats
                const statsDiv = document.getElementById('patternStats');
                const maxCount = Math.max(...counts);
                const minCount = Math.min(...counts);
                const variance = counts.reduce((sum, c) => sum + Math.pow(c - expected, 2), 0) / m;
                const stdDev = Math.sqrt(variance);
                
                statsDiv.innerHTML = `
                    <div class="stat"><div class="val">${totalPrimitive}</div><div class="lbl">Total Primitive</div></div>
                    <div class="stat"><div class="val">${expected.toFixed(1)}</div><div class="lbl">Expected per Class</div></div>
                    <div class="stat"><div class="val">${maxCount}</div><div class="lbl">Max Count</div></div>
                    <div class="stat"><div class="val">${minCount}</div><div class="lbl">Min Count</div></div>
                    <div class="stat"><div class="val">${stdDev.toFixed(2)}</div><div class="lbl">Std Deviation</div></div>
                `;
                
            } else if (patternType === 'density') {
                const gridSize = parseInt(document.getElementById('gridSizeInput').value) || parseInt(document.getElementById('gridSize').value);
                const R = parseInt(document.getElementById('densityRInput').value) || parseInt(document.getElementById('densityR').value);
                
                document.getElementById('gridSizev').textContent = gridSize;
                document.getElementById('densityRv').textContent = R;
                
                const canvas = document.getElementById('densityCanvas');
                const ctx = canvas.getContext('2d');
                const cellSize = 800 / gridSize;
                
                ctx.clearRect(0, 0, 800, 800);
                
                // Compute density in each grid cell
                const cellR = R / gridSize;
                const densities = [];
                let maxDensity = 0;
                
                for (let i = 0; i < gridSize; i++) {
                    densities[i] = [];
                    for (let j = 0; j < gridSize; j++) {
                        const cx = (i - gridSize/2) * cellR;
                        const cy = (j - gridSize/2) * cellR;
                        
                        let primCount = 0, totalCount = 0;
                        
                        // Count points in this cell
                        for (let x = Math.floor(cx - cellR); x <= Math.ceil(cx + cellR); x++) {
                            for (let y = Math.floor(cy - cellR); y <= Math.ceil(cy + cellR); y++) {
                                const dx = x - cx, dy = y - cy;
                                if (dx*dx + dy*dy <= cellR*cellR) {
                                    totalCount++;
                                    if (gcd(Math.abs(x), Math.abs(y)) === 1) primCount++;
                                }
                            }
                        }
                        
                        const density = totalCount > 0 ? primCount / totalCount : 0;
                        densities[i][j] = density;
                        maxDensity = Math.max(maxDensity, density);
                    }
                }
                
                // Draw heatmap
                for (let i = 0; i < gridSize; i++) {
                    for (let j = 0; j < gridSize; j++) {
                        const density = densities[i][j];
                        const intensity = density / (maxDensity || 1);
                        const hue = 240 - intensity * 240; // Blue to red
                        ctx.fillStyle = `hsl(${hue}, 70%, 50%)`;
                        ctx.fillRect(i * cellSize, j * cellSize, cellSize, cellSize);
                        
                        // Draw border
                        ctx.strokeStyle = 'rgba(255,255,255,0.2)';
                        ctx.strokeRect(i * cellSize, j * cellSize, cellSize, cellSize);
                    }
                }
                
                // Add legend
                ctx.fillStyle = 'rgba(255,255,255,0.9)';
                ctx.fillRect(20, 720, 200, 60);
                ctx.fillStyle = '#000';
                ctx.font = '14px system-ui';
                ctx.fillText('Density Scale:', 30, 740);
                ctx.fillText(`0% → ${(maxDensity * 100).toFixed(1)}%`, 30, 760);
                
            } else if (patternType === 'angular') {
                const numSectors = parseInt(document.getElementById('numSectors').value);
                const R = parseInt(document.getElementById('angularR').value);
                
                document.getElementById('numSectorsv').textContent = numSectors;
                document.getElementById('angularRv').textContent = R;
                
                const sectorCounts = new Array(numSectors).fill(0);
                let totalPrimitive = 0;
                
                for (let x = -R; x <= R; x++) {
                    for (let y = -R; y <= R; y++) {
                        if (x*x + y*y <= R*R && gcd(Math.abs(x), Math.abs(y)) === 1) {
                            const angle = Math.atan2(y, x) + Math.PI; // 0 to 2π
                            const sector = Math.floor(angle / (2 * Math.PI / numSectors)) % numSectors;
                            sectorCounts[sector]++;
                            totalPrimitive++;
                        }
                    }
                }
                
                const expected = totalPrimitive / numSectors;
                
                const canvas = document.getElementById('angularCanvas');
                const ctx = canvas.getContext('2d');
                
                if (patternChart) patternChart.destroy();
                
                patternChart = new Chart(ctx, {
                    type: 'bar',
                    data: {
                        labels: Array.from({length: numSectors}, (_, i) => {
                            const startAngle = (i * 360 / numSectors).toFixed(0);
                            const endAngle = ((i + 1) * 360 / numSectors).toFixed(0);
                            return `${startAngle}°-${endAngle}°`;
                        }),
                        datasets: [{
                            label: 'Primitive Points',
                            data: sectorCounts,
                            backgroundColor: Array.from({length: numSectors}, (_, i) => {
                                const hue = (i / numSectors) * 360;
                                return `hsla(${hue}, 70%, 50%, 0.6)`;
                            }),
                            borderWidth: 2
                        }, {
                            label: 'Expected (Uniform)',
                            data: new Array(numSectors).fill(expected),
                            type: 'line',
                            borderColor: '#dc3545',
                            borderWidth: 2,
                            borderDash: [5, 5],
                            pointRadius: 0,
                            fill: false
                        }]
                    },
                    options: {
                        responsive: true,
                        scales: {
                            y: { title: { display: true, text: 'Count', font: { size: 14 } } },
                            x: { title: { display: true, text: 'Angular Sector', font: { size: 14 } } }
                        },
                        plugins: {
                            title: {
                                display: true,
                                text: `Angular Distribution (${numSectors} sectors, R=${R})`,
                                font: { size: 16, weight: 'bold' }
                            }
                        }
                    }
                });
                
            } else if (patternType === 'radial') {
                const shellThick = parseInt(document.getElementById('shellThick').value);
                const maxR = parseInt(document.getElementById('radialMaxR').value);
                
                document.getElementById('shellThickv').textContent = shellThick;
                document.getElementById('radialMaxRv').textContent = maxR;
                
                const numShells = Math.floor(maxR / shellThick);
                const shellCounts = [];
                const radii = [];
                
                for (let i = 0; i < numShells; i++) {
                    const innerR = i * shellThick;
                    const outerR = (i + 1) * shellThick;
                    radii.push(outerR);
                    
                    let count = 0;
                    for (let x = -outerR; x <= outerR; x++) {
                        for (let y = -outerR; y <= outerR; y++) {
                            const distSq = x*x + y*y;
                            if (distSq > innerR*innerR && distSq <= outerR*outerR && 
                                gcd(Math.abs(x), Math.abs(y)) === 1) {
                                count++;
                            }
                        }
                    }
                    shellCounts.push(count);
                }
                
                const canvas = document.getElementById('radialCanvas');
                const ctx = canvas.getContext('2d');
                
                if (patternChart) patternChart.destroy();
                
                patternChart = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: radii,
                        datasets: [{
                            label: 'Primitive Points in Shell',
                            data: shellCounts,
                            backgroundColor: 'rgba(0, 102, 204, 0.2)',
                            borderColor: '#0066cc',
                            borderWidth: 2,
                            fill: true,
                            tension: 0.3
                        }]
                    },
                    options: {
                        responsive: true,
                        scales: {
                            y: { 
                                title: { display: true, text: 'Count per Shell', font: { size: 14 } },
                                beginAtZero: true
                            },
                            x: { title: { display: true, text: 'Radius', font: { size: 14 } } }
                        },
                        plugins: {
                            title: {
                                display: true,
                                text: `Radial Shell Distribution (thickness=${shellThick})`,
                                font: { size: 16, weight: 'bold' }
                            }
                        }
                    }
                });
            }
        }

        function exportPatternData() {
            if (!patternChart) { alert('Generate a pattern visualization first'); return; }
            
            let csv = `# Pattern Analysis - ${patternType}\n`;
            csv += `# Generated: ${new Date().toISOString()}\n`;
            csv += `# By Wessen Getachew | @7dview | wessengetachew.github.io\n`;
            csv += `#\n`;
            
            const data = patternChart.data;
            
            if (patternType === 'modular') {
                const m = parseInt(document.getElementById('patternMod').value);
                const R = parseInt(document.getElementById('patternR').value);
                csv += `# Modular Pattern: mod ${m}, Radius ${R}\n#\n`;
                csv += 'residue_class,count,expected_uniform\n';
                const total = data.datasets[0].data.reduce((a, b) => a + b, 0);
                const expected = total / m;
                data.labels.forEach((label, i) => {
                    csv += `${label},${data.datasets[0].data[i]},${formatPrecise(expected, 6)}\n`;
                });
            } else if (patternType === 'angular') {
                const numSectors = parseInt(document.getElementById('numSectors').value);
                const R = parseInt(document.getElementById('angularR').value);
                csv += `# Angular Distribution: ${numSectors} sectors, Radius ${R}\n#\n`;
                csv += 'sector,angle_range,count\n';
                data.labels.forEach((label, i) => {
                    csv += `${i},${label},${data.datasets[0].data[i]}\n`;
                });
            } else if (patternType === 'radial') {
                const shellThick = parseInt(document.getElementById('shellThick').value);
                csv += `# Radial Shell Distribution: thickness ${shellThick}\n#\n`;
                csv += 'outer_radius,count_in_shell\n';
                data.labels.forEach((label, i) => {
                    csv += `${label},${data.datasets[0].data[i]}\n`;
                });
            }
            
            downloadCSV(csv, `pattern-${patternType}-analysis.csv`);
        }

        function set2DLabelMode(mode) {
            labelMode2D = mode;
            document.querySelectorAll('#label2DNone, #label2DGCD, #label2DCoords, #label2DAngle').forEach(btn => btn.classList.remove('active'));
            const btnIds = { 'none': 'label2DNone', 'gcd': 'label2DGCD', 'coords': 'label2DCoords', 'angle': 'label2DAngle' };
            document.getElementById(btnIds[mode]).classList.add('active');
            document.getElementById('labelControls2D').style.display = mode === 'none' ? 'none' : 'block';
            draw2D();
        }

        function set3DLabelMode(mode) {
            labelMode3D = mode;
            document.querySelectorAll('#label3DNone, #label3DGCD, #label3DCoords').forEach(btn => btn.classList.remove('active'));
            const btnIds = { 'none': 'label3DNone', 'gcd': 'label3DGCD', 'coords': 'label3DCoords' };
            document.getElementById(btnIds[mode]).classList.add('active');
            document.getElementById('labelControls3D').style.display = mode === 'none' ? 'none' : 'block';
            draw3D();
        }

        function update3DZoom() {
            if (!camera) return;
            const zoom = parseInt(document.getElementById('zoom3D').value);
            document.getElementById('zoom3Dv').textContent = zoom;
            const angle = Math.atan2(camera.position.y, Math.sqrt(camera.position.x**2 + camera.position.z**2));
            const azimuth = Math.atan2(camera.position.x, camera.position.z);
            camera.position.x = zoom * Math.sin(azimuth) * Math.cos(angle);
            camera.position.z = zoom * Math.cos(azimuth) * Math.cos(angle);
            camera.position.y = zoom * Math.sin(angle);
            camera.lookAt(0, 0, 0);
        }

        function setGCDTablePreset(preset) {
            const presets = { 'small': 20, 'medium': 50, 'large': 100 };
            const size = presets[preset];
            document.getElementById('gcdTableSize').value = size;
            document.getElementById('gcdTableSizeInput').value = size;
            document.getElementById('gcdTableSizev').textContent = size;
            updateGCDTable();
        }

        let gcdTableColorMode = 'heat'; // 'heat', 'discrete', 'prime'

        function setGCDTableColor(mode) {
            gcdTableColorMode = mode;
            document.querySelectorAll('#gcdTableHeat, #gcdTableDiscrete, #gcdTablePrime').forEach(btn => btn.classList.remove('active'));
            const btnIds = { 'heat': 'gcdTableHeat', 'discrete': 'gcdTableDiscrete', 'prime': 'gcdTablePrime' };
            document.getElementById(btnIds[mode]).classList.add('active');
            updateGCDTable();
        }

        function updateGCDTable() {
            const size = parseInt(document.getElementById('gcdTableSizeInput').value) || parseInt(document.getElementById('gcdTableSize').value);
            const showValues = document.getElementById('showGCDValues').checked;
            const highlightDiag = document.getElementById('highlightDiagonal').checked;
            
            document.getElementById('gcdTableSizev').textContent = size;
            document.getElementById('gcdTableSize').value = Math.min(size, 150);
            document.getElementById('gcdTableSizeInput').value = size;
            
            const canvas = document.getElementById('gcdTableCanvas');
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            const cellSize = Math.min(canvas.width / (size + 1), 30); // +1 for labels
            const startX = 40, startY = 40;
            
            // Compute max GCD for normalization
            let maxGCD = 0;
            for (let i = 1; i <= size; i++) {
                for (let j = 1; j <= size; j++) {
                    maxGCD = Math.max(maxGCD, gcd(i, j));
                }
            }
            
            // Store data for click detection
            window.gcdTableData = [];
            
            // Draw cells
            for (let i = 1; i <= size; i++) {
                for (let j = 1; j <= size; j++) {
                    const g = gcd(i, j);
                    const x = startX + (j - 1) * cellSize;
                    const y = startY + (i - 1) * cellSize;
                    
                    let color;
                    if (gcdTableColorMode === 'heat') {
                        const intensity = g / maxGCD;
                        const hue = 240 - intensity * 240; // Blue to red
                        color = `hsl(${hue}, 70%, 50%)`;
                    } else if (gcdTableColorMode === 'discrete') {
                        const colors = ['#0066cc', '#dc3545', '#28a745', '#ffc107', '#6f42c1', '#fd7e14', '#00d4ff', '#ff006e'];
                        color = colors[Math.min(g - 1, 7)];
                    } else if (gcdTableColorMode === 'prime') {
                        color = isPrime(g) ? '#6f42c1' : (g === 1 ? '#0066cc' : '#dc3545');
                    }
                    
                    ctx.fillStyle = color;
                    ctx.fillRect(x, y, cellSize, cellSize);
                    
                    // Highlight diagonal
                    if (highlightDiag && i === j) {
                        ctx.strokeStyle = '#fff';
                        ctx.lineWidth = 2;
                        ctx.strokeRect(x, y, cellSize, cellSize);
                    }
                    
                    // Draw border
                    ctx.strokeStyle = 'rgba(255,255,255,0.1)';
                    ctx.lineWidth = 1;
                    ctx.strokeRect(x, y, cellSize, cellSize);
                    
                    // Draw value
                    if (showValues && cellSize > 12) {
                        ctx.fillStyle = '#fff';
                        ctx.font = `${Math.min(cellSize * 0.4, 12)}px system-ui`;
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText(g, x + cellSize/2, y + cellSize/2);
                    }
                    
                    // Store for click detection
                    window.gcdTableData.push({ i, j, g, x, y, size: cellSize });
                }
            }
            
            // Draw row/column labels
            ctx.fillStyle = getComputedStyle(document.body).getPropertyValue('--text');
            ctx.font = 'bold 10px system-ui';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            
            const labelStep = Math.max(1, Math.floor(size / 20));
            for (let i = 1; i <= size; i += labelStep) {
                // Row labels
                ctx.fillText(i, 20, startY + (i - 0.5) * cellSize);
                // Column labels
                ctx.fillText(i, startX + (i - 0.5) * cellSize, 20);
            }
        }

        function exportGCDTableData() {
            const size = parseInt(document.getElementById('gcdTableSizeInput').value);
            
            let csv = `# GCD Multiplication Table - ${size}x${size}\n`;
            csv += `# Generated: ${new Date().toISOString()}\n`;
            csv += `# Color Scheme: ${gcdTableColorMode}\n`;
            csv += `# By Wessen Getachew | @7dview | wessengetachew.github.io\n`;
            csv += `#\n`;
            csv += '# Each entry shows GCD(row, column)\n';
            csv += `# Symmetric matrix: GCD(a,b) = GCD(b,a)\n`;
            csv += `# Diagonal: GCD(n,n) = n\n`;
            csv += `#\n`;
            csv += 'row,column,gcd,coprime\n';
            for (let i = 1; i <= size; i++) {
                for (let j = 1; j <= size; j++) {
                    const g = gcd(i, j);
                    csv += `${i},${j},${g},${g === 1 ? 'true' : 'false'}\n`;
                }
            }
            downloadCSV(csv, `gcd-table-${size}x${size}.csv`);
        }

        function updateGridSize() {
            const val = parseInt(document.getElementById('gridSizeInput').value) || parseInt(document.getElementById('gridSize').value);
            document.getElementById('gridSizev').textContent = val;
            document.getElementById('gridSize').value = Math.min(val, 50);
            document.getElementById('gridSizeInput').value = val;
        }

        function updateDensityR() {
            const val = parseInt(document.getElementById('densityRInput').value) || parseInt(document.getElementById('densityR').value);
            document.getElementById('densityRv').textContent = val;
            document.getElementById('densityR').value = Math.min(val, 200);
            document.getElementById('densityRInput').value = val;
        }

        function updateHeatmapR() {
            const val = parseInt(document.getElementById('heatmapRinput').value) || parseInt(document.getElementById('heatmapR').value);
            document.getElementById('heatmapRv').textContent = val;
            document.getElementById('heatmapR').value = Math.min(val, 100);
            document.getElementById('heatmapRinput').value = val;
            updateGCDHeatmap();
        }

        function updateCriticalMaxR() {
            const val = parseInt(document.getElementById('criticalMaxRinput').value) || parseInt(document.getElementById('criticalMaxR').value);
            document.getElementById('criticalMaxRv').textContent = val;
            document.getElementById('criticalMaxR').value = Math.min(val, 500);
            document.getElementById('criticalMaxRinput').value = val;
        }

        function updateCriticalStep() {
            const val = parseInt(document.getElementById('criticalStepInput').value) || parseInt(document.getElementById('criticalStep').value);
            document.getElementById('criticalStepv').textContent = val;
            document.getElementById('criticalStep').value = Math.min(val, 10);
            document.getElementById('criticalStepInput').value = val;
        }

        function update2DZoom() {
            zoom2D = parseInt(document.getElementById('zoom2D').value);
            document.getElementById('zoom2Dv').textContent = zoom2D;
            draw2D();
        }

        function formatPrecise(num, maxDecimals = 17) {
            if (Number.isInteger(num)) return num.toString();
            const str = num.toFixed(maxDecimals);
            // Remove trailing zeros
            return str.replace(/\.?0+$/, '');
        }

        let exportResolution = '1k';

        function setExportRes(res) {
            exportResolution = res;
            document.querySelectorAll('#res1k, #res2k, #res4k, #res8k').forEach(btn => btn.classList.remove('active'));
            document.getElementById(`res${res}`).classList.add('active');
        }

        function getExportDimensions() {
            const dims = {
                '1k': [1920, 1080],
                '2k': [2560, 1440],
                '4k': [3840, 2160],
                '8k': [7680, 4320]
            };
            return dims[exportResolution] || [1920, 1080];
        }

        function performAdvancedExport() {
            const canvasId = document.getElementById('exportCanvas').value;
            const sourceCanvas = document.getElementById(canvasId);
            
            if (!sourceCanvas) {
                alert('Please generate the visualization first before exporting');
                return;
            }
            
            const includeMetadata = document.getElementById('includeMetadata').checked;
            const includeTimestamp = document.getElementById('includeTimestamp').checked;
            const includeWatermark = document.getElementById('includeWatermark').checked;
            const title = document.getElementById('exportTitle').value || 'Primitive Lattice Point Analysis';
            const subtitle = document.getElementById('exportSubtitle').value;
            const legend = document.getElementById('exportLegend').value;
            
            const [width, height] = getExportDimensions();
            
            // Create high-res canvas
            const exportCanvas = document.createElement('canvas');
            exportCanvas.width = width;
            exportCanvas.height = height;
            const ctx = exportCanvas.getContext('2d');
            
            // White background
            ctx.fillStyle = document.body.classList.contains('light') ? '#ffffff' : '#1a1a1a';
            ctx.fillRect(0, 0, width, height);
            
            // Calculate layout
            const padding = Math.floor(width * 0.03);
            const titleHeight = includeMetadata ? Math.floor(height * 0.12) : 0;
            const legendWidth = legend && includeMetadata ? Math.floor(width * 0.25) : 0;
            const footerHeight = includeWatermark || includeTimestamp ? Math.floor(height * 0.04) : 0;
            
            const contentWidth = width - 2 * padding - legendWidth;
            const contentHeight = height - titleHeight - footerHeight - 2 * padding;
            const contentX = padding;
            const contentY = titleHeight + padding;
            
            // Draw title
            if (includeMetadata && title) {
                ctx.fillStyle = document.body.classList.contains('light') ? '#212529' : '#e0e0e0';
                ctx.font = `bold ${Math.floor(height * 0.04)}px system-ui`;
                ctx.textAlign = 'center';
                ctx.fillText(title, width / 2, padding + Math.floor(height * 0.035));
                
                if (subtitle) {
                    ctx.font = `${Math.floor(height * 0.025)}px system-ui`;
                    ctx.fillStyle = document.body.classList.contains('light') ? '#495057' : '#b0b0b0';
                    ctx.fillText(subtitle, width / 2, padding + Math.floor(height * 0.07));
                }
            }
            
            // Draw source canvas (scaled to fit)
            const scale = Math.min(contentWidth / sourceCanvas.width, contentHeight / sourceCanvas.height);
            const scaledWidth = sourceCanvas.width * scale;
            const scaledHeight = sourceCanvas.height * scale;
            const centerX = contentX + (contentWidth - scaledWidth) / 2;
            const centerY = contentY + (contentHeight - scaledHeight) / 2;
            
            ctx.drawImage(sourceCanvas, centerX, centerY, scaledWidth, scaledHeight);
            
            // Draw legend
            if (legend && includeMetadata && legendWidth > 0) {
                const legendX = width - legendWidth - padding;
                const legendY = contentY;
                
                ctx.fillStyle = document.body.classList.contains('light') ? '#f8f9fa' : '#2d2d2d';
                ctx.fillRect(legendX, legendY, legendWidth - padding, contentHeight);
                
                ctx.fillStyle = document.body.classList.contains('light') ? '#212529' : '#e0e0e0';
                ctx.font = `bold ${Math.floor(height * 0.02)}px system-ui`;
                ctx.textAlign = 'left';
                ctx.fillText('Legend', legendX + padding / 2, legendY + padding);
                
                const lines = legend.split('\n');
                ctx.font = `${Math.floor(height * 0.016)}px monospace`;
                let yPos = legendY + padding * 2;
                lines.forEach(line => {
                    if (yPos < legendY + contentHeight - padding) {
                        ctx.fillText(line, legendX + padding / 2, yPos);
                        yPos += Math.floor(height * 0.025);
                    }
                });
            }
            
            // Draw footer
            if (includeWatermark || includeTimestamp) {
                const footerY = height - footerHeight;
                ctx.fillStyle = document.body.classList.contains('light') ? '#212529' : '#e0e0e0';
                ctx.font = `${Math.floor(height * 0.018)}px system-ui`;
                ctx.textAlign = 'left';
                
                if (includeWatermark) {
                    ctx.fillText('By Wessen Getachew | @7dview | wessengetachew.github.io', padding, footerY + footerHeight * 0.6);
                }
                
                if (includeTimestamp) {
                    ctx.textAlign = 'right';
                    const timestamp = new Date().toLocaleString();
                    ctx.fillText(`Generated: ${timestamp}`, width - padding, footerY + footerHeight * 0.6);
                }
            }
            
            // Download
            const link = document.createElement('a');
            const filename = `${title.replace(/\s+/g, '-').toLowerCase()}-${exportResolution}.png`;
            link.download = filename;
            link.href = exportCanvas.toDataURL('image/png');
            link.click();
            
            // Show preview
            const previewCanvas = document.getElementById('exportPreviewCanvas');
            previewCanvas.width = 800;
            previewCanvas.height = 450;
            const previewCtx = previewCanvas.getContext('2d');
            previewCtx.drawImage(exportCanvas, 0, 0, 800, 450);
            previewCanvas.style.display = 'block';
            document.getElementById('exportPreview').querySelector('p').style.display = 'none';
        }

        function quickExport2D() {
            document.getElementById('exportCanvas').value = 'c2d';
            const R = document.getElementById('r2input').value;
            document.getElementById('exportTitle').value = '2D Primitive Lattice Points';
            document.getElementById('exportSubtitle').value = `Radius R=${R}, showing ${colorMode2D} coloring`;
            document.getElementById('exportLegend').value = `View Mode: ${view2D}
Color Mode: ${colorMode2D}
Radius: ${R}
Total Points: ${document.getElementById('t2').textContent}
Primitive Points: ${document.getElementById('p2').textContent}
Density: ${document.getElementById('d2').textContent}`;
            showTab('export');
        }

        function quickExport3D() {
            alert('3D export requires screenshot. Use browser screenshot or screen capture tool.');
        }

        function quickExportHeatmap() {
            document.getElementById('exportCanvas').value = 'heatmapCanvas';
            const R = document.getElementById('heatmapRinput').value;
            document.getElementById('exportTitle').value = 'GCD Heatmap Visualization';
            document.getElementById('exportSubtitle').value = `Radius R=${R}, ${heatmapMode} mode`;
            document.getElementById('exportLegend').value = `Display Mode: ${heatmapMode}
Radius: ${R}
Total Points: ${document.getElementById('heatmapTotal').textContent}
GCD=1: ${document.getElementById('heatmapPrim').textContent}
GCD=2: ${document.getElementById('heatmapGCD2').textContent}
GCD=3: ${document.getElementById('heatmapGCD3').textContent}`;
            showTab('export');
        }

        function quickExportCritical() {
            document.getElementById('exportCanvas').value = 'criticalCanvas';
            const maxR = document.getElementById('criticalMaxRinput').value;
            document.getElementById('exportTitle').value = 'Critical Strip Error Analysis';
            document.getElementById('exportSubtitle').value = `${criticalProblem === 'all' ? 'Gauss Circle Problem' : 'Primitive Points'}, ${criticalViz} visualization, Max R=${maxR}`;
            document.getElementById('exportLegend').value = `Problem: ${criticalProblem}
Visualization: ${criticalViz}
Max Radius: ${maxR}
Data Points: ${document.getElementById('criticalPoints').textContent}
Max Error: ${document.getElementById('criticalMaxErr').textContent}
Avg Error: ${document.getElementById('criticalAvgErr').textContent}`;
            showTab('export');
        }

        function quickExportTable() {
            document.getElementById('exportCanvas').value = 'gcdTableCanvas';
            const size = document.getElementById('gcdTableSizeInput').value;
            document.getElementById('exportTitle').value = 'GCD Multiplication Table';
            document.getElementById('exportSubtitle').value = `${size}×${size} grid, ${gcdTableColorMode} coloring`;
            document.getElementById('exportLegend').value = `Grid Size: ${size}×${size}
Color Scheme: ${gcdTableColorMode}
Each cell shows: GCD(row, col)`;
            showTab('export');
        }

        function quickExportAnalysis() {
            document.getElementById('exportCanvas').value = 'ch';
            const k = document.getElementById('analysisK').value;
            const maxR = document.getElementById('mrinput').value;
            document.getElementById('exportTitle').value = 'Error Analysis';
            document.getElementById('exportSubtitle').value = `Dimension k=${k}, Max Radius R=${maxR}`;
            document.getElementById('exportLegend').value = `Dimension: k=${k}
Max Radius: ${maxR}
Shows error term growth
as predicted by theory`;
            showTab('export');
        }

        function setGCDHeatmapPreset(preset) {
            const presets = { 'small': 15, 'medium': 30, 'large': 50 };
            const R = presets[preset];
            document.getElementById('heatmapR').value = R;
            document.getElementById('heatmapRinput').value = R;
            document.getElementById('heatmapRv').textContent = R;
            updateGCDHeatmap();
        }

        function setHeatmapMode(mode) {
            heatmapMode = mode;
            document.querySelectorAll('#heatmapGCD, #heatmapPrimitive, #heatmapGradient').forEach(btn => btn.classList.remove('active'));
            const btnIds = { 'gcd': 'heatmapGCD', 'primitive': 'heatmapPrimitive', 'gradient': 'heatmapGradient' };
            document.getElementById(btnIds[mode]).classList.add('active');
            updateGCDHeatmap();
        }

        function updateGCDHeatmap() {
            const R = parseInt(document.getElementById('heatmapRinput').value) || parseInt(document.getElementById('heatmapR').value);
            const pointSize = parseInt(document.getElementById('heatmapPS').value);
            
            document.getElementById('heatmapRv').textContent = R;
            document.getElementById('heatmapPSv').textContent = pointSize;
            document.getElementById('heatmapR').value = Math.min(R, 80);
            document.getElementById('heatmapRinput').value = R;
            
            const canvas = document.getElementById('heatmapCanvas');
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            const cx = canvas.width / 2, cy = canvas.height / 2;
            const scale = Math.min(canvas.width, canvas.height) / (2.2 * R);
            
            // Draw axes
            ctx.strokeStyle = getComputedStyle(document.body).getPropertyValue('--border');
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(0, cy); ctx.lineTo(canvas.width, cy);
            ctx.moveTo(cx, 0); ctx.lineTo(cx, canvas.height);
            ctx.stroke();
            
            // Draw circle boundary
            ctx.beginPath();
            ctx.arc(cx, cy, R * scale, 0, 2 * Math.PI);
            ctx.stroke();
            
            // Collect and categorize points
            heatmapPointsData = [];
            let counts = { total: 0, gcd1: 0, gcd2: 0, gcd3: 0, gcdOther: 0 };
            
            const filterGCD1 = document.getElementById('filterGCD1').checked;
            const filterGCD2 = document.getElementById('filterGCD2').checked;
            const filterGCD3 = document.getElementById('filterGCD3').checked;
            const filterGCDOther = document.getElementById('filterGCDOther').checked;
            
            for (let x = -R; x <= R; x++) {
                for (let y = -R; y <= R; y++) {
                    const distSq = x*x + y*y;
                    if (distSq <= R*R) {
                        counts.total++;
                        const g = gcd(Math.abs(x), Math.abs(y));
                        const dist = Math.sqrt(distSq);
                        
                        if (g === 1) counts.gcd1++;
                        else if (g === 2) counts.gcd2++;
                        else if (g === 3) counts.gcd3++;
                        else counts.gcdOther++;
                        
                        // Apply filters
                        let shouldDisplay = false;
                        if (g === 1 && filterGCD1) shouldDisplay = true;
                        if (g === 2 && filterGCD2) shouldDisplay = true;
                        if (g === 3 && filterGCD3) shouldDisplay = true;
                        if (g > 3 && filterGCDOther) shouldDisplay = true;
                        
                        if (shouldDisplay) {
                            heatmapPointsData.push({ x, y, gcd: g, dist, screenX: cx + x*scale, screenY: cy - y*scale });
                        }
                    }
                }
            }
            
            // Draw points based on mode
            heatmapPointsData.forEach(pt => {
                let color;
                
                if (heatmapMode === 'gcd') {
                    const gcdColors = {
                        1: '#0066cc', 2: '#dc3545', 3: '#28a745', 4: '#ffc107',
                        5: '#6f42c1', 6: '#fd7e14', 7: '#00d4ff', 8: '#ff006e'
                    };
                    color = gcdColors[Math.min(pt.gcd, 8)] || '#999';
                } else if (heatmapMode === 'primitive') {
                    color = pt.gcd === 1 ? '#0066cc' : '#e0e0e0';
                } else if (heatmapMode === 'gradient') {
                    const ratio = pt.dist / R;
                    const hue = 240 - ratio * 240; // Blue to red
                    color = `hsl(${hue}, 70%, 50%)`;
                }
                
                ctx.fillStyle = color;
                ctx.beginPath();
                ctx.arc(pt.screenX, pt.screenY, pointSize, 0, 2*Math.PI);
                ctx.fill();
            });
            
            // Update stats
            animateValue('heatmapTotal', 0, counts.total);
            animateValue('heatmapPrim', 0, counts.gcd1);
            animateValue('heatmapGCD2', 0, counts.gcd2);
            animateValue('heatmapGCD3', 0, counts.gcd3);
            animateValue('heatmapGCDOther', 0, counts.gcdOther);
        }

        function exportHeatmapData() {
            if (heatmapPointsData.length === 0) { alert('Generate heatmap first'); return; }
            let csv = 'x,y,gcd,distance\n';
            heatmapPointsData.forEach(pt => csv += `${pt.x},${pt.y},${pt.gcd},${pt.dist.toFixed(4)}\n`);
            downloadCSV(csv, 'gcd-heatmap-data.csv');
        }

        function setCriticalStripPreset(preset) {
            if (preset === 'standard') {
                document.getElementById('criticalMaxR').value = 100;
                document.getElementById('criticalMaxRinput').value = 100;
                document.getElementById('criticalStep').value = 1;
            } else if (preset === 'detailed') {
                document.getElementById('criticalMaxR').value = 200;
                document.getElementById('criticalMaxRinput').value = 200;
                document.getElementById('criticalStep').value = 1;
            } else if (preset === 'extended') {
                document.getElementById('criticalMaxR').value = 300;
                document.getElementById('criticalMaxRinput').value = 300;
                document.getElementById('criticalStep').value = 2;
            }
            document.getElementById('criticalStepv').textContent = document.getElementById('criticalStep').value;
            updateCriticalStrip();
        }

        function setCriticalProblem(type) {
            criticalProblem = type;
            document.querySelectorAll('#criticalAllPoints, #criticalPrimitive').forEach(btn => btn.classList.remove('active'));
            document.getElementById(type === 'all' ? 'criticalAllPoints' : 'criticalPrimitive').classList.add('active');
            updateCriticalStrip();
        }

        function setCriticalViz(type) {
            criticalViz = type;
            document.querySelectorAll('#criticalVizError, #criticalVizNormalized, #criticalVizLog, #criticalVizBounds').forEach(btn => btn.classList.remove('active'));
            const btnIds = {
                'error': 'criticalVizError',
                'normalized': 'criticalVizNormalized',
                'loglog': 'criticalVizLog',
                'bounds': 'criticalVizBounds'
            };
            document.getElementById(btnIds[type]).classList.add('active');
            updateCriticalStrip();
        }

        function updateCriticalStrip() {
            const maxR = parseInt(document.getElementById('criticalMaxRinput').value) || parseInt(document.getElementById('criticalMaxR').value);
            const step = parseInt(document.getElementById('criticalStep').value);
            
            document.getElementById('criticalMaxRv').textContent = maxR;
            document.getElementById('criticalStepv').textContent = step;
            document.getElementById('criticalMaxR').value = Math.min(maxR, 300);
            document.getElementById('criticalMaxRinput').value = maxR;
            
            const showZeroLine = document.getElementById('showZeroLine').checked;
            const showRHBound = document.getElementById('showRHBound').checked;
            const showClassicalBound = document.getElementById('showClassicalBound').checked;
            const colorBySign = document.getElementById('colorBySign').checked;
            
            document.getElementById('loadCritical').classList.add('active');
            
            setTimeout(() => {
                const canvas = document.getElementById('criticalCanvas');
                const ctx = canvas.getContext('2d');
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                // Setup coordinate system
                const padding = 80;
                const plotWidth = canvas.width - 2*padding;
                const plotHeight = canvas.height - 2*padding;
                
                // Collect error data
                const errorData = [];
                let maxAbsError = 0, sumAbsError = 0, sumSqError = 0;
                let maxNormalizedError = 0;
                
                for (let R = step; R <= maxR; R += step) {
                    // Calculate actual count
                    let actualCount = 0;
                    
                    if (R <= 80) {
                        // Exact computation for small R
                        for (let x = -R; x <= R; x++) {
                            for (let y = -R; y <= R; y++) {
                                const distSq = x*x + y*y;
                                if (distSq <= R*R) {
                                    if (criticalProblem === 'all') {
                                        actualCount++;
                                    } else if (gcd(Math.abs(x), Math.abs(y)) === 1) {
                                        actualCount++;
                                    }
                                }
                            }
                        }
                    } else {
                        // Approximation for large R
                        if (criticalProblem === 'all') {
                            actualCount = Math.round(Math.PI * R * R);
                        } else {
                            actualCount = Math.round(Math.PI * R * R / zeta(2));
                        }
                    }
                    
                    // Predicted value
                    let predicted;
                    if (criticalProblem === 'all') {
                        predicted = Math.PI * R * R;
                    } else {
                        predicted = Math.PI * R * R / zeta(2);
                    }
                    
                    const error = actualCount - predicted;
                    const absError = Math.abs(error);
                    const normalizedError = absError / Math.sqrt(R);
                    
                    maxAbsError = Math.max(maxAbsError, absError);
                    sumAbsError += absError;
                    sumSqError += error * error;
                    maxNormalizedError = Math.max(maxNormalizedError, normalizedError);
                    
                    errorData.push({ 
                        R, 
                        error, 
                        absError, 
                        normalizedError,
                        actualCount,
                        predicted
                    });
                }
                
                // Determine axis ranges based on visualization type
                let xMin, xMax, yMin, yMax, xLabel, yLabel;
                
                if (criticalViz === 'error') {
                    xMin = 0; xMax = maxR;
                    const maxErrorForPlot = Math.max(...errorData.map(d => Math.abs(d.error)));
                    yMin = -maxErrorForPlot * 1.1;
                    yMax = maxErrorForPlot * 1.1;
                    xLabel = 'Radius R';
                    yLabel = 'Error Δ(R)';
                } else if (criticalViz === 'normalized') {
                    xMin = 0; xMax = maxR;
                    yMin = -maxNormalizedError * 1.2;
                    yMax = maxNormalizedError * 1.2;
                    xLabel = 'Radius R';
                    yLabel = 'Normalized Error Δ(R)/R^(1/2)';
                } else if (criticalViz === 'loglog') {
                    xMin = Math.log10(step);
                    xMax = Math.log10(maxR);
                    yMin = Math.log10(Math.min(...errorData.filter(d => d.absError > 0).map(d => d.absError)));
                    yMax = Math.log10(maxAbsError) * 1.1;
                    xLabel = 'log₁₀(R)';
                    yLabel = 'log₁₀(|Δ(R)|)';
                } else if (criticalViz === 'bounds') {
                    xMin = 0; xMax = maxR;
                    yMin = 0;
                    yMax = Math.max(
                        maxAbsError,
                        Math.pow(maxR, 2/3) * 2,
                        Math.sqrt(maxR) * 10
                    ) * 1.1;
                    xLabel = 'Radius R';
                    yLabel = '|Δ(R)|';
                }
                
                // Draw axes
                ctx.strokeStyle = getComputedStyle(document.body).getPropertyValue('--text2');
                ctx.lineWidth = 2;
                
                // X-axis
                ctx.beginPath();
                ctx.moveTo(padding, canvas.height - padding);
                ctx.lineTo(canvas.width - padding, canvas.height - padding);
                ctx.stroke();
                
                // Y-axis
                ctx.beginPath();
                ctx.moveTo(padding, padding);
                ctx.lineTo(padding, canvas.height - padding);
                ctx.stroke();
                
                // Helper function to map data to screen coordinates
                function mapX(val) {
                    if (criticalViz === 'loglog') val = Math.log10(val);
                    return padding + ((val - xMin) / (xMax - xMin)) * plotWidth;
                }
                
                function mapY(val) {
                    if (criticalViz === 'loglog' && val > 0) val = Math.log10(val);
                    return canvas.height - padding - ((val - yMin) / (yMax - yMin)) * plotHeight;
                }
                
                // Draw zero line
                if (showZeroLine && (criticalViz === 'error' || criticalViz === 'normalized')) {
                    ctx.strokeStyle = 'rgba(128, 128, 128, 0.5)';
                    ctx.lineWidth = 1;
                    ctx.setLineDash([5, 5]);
                    ctx.beginPath();
                    ctx.moveTo(padding, mapY(0));
                    ctx.lineTo(canvas.width - padding, mapY(0));
                    ctx.stroke();
                    ctx.setLineDash([]);
                }
                
                // Draw theoretical bounds
                if (showRHBound && (criticalViz === 'bounds' || criticalViz === 'loglog')) {
                    ctx.strokeStyle = 'rgba(111, 66, 193, 0.7)';
                    ctx.lineWidth = 3;
                    ctx.setLineDash([10, 5]);
                    ctx.beginPath();
                    
                    for (let R = step; R <= maxR; R += Math.max(1, step)) {
                        const bound = Math.sqrt(R) * (criticalViz === 'loglog' ? 3 : 5);
                        const x = mapX(R);
                        const y = mapY(bound);
                        if (R === step) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                    ctx.stroke();
                    ctx.setLineDash([]);
                    
                    // Add label
                    ctx.fillStyle = 'rgba(111, 66, 193, 0.9)';
                    ctx.font = 'bold 12px system-ui';
                    const labelText = criticalViz === 'loglog' ? 'Slope 1/2 (RH)' : 'RH Bound';
                    ctx.fillText(labelText, canvas.width - padding - 80, padding + 30);
                }
                
                if (showClassicalBound && (criticalViz === 'bounds' || criticalViz === 'loglog')) {
                    ctx.strokeStyle = 'rgba(220, 53, 69, 0.7)';
                    ctx.lineWidth = 3;
                    ctx.setLineDash([5, 10]);
                    ctx.beginPath();
                    
                    for (let R = step; R <= maxR; R += Math.max(1, step)) {
                        const bound = Math.pow(R, 2/3) * (criticalViz === 'loglog' ? 1.5 : 2);
                        const x = mapX(R);
                        const y = mapY(bound);
                        if (R === step) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                    ctx.stroke();
                    ctx.setLineDash([]);
                    
                    // Add label
                    ctx.fillStyle = 'rgba(220, 53, 69, 0.9)';
                    ctx.font = 'bold 12px system-ui';
                    const labelText = criticalViz === 'loglog' ? 'Slope 2/3' : 'Classical Bound';
                    ctx.fillText(labelText, canvas.width - padding - 80, padding + 50);
                }
                
                // Draw data points
                errorData.forEach((d, i) => {
                    let x, y, color, pointSize = 4;
                    
                    if (criticalViz === 'error') {
                        x = mapX(d.R);
                        y = mapY(d.error);
                        color = colorBySign ? (d.error > 0 ? 'rgba(0, 102, 204, 0.7)' : 'rgba(220, 53, 69, 0.7)') : 'rgba(0, 102, 204, 0.7)';
                    } else if (criticalViz === 'normalized') {
                        x = mapX(d.R);
                        y = mapY(d.error / Math.sqrt(d.R));
                        color = colorBySign ? (d.error > 0 ? 'rgba(0, 102, 204, 0.7)' : 'rgba(220, 53, 69, 0.7)') : 'rgba(0, 102, 204, 0.7)';
                    } else if (criticalViz === 'loglog') {
                        if (d.absError > 0) {
                            x = mapX(d.R);
                            y = mapY(d.absError);
                            const ratio = d.normalizedError / maxNormalizedError;
                            const hue = 240 - ratio * 240;
                            color = `hsla(${hue}, 70%, 50%, 0.7)`;
                        } else return;
                    } else if (criticalViz === 'bounds') {
                        x = mapX(d.R);
                        y = mapY(d.absError);
                        const ratio = d.absError / maxAbsError;
                        const hue = 240 - ratio * 240;
                        color = `hsla(${hue}, 70%, 50%, 0.7)`;
                    }
                    
                    ctx.fillStyle = color;
                    ctx.beginPath();
                    ctx.arc(x, y, pointSize, 0, 2*Math.PI);
                    ctx.fill();
                    
                    // Store screen coordinates for click detection
                    d.screenX = x;
                    d.screenY = y;
                });
                
                // Store data globally
                window.criticalStripData = errorData;
                
                // Axis labels
                ctx.fillStyle = getComputedStyle(document.body).getPropertyValue('--text');
                ctx.font = 'bold 14px system-ui';
                ctx.textAlign = 'center';
                
                ctx.fillText(xLabel, canvas.width / 2, canvas.height - 20);
                
                ctx.save();
                ctx.translate(20, canvas.height / 2);
                ctx.rotate(-Math.PI/2);
                ctx.fillText(yLabel, 0, 0);
                ctx.restore();
                
                // Title
                ctx.font = 'bold 16px system-ui';
                const problemTitle = criticalProblem === 'all' ? 'Gauss Circle Problem' : 'Primitive Lattice Points';
                const vizTitle = {
                    'error': 'Error Term',
                    'normalized': 'Normalized Error',
                    'loglog': 'Log-Log Error',
                    'bounds': 'Error with Bounds'
                }[criticalViz];
                ctx.fillText(`${problemTitle}: ${vizTitle}`, canvas.width / 2, padding - 40);
                
                // Tick marks and labels
                ctx.font = '12px system-ui';
                ctx.fillStyle = getComputedStyle(document.body).getPropertyValue('--text2');
                
                // X-axis ticks
                const numXTicks = 5;
                for (let i = 0; i <= numXTicks; i++) {
                    const val = xMin + (xMax - xMin) * i / numXTicks;
                    const x = mapX(criticalViz === 'loglog' ? Math.pow(10, val) : val);
                    ctx.beginPath();
                    ctx.moveTo(x, canvas.height - padding);
                    ctx.lineTo(x, canvas.height - padding + 5);
                    ctx.stroke();
                    
                    const label = criticalViz === 'loglog' ? 
                        Math.pow(10, val).toFixed(0) : 
                        val.toFixed(criticalViz === 'normalized' || criticalViz === 'error' ? 0 : 1);
                    ctx.fillText(label, x, canvas.height - padding + 20);
                }
                
                // Y-axis ticks
                const numYTicks = 5;
                for (let i = 0; i <= numYTicks; i++) {
                    const val = yMin + (yMax - yMin) * i / numYTicks;
                    const y = mapY(criticalViz === 'loglog' ? Math.pow(10, val) : val);
                    ctx.beginPath();
                    ctx.moveTo(padding - 5, y);
                    ctx.lineTo(padding, y);
                    ctx.stroke();
                    
                    const label = criticalViz === 'loglog' ? 
                        Math.pow(10, val).toExponential(0) : 
                        val.toFixed(1);
                    ctx.textAlign = 'right';
                    ctx.fillText(label, padding - 10, y + 4);
                    ctx.textAlign = 'center';
                }
                
                // Update stats
                const rmsError = Math.sqrt(sumSqError / errorData.length);
                const avgError = sumAbsError / errorData.length;
                
                document.getElementById('criticalPoints').textContent = errorData.length;
                animateValue('criticalMaxErr', 0, maxAbsError);
                animateValue('criticalAvgErr', 0, avgError);
                animateValue('criticalRMSErr', 0, rmsError);
                document.getElementById('criticalMaxNorm').textContent = maxNormalizedError.toFixed(3);
                
                document.getElementById('loadCritical').classList.remove('active');
            }, 100);
        }

        function exportCriticalData() {
            if (!window.criticalStripData) { alert('Generate critical strip analysis first'); return; }
            const problemType = criticalProblem === 'all' ? 'all_points' : 'primitive_points';
            let csv = 'radius,actual_count,predicted_count,error,abs_error,normalized_error\n';
            window.criticalStripData.forEach(d => {
                csv += `${d.R},${d.actualCount},${d.predicted.toFixed(4)},${d.error.toFixed(4)},${d.absError.toFixed(4)},${d.normalizedError.toFixed(6)}\n`;
            });
            downloadCSV(csv, `critical-strip-${problemType}-data.csv`);
        }

        // Init
        updateTheory();
        updateDimScale();
        const tb = document.getElementById('tbl');
        for (let k = 2; k <= 12; k++) {
            const z = zeta(k);
            const precision = k > 6 ? 17 : 6;
            const v = k % 2 === 0 ? 
                (Math.PI**(k/2) / factorial(k/2)) :
                (2 * factorial((k-1)/2) * Math.PI**((k-1)/2) / factorial(k));
            tb.innerHTML += `<tr><td>${k}</td><td>${formatPrecise(z, precision)}</td><td>${formatPrecise(1/z, precision)}</td><td>${formatPrecise(v, precision)}</td></tr>`;
        }
        
        document.getElementById('helpModal').addEventListener('click', e => {
            if (e.target.id === 'helpModal') closeHelp();
        });
        
        // Add click handlers for interactive canvases
        document.getElementById('heatmapCanvas').addEventListener('click', function(e) {
            const rect = this.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            // Find closest point
            let closestPoint = null;
            let minDist = Infinity;
            
            heatmapPointsData.forEach(pt => {
                const dist = Math.sqrt((x - pt.screenX)**2 + (y - pt.screenY)**2);
                if (dist < minDist && dist < 15) {
                    minDist = dist;
                    closestPoint = pt;
                }
            });
            
            if (closestPoint) {
                const factors = primeFactors(closestPoint.gcd);
                const fc = {};
                factors.forEach(p => fc[p] = (fc[p]||0) + 1);
                const factorStr = Object.entries(fc).map(([p,c]) => c>1 ? `${p}^${c}` : p).join(' × ');
                
                const isPrimitive = closestPoint.gcd === 1;
                const reducedX = closestPoint.x / closestPoint.gcd;
                const reducedY = closestPoint.y / closestPoint.gcd;
                
                const infoDiv = document.getElementById('pointInfo');
                infoDiv.classList.add('point-info-active');
                setTimeout(() => infoDiv.classList.remove('point-info-active'), 500);
                
                infoDiv.innerHTML = `
                    <h3 style="color:var(--blue); margin-bottom:15px;">Point: (${closestPoint.x}, ${closestPoint.y})</h3>
                    <div style="display:grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap:15px;">
                        <div>
                            <p><b>GCD:</b> ${closestPoint.gcd}</p>
                            <p><b>Prime factorization:</b> ${factorStr || '1'}</p>
                            <p><b>Distance:</b> ${closestPoint.dist.toFixed(4)}</p>
                        </div>
                        <div>
                            <p><b>Type:</b> <span style="color:${isPrimitive ? 'var(--green)' : 'var(--red)'}">${isPrimitive ? 'Primitive' : 'Non-Primitive'}</span></p>
                            ${!isPrimitive ? `<p><b>Reduced form:</b> (${reducedX}, ${reducedY})</p>` : ''}
                            ${!isPrimitive ? `<p><b>Relationship:</b> ${closestPoint.gcd} × (${reducedX}, ${reducedY})</p>` : ''}
                        </div>
                    </div>
                `;
            }
        });
        
        document.getElementById('gcdTableCanvas').addEventListener('click', function(e) {
            if (!window.gcdTableData) return;
            
            const rect = this.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            // Find clicked cell
            let clickedCell = null;
            
            window.gcdTableData.forEach(cell => {
                if (x >= cell.x && x <= cell.x + cell.size &&
                    y >= cell.y && y <= cell.y + cell.size) {
                    clickedCell = cell;
                }
            });
            
            if (clickedCell) {
                const i = clickedCell.i;
                const j = clickedCell.j;
                const g = clickedCell.g;
                
                // Factor both numbers
                const factorsI = primeFactors(i);
                const factorsJ = primeFactors(j);
                const factorsG = primeFactors(g);
                
                const fci = {};
                factorsI.forEach(p => fci[p] = (fci[p]||0) + 1);
                const fcj = {};
                factorsJ.forEach(p => fcj[p] = (fcj[p]||0) + 1);
                const fcg = {};
                factorsG.forEach(p => fcg[p] = (fcg[p]||0) + 1);
                
                const strI = Object.entries(fci).map(([p,c]) => c>1 ? `${p}^${c}` : p).join(' × ') || '1';
                const strJ = Object.entries(fcj).map(([p,c]) => c>1 ? `${p}^${c}` : p).join(' × ') || '1';
                const strG = Object.entries(fcg).map(([p,c]) => c>1 ? `${p}^${c}` : p).join(' × ') || '1';
                
                const coprime = g === 1;
                
                const infoDiv = document.getElementById('gcdTableInfo');
                infoDiv.classList.add('point-info-active');
                setTimeout(() => infoDiv.classList.remove('point-info-active'), 500);
                
                infoDiv.innerHTML = `
                    <h3 style="color:var(--blue); margin-bottom:15px;">GCD(${i}, ${j}) = ${g}</h3>
                    <div style="display:grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap:15px;">
                        <div>
                            <p><b>${i} =</b> ${strI}</p>
                            <p><b>${j} =</b> ${strJ}</p>
                            <p><b>GCD =</b> ${strG}</p>
                        </div>
                        <div>
                            <p><b>Coprime:</b> <span style="color:${coprime ? 'var(--green)' : 'var(--red)'}">${coprime ? 'Yes' : 'No'}</span></p>
                            <p><b>LCM(${i}, ${j}):</b> ${(i * j) / g}</p>
                            ${!coprime ? `<p><b>Common factors:</b> Divisors of ${g}</p>` : ''}
                        </div>
                    </div>
                    <div style="margin-top:15px; padding:10px; background:var(--bg); border-radius:6px;">
                        <p style="font-size:0.9em; color:var(--text2);">
                            ${coprime ? 
                                `${i} and ${j} share no common prime factors.` :
                                `${i} and ${j} share the common factor ${g}.`
                            }
                        </p>
                    </div>
                `;
            }
        });
        
        document.getElementById('criticalCanvas').addEventListener('click', function(e) {
            if (!window.criticalStripData) return;
            
            const rect = this.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            // Find closest point
            let closestPoint = null;
            let minDist = Infinity;
            
            window.criticalStripData.forEach(d => {
                const dist = Math.sqrt((x - d.screenX)**2 + (y - d.screenY)**2);
                if (dist < minDist && dist < 20) {
                    minDist = dist;
                    closestPoint = d;
                }
            });
            
            if (closestPoint) {
                const errorPercent = ((Math.abs(closestPoint.error) / closestPoint.predicted) * 100).toFixed(4);
                const rhBound = Math.sqrt(closestPoint.R) * 5;
                const classicalBound = Math.pow(closestPoint.R, 2/3) * 2;
                const exceedsRH = closestPoint.absError > rhBound;
                const exceedsClassical = closestPoint.absError > classicalBound;
                
                const problemType = criticalProblem === 'all' ? 'All lattice points' : 'Primitive points only';
                const formula = criticalProblem === 'all' ? 
                    'N(R) = πR² + Δ(R)' : 
                    'N_prim(R) = πR²/ζ(2) + Δ(R)';
                
                const infoDiv = document.getElementById('criticalPointInfo');
                infoDiv.classList.add('point-info-active');
                setTimeout(() => infoDiv.classList.remove('point-info-active'), 500);
                
                infoDiv.innerHTML = `
                    <h3 style="color:var(--blue); margin-bottom:15px;">Radius R = ${closestPoint.R} (${problemType})</h3>
                    <div style="display:grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap:15px;">
                        <div>
                            <p><b>Formula:</b> ${formula}</p>
                            <p><b>Predicted N(R):</b> ${closestPoint.predicted.toFixed(2)}</p>
                            <p><b>Actual N(R):</b> ${closestPoint.actualCount}</p>
                            <p><b>Error Δ(R):</b> <span style="color:${closestPoint.error > 0 ? 'var(--green)' : 'var(--red)'}">${closestPoint.error > 0 ? '+' : ''}${closestPoint.error.toFixed(2)}</span></p>
                            <p><b>Relative Error:</b> ${errorPercent}%</p>
                        </div>
                        <div>
                            <p><b>Normalized:</b> Δ(R)/R^(1/2) = ${closestPoint.normalizedError.toFixed(4)}</p>
                            <p><b>RH Bound (5R^(1/2)):</b> ${rhBound.toFixed(2)}</p>
                            <p><b>Classical Bound (2R^(2/3)):</b> ${classicalBound.toFixed(2)}</p>
                            <p style="margin-top:8px;">
                                <b>Status:</b> 
                                ${exceedsRH ? '<span style="color:var(--red)">Warning: Exceeds RH bound</span>' : '<span style="color:var(--green)">Within RH bound</span>'}
                            </p>
                        </div>
                    </div>
                    <div style="margin-top:15px; padding:10px; background:var(--bg); border-radius:6px;">
                        <p style="font-size:0.9em; color:var(--text2);">
                            <b>Interpretation:</b> ${closestPoint.error > 0 ? 
                                'Positive error means more points than predicted by the smooth approximation.' : 
                                'Negative error means fewer points than predicted by the smooth approximation.'} 
                            ${!exceedsRH ? 
                                'The error is consistent with the Riemann Hypothesis bound O(R^(1/2+ε)).' : 
                                'The error exceeds our simplified RH bound, but note this is just a constant multiple.'}
                        </p>
                    </div>
                `;
            }
        });
    </script>
</body>
                            </html>

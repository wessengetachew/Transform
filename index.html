
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mathematical Discovery Platform</title>
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        :root {
            --bg: #1a1a1a; --bg2: #2d2d2d; --bg3: #3a3a3a; --text: #e0e0e0; --text2: #b0b0b0;
            --border: #4a4a4a; --blue: #0066cc; --purple: #6f42c1; --green: #28a745; --red: #dc3545;
            --yellow: #ffc107; --orange: #fd7e14;
        }
        body.light { --bg: #fff; --bg2: #f8f9fa; --bg3: #e9ecef; --text: #212529; --text2: #495057; --border: #dee2e6; }
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: system-ui; background: var(--bg); color: var(--text); line-height: 1.6; transition: background 0.3s, color 0.3s; }
        .container { max-width: 1400px; margin: 0 auto; padding: 20px; }
        .header { text-align: center; padding: 40px 20px; background: linear-gradient(135deg, var(--blue), var(--purple));
            color: white; border-radius: 12px; margin-bottom: 30px; position: relative; overflow: hidden; }
        .header::before { content: ''; position: absolute; top: -50%; left: -50%; width: 200%; height: 200%;
            background: radial-gradient(circle, rgba(255,255,255,0.1) 0%, transparent 70%); animation: pulse 4s infinite; }
        @keyframes pulse { 0%, 100% { transform: scale(1); } 50% { transform: scale(1.1); } }
        .header h1 { font-size: 2.5rem; margin-bottom: 10px; position: relative; z-index: 1; }
        .header p { position: relative; z-index: 1; }
        .tabs { display: flex; gap: 5px; margin-bottom: 30px; background: var(--bg2); padding: 10px; border-radius: 12px; flex-wrap: wrap; }
        .tab-btn { flex: 1; min-width: 120px; padding: 12px 20px; border: none; background: var(--bg3); color: var(--text);
            cursor: pointer; border-radius: 8px; font-weight: 600; transition: all 0.3s; }
        .tab-btn:hover { background: var(--blue); color: white; transform: translateY(-2px); }
        .tab-btn.active { background: var(--blue); color: white; box-shadow: 0 4px 12px rgba(0,102,204,0.3); }
        .controls button.active { background: var(--purple); }
        select { font-size: 1em; }
        .panel { display: none; animation: fadeIn 0.5s; }
        .panel.active { display: block; }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }
        .section { background: var(--bg2); padding: 30px; border-radius: 12px; margin-bottom: 30px; transition: all 0.3s; }
        .section:hover { box-shadow: 0 4px 20px rgba(0,0,0,0.1); }
        .section h2 { color: var(--blue); margin-bottom: 20px; display: flex; align-items: center; gap: 10px; }
        .help-icon { display: inline-block; width: 20px; height: 20px; background: var(--blue); color: white;
            border-radius: 50%; text-align: center; line-height: 20px; font-size: 12px; cursor: help; }
        .tooltip { position: relative; }
        .tooltip:hover::after { content: attr(data-tip); position: absolute; bottom: 125%; left: 50%;
            transform: translateX(-50%); padding: 8px 12px; background: var(--text); color: var(--bg);
            border-radius: 6px; white-space: nowrap; z-index: 1000; font-size: 12px; }
        .controls { margin: 20px 0; padding: 20px; background: var(--bg3); border-radius: 8px; }
        .controls label { display: block; margin: 10px 0; font-weight: 600; }
        .controls input[type="range"] { width: 100%; }
        .controls button { padding: 10px 20px; background: var(--blue); color: white; border: none;
            border-radius: 6px; cursor: pointer; margin: 5px; transition: all 0.3s; }
        .controls button:hover { background: var(--purple); transform: scale(1.05); }
        .controls button:disabled { background: var(--text2); cursor: not-allowed; transform: none; }
        .stats { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; margin: 20px 0; }
        .stat { background: var(--bg3); padding: 20px; border-radius: 8px; text-align: center; transition: all 0.3s; }
        .stat:hover { transform: translateY(-5px); box-shadow: 0 4px 12px rgba(0,0,0,0.15); }
        .stat .val { font-size: 2rem; font-weight: bold; color: var(--blue); transition: all 0.5s; }
        .stat .lbl { font-size: 0.9rem; color: var(--text2); }
        canvas { border: 2px solid var(--border); border-radius: 8px; display: block; margin: 20px auto; max-width: 100%; }
        #canvas3d { width: 100%; height: 600px; cursor: grab; }
        #canvas3d:active { cursor: grabbing; }
        table { width: 100%; border-collapse: collapse; margin: 20px 0; overflow-x: auto; display: block; }
        th, td { padding: 12px; text-align: left; border-bottom: 1px solid var(--border); }
        th { background: var(--bg3); color: var(--blue); font-weight: 600; position: sticky; top: 0; }
        .btn-fixed { position: fixed; bottom: 20px; padding: 12px 24px; border: none; border-radius: 25px;
            cursor: pointer; font-weight: 600; z-index: 1000; color: white; transition: all 0.3s; }
        .btn-fixed:hover { transform: translateY(-3px); box-shadow: 0 6px 20px rgba(0,0,0,0.3); }
        #darkBtn { right: 20px; background: var(--blue); }
        #helpBtn { right: 140px; background: var(--green); }
        .formula { background: var(--bg3); padding: 20px; border-left: 4px solid var(--blue); border-radius: 8px; margin: 20px 0; }
        .warning { background: #3d3106; color: #ffc107; padding: 15px; border-left: 4px solid var(--yellow); border-radius: 8px; margin: 20px 0; }
        body.light .warning { background: #fff3cd; color: #856404; }
        .loading { display: none; text-align: center; padding: 20px; }
        .loading.active { display: block; }
        .spinner { border: 4px solid var(--border); border-top: 4px solid var(--blue); border-radius: 50%;
            width: 40px; height: 40px; animation: spin 1s linear infinite; margin: 20px auto; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        .compare-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 20px; }
        .compare-item { background: var(--bg3); padding: 15px; border-radius: 8px; }
        .modal { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7);
            z-index: 2000; align-items: center; justify-content: center; }
        .modal.active { display: flex; }
        .modal-content { background: var(--bg); padding: 30px; border-radius: 12px; max-width: 600px; max-height: 80vh;
            overflow-y: auto; position: relative; }
        .modal-close { position: absolute; top: 10px; right: 10px; font-size: 24px; cursor: pointer; color: var(--text2); }
        .export-buttons { display: flex; gap: 10px; flex-wrap: wrap; }
        .data-table-container { max-height: 400px; overflow-y: auto; }
        @media (max-width: 768px) {
            .header h1 { font-size: 1.8rem; }
            .tabs { flex-direction: column; }
            .tab-btn { min-width: 100%; }
            #canvas3d { height: 400px; }
            .btn-fixed { padding: 10px 16px; font-size: 14px; }
            #helpBtn { right: 20px; bottom: 70px; }
        }
    </style>
</head>
<body>
    <div class="container">
        <header class="header">
            <h1>Primitive Lattice Point Theory</h1>
            <p>A Computational Framework for Boundary Cancellation Analysis</p>
            <p style="margin-top:10px; font-size:0.9rem">By Wessen Getachew | <a href="https://twitter.com/7dview" style="color:white">@7dview</a></p>
        </header>

        <nav class="tabs">
            <button class="tab-btn active" onclick="showTab('theory')">Theory</button>
            <button class="tab-btn" onclick="showTab('patterns')">Pattern Explorer</button>
            <button class="tab-btn" onclick="showTab('gcdheatmap')">GCD Heatmap</button>
            <button class="tab-btn" onclick="showTab('gcdtable')">GCD Table</button>
            <button class="tab-btn" onclick="showTab('criticalstrip')">Critical Strip</button>
            <button class="tab-btn" onclick="showTab('viz2d')">2D Viz</button>
            <button class="tab-btn" onclick="showTab('viz3d')">3D Viz</button>
            <button class="tab-btn" onclick="showTab('comparison')">Compare</button>
            <button class="tab-btn" onclick="showTab('analysis')">Analysis</button>
            <button class="tab-btn" onclick="showTab('tools')">Tools</button>
            <button class="tab-btn" onclick="showTab('export')">Export</button>
            <button class="tab-btn" onclick="showTab('derivation')">Derivation</button>
        </nav>

        <div id="theory" class="panel active">
            <div class="section">
                <h2>Abstract <span class="help-icon tooltip" data-tip="Core theoretical framework">?</span></h2>
                <p>We present a framework for counting primitive lattice points in k-dimensional spheres. Points (x₁, x₂, ..., xₖ) with gcd(x₁, x₂, ..., xₖ) = 1 follow the asymptotic formula:</p>
                <div class="formula">$$N_k(R) = \frac{V_k R^k}{\zeta(k)} + O(R^{k-1})$$</div>
                <p style="margin-top:15px">Where V_k is the volume of the unit k-sphere and ζ(k) is the Riemann zeta function. The density of primitive points approaches 1/ζ(k) as R → ∞.</p>
            </div>
            
            <div class="section">
                <h2>Boundary Cancellation Principle</h2>
                <p>The key insight is that non-primitive points (those sharing a common factor d > 1) can be expressed as d·(primitive point). Through Möbius inversion, we show that boundary contributions from non-primitive points cancel systematically, leaving only the volume term divided by ζ(k).</p>
                <div class="formula">$$N_k(R) = \sum_{d=1}^{R} \mu(d) \cdot |\{(x_1,...,x_k) : \sum x_i^2 \leq (R/d)^2\}|$$</div>
                <p style="margin-top:15px">The Möbius function μ(d) = (-1)^ω(d) for square-free d (where ω counts distinct prime factors) ensures alternating cancellation of boundary terms.</p>
            </div>

            <div class="section">
                <h2>Interactive Explorer <span class="help-icon tooltip" data-tip="Adjust parameters to see predictions">?</span></h2>
                <div class="controls">
                    <label>Dimension k: <span id="tk">3</span></label>
                    <input type="range" id="tks" min="2" max="12" value="3" oninput="updateTheory()">
                    <label>Radius R: <span id="tr">50</span></label>
                    <input type="range" id="trs" min="10" max="200" value="50" step="10" oninput="updateTheory()">
                    <button onclick="exportTheoryData()">Export Data</button>
                </div>
                <div class="stats">
                    <div class="stat"><div class="val" id="sz">1.202</div><div class="lbl">ζ(k)</div></div>
                    <div class="stat"><div class="val" id="sp">4186</div><div class="lbl">Predicted N_k(R)</div></div>
                    <div class="stat"><div class="val" id="sd">0.832</div><div class="lbl">Density (1/ζ(k))</div></div>
                    <div class="stat"><div class="val" id="svol">523.6</div><div class="lbl">Sphere Volume</div></div>
                </div>
                <div class="data-table-container">
                    <table><thead><tr><th>k</th><th>ζ(k)</th><th>1/ζ(k)</th><th>V_k (unit sphere)</th></tr></thead><tbody id="tbl"></tbody></table>
                </div>
            </div>
        </div>

        <div id="patterns" class="panel">
            <div class="section">
                <h2>Pattern Explorer <span class="help-icon tooltip" data-tip="Discover patterns in primitive lattice points">?</span></h2>
                <p>Explore mathematical patterns and structures within primitive lattice point distributions. Interactive tools reveal modular patterns, density variations, and symmetry properties.</p>
                
                <div class="controls">
                    <label><b>Select Pattern Type:</b></label>
                    <div style="display:grid; grid-template-columns: repeat(auto-fit, minmax(180px, 1fr)); gap:10px; margin:15px 0;">
                        <button id="patternModular" class="active" onclick="setPatternType('modular')" style="padding:12px;">Modular Residue Classes</button>
                        <button id="patternDensity" onclick="setPatternType('density')" style="padding:12px;">Density Distribution</button>
                        <button id="patternAngular" onclick="setPatternType('angular')" style="padding:12px;">Angular Distribution</button>
                        <button id="patternRadial" onclick="setPatternType('radial')" style="padding:12px;">Radial Shells</button>
                    </div>
                    
                    <div id="modularPatternControls">
                        <div style="background:var(--bg3); padding:20px; border-radius:8px; margin:15px 0;">
                            <h3 style="color:var(--blue); margin-bottom:15px;">Modular Arithmetic Patterns</h3>
                            <p style="margin-bottom:15px;">Analyze how primitive points distribute across residue classes modulo m. This reveals deep connections between coprimality and modular arithmetic.</p>
                            
                            <label>Modulus m: <span id="patternModv">7</span></label>
                            <input type="range" id="patternMod" min="2" max="20" value="7" step="1" oninput="updatePatternViz()">
                            
                            <label style="margin-top:15px;">Radius R: <span id="patternRv">30</span></label>
                            <input type="range" id="patternR" min="10" max="100" value="30" step="5" oninput="updatePatternViz()">
                            
                            <div style="margin-top:15px;">
                                <label><input type="checkbox" id="showExpected" checked onchange="updatePatternViz()"> Show Expected Distribution</label>
                            </div>
                        </div>
                        
                        <div style="margin:20px 0;">
                            <button onclick="updatePatternViz()" style="padding:12px 24px;">Compute Pattern</button>
                            <button onclick="exportPatternData()" style="padding:12px 24px;">Export Data</button>
                        </div>
                        
                        <canvas id="patternCanvas" width="1000" height="600" style="max-width:100%;"></canvas>
                        
                        <div class="stats" id="patternStats" style="margin-top:20px;"></div>
                        
                        <div class="formula" style="margin-top:20px;">
                            <p><b>Theoretical Background:</b></p>
                            <p>For modulus m and primitive points with gcd(x,y) = 1, the distribution across residue classes (x+y) mod m reveals patterns related to Euler's totient function φ(m). Residue classes coprime to m tend to have higher concentrations of primitive points.</p>
                        </div>
                    </div>
                    
                    <div id="densityPatternControls" style="display:none;">
                        <div style="background:var(--bg3); padding:20px; border-radius:8px; margin:15px 0;">
                            <h3 style="color:var(--blue); margin-bottom:15px;">Density Distribution Analysis</h3>
                            <p style="margin-bottom:15px;">Examine how the density of primitive points varies across different regions of the lattice.</p>
                            
                            <label>Grid Size: <span id="gridSizev">10</span></label>
                            <div style="display:flex; gap:10px; align-items:center; margin-bottom:15px;">
                                <input type="range" id="gridSize" min="5" max="50" value="10" step="1" oninput="updateGridSize()" style="flex:1;">
                                <input type="number" id="gridSizeInput" min="5" max="100" value="10" style="width:100px; padding:8px;" oninput="updateGridSize()">
                            </div>
                            
                            <label style="margin-top:15px;">Max Radius: <span id="densityRv">50</span></label>
                            <div style="display:flex; gap:10px; align-items:center; margin-bottom:15px;">
                                <input type="range" id="densityR" min="20" max="200" value="50" step="5" oninput="updateDensityR()" style="flex:1;">
                                <input type="number" id="densityRInput" min="20" max="500" value="50" step="5" style="width:100px; padding:8px;" oninput="updateDensityR()">
                            </div>
                        </div>
                        
                        <button onclick="updatePatternViz()" style="padding:12px 24px; margin:10px 0;">Compute Density Map</button>
                        
                        <canvas id="densityCanvas" width="800" height="800" style="max-width:100%;"></canvas>
                        
                        <div class="formula" style="margin-top:20px;">
                            <p><b>Observation:</b> Density approaches 1/ζ(2) ≈ 60.79% uniformly as radius increases, confirming the asymptotic formula.</p>
                        </div>
                    </div>
                    
                    <div id="angularPatternControls" style="display:none;">
                        <div style="background:var(--bg3); padding:20px; border-radius:8px; margin:15px 0;">
                            <h3 style="color:var(--blue); margin-bottom:15px;">Angular Distribution</h3>
                            <p style="margin-bottom:15px;">How are primitive points distributed by angle around the origin?</p>
                            
                            <label>Number of Sectors: <span id="numSectorsv">16</span></label>
                            <input type="range" id="numSectors" min="4" max="32" value="16" step="1" oninput="updatePatternViz()">
                            
                            <label style="margin-top:15px;">Radius: <span id="angularRv">40</span></label>
                            <input type="range" id="angularR" min="10" max="100" value="40" step="5" oninput="updatePatternViz()">
                        </div>
                        
                        <button onclick="updatePatternViz()" style="padding:12px 24px; margin:10px 0;">Analyze Angular Distribution</button>
                        
                        <canvas id="angularCanvas" width="1000" height="600" style="max-width:100%;"></canvas>
                        
                        <div class="formula" style="margin-top:20px;">
                            <p><b>Expected Result:</b> For large R, angular distribution should be approximately uniform, with each sector containing roughly (total primitive points) / (number of sectors).</p>
                        </div>
                    </div>
                    
                    <div id="radialPatternControls" style="display:none;">
                        <div style="background:var(--bg3); padding:20px; border-radius:8px; margin:15px 0;">
                            <h3 style="color:var(--blue); margin-bottom:15px;">Radial Shell Analysis</h3>
                            <p style="margin-bottom:15px;">Count primitive points in concentric shells to observe growth patterns.</p>
                            
                            <label>Shell Thickness: <span id="shellThickv">2</span></label>
                            <input type="range" id="shellThick" min="1" max="10" value="2" step="1" oninput="updatePatternViz()">
                            
                            <label style="margin-top:15px;">Maximum Radius: <span id="radialMaxRv">60</span></label>
                            <input type="range" id="radialMaxR" min="20" max="100" value="60" step="5" oninput="updatePatternViz()">
                        </div>
                        
                        <button onclick="updatePatternViz()" style="padding:12px 24px; margin:10px 0;">Compute Radial Distribution</button>
                        
                        <canvas id="radialCanvas" width="1000" height="600" style="max-width:100%;"></canvas>
                        
                        <div class="formula" style="margin-top:20px;">
                            <p><b>Growth Pattern:</b> The number of primitive points in shell [r, r+Δr] grows approximately as 2πrΔr/ζ(2), reflecting the density theorem.</p>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div id="gcdheatmap" class="panel">
            <div class="section">
                <h2>Interactive GCD Heatmap <span class="help-icon tooltip" data-tip="Click on points to see details">?</span></h2>
                <p>Explore GCD patterns in the lattice. Click on any point to see detailed information about its coordinates and GCD value.</p>
                
                <div class="controls">
                    <div style="margin-bottom:10px;">
                        <label><b>Presets:</b></label>
                        <div style="display:flex; gap:8px; flex-wrap:wrap; margin-top:5px;">
                            <button onclick="setGCDHeatmapPreset('small')" style="padding:6px 12px; font-size:0.9em;">Small (R=15)</button>
                            <button onclick="setGCDHeatmapPreset('medium')" style="padding:6px 12px; font-size:0.9em;">Medium (R=30)</button>
                            <button onclick="setGCDHeatmapPreset('large')" style="padding:6px 12px; font-size:0.9em;">Large (R=50)</button>
                        </div>
                    </div>
                    
                    <label>Radius: <span id="heatmapRv">25</span></label>
                    <div style="display:flex; gap:10px; align-items:center; margin-bottom:15px;">
                        <input type="range" id="heatmapR" min="5" max="100" value="25" step="1" oninput="updateHeatmapR()" style="flex:1;">
                        <input type="number" id="heatmapRinput" min="5" max="1000" value="25" style="width:100px; padding:8px;" oninput="updateHeatmapR()">
                    </div>
                    
                    <div style="background:var(--bg3); padding:15px; border-radius:8px; margin-bottom:15px;">
                        <label style="font-size:1.1em; color:var(--blue); margin-bottom:10px; display:block;"><b>Display Mode:</b></label>
                        <div style="display:grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap:8px;">
                            <button id="heatmapGCD" class="active" onclick="setHeatmapMode('gcd')" style="padding:10px;">By GCD Value</button>
                            <button id="heatmapPrimitive" onclick="setHeatmapMode('primitive')" style="padding:10px;">Primitive Only</button>
                            <button id="heatmapGradient" onclick="setHeatmapMode('gradient')" style="padding:10px;">Distance Gradient</button>
                        </div>
                    </div>
                    
                    <div style="background:var(--bg3); padding:15px; border-radius:8px; margin-bottom:15px;">
                        <label style="font-size:1.1em; color:var(--blue); margin-bottom:10px; display:block;"><b>Filter Options:</b></label>
                        <label style="display:flex; align-items:center; gap:8px; margin:8px 0;">
                            <input type="checkbox" id="filterGCD1" checked onchange="updateGCDHeatmap()"> Show GCD = 1 (Primitive)
                        </label>
                        <label style="display:flex; align-items:center; gap:8px; margin:8px 0;">
                            <input type="checkbox" id="filterGCD2" checked onchange="updateGCDHeatmap()"> Show GCD = 2
                        </label>
                        <label style="display:flex; align-items:center; gap:8px; margin:8px 0;">
                            <input type="checkbox" id="filterGCD3" checked onchange="updateGCDHeatmap()"> Show GCD = 3
                        </label>
                        <label style="display:flex; align-items:center; gap:8px; margin:8px 0;">
                            <input type="checkbox" id="filterGCDOther" checked onchange="updateGCDHeatmap()"> Show GCD > 3
                        </label>
                    </div>
                    
                    <label>Point Size: <span id="heatmapPSv">4</span></label>
                    <input type="range" id="heatmapPS" min="2" max="10" value="4" oninput="updateGCDHeatmap()">
                    
                    <div style="margin-top:15px;">
                        <button onclick="updateGCDHeatmap()">Refresh Heatmap</button>
                        <button onclick="exportCanvas('heatmapCanvas', 'gcd-heatmap')">Export Image</button>
                        <button onclick="exportHeatmapData()">Export Data</button>
                    </div>
                </div>
                
                <canvas id="heatmapCanvas" width="1200" height="1200" style="max-width:100%; cursor:crosshair;"></canvas>
                
                <div id="pointInfo" style="background:var(--bg3); padding:20px; border-radius:8px; margin-top:20px; min-height:100px;">
                    <p style="color:var(--text2); font-style:italic;">Click on a point to see details</p>
                </div>
                
                <div class="stats">
                    <div class="stat"><div class="val" id="heatmapTotal">0</div><div class="lbl">Total Points</div></div>
                    <div class="stat"><div class="val" id="heatmapPrim">0</div><div class="lbl">Primitive (GCD=1)</div></div>
                    <div class="stat"><div class="val" id="heatmapGCD2">0</div><div class="lbl">GCD = 2</div></div>
                    <div class="stat"><div class="val" id="heatmapGCD3">0</div><div class="lbl">GCD = 3</div></div>
                    <div class="stat"><div class="val" id="heatmapGCDOther">0</div><div class="lbl">GCD > 3</div></div>
                </div>
                
                <div class="formula" style="margin-top:20px;">
                    <p><b>GCD Patterns:</b></p>
                    <p>• Points with GCD = d form a scaled copy of the primitive lattice, scaled by factor d</p>
                    <p>• The number of points with GCD = d in radius R is approximately N₁(R/d) where N₁ is the primitive count</p>
                    <p>• GCD values reveal the arithmetic structure of the lattice - patterns repeat at each GCD level</p>
                </div>
            </div>
        </div>

        <div id="gcdtable" class="panel">
            <div class="section">
                <h2>GCD Multiplication Table <span class="help-icon tooltip" data-tip="Interactive GCD grid visualization">?</span></h2>
                <p>Explore GCD patterns in a multiplication table format. Each cell shows gcd(row, column) with color-coding by value.</p>
                
                <div class="controls">
                    <div style="margin-bottom:10px;">
                        <label><b>Presets:</b></label>
                        <div style="display:flex; gap:8px; flex-wrap:wrap; margin-top:5px;">
                            <button onclick="setGCDTablePreset('small')" style="padding:6px 12px; font-size:0.9em;">Small (20×20)</button>
                            <button onclick="setGCDTablePreset('medium')" style="padding:6px 12px; font-size:0.9em;">Medium (50×50)</button>
                            <button onclick="setGCDTablePreset('large')" style="padding:6px 12px; font-size:0.9em;">Large (100×100)</button>
                        </div>
                    </div>
                    
                    <label>Grid Size: <span id="gcdTableSizev">30</span></label>
                    <div style="display:flex; gap:10px; align-items:center; margin-bottom:15px;">
                        <input type="range" id="gcdTableSize" min="5" max="150" value="30" step="1" oninput="updateGCDTable()" style="flex:1;">
                        <input type="number" id="gcdTableSizeInput" min="5" max="200" value="30" style="width:100px; padding:8px;" oninput="updateGCDTable()">
                    </div>
                    
                    <div style="background:var(--bg3); padding:15px; border-radius:8px; margin-bottom:15px;">
                        <label style="font-size:1.1em; color:var(--blue); margin-bottom:10px; display:block;"><b>Color Scheme:</b></label>
                        <div style="display:grid; grid-template-columns: repeat(auto-fit, minmax(140px, 1fr)); gap:8px;">
                            <button id="gcdTableHeat" class="active" onclick="setGCDTableColor('heat')" style="padding:10px;">Heat Map</button>
                            <button id="gcdTableDiscrete" onclick="setGCDTableColor('discrete')" style="padding:10px;">Discrete GCD</button>
                            <button id="gcdTablePrime" onclick="setGCDTableColor('prime')" style="padding:10px;">Prime Powers</button>
                        </div>
                    </div>
                    
                    <label style="display:flex; align-items:center; gap:8px; margin:10px 0;">
                        <input type="checkbox" id="showGCDValues" checked onchange="updateGCDTable()"> Show GCD Values
                    </label>
                    
                    <label style="display:flex; align-items:center; gap:8px; margin:10px 0;">
                        <input type="checkbox" id="highlightDiagonal" checked onchange="updateGCDTable()"> Highlight Diagonal
                    </label>
                    
                    <div style="margin-top:15px;">
                        <button onclick="updateGCDTable()">Refresh Table</button>
                        <button onclick="exportCanvas('gcdTableCanvas', 'gcd-table')">Export Image</button>
                        <button onclick="exportGCDTableData()">Export Data</button>
                    </div>
                </div>
                
                <canvas id="gcdTableCanvas" width="1200" height="1200" style="max-width:100%; cursor:crosshair;"></canvas>
                
                <div id="gcdTableInfo" style="background:var(--bg3); padding:20px; border-radius:8px; margin-top:20px; min-height:100px;">
                    <p style="color:var(--text2); font-style:italic;">Click on a cell to see GCD(row, col) details</p>
                </div>
                
                <div class="formula" style="margin-top:20px;">
                    <p><b>Patterns to Observe:</b></p>
                    <p>• Diagonal elements: gcd(n, n) = n (perfect squares in intensity)</p>
                    <p>• Symmetry: gcd(a, b) = gcd(b, a) - table is symmetric</p>
                    <p>• Rows/columns of primes: mostly 1s except at multiples</p>
                    <p>• Coprimality appears as value 1 (darkest cells in heat map)</p>
                    <p>• Patterns reveal divisibility relationships at a glance</p>
                </div>
            </div>
        </div>

        <div id="criticalstrip" class="panel">
            <div class="section">
                <h2>Critical Strip & Error Analysis <span class="help-icon tooltip" data-tip="Gauss Circle Problem & RH Connection">?</span></h2>
                <p>Analyzes the error term Δ(R) from the Gauss Circle Problem and its connection to the Riemann Hypothesis. The growth rate of |Δ(R)| is deeply connected to the distribution of zeros of the Riemann zeta function.</p>
                
                <div class="controls">
                    <div style="background:var(--bg3); padding:15px; border-radius:8px; margin-bottom:15px;">
                        <label style="font-size:1.1em; color:var(--blue); margin-bottom:10px; display:block;"><b>Problem Type:</b></label>
                        <div style="display:flex; gap:10px; flex-wrap:wrap;">
                            <button id="criticalAllPoints" class="active" onclick="setCriticalProblem('all')" style="flex:1; min-width:150px; padding:12px;">Gauss Circle (All Points)</button>
                            <button id="criticalPrimitive" onclick="setCriticalProblem('primitive')" style="flex:1; min-width:150px; padding:12px;">Primitive Points Only</button>
                        </div>
                    </div>
                    
                    <div style="background:var(--bg3); padding:15px; border-radius:8px; margin-bottom:15px;">
                        <label style="font-size:1.1em; color:var(--blue); margin-bottom:10px; display:block;"><b>Visualization Type:</b></label>
                        <div style="display:grid; grid-template-columns: repeat(auto-fit, minmax(160px, 1fr)); gap:8px;">
                            <button id="criticalVizError" class="active" onclick="setCriticalViz('error')" style="padding:10px;">Error vs Radius</button>
                            <button id="criticalVizNormalized" onclick="setCriticalViz('normalized')" style="padding:10px;">Δ(R)/R^(1/2)</button>
                            <button id="criticalVizLog" onclick="setCriticalViz('loglog')" style="padding:10px;">Log-Log Plot</button>
                            <button id="criticalVizBounds" onclick="setCriticalViz('bounds')" style="padding:10px;">With Bounds</button>
                        </div>
                    </div>
                    
                    <div style="margin-bottom:10px;">
                        <label><b>Presets:</b></label>
                        <div style="display:flex; gap:8px; flex-wrap:wrap; margin-top:5px;">
                            <button onclick="setCriticalStripPreset('standard')" style="padding:6px 12px; font-size:0.9em;">Standard (R≤100)</button>
                            <button onclick="setCriticalStripPreset('detailed')" style="padding:6px 12px; font-size:0.9em;">Detailed (R≤200)</button>
                            <button onclick="setCriticalStripPreset('extended')" style="padding:6px 12px; font-size:0.9em;">Extended (R≤300)</button>
                        </div>
                    </div>
                    
                    <label>Max Radius: <span id="criticalMaxRv">100</span></label>
                    <div style="display:flex; gap:10px; align-items:center; margin-bottom:15px;">
                        <input type="range" id="criticalMaxR" min="20" max="500" value="100" step="10" oninput="updateCriticalMaxR()" style="flex:1;">
                        <input type="number" id="criticalMaxRinput" min="20" max="1000" value="100" step="10" style="width:100px; padding:8px;" oninput="updateCriticalMaxR()">
                    </div>
                    
                    <label>Step Size: <span id="criticalStepv">1</span></label>
                    <div style="display:flex; gap:10px; align-items:center; margin-bottom:15px;">
                        <input type="range" id="criticalStep" min="1" max="10" value="1" step="1" oninput="updateCriticalStep()" style="flex:1;">
                        <input type="number" id="criticalStepInput" min="1" max="20" value="1" style="width:100px; padding:8px;" oninput="updateCriticalStep()">
                    </div>
                    
                    <div style="background:var(--bg3); padding:15px; border-radius:8px; margin:15px 0;">
                        <label style="font-size:1.1em; color:var(--blue); margin-bottom:10px; display:block;"><b>Display Options:</b></label>
                        <label style="display:flex; align-items:center; gap:8px; margin:8px 0;">
                            <input type="checkbox" id="showZeroLine" checked onchange="updateCriticalStrip()"> Show Zero Line
                        </label>
                        <label style="display:flex; align-items:center; gap:8px; margin:8px 0;">
                            <input type="checkbox" id="showRHBound" checked onchange="updateCriticalStrip()"> Show RH Bound (R^(1/2))
                        </label>
                        <label style="display:flex; align-items:center; gap:8px; margin:8px 0;">
                            <input type="checkbox" id="showClassicalBound" onchange="updateCriticalStrip()"> Show Classical Bound (R^(2/3))
                        </label>
                        <label style="display:flex; align-items:center; gap:8px; margin:8px 0;">
                            <input type="checkbox" id="colorBySign" checked onchange="updateCriticalStrip()"> Color by Error Sign
                        </label>
                    </div>
                    
                    <div style="margin-top:15px;">
                        <button onclick="updateCriticalStrip()">Compute Analysis</button>
                        <button onclick="exportCanvas('criticalCanvas', 'critical-strip')">Export Image</button>
                        <button onclick="exportCriticalData()">Export Data</button>
                    </div>
                </div>
                
                <div class="loading" id="loadCritical"><div class="spinner"></div><p>Computing error analysis...</p></div>
                
                <canvas id="criticalCanvas" width="1400" height="1000" style="max-width:100%; cursor:crosshair;"></canvas>
                
                <div id="criticalPointInfo" style="background:var(--bg3); padding:20px; border-radius:8px; margin-top:20px; min-height:100px;">
                    <p style="color:var(--text2); font-style:italic;">Click on a point to see detailed error information</p>
                </div>
                
                <div class="stats">
                    <div class="stat"><div class="val" id="criticalPoints">0</div><div class="lbl">Data Points</div></div>
                    <div class="stat"><div class="val" id="criticalMaxErr">0</div><div class="lbl">Max |Δ(R)|</div></div>
                    <div class="stat"><div class="val" id="criticalAvgErr">0</div><div class="lbl">Avg |Δ(R)|</div></div>
                    <div class="stat"><div class="val" id="criticalRMSErr">0</div><div class="lbl">RMS Error</div></div>
                    <div class="stat"><div class="val" id="criticalMaxNorm">0</div><div class="lbl">Max |Δ(R)/R^(1/2)|</div></div>
                </div>
                
                <div class="formula" style="margin-top:20px;">
                    <p><b>Gauss Circle Problem:</b></p>
                    <p>Let N(R) = |{(x,y) ∈ ℤ² : x² + y² ≤ R²}| be the number of lattice points in a circle of radius R.</p>
                    <p style="margin-top:10px;">We have N(R) = πR² + Δ(R), where Δ(R) is the error term.</p>
                    
                    <p style="margin-top:15px;"><b>Connection to Riemann Hypothesis:</b></p>
                    <p>• <b>Known:</b> |Δ(R)| = O(R^(2/3)) (classical result by van der Corput, 1923)</p>
                    <p>• <b>Conjectured (Hardy, 1915):</b> |Δ(R)| = O(R^(1/2 + ε)) for any ε > 0</p>
                    <p>• <b>If RH is true:</b> This bound is expected to hold, though not yet proven</p>
                    <p>• <b>Lower bound:</b> |Δ(R)| = Ω(R^(1/4)) (Sierpiński, 1906)</p>
                    
                    <p style="margin-top:15px;"><b>For Primitive Points:</b></p>
                    <p>N_prim(R) = πR²/ζ(2) + Δ_prim(R), with similar error behavior scaled by 1/ζ(2) ≈ 0.608</p>
                    
                    <p style="margin-top:15px;"><b>Key Observations:</b></p>
                    <p>• The error oscillates around zero with increasing amplitude</p>
                    <p>• Normalized error Δ(R)/R^(1/2) should be bounded if RH is true</p>
                    <p>• The oscillation frequency relates to the imaginary parts of zeta zeros</p>
                </div>
            </div>
        </div>

        <div id="viz2d" class="panel">
            <div class="section">
                <h2>2D Lattice Visualization <span class="help-icon tooltip" data-tip="Explore primitive lattice points">?</span></h2>
                <div class="controls">
                    <div style="background: var(--bg3); padding: 15px; border-radius: 8px; margin-bottom: 15px;">
                        <label style="font-size: 1.1em; color: var(--blue); margin-bottom: 10px; display: block;"><b>View Mode:</b></label>
                        <div style="display:flex; gap:10px; flex-wrap:wrap;">
                            <button id="viewPrimitive" class="active" onclick="set2DView('primitive')" style="flex:1; min-width:150px; padding: 12px;">Colored by Mode</button>
                            <button id="viewGauss" onclick="set2DView('gauss')" style="flex:1; min-width:150px; padding: 12px;">Circle Problem (All Points)</button>
                        </div>
                    </div>
                    
                    <div style="background: var(--bg3); padding: 15px; border-radius: 8px; margin-bottom: 15px;">
                        <label style="font-size: 1.1em; color: var(--blue); margin-bottom: 10px; display: block;"><b>Coloring Mode:</b></label>
                        <div style="display:grid; grid-template-columns: repeat(auto-fit, minmax(160px, 1fr)); gap:8px;">
                            <button id="color2DPrimitive" class="active" onclick="set2DColorMode('primitive')" style="padding:10px 12px; font-size:0.85em;">GCD=1 vs GCD>1</button>
                            <button id="color2DGCD" onclick="set2DColorMode('gcd')" style="padding:10px 12px; font-size:0.85em;">By GCD Value</button>
                            <button id="color2DMod" onclick="set2DColorMode('mod')" style="padding:10px 12px; font-size:0.85em;">By Mod m</button>
                            <button id="color2DQuadrant" onclick="set2DColorMode('quadrant')" style="padding:10px 12px; font-size:0.85em;">By Quadrant</button>
                            <button id="color2DAngular" onclick="set2DColorMode('angular')" style="padding:10px 12px; font-size:0.85em;">By Angular Sector</button>
                            <button id="color2DGCDQuad" onclick="set2DColorMode('gcdquad')" style="padding:10px 12px; font-size:0.85em;">GCD × Quadrant</button>
                            <button id="color2DGCDMod" onclick="set2DColorMode('gcdmod')" style="padding:10px 12px; font-size:0.85em;">GCD × Mod</button>
                        </div>
                        <div id="modControls2D" style="display:none; margin-top:10px;">
                            <label>Modulus m: <span id="mod2Dv">3</span></label>
                            <input type="range" id="mod2D" min="2" max="12" value="3" step="1" oninput="document.getElementById('mod2Dv').textContent=this.value; draw2D()">
                        </div>
                        <div id="sectorControls2D" style="display:none; margin-top:10px;">
                            <label>Angular Sectors: <span id="sectors2Dv">8</span></label>
                            <input type="range" id="sectors2D" min="4" max="16" value="8" step="1" oninput="document.getElementById('sectors2Dv').textContent=this.value; draw2D()">
                        </div>
                    </div>
                    <div style="margin-bottom:10px;">
                        <label><b>Presets:</b></label>
                        <div style="display:flex; gap:8px; flex-wrap:wrap; margin-top:5px;">
                            <button onclick="set2DPreset('small')" style="padding:6px 12px; font-size:0.9em;">Small (R=10)</button>
                            <button onclick="set2DPreset('medium')" style="padding:6px 12px; font-size:0.9em;">Medium (R=50)</button>
                            <button onclick="set2DPreset('large')" style="padding:6px 12px; font-size:0.9em;">Large (R=100)</button>
                            <button onclick="set2DPreset('xlarge')" style="padding:6px 12px; font-size:0.9em;">X-Large (R=200)</button>
                        </div>
                    </div>
                    <label>Radius: <span id="r2v">20</span></label>
                    <div style="display:flex; gap:10px; align-items:center; margin-bottom:10px;">
                        <input type="range" id="r2" min="1" max="500" value="20" step="1" oninput="update2DRadius(this.value)" style="flex:1;">
                        <input type="number" id="r2input" min="1" max="2000" value="20" style="width:100px; padding:8px;" oninput="update2DRadius(this.value)">
                    </div>
                    
                    <label>Canvas Zoom: <span id="zoom2Dv">100</span>%</label>
                    <input type="range" id="zoom2D" min="50" max="200" value="100" step="5" oninput="update2DZoom()">
                    
                    <label>Point Size: <span id="psv">3</span></label>
                    <input type="range" id="ps" min="1" max="20" value="3" oninput="draw2D()">
                    
                    <div style="background: var(--bg3); padding: 15px; border-radius: 8px; margin: 15px 0;">
                        <label style="font-size: 1.1em; color: var(--blue); margin-bottom: 10px; display: block;"><b>Point Labels:</b></label>
                        <div style="display:grid; grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); gap:8px; margin-bottom:10px;">
                            <button id="label2DNone" class="active" onclick="set2DLabelMode('none')" style="padding:8px; font-size:0.85em;">No Labels</button>
                            <button id="label2DGCD" onclick="set2DLabelMode('gcd')" style="padding:8px; font-size:0.85em;">By GCD</button>
                            <button id="label2DCoords" onclick="set2DLabelMode('coords')" style="padding:8px; font-size:0.85em;">Coordinates</button>
                            <button id="label2DAngle" onclick="set2DLabelMode('angle')" style="padding:8px; font-size:0.85em;">By Angle</button>
                        </div>
                        <div id="labelControls2D" style="display:none;">
                            <label>Label Font Size: <span id="labelSize2Dv">8</span>px</label>
                            <input type="range" id="labelSize2D" min="6" max="16" value="8" step="1" oninput="draw2D()">
                            <label style="margin-top:10px;">Max Points to Label: <span id="maxLabels2Dv">50</span></label>
                            <input type="range" id="maxLabels2D" min="10" max="500" value="50" step="10" oninput="draw2D()">
                            <p style="font-size:0.85em; color:var(--text2); margin-top:8px;">Labels shown for points closest to origin</p>
                        </div>
                    </div>
                    
                    <button onclick="exportCanvas('c2d', '2d-lattice')">Export Image</button>
                    <button onclick="exportPointData2D()">Export Points</button>
                </div>
                <div class="warning" id="warn2d" style="display:none;">
                    ⚠️ Large radius values may slow performance. Consider using R ≤ 200 for smooth rendering.
                </div>
                <div class="loading" id="load2d"><div class="spinner"></div><p>Computing lattice points...</p></div>
                <canvas id="c2d" width="800" height="800"></canvas>
                <div class="stats">
                    <div class="stat"><div class="val" id="p2">0</div><div class="lbl">Primitive Points</div></div>
                    <div class="stat"><div class="val" id="t2">0</div><div class="lbl">Total Points</div></div>
                    <div class="stat"><div class="val" id="d2">0%</div><div class="lbl">Density</div></div>
                    <div class="stat"><div class="val" id="e2">0</div><div class="lbl">|Predicted - Actual|</div></div>
                </div>
            </div>
        </div>

        <div id="viz3d" class="panel">
            <div class="section">
                <h2>3D Lattice Visualization <span class="help-icon tooltip" data-tip="Click and drag to rotate">?</span></h2>
                <div class="controls">
                    <div style="background: var(--bg3); padding: 15px; border-radius: 8px; margin-bottom: 15px;">
                        <label style="font-size: 1.1em; color: var(--blue); margin-bottom: 10px; display: block;"><b>Boundary Shape:</b></label>
                        <div style="display:flex; gap:10px; flex-wrap:wrap;">
                            <button id="shape3DSphere" class="active" onclick="set3DShape('sphere')" style="flex:1; min-width:120px; padding: 12px;">Sphere (x²+y²+z² ≤ R²)</button>
                            <button id="shape3DCube" onclick="set3DShape('cube')" style="flex:1; min-width:120px; padding: 12px;">Cube (|x|,|y|,|z| ≤ R)</button>
                        </div>
                    </div>
                    
                    <div style="background: var(--bg3); padding: 15px; border-radius: 8px; margin-bottom: 15px;">
                        <label style="font-size: 1.1em; color: var(--blue); margin-bottom: 10px; display: block;"><b>Coloring Mode:</b></label>
                        <div style="display:grid; grid-template-columns: repeat(auto-fit, minmax(160px, 1fr)); gap:8px;">
                            <button id="colorPrimitive" class="active" onclick="set3DColorMode('primitive')" style="padding:10px 12px; font-size:0.85em;">GCD=1 vs GCD>1</button>
                            <button id="colorGCD" onclick="set3DColorMode('gcd')" style="padding:10px 12px; font-size:0.85em;">By GCD Value</button>
                            <button id="colorMod" onclick="set3DColorMode('mod')" style="padding:10px 12px; font-size:0.85em;">By Mod m</button>
                            <button id="colorOctant" onclick="set3DColorMode('octant')" style="padding:10px 12px; font-size:0.85em;">By Octant</button>
                            <button id="colorDistance" onclick="set3DColorMode('distance')" style="padding:10px 12px; font-size:0.85em;">By Distance</button>
                            <button id="colorGCDOct" onclick="set3DColorMode('gcdoct')" style="padding:10px 12px; font-size:0.85em;">GCD × Octant</button>
                            <button id="colorGCDMod" onclick="set3DColorMode('gcdmod')" style="padding:10px 12px; font-size:0.85em;">GCD × Mod</button>
                        </div>
                        <div id="modControls3D" style="display:none; margin-top:10px;">
                            <label>Modulus m: <span id="mod3Dv">3</span></label>
                            <input type="range" id="mod3D" min="2" max="12" value="3" step="1" oninput="document.getElementById('mod3Dv').textContent=this.value; draw3D()">
                        </div>
                    </div>
                    
                    <div style="margin-bottom:10px;">
                        <label><b>Presets:</b></label>
                        <div style="display:flex; gap:8px; flex-wrap:wrap; margin-top:5px;">
                            <button onclick="set3DPreset('tiny')" style="padding:6px 12px; font-size:0.9em;">Tiny (R=5)</button>
                            <button onclick="set3DPreset('small')" style="padding:6px 12px; font-size:0.9em;">Small (R=10)</button>
                            <button onclick="set3DPreset('medium')" style="padding:6px 12px; font-size:0.9em;">Medium (R=20)</button>
                            <button onclick="set3DPreset('large')" style="padding:6px 12px; font-size:0.9em;">Large (R=30)</button>
                        </div>
                    </div>
                    <label>Radius: <span id="r3v">10</span></label>
                    <input type="range" id="r3" min="1" max="40" value="10" step="1" oninput="draw3D()">
                    
                    <label>Point Size: <span id="ps3v">0.6</span></label>
                    <input type="range" id="ps3" min="0.2" max="2.0" value="0.6" step="0.1" oninput="draw3D()">
                    
                    <label>Camera Distance (Zoom): <span id="zoom3Dv">86</span></label>
                    <input type="range" id="zoom3D" min="30" max="150" value="86" step="1" oninput="update3DZoom()">
                    
                    <div style="background: var(--bg3); padding: 15px; border-radius: 8px; margin: 15px 0;">
                        <label style="font-size: 1.1em; color: var(--blue); margin-bottom: 10px; display: block;"><b>Point Labels:</b></label>
                        <div style="display:grid; grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); gap:8px; margin-bottom:10px;">
                            <button id="label3DNone" class="active" onclick="set3DLabelMode('none')" style="padding:8px; font-size:0.85em;">No Labels</button>
                            <button id="label3DGCD" onclick="set3DLabelMode('gcd')" style="padding:8px; font-size:0.85em;">By GCD</button>
                            <button id="label3DCoords" onclick="set3DLabelMode('coords')" style="padding:8px; font-size:0.85em;">Coordinates</button>
                        </div>
                        <div id="labelControls3D" style="display:none;">
                            <label>Max Points to Label: <span id="maxLabels3Dv">30</span></label>
                            <input type="range" id="maxLabels3D" min="10" max="200" value="30" step="10" oninput="draw3D()">
                            <p style="font-size:0.85em; color:var(--text2); margin-top:8px;">Labels shown for points closest to origin</p>
                        </div>
                    </div>
                    
                    <button onclick="reset3D()">Reset View</button>
                    <button onclick="toggleRotation()">Auto-Rotate</button>
                    <button onclick="export3DData()">Export Points</button>
                </div>
                <div class="warning" id="warn3d" style="display:none;">
                    ⚠️ Radius > 30 generates many points and may impact performance.
                </div>
                <div class="loading" id="load3d"><div class="spinner"></div><p>Generating 3D lattice...</p></div>
                <div id="c3d"></div>
                <div class="stats">
                    <div class="stat"><div class="val" id="p3">0</div><div class="lbl">Primitive Points</div></div>
                    <div class="stat"><div class="val" id="t3">0</div><div class="lbl">Total Points</div></div>
                    <div class="stat"><div class="val" id="d3">0%</div><div class="lbl">Density</div></div>
                    <div class="stat"><div class="val" id="e3">0</div><div class="lbl">Error</div></div>
                </div>
            </div>
        </div>

        <div id="comparison" class="panel">
            <div class="section">
                <h2>Dimension Comparison <span class="help-icon tooltip" data-tip="Compare different dimensions">?</span></h2>
                <p>Compare how primitive lattice point counts change across dimensions for a fixed radius, or analyze how different radii affect each dimension.</p>
                
                <div class="controls">
                    <label>Comparison Mode:</label>
                    <div style="display:flex; gap:10px; margin-bottom:15px; flex-wrap:wrap;">
                        <button id="modeFixed" class="active" onclick="setComparisonMode('fixed')" style="flex:1; min-width:150px;">Fixed Radius</button>
                        <button id="modeMulti" onclick="setComparisonMode('multi')" style="flex:1; min-width:150px;">Multiple Radii</button>
                    </div>
                    
                    <div style="margin-bottom:10px;">
                        <label><b>Presets:</b></label>
                        <div style="display:flex; gap:8px; flex-wrap:wrap; margin-top:5px;">
                            <button onclick="setComparisonPreset('low')" style="padding:6px 12px; font-size:0.9em;">Low Dimensions (2-4)</button>
                            <button onclick="setComparisonPreset('mid')" style="padding:6px 12px; font-size:0.9em;">Mid Dimensions (3-6)</button>
                            <button onclick="setComparisonPreset('high')" style="padding:6px 12px; font-size:0.9em;">High Dimensions (5-10)</button>
                            <button onclick="setComparisonPreset('all')" style="padding:6px 12px; font-size:0.9em;">All Dimensions (2-10)</button>
                            <button onclick="setComparisonPreset('growth')" style="padding:6px 12px; font-size:0.9em;">Growth Analysis</button>
                        </div>
                    </div>
                    
                    <div id="fixedRadiusControls">
                        <label>Radius: <span id="crv">15</span></label>
                        <div style="display:flex; gap:10px; align-items:center; margin-bottom:15px;">
                            <input type="range" id="cr" min="1" max="100" value="15" step="1" oninput="updateComparisonRadius(this.value)" style="flex:1;">
                            <input type="number" id="crinput" min="1" max="200" value="15" style="width:100px; padding:8px;" oninput="updateComparisonRadius(this.value)">
                        </div>
                    </div>
                    
                    <div id="multiRadiusControls" style="display:none;">
                        <label>Radii to compare (comma-separated): </label>
                        <input type="text" id="multiRadii" value="10, 20, 30, 40, 50" style="width:100%; padding:10px; margin-bottom:15px;" oninput="updateComparison()">
                    </div>
                    
                    <div style="margin-bottom:15px;">
                        <p><b>Dimensions to compare:</b></p>
                        <div style="display:grid; grid-template-columns: repeat(auto-fit, minmax(80px, 1fr)); gap:10px; margin-top:10px;">
                            <label style="display:flex; align-items:center; gap:8px;">
                                <input type="checkbox" id="compk2" checked onchange="updateComparison()"> k=2
                            </label>
                            <label style="display:flex; align-items:center; gap:8px;">
                                <input type="checkbox" id="compk3" checked onchange="updateComparison()"> k=3
                            </label>
                            <label style="display:flex; align-items:center; gap:8px;">
                                <input type="checkbox" id="compk4" checked onchange="updateComparison()"> k=4
                            </label>
                            <label style="display:flex; align-items:center; gap:8px;">
                                <input type="checkbox" id="compk5" checked onchange="updateComparison()"> k=5
                            </label>
                            <label style="display:flex; align-items:center; gap:8px;">
                                <input type="checkbox" id="compk6" checked onchange="updateComparison()"> k=6
                            </label>
                            <label style="display:flex; align-items:center; gap:8px;">
                                <input type="checkbox" id="compk7" onchange="updateComparison()"> k=7
                            </label>
                            <label style="display:flex; align-items:center; gap:8px;">
                                <input type="checkbox" id="compk8" onchange="updateComparison()"> k=8
                            </label>
                            <label style="display:flex; align-items:center; gap:8px;">
                                <input type="checkbox" id="compk9" onchange="updateComparison()"> k=9
                            </label>
                            <label style="display:flex; align-items:center; gap:8px;">
                                <input type="checkbox" id="compk10" onchange="updateComparison()"> k=10
                            </label>
                        </div>
                    </div>
                    
                    <div style="margin-bottom:15px;">
                        <p><b>Display options:</b></p>
                        <label style="display:flex; align-items:center; gap:8px; margin:8px 0;">
                            <input type="checkbox" id="showDensity" checked onchange="updateComparison()"> Show Density (1/ζ(k))
                        </label>
                        <label style="display:flex; align-items:center; gap:8px; margin:8px 0;">
                            <input type="checkbox" id="showVolume" checked onchange="updateComparison()"> Show Sphere Volume
                        </label>
                        <label style="display:flex; align-items:center; gap:8px; margin:8px 0;">
                            <input type="checkbox" id="showZeta" checked onchange="updateComparison()"> Show ζ(k) Values
                        </label>
                        <label style="display:flex; align-items:center; gap:8px; margin:8px 0;">
                            <input type="checkbox" id="showChart" checked onchange="updateComparison()"> Show Comparison Chart
                        </label>
                    </div>
                    
                    <button onclick="updateComparison()">Refresh Comparison</button>
                    <button onclick="exportComparisonData()">Export Data</button>
                    <button onclick="exportComparisonChart()">Export Chart</button>
                </div>
                
                <div class="compare-grid" id="compGrid"></div>
                
                <div id="comparisonChart" style="margin-top:30px;">
                    <canvas id="compChart" width="800" height="400"></canvas>
                </div>
                
                <div class="formula" style="margin-top:20px;">
                    <p><b>Key Observations:</b></p>
                    <p>• As dimension k increases, ζ(k) approaches 1, meaning the density 1/ζ(k) approaches 100%</p>
                    <p>• Higher dimensions have exponentially more lattice points (grows as R^k)</p>
                    <p>• The ratio of primitive to total points stabilizes at 1/ζ(k) for each dimension</p>
                    <p>• Sphere volume grows dramatically with dimension, following the gamma function pattern</p>
                </div>
            </div>
        </div>

        <div id="analysis" class="panel">
            <div class="section">
                <h2>Error Analysis <span class="help-icon tooltip" data-tip="Study O(R^(k-1)) error term">?</span></h2>
                <p>Visualization of the error term Δ(R) for different dimensions. The chart shows absolute and relative errors for each radius value.</p>
                <div class="controls">
                    <div style="margin-bottom:10px;">
                        <label><b>Presets:</b></label>
                        <div style="display:flex; gap:8px; flex-wrap:wrap; margin-top:5px;">
                            <button onclick="setAnalysisPreset('quick')" style="padding:6px 12px; font-size:0.9em;">Quick (R≤50)</button>
                            <button onclick="setAnalysisPreset('standard')" style="padding:6px 12px; font-size:0.9em;">Standard (R≤100)</button>
                            <button onclick="setAnalysisPreset('detailed')" style="padding:6px 12px; font-size:0.9em;">Detailed (R≤150)</button>
                            <button onclick="setAnalysisPreset('absolute')" style="padding:6px 12px; font-size:0.9em;">Absolute Only</button>
                            <button onclick="setAnalysisPreset('relative')" style="padding:6px 12px; font-size:0.9em;">Relative Only</button>
                            <button onclick="setAnalysisPreset('boundary')" style="padding:6px 12px; font-size:0.9em;">Boundary Only</button>
                        </div>
                    </div>
                    
                    <label>Dimension k: <span id="analysisKv">2</span></label>
                    <input type="range" id="analysisK" min="2" max="5" value="2" step="1" oninput="document.getElementById('analysisKv').textContent=this.value">
                    
                    <label>Max Radius: <span id="mrv">100</span></label>
                    <div style="display:flex; gap:10px; align-items:center; margin-bottom:10px;">
                        <input type="range" id="mr" min="10" max="200" value="100" step="5" oninput="updateAnalysisRadius(this.value)" style="flex:1;">
                        <input type="number" id="mrinput" min="10" max="300" value="100" step="5" style="width:100px; padding:8px;" oninput="updateAnalysisRadius(this.value)">
                    </div>
                    
                    <label>Start from Radius: <span id="minrv">1</span></label>
                    <input type="range" id="minr" min="1" max="50" value="1" step="1" oninput="document.getElementById('minrv').textContent=this.value">
                    
                    <div style="margin-top:20px;">
                        <label style="display:flex; align-items:center; gap:8px; margin:8px 0;">
                            <input type="checkbox" id="showAbsError" checked onchange="runAnalysis()"> Show Absolute Error
                        </label>
                        <label style="display:flex; align-items:center; gap:8px; margin:8px 0;">
                            <input type="checkbox" id="showRelError" checked onchange="runAnalysis()"> Show Relative Error (%)
                        </label>
                        <label style="display:flex; align-items:center; gap:8px; margin:8px 0;">
                            <input type="checkbox" id="showBoundary" onchange="runAnalysis()"> Show Theoretical Boundary R^(k-1)
                        </label>
                        <label style="display:flex; align-items:center; gap:8px; margin:8px 0;">
                            <input type="checkbox" id="showActualCount" onchange="runAnalysis()"> Show Actual Primitive Count
                        </label>
                    </div>
                    
                    <button onclick="runAnalysis()" style="margin-top:15px;">Compute Analysis</button>
                    <button onclick="exportChartData()">Export Chart Data</button>
                </div>
                <div class="loading" id="loadAnalysis"><div class="spinner"></div><p>Computing error analysis...</p></div>
                <canvas id="ch" width="1600" height="1000" style="max-width: 100%;"></canvas>
                <div class="formula" style="margin-top: 20px;">
                    <p><b>Error Bound Theory:</b></p>
                    <p>The error term O(R^(k-1)) arises from boundary effects. For k=2, the error is O(R), corresponding to points near the circle boundary. As k increases, the error term becomes relatively smaller compared to the main term R^k.</p>
                    <p style="margin-top:10px;"><b>Relative Error:</b> Shows |Predicted - Actual| / Predicted as a percentage. This decreases as R grows, confirming the asymptotic accuracy.</p>
                    <p style="margin-top:10px;"><b>Boundary Term:</b> The theoretical R^(k-1) term, showing the expected growth rate of the error.</p>
                </div>
            </div>
        </div>

        <div id="tools" class="panel">
            <div class="section">
                <h2>Mathematical Tools <span class="help-icon tooltip" data-tip="Number theory utilities">?</span></h2>
                
                <h3>GCD Calculator</h3>
                <div class="controls">
                    <div style="display:flex; gap:8px; margin-bottom:10px; flex-wrap:wrap;">
                        <button onclick="setGCDPreset('coprime')" style="padding:6px 12px; font-size:0.9em;">Coprime Example</button>
                        <button onclick="setGCDPreset('common')" style="padding:6px 12px; font-size:0.9em;">Common Factor</button>
                        <button onclick="setGCDPreset('large')" style="padding:6px 12px; font-size:0.9em;">Large Numbers</button>
                        <button onclick="setGCDPreset('many')" style="padding:6px 12px; font-size:0.9em;">Many Numbers</button>
                    </div>
                    <input type="text" id="gi" placeholder="12, 18, 24" style="width:100%; padding:10px">
                    <button onclick="calcGCD()">Calculate</button>
                    <div id="gr" style="margin-top:15px"></div>
                </div>

                <h3>Möbius Function μ(n)</h3>
                <div class="controls">
                    <div style="display:flex; gap:8px; margin-bottom:10px; flex-wrap:wrap;">
                        <button onclick="setMobiusPreset('squarefree')" style="padding:6px 12px; font-size:0.9em;">Square-free</button>
                        <button onclick="setMobiusPreset('notsquarefree')" style="padding:6px 12px; font-size:0.9em;">Not Square-free</button>
                        <button onclick="setMobiusPreset('prime')" style="padding:6px 12px; font-size:0.9em;">Prime Number</button>
                        <button onclick="setMobiusPreset('composite')" style="padding:6px 12px; font-size:0.9em;">Large Composite</button>
                    </div>
                    <input type="number" id="mi" placeholder="30" style="width:100%; padding:10px" min="1">
                    <button onclick="calcMobius()">Calculate</button>
                    <div id="mr2" style="margin-top:15px"></div>
                </div>

                <h3>Prime Factorization</h3>
                <div class="controls">
                    <div style="display:flex; gap:8px; margin-bottom:10px; flex-wrap:wrap;">
                        <button onclick="setPrimePreset('small')" style="padding:6px 12px; font-size:0.9em;">Small Number</button>
                        <button onclick="setPrimePreset('perfect')" style="padding:6px 12px; font-size:0.9em;">Perfect Number</button>
                        <button onclick="setPrimePreset('highly')" style="padding:6px 12px; font-size:0.9em;">Highly Composite</button>
                        <button onclick="setPrimePreset('large')" style="padding:6px 12px; font-size:0.9em;">Large Number</button>
                        <button onclick="setPrimePreset('power')" style="padding:6px 12px; font-size:0.9em;">Prime Power</button>
                    </div>
                    <input type="number" id="pi" placeholder="360" style="width:100%; padding:10px" min="2">
                    <button onclick="calcPrime()">Factorize</button>
                    <div id="pr" style="margin-top:15px"></div>
                </div>

                <h3>Coprimality Checker</h3>
                <div class="controls">
                    <div style="display:flex; gap:8px; margin-bottom:10px; flex-wrap:wrap;">
                        <button onclick="setCoprimePreset('coprime2')" style="padding:6px 12px; font-size:0.9em;">Coprime Pair</button>
                        <button onclick="setCoprimePreset('notcoprime2')" style="padding:6px 12px; font-size:0.9em;">Non-Coprime Pair</button>
                        <button onclick="setCoprimePreset('coprime3')" style="padding:6px 12px; font-size:0.9em;">Coprime Triple</button>
                        <button onclick="setCoprimePreset('consecutive')" style="padding:6px 12px; font-size:0.9em;">Consecutive Numbers</button>
                    </div>
                    <input type="text" id="cci" placeholder="15, 28" style="width:100%; padding:10px">
                    <button onclick="checkCoprime()">Check</button>
                    <div id="ccr" style="margin-top:15px"></div>
                </div>

                <h3>Point Search</h3>
                <div class="controls">
                    <div style="display:flex; gap:8px; margin-bottom:10px; flex-wrap:wrap;">
                        <button onclick="setPointPreset('pythagorean')" style="padding:6px 12px; font-size:0.9em;">Pythagorean Triple</button>
                        <button onclick="setPointPreset('primitive2d')" style="padding:6px 12px; font-size:0.9em;">Primitive 2D</button>
                        <button onclick="setPointPreset('nonprimitive2d')" style="padding:6px 12px; font-size:0.9em;">Non-Primitive 2D</button>
                        <button onclick="setPointPreset('primitive3d')" style="padding:6px 12px; font-size:0.9em;">Primitive 3D</button>
                        <button onclick="setPointPreset('highd')" style="padding:6px 12px; font-size:0.9em;">High-D Point</button>
                    </div>
                    <input type="text" id="psi" placeholder="3, 4 (finds if primitive)" style="width:100%; padding:10px">
                    <button onclick="searchPoint()">Search</button>
                    <div id="psr" style="margin-top:15px"></div>
                </div>
            </div>
        </div>

        <div id="export" class="panel">
            <div class="section">
                <h2>Advanced Export Center <span class="help-icon tooltip" data-tip="Professional export with titles and legends">?</span></h2>
                <p>Export high-resolution images with custom titles, subtitles, and legends. Choose resolution and canvas to export.</p>
                
                <div class="controls">
                    <div style="background:var(--bg3); padding:20px; border-radius:8px; margin-bottom:20px;">
                        <h3 style="color:var(--blue); margin-bottom:15px;">Export Settings</h3>
                        
                        <label><b>Canvas to Export:</b></label>
                        <select id="exportCanvas" style="width:100%; padding:10px; margin:10px 0; border-radius:6px; background:var(--bg); color:var(--text); border:1px solid var(--border);">
                            <option value="c2d">2D Lattice Visualization</option>
                            <option value="heatmapCanvas">GCD Heatmap</option>
                            <option value="gcdTableCanvas">GCD Multiplication Table</option>
                            <option value="criticalCanvas">Critical Strip Analysis</option>
                            <option value="patternCanvas">Pattern Visualization</option>
                            <option value="densityCanvas">Density Distribution</option>
                            <option value="angularCanvas">Angular Distribution</option>
                            <option value="radialCanvas">Radial Shell Analysis</option>
                            <option value="compChart">Dimension Comparison Chart</option>
                            <option value="ch">Error Analysis Chart</option>
                        </select>
                        
                        <label style="margin-top:15px;"><b>Resolution:</b></label>
                        <div style="display:grid; grid-template-columns: repeat(auto-fit, minmax(100px, 1fr)); gap:10px; margin:10px 0;">
                            <button id="res1k" class="active" onclick="setExportRes('1k')" style="padding:10px;">1K (1920×1080)</button>
                            <button id="res2k" onclick="setExportRes('2k')" style="padding:10px;">2K (2560×1440)</button>
                            <button id="res4k" onclick="setExportRes('4k')" style="padding:10px;">4K (3840×2160)</button>
                            <button id="res8k" onclick="setExportRes('8k')" style="padding:10px;">8K (7680×4320)</button>
                        </div>
                        
                        <label style="margin-top:15px;"><b>Title:</b></label>
                        <input type="text" id="exportTitle" placeholder="e.g., Primitive Lattice Point Distribution" style="width:100%; padding:10px; margin:5px 0; border-radius:6px; background:var(--bg); color:var(--text); border:1px solid var(--border);">
                        
                        <label style="margin-top:10px;"><b>Subtitle:</b></label>
                        <input type="text" id="exportSubtitle" placeholder="e.g., R=100, k=2, showing GCD patterns" style="width:100%; padding:10px; margin:5px 0; border-radius:6px; background:var(--bg); color:var(--text); border:1px solid var(--border);">
                        
                        <label style="margin-top:10px;"><b>Legend/Description:</b></label>
                        <textarea id="exportLegend" placeholder="Blue: Primitive (GCD=1)
Red: Non-Primitive (GCD>1)
Total Points: 12,345
Density: 60.79%" style="width:100%; padding:10px; margin:5px 0; border-radius:6px; background:var(--bg); color:var(--text); border:1px solid var(--border); min-height:100px; font-family:monospace;"></textarea>
                        
                        <div style="margin-top:15px;">
                            <label style="display:flex; align-items:center; gap:8px;">
                                <input type="checkbox" id="includeMetadata" checked> Include Title & Legend
                            </label>
                            <label style="display:flex; align-items:center; gap:8px; margin-top:8px;">
                                <input type="checkbox" id="includeTimestamp" checked> Include Timestamp
                            </label>
                            <label style="display:flex; align-items:center; gap:8px; margin-top:8px;">
                                <input type="checkbox" id="includeWatermark" checked> Include "By Wessen Getachew | @7dview"
                            </label>
                        </div>
                    </div>
                    
                    <div style="background:var(--bg3); padding:20px; border-radius:8px; margin-bottom:20px;">
                        <h3 style="color:var(--blue); margin-bottom:15px;">Quick Export Presets</h3>
                        <div style="display:grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap:10px;">
                            <button onclick="quickExport2D()" style="padding:12px;">Export Current 2D View</button>
                            <button onclick="quickExport3D()" style="padding:12px;">Export Current 3D View</button>
                            <button onclick="quickExportHeatmap()" style="padding:12px;">Export GCD Heatmap</button>
                            <button onclick="quickExportCritical()" style="padding:12px;">Export Critical Strip</button>
                            <button onclick="quickExportTable()" style="padding:12px;">Export GCD Table</button>
                            <button onclick="quickExportAnalysis()" style="padding:12px;">Export Error Analysis</button>
                        </div>
                    </div>
                    
                    <div style="text-align:center; margin-top:20px;">
                        <button onclick="performAdvancedExport()" style="padding:15px 40px; font-size:1.1em; background:var(--green); color:white;">
                            🖼️ Export with Metadata
                        </button>
                    </div>
                </div>
                
                <div id="exportPreview" style="background:var(--bg3); padding:20px; border-radius:8px; margin-top:20px; min-height:200px; text-align:center;">
                    <p style="color:var(--text2); font-style:italic;">Export preview will appear here</p>
                    <canvas id="exportPreviewCanvas" style="max-width:100%; margin-top:20px; display:none; border:2px solid var(--border); border-radius:8px;"></canvas>
                </div>
                
                <div class="formula" style="margin-top:20px;">
                    <p><b>Export Features:</b></p>
                    <p>• High-resolution output (up to 8K)</p>
                    <p>• Custom titles, subtitles, and legends</p>
                    <p>• Automatic parameter documentation</p>
                    <p>• Clean layout without overlap</p>
                    <p>• Professional formatting for publications</p>
                    <p>• Timestamp and attribution options</p>
                </div>
            </div>
        </div>

        <div id="derivation" class="panel">
            <div class="section">
                <h2>Interactive Derivation</h2>
                
                <h3>Step 1: Counting Lattice Points</h3>
                <p>Start with all lattice points in a k-dimensional sphere of radius R:</p>
                <div class="formula">$$L_k(R) = |\{(x_1,...,x_k) \in \mathbb{Z}^k : x_1^2 + ... + x_k^2 \leq R^2\}|$$</div>
                <p>Asymptotically, this equals the volume: L_k(R) ~ V_k R^k</p>

                <h3>Step 2: Separating by GCD</h3>
                <p>Partition points by their greatest common divisor d:</p>
                <div class="formula">$$L_k(R) = \sum_{d=1}^{R} N_k(R/d)$$</div>
                <p>Where N_k(R/d) counts primitive points in a sphere of radius R/d.</p>

                <h3>Step 3: Möbius Inversion</h3>
                <p>Inverting the previous relation using Möbius function:</p>
                <div class="formula">$$N_k(R) = \sum_{d=1}^{R} \mu(d) L_k(R/d)$$</div>
                
                <h3>Step 4: Asymptotic Expansion</h3>
                <p>Substituting L_k(R/d) ~ V_k (R/d)^k:</p>
                <div class="formula">$$N_k(R) = V_k R^k \sum_{d=1}^{\infty} \frac{\mu(d)}{d^k} + O(R^{k-1})$$</div>

                <h3>Step 5: Zeta Connection</h3>
                <p>The sum equals the reciprocal of the zeta function:</p>
                <div class="formula">$$\sum_{d=1}^{\infty} \frac{\mu(d)}{d^k} = \frac{1}{\zeta(k)}$$</div>
                
                <h3>Final Result</h3>
                <div class="formula">$$N_k(R) = \frac{V_k R^k}{\zeta(k)} + O(R^{k-1})$$</div>
                <p>This elegant formula connects geometry (V_k), analysis (ζ(k)), and number theory (primitive points)!</p>
                
                <div class="controls" style="margin-top: 30px;">
                    <button onclick="showDerivationAnimation()">Animate Derivation</button>
                </div>
            </div>
        </div>
    </div>

    <button class="btn-fixed" id="helpBtn" onclick="showHelp()">Help</button>
    <button class="btn-fixed" id="darkBtn" onclick="toggleDark()">Light Mode</button>

    <div class="modal" id="helpModal">
        <div class="modal-content">
            <span class="modal-close" onclick="closeHelp()">&times;</span>
            <h2>Platform Guide</h2>
            <h3>Navigation</h3>
            <p>Use the tabs to explore different aspects of primitive lattice points.</p>
            
            <h3>2D Visualizations</h3>
            <p><b>View Modes:</b></p>
            <p>• <b>Colored by Mode:</b> Points colored according to selected coloring mode</p>
            <p>• <b>Gauss Circle Problem:</b> All lattice points in purple, comparing against πR²</p>
            
            <p style="margin-top:15px;"><b>Coloring Modes (2D):</b></p>
            <p>• <b>GCD=1 vs GCD>1:</b> Blue for primitive (coprime), red for non-primitive</p>
            <p>• <b>By GCD Value:</b> Different color for each GCD (1=blue, 2=red, 3=green, 4=yellow, etc.)</p>
            <p>• <b>By Mod m:</b> Colors based on (x+y) mod m - reveals modular patterns</p>
            <p>• <b>By Quadrant:</b> Four colors for four quadrants (I=blue, II=green, III=yellow, IV=red)</p>
            <p>• <b>By Angular Sector:</b> Rainbow colors dividing circle into sectors</p>
            <p>• <b>GCD × Quadrant:</b> Combined coloring showing both GCD structure and spatial position</p>
            <p>• <b>GCD × Mod:</b> Combined coloring revealing GCD and modular arithmetic patterns</p>
            
            <p style="margin-top:15px;"><b>View Modes:</b></p>
            <p>• <b>Colored by Mode:</b> Points colored according to selected coloring mode</p>
            <p>• <b>Gauss Circle Problem:</b> All lattice points in purple, comparing against πR²</p>
            <p>• <b>GCD=1 vs GCD>1:</b> Blue for primitive (coprime), red for non-primitive</p>
            <p>• <b>By GCD Value:</b> Different color for each GCD (1=blue, 2=red, 3=green, 4=yellow, etc.)</p>
            <p>• <b>By Mod m:</b> Colors based on (x+y) mod m - reveals modular patterns</p>
            <p>• <b>By Quadrant:</b> Four colors for four quadrants (I=blue, II=green, III=yellow, IV=red)</p>
            <p>• <b>By Angular Sector:</b> Rainbow colors dividing circle into sectors</p>
            <p>• <b>GCD × Quadrant:</b> Combined coloring showing both GCD structure and spatial position</p>
            <p>• <b>GCD × Mod:</b> Combined coloring revealing GCD and modular arithmetic patterns</p>
            
            <h3>3D Visualizations</h3>
            <p><b>Camera Controls:</b></p>
            <p>• Click and drag to rotate view</p>
            <p>• Use zoom slider (30-150) to adjust camera distance</p>
            <p>• Reset button returns to default view</p>
            <p>• Auto-rotate button for continuous rotation</p>
            
            <p style="margin-top:10px;"><b>Point Labeling:</b></p>
            <p>• <b>No Labels:</b> Clean 3D view</p>
            <p>• <b>By GCD:</b> Shows GCD value on sprites</p>
            <p>• <b>Coordinates:</b> Displays (x,y,z) for each labeled point</p>
            <p>• Control max labels (10-200) to avoid clutter</p>
            <p>• Labels shown for points closest to origin</p>
            
            <p style="margin-top:10px;"><b>Boundary Shapes:</b></p>
            <p>• Sphere: Points within distance R (x²+y²+z² ≤ R²)</p>
            <p>• Cube: Points within cube of side 2R (|x|,|y|,|z| ≤ R)</p>
            
            <p style="margin-top:15px;"><b>Coloring Modes (3D):</b></p>
            <p>• <b>GCD=1 vs GCD>1:</b> Blue for primitive, red for non-primitive</p>
            <p>• <b>By GCD Value:</b> Different colors for different GCD values</p>
            <p>• <b>By Mod m:</b> Colors based on (x+y+z) mod m</p>
            <p>• <b>By Octant:</b> Eight colors for eight octants in 3D space</p>
            <p>• <b>By Distance:</b> Gradient from center (blue) to boundary (red)</p>
            <p>• <b>GCD × Octant:</b> Combined coloring showing GCD and spatial structure</p>
            <p>• <b>GCD × Mod:</b> Combined GCD and modular arithmetic visualization</p>
            
            <p style="margin-top:10px;">Click and drag to rotate the view. Adjust point size for clarity.</p>
            
            <h3>Error Analysis</h3>
            <p>Shows error per radius value from start to max radius:</p>
            <p>• <b>Absolute Error:</b> |Predicted - Actual| count of points</p>
            <p>• <b>Relative Error:</b> Percentage error relative to prediction</p>
            <p>• <b>Boundary Term:</b> Theoretical R^(k-1) error bound</p>
            <p>• <b>Actual Count:</b> The true primitive point count at each radius</p>
            
            <h3>Performance Tips</h3>
            <p>• Keep radius ≤ 200 in 2D, ≤ 30 in 3D for smooth performance</p>
            <p>• Use zoom slider in 2D to focus on specific regions</p>
            <p>• Limit number of labels for large radius values</p>
            <p>• Use Export tab for high-resolution outputs</p>
            <p>• Compare mode shows multiple dimensions simultaneously</p>
            
            <h3>Export Features</h3>
            <p><b>Advanced Export Center:</b></p>
            <p>• Export at 1K, 2K, 4K, or 8K resolution</p>
            <p>• Add custom titles, subtitles, and legends</p>
            <p>• Include timestamps and attribution</p>
            <p>• Clean layout optimized for publications</p>
            <p>• Quick export presets for each visualization</p>
            <p>• Preview before downloading</p>
            
            <h3>Precision Display</h3>
            <p>• Higher dimensions (k>6) show up to 17 decimal places</p>
            <p>• All exports include precise values</p>
            <p>• Theory table shows maximum precision for each k</p>
            
            <h3>Tools Section</h3>
            <p>Calculate GCD, Möbius function, prime factorizations, and search for specific lattice points.</p>
        </div>
    </div>

    <script>
        let scene, camera, renderer, chart, autoRotate = false;
        const cache = { mobius: new Map(), gcd: new Map(), points2D: null, points3D: null };
        let mouseDown = false, prevMouse = { x: 0, y: 0 };
        let view2D = 'primitive'; // 'primitive' or 'gauss'
        let comparisonMode = 'fixed'; // 'fixed' or 'multi'
        let comparisonChart = null;
        let shape3D = 'sphere'; // 'sphere' or 'cube'
        let colorMode3D = 'primitive'; // 'primitive', 'gcd', 'mod', 'octant', 'distance', 'gcdoct', 'gcdmod'
        let colorMode2D = 'primitive'; // 'primitive', 'gcd', 'mod', 'quadrant', 'angular', 'gcdquad', 'gcdmod'
        let patternType = 'modular'; // 'modular', 'density', 'angular', 'radial'
        let patternChart = null;
        let heatmapMode = 'gcd'; // 'gcd', 'primitive', 'gradient'
        let heatmapPointsData = [];
        let criticalProblem = 'all'; // 'all' or 'primitive'
        let criticalViz = 'error'; // 'error', 'normalized', 'loglog', 'bounds'
        let labelMode2D = 'none'; // 'none', 'gcd', 'coords', 'angle'
        let labelMode3D = 'none'; // 'none', 'gcd', 'coords'
        let zoom2D = 100; // percentage

        function gcd(a, b) {
            a = Math.abs(a); b = Math.abs(b);
            while (b) [a, b] = [b, a % b];
            return a;
        }

        function gcdArray(arr) { return arr.reduce((a, b) => gcd(a, b)); }

        function isPrime(n) {
            if (n < 2) return false;
            if (n === 2) return true;
            if (n % 2 === 0) return false;
            for (let i = 3; i <= Math.sqrt(n); i += 2)
                if (n % i === 0) return false;
            return true;
        }

        function primeFactors(n) {
            const f = []; let d = 2;
            while (n > 1) {
                while (n % d === 0) { f.push(d); n /= d; }
                d++; if (d * d > n && n > 1) { f.push(n); break; }
            }
            return f;
        }

        function mobius(n) {
            if (cache.mobius.has(n)) return cache.mobius.get(n);
            if (n === 1) return 1;
            const f = primeFactors(n), u = [...new Set(f)];
            const r = f.length !== u.length ? 0 : Math.pow(-1, f.length);
            cache.mobius.set(n, r);
            return r;
        }

        function zeta(k) {
            const z = { 2: Math.PI**2/6, 3: 1.2020569, 4: Math.PI**4/90, 5: 1.0369278, 6: Math.PI**6/945, 
                       7: 1.0083493, 8: Math.PI**8/9450, 9: 1.00200839, 10: 1.00099457, 11: 1.00049419, 12: 1.00024608 };
            return z[k] || 1 + 2**-k;
        }

        function sphereVolume(k, R) {
            const gamma = k % 2 === 0 ? 
                Math.PI**(k/2) / factorial(k/2) : 
                2 * factorial((k-1)/2) * Math.PI**((k-1)/2) / factorial(k);
            return gamma * R**k;
        }

        function factorial(n) {
            if (n <= 1) return 1;
            let res = 1;
            for (let i = 2; i <= n; i++) res *= i;
            return res;
        }

        function animateValue(id, start, end, duration = 500) {
            const el = document.getElementById(id);
            const range = end - start;
            const increment = range / (duration / 16);
            let current = start;
            const timer = setInterval(() => {
                current += increment;
                if ((increment > 0 && current >= end) || (increment < 0 && current <= end)) {
                    el.textContent = typeof end === 'number' && end % 1 !== 0 ? end.toFixed(3) : Math.round(end).toLocaleString();
                    clearInterval(timer);
                } else {
                    el.textContent = typeof current === 'number' && current % 1 !== 0 ? current.toFixed(3) : Math.round(current).toLocaleString();
                }
            }, 16);
        }

        function showTab(id) {
            document.querySelectorAll('.panel').forEach(p => p.classList.remove('active'));
            document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
            document.getElementById(id).classList.add('active');
            event.target.classList.add('active');
            if (id === 'viz2d') draw2D();
            if (id === 'viz3d' && !scene) init3D();
            if (id === 'comparison') updateComparison();
            if (id === 'patterns') {
                setPatternType('modular');
                updatePatternViz();
            }
        }

        function updateTheory() {
            const k = parseInt(document.getElementById('tks').value);
            const R = parseInt(document.getElementById('trs').value);
            document.getElementById('tk').textContent = k;
            document.getElementById('tr').textContent = R;
            const z = zeta(k), d = 1/z;
            const vol = sphereVolume(k, R);
            const pred = Math.round(vol / z);
            
            // Use high precision for k > 6
            const precision = k > 6 ? 17 : 6;
            
            document.getElementById('sz').textContent = formatPrecise(z, precision);
            document.getElementById('sd').textContent = formatPrecise(d, precision);
            animateValue('sp', parseInt(document.getElementById('sp').textContent.replace(/,/g, '')) || pred, pred);
            document.getElementById('svol').textContent = formatPrecise(vol, precision);
        }

        function set2DView(mode) {
            view2D = mode;
            document.querySelectorAll('#viewPrimitive, #viewGauss').forEach(btn => btn.classList.remove('active'));
            document.getElementById(mode === 'primitive' ? 'viewPrimitive' : 'viewGauss').classList.add('active');
            draw2D();
        }

        function set2DColorMode(mode) {
            colorMode2D = mode;
            document.querySelectorAll('#color2DPrimitive, #color2DGCD, #color2DMod, #color2DQuadrant, #color2DAngular, #color2DGCDQuad, #color2DGCDMod').forEach(btn => btn.classList.remove('active'));
            const btnIds = {
                'primitive': 'color2DPrimitive',
                'gcd': 'color2DGCD',
                'mod': 'color2DMod',
                'quadrant': 'color2DQuadrant',
                'angular': 'color2DAngular',
                'gcdquad': 'color2DGCDQuad',
                'gcdmod': 'color2DGCDMod'
            };
            document.getElementById(btnIds[mode]).classList.add('active');
            
            // Show/hide modulus controls
            document.getElementById('modControls2D').style.display = (mode === 'mod' || mode === 'gcdmod') ? 'block' : 'none';
            document.getElementById('sectorControls2D').style.display = (mode === 'angular') ? 'block' : 'none';
            
            draw2D();
        }

        function update2DRadius(value) {
            const R = parseInt(value);
            if (R < 1 || R > 1000 || isNaN(R)) return;
            
            document.getElementById('r2v').textContent = R;
            document.getElementById('r2').value = Math.min(R, 500);
            document.getElementById('r2input').value = R;
            
            // Show performance warning
            document.getElementById('warn2d').style.display = R > 200 ? 'block' : 'none';
            
            draw2D();
        }

        function draw2D() {
            const canvas = document.getElementById('c2d'), ctx = canvas.getContext('2d');
            const R = parseInt(document.getElementById('r2input').value);
            const sz = parseInt(document.getElementById('ps').value);
            document.getElementById('r2v').textContent = R;
            document.getElementById('psv').textContent = sz;
            
            document.getElementById('warn2d').style.display = R > 200 ? 'block' : 'none';
            if (R > 250) {
                document.getElementById('load2d').classList.add('active');
            }
            
            setTimeout(() => {
                ctx.clearRect(0, 0, 800, 800);
                const cx = 400, cy = 400, sc = 350/R;
                ctx.strokeStyle = getComputedStyle(document.body).getPropertyValue('--border');
                ctx.lineWidth = 2;
                ctx.beginPath(); ctx.arc(cx, cy, R*sc, 0, 2*Math.PI); ctx.stroke();
                
                const allPoints = [];
                let prim = 0, tot = 0;
                
                // Collect all points with properties
                for (let x = -R; x <= R; x++) {
                    for (let y = -R; y <= R; y++) {
                        if (x*x + y*y <= R*R) {
                            tot++;
                            const g = gcd(Math.abs(x), Math.abs(y));
                            const isPrimitive = g === 1;
                            if (isPrimitive) prim++;
                            
                            // Calculate quadrant
                            let quadrant;
                            if (x >= 0 && y >= 0) quadrant = 1;
                            else if (x < 0 && y >= 0) quadrant = 2;
                            else if (x < 0 && y < 0) quadrant = 3;
                            else quadrant = 4;
                            
                            // Calculate angle (0 to 2π)
                            const angle = Math.atan2(y, x) + Math.PI; // 0 to 2π
                            
                            allPoints.push({
                                x, y, gcd: g, isPrimitive, quadrant, angle,
                                sum: x + y
                            });
                        }
                    }
                }
                
                // Group points by color based on mode
                const pointsByColor = {};
                const modulus = parseInt(document.getElementById('mod2D').value);
                const numSectors = parseInt(document.getElementById('sectors2D').value);
                
                allPoints.forEach(pt => {
                    let colorKey;
                    
                    if (view2D === 'gauss') {
                        colorKey = 'all';
                    } else {
                        switch(colorMode2D) {
                            case 'primitive':
                                colorKey = pt.isPrimitive ? 'prim' : 'nonprim';
                                break;
                            case 'gcd':
                                colorKey = `gcd${Math.min(pt.gcd, 8)}`;
                                break;
                            case 'mod':
                                colorKey = `mod${((pt.x + pt.y) % modulus + modulus) % modulus}`;
                                break;
                            case 'quadrant':
                                colorKey = `quad${pt.quadrant}`;
                                break;
                            case 'angular':
                                const sector = Math.floor(pt.angle / (2 * Math.PI / numSectors));
                                colorKey = `sector${sector}`;
                                break;
                            case 'gcdquad':
                                colorKey = `gcd${Math.min(pt.gcd, 4)}_q${pt.quadrant}`;
                                break;
                            case 'gcdmod':
                                const modVal = ((pt.x + pt.y) % modulus + modulus) % modulus;
                                colorKey = `gcd${Math.min(pt.gcd, 4)}_m${modVal}`;
                                break;
                        }
                    }
                    
                    if (!pointsByColor[colorKey]) pointsByColor[colorKey] = [];
                    pointsByColor[colorKey].push(pt);
                });
                
                // Define color palettes
                const colors = {
                    all: '#6f42c1',
                    prim: '#0066cc',
                    nonprim: '#dc3545',
                    gcd1: '#0066cc', gcd2: '#dc3545', gcd3: '#28a745', gcd4: '#ffc107',
                    gcd5: '#6f42c1', gcd6: '#fd7e14', gcd7: '#00d4ff', gcd8: '#ff006e',
                    quad1: '#0066cc', quad2: '#28a745', quad3: '#ffc107', quad4: '#dc3545',
                    mod0: '#0066cc', mod1: '#dc3545', mod2: '#28a745', mod3: '#ffc107',
                    mod4: '#6f42c1', mod5: '#fd7e14', mod6: '#00d4ff', mod7: '#ff006e',
                    mod8: '#20c997', mod9: '#e83e8c', mod10: '#17a2b8', mod11: '#6610f2'
                };
                
                // Generate sector colors (rainbow)
                for (let i = 0; i < 16; i++) {
                    const hue = (i / 16) * 360;
                    colors[`sector${i}`] = `hsl(${hue}, 70%, 50%)`;
                }
                
                // Generate combined colors
                const baseColors = ['#0066cc', '#dc3545', '#28a745', '#ffc107'];
                for (let g = 1; g <= 4; g++) {
                    for (let q = 1; q <= 4; q++) {
                        colors[`gcd${g}_q${q}`] = baseColors[(g - 1 + q - 1) % 4];
                    }
                    for (let m = 0; m < 12; m++) {
                        const hue = ((g - 1) * 90 + m * 30) % 360;
                        colors[`gcd${g}_m${m}`] = `hsl(${hue}, 65%, 50%)`;
                    }
                }
                
                // Draw points
                Object.entries(pointsByColor).forEach(([colorKey, points]) => {
                    ctx.fillStyle = colors[colorKey] || '#999';
                    points.forEach(pt => {
                        ctx.beginPath();
                        ctx.arc(cx + pt.x*sc, cy - pt.y*sc, sz, 0, 2*Math.PI);
                        ctx.fill();
                    });
                });
                
                cache.points2D = { primitive: allPoints.filter(p => p.isPrimitive), 
                                   nonPrimitive: allPoints.filter(p => !p.isPrimitive), R };
                
                // Draw labels if enabled
                if (labelMode2D !== 'none') {
                    const labelSize = parseInt(document.getElementById('labelSize2D').value);
                    const maxLabels = parseInt(document.getElementById('maxLabels2D').value);
                    document.getElementById('labelSize2Dv').textContent = labelSize;
                    document.getElementById('maxLabels2Dv').textContent = maxLabels;
                    
                    // Sort points by distance from origin
                    const sortedPoints = [...allPoints].sort((a, b) => 
                        (a.x*a.x + a.y*a.y) - (b.x*b.x + b.y*b.y)
                    ).slice(0, maxLabels);
                    
                    ctx.fillStyle = getComputedStyle(document.body).getPropertyValue('--text');
                    ctx.font = `${labelSize}px system-ui`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    
                    sortedPoints.forEach(pt => {
                        let label;
                        if (labelMode2D === 'gcd') {
                            label = pt.gcd.toString();
                        } else if (labelMode2D === 'coords') {
                            label = `(${pt.x},${pt.y})`;
                        } else if (labelMode2D === 'angle') {
                            const angle = Math.atan2(pt.y, pt.x) * 180 / Math.PI;
                            label = `${angle.toFixed(0)}°`;
                        }
                        
                        const screenX = cx + pt.x*sc;
                        const screenY = cy - pt.y*sc;
                        
                        // Draw background for label
                        const metrics = ctx.measureText(label);
                        const labelWidth = metrics.width + 4;
                        const labelHeight = labelSize + 2;
                        ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                        ctx.fillRect(screenX - labelWidth/2, screenY - labelHeight/2, labelWidth, labelHeight);
                        
                        // Draw label text
                        ctx.fillStyle = '#fff';
                        ctx.fillText(label, screenX, screenY);
                    });
                }
                
                const pred = Math.round(Math.PI * R * R / zeta(2));
                const error = Math.abs(pred - prim);
                
                // Update stats based on view mode
                if (view2D === 'gauss') {
                    document.getElementById('p2').parentElement.querySelector('.lbl').textContent = 'Total Lattice Points';
                    animateValue('p2', 0, tot);
                    document.getElementById('t2').parentElement.querySelector('.lbl').textContent = 'Expected (πR²)';
                    animateValue('t2', 0, Math.round(Math.PI * R * R));
                    document.getElementById('d2').parentElement.querySelector('.lbl').textContent = 'Error';
                    document.getElementById('d2').textContent = Math.abs(tot - Math.PI * R * R).toFixed(1);
                    document.getElementById('e2').parentElement.querySelector('.lbl').textContent = '% of Expected';
                    document.getElementById('e2').textContent = ((tot / (Math.PI * R * R)) * 100).toFixed(2) + '%';
                } else {
                    document.getElementById('p2').parentElement.querySelector('.lbl').textContent = 'Primitive Points';
                    animateValue('p2', 0, prim);
                    document.getElementById('t2').parentElement.querySelector('.lbl').textContent = 'Total Points';
                    animateValue('t2', 0, tot);
                    document.getElementById('d2').parentElement.querySelector('.lbl').textContent = 'Density';
                    document.getElementById('d2').textContent = ((prim/tot)*100).toFixed(1) + '%';
                    document.getElementById('e2').parentElement.querySelector('.lbl').textContent = '|Predicted - Actual|';
                    animateValue('e2', 0, error);
                }
                
                document.getElementById('load2d').classList.remove('active');
            }, 100);
        }

        function init3D() {
            const c = document.getElementById('c3d');
            scene = new THREE.Scene();
            scene.background = new THREE.Color(document.body.classList.contains('light') ? 0xffffff : 0x1a1a1a);
            camera = new THREE.PerspectiveCamera(75, c.clientWidth/600, 0.1, 1000);
            camera.position.set(50, 50, 50);
            camera.lookAt(0, 0, 0);
            renderer = new THREE.WebGLRenderer({ antialias: true, preserveDrawingBuffer: true });
            renderer.setSize(c.clientWidth, 600);
            c.appendChild(renderer.domElement);
            
            const light1 = new THREE.AmbientLight(0xffffff, 0.6);
            const light2 = new THREE.DirectionalLight(0xffffff, 0.4);
            light2.position.set(1, 1, 1);
            scene.add(light1, light2);
            
            const axes = new THREE.AxesHelper(35);
            scene.add(axes);
            
            const canvas = renderer.domElement;
            canvas.addEventListener('mousedown', e => {
                mouseDown = true;
                prevMouse = { x: e.clientX, y: e.clientY };
            });
            canvas.addEventListener('mousemove', e => {
                if (mouseDown && !autoRotate) {
                    const dx = e.clientX - prevMouse.x;
                    const dy = e.clientY - prevMouse.y;
                    const rotSpeed = 0.005;
                    camera.position.applyAxisAngle(new THREE.Vector3(0, 1, 0), dx * rotSpeed);
                    const right = new THREE.Vector3(1, 0, 0).applyQuaternion(camera.quaternion);
                    camera.position.applyAxisAngle(right, dy * rotSpeed);
                    camera.lookAt(0, 0, 0);
                    prevMouse = { x: e.clientX, y: e.clientY };
                }
            });
            canvas.addEventListener('mouseup', () => mouseDown = false);
            canvas.addEventListener('mouseleave', () => mouseDown = false);
            
            draw3D();
            animate3D();
        }

        function set3DShape(shape) {
            shape3D = shape;
            document.querySelectorAll('#shape3DSphere, #shape3DCube').forEach(btn => btn.classList.remove('active'));
            document.getElementById(shape === 'sphere' ? 'shape3DSphere' : 'shape3DCube').classList.add('active');
            draw3D();
        }

        function set3DColorMode(mode) {
            colorMode3D = mode;
            document.querySelectorAll('#colorPrimitive, #colorGCD, #colorMod, #colorOctant, #colorDistance, #colorGCDOct, #colorGCDMod').forEach(btn => btn.classList.remove('active'));
            const btnIds = {
                'primitive': 'colorPrimitive',
                'gcd': 'colorGCD',
                'mod': 'colorMod',
                'octant': 'colorOctant',
                'distance': 'colorDistance',
                'gcdoct': 'colorGCDOct',
                'gcdmod': 'colorGCDMod'
            };
            document.getElementById(btnIds[mode]).classList.add('active');
            
            // Show/hide modulus controls
            document.getElementById('modControls3D').style.display = (mode === 'mod' || mode === 'gcdmod') ? 'block' : 'none';
            
            draw3D();
        }

        function draw3D() {
            if (!scene) return;
            while(scene.children.length > 3) scene.remove(scene.children[3]);
            
            const R = parseInt(document.getElementById('r3').value);
            const pointSize = parseFloat(document.getElementById('ps3').value);
            document.getElementById('r3v').textContent = R;
            document.getElementById('ps3v').textContent = pointSize;
            document.getElementById('warn3d').style.display = R > 30 ? 'block' : 'none';
            
            if (R > 25) document.getElementById('load3d').classList.add('active');
            
            setTimeout(() => {
                // Add boundary shape
                if (shape3D === 'sphere') {
                    const sg = new THREE.SphereGeometry(R, 32, 32);
                    const sm = new THREE.MeshBasicMaterial({ 
                        color: 0x6f42c1, wireframe: true, transparent: true, opacity: 0.15 
                    });
                    scene.add(new THREE.Mesh(sg, sm));
                } else {
                    const boxGeometry = new THREE.BoxGeometry(2*R, 2*R, 2*R);
                    const edges = new THREE.EdgesGeometry(boxGeometry);
                    const line = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ 
                        color: 0x6f42c1, transparent: true, opacity: 0.3 
                    }));
                    scene.add(line);
                }
                
                // Collect all points with their properties
                const allPoints = [];
                let prim = 0, tot = 0;
                const modulus = parseInt(document.getElementById('mod3D').value);
                
                for (let x = -R; x <= R; x++) {
                    for (let y = -R; y <= R; y++) {
                        for (let z = -R; z <= R; z++) {
                            const distSq = x*x + y*y + z*z;
                            const inBounds = shape3D === 'sphere' ? 
                                (distSq <= R*R) : 
                                (Math.abs(x) <= R && Math.abs(y) <= R && Math.abs(z) <= R);
                            
                            if (inBounds) {
                                tot++;
                                const g = gcdArray([Math.abs(x), Math.abs(y), Math.abs(z)]);
                                const isPrimitive = g === 1;
                                if (isPrimitive) prim++;
                                
                                // Determine octant (1-8)
                                let octant = 1;
                                if (x >= 0 && y >= 0 && z >= 0) octant = 1;
                                else if (x < 0 && y >= 0 && z >= 0) octant = 2;
                                else if (x < 0 && y < 0 && z >= 0) octant = 3;
                                else if (x >= 0 && y < 0 && z >= 0) octant = 4;
                                else if (x >= 0 && y >= 0 && z < 0) octant = 5;
                                else if (x < 0 && y >= 0 && z < 0) octant = 6;
                                else if (x < 0 && y < 0 && z < 0) octant = 7;
                                else octant = 8;
                                
                                allPoints.push({
                                    x, y, z,
                                    gcd: g,
                                    isPrimitive,
                                    distance: Math.sqrt(distSq),
                                    sum: x + y + z,
                                    octant
                                });
                            }
                        }
                    }
                }
                
                cache.points3D = { 
                    primitive: allPoints.filter(p => p.isPrimitive),
                    nonPrimitive: allPoints.filter(p => !p.isPrimitive),
                    R 
                };
                
                // Color points based on mode
                const pointsByColor = {};
                
                allPoints.forEach(pt => {
                    let colorKey;
                    
                    switch(colorMode3D) {
                        case 'primitive':
                            colorKey = pt.isPrimitive ? 'prim' : 'nonprim';
                            break;
                        case 'gcd':
                            colorKey = `gcd${Math.min(pt.gcd, 8)}`;
                            break;
                        case 'mod':
                            colorKey = `mod${((pt.sum % modulus) + modulus) % modulus}`;
                            break;
                        case 'octant':
                            colorKey = `oct${pt.octant}`;
                            break;
                        case 'distance':
                            const distBucket = Math.floor(pt.distance / (R / 5));
                            colorKey = `dist${Math.min(distBucket, 5)}`;
                            break;
                        case 'gcdoct':
                            colorKey = `gcd${Math.min(pt.gcd, 4)}_oct${pt.octant}`;
                            break;
                        case 'gcdmod':
                            const modVal = ((pt.sum % modulus) + modulus) % modulus;
                            colorKey = `gcd${Math.min(pt.gcd, 4)}_m${modVal}`;
                            break;
                    }
                    
                    if (!pointsByColor[colorKey]) pointsByColor[colorKey] = [];
                    pointsByColor[colorKey].push(pt.x, pt.y, pt.z);
                });
                
                // Define color schemes
                const colorMap = {
                    prim: 0x0066cc,
                    nonprim: 0xdc3545,
                    gcd1: 0x0066cc, gcd2: 0xdc3545, gcd3: 0x28a745, gcd4: 0xffc107,
                    gcd5: 0x6f42c1, gcd6: 0xfd7e14, gcd7: 0x00d4ff, gcd8: 0xff006e,
                    oct1: 0x0066cc, oct2: 0xdc3545, oct3: 0x28a745, oct4: 0xffc107,
                    oct5: 0x6f42c1, oct6: 0xfd7e14, oct7: 0x00d4ff, oct8: 0xff006e,
                    dist0: 0x0066cc, dist1: 0x00d4ff, dist2: 0x28a745, 
                    dist3: 0xffc107, dist4: 0xfd7e14, dist5: 0xdc3545,
                    mod0: 0x0066cc, mod1: 0xdc3545, mod2: 0x28a745, mod3: 0xffc107,
                    mod4: 0x6f42c1, mod5: 0xfd7e14, mod6: 0x00d4ff, mod7: 0xff006e,
                    mod8: 0x20c997, mod9: 0xe83e8c, mod10: 0x17a2b8, mod11: 0x6610f2
                };
                
                // Generate combined colors
                const baseColors = [0x0066cc, 0xdc3545, 0x28a745, 0xffc107, 0x6f42c1, 0xfd7e14, 0x00d4ff, 0xff006e];
                for (let g = 1; g <= 4; g++) {
                    for (let o = 1; o <= 8; o++) {
                        colorMap[`gcd${g}_oct${o}`] = baseColors[(g - 1 + o - 1) % 8];
                    }
                    for (let m = 0; m < 12; m++) {
                        colorMap[`gcd${g}_m${m}`] = baseColors[(g - 1 + m) % 8];
                    }
                }
                
                // Create point groups
                Object.entries(pointsByColor).forEach(([colorKey, positions]) => {
                    if (positions.length > 0) {
                        const geometry = new THREE.BufferGeometry();
                        geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
                        
                        const color = colorMap[colorKey] || 0x999999;
                        const material = new THREE.PointsMaterial({ color, size: pointSize });
                        scene.add(new THREE.Points(geometry, material));
                    }
                });
                
                // Add labels if enabled
                if (labelMode3D !== 'none') {
                    const maxLabels = parseInt(document.getElementById('maxLabels3D').value);
                    document.getElementById('maxLabels3Dv').textContent = maxLabels;
                    
                    // Sort by distance and take closest points
                    const sortedPoints = [...allPoints].sort((a, b) => a.distance - b.distance).slice(0, maxLabels);
                    
                    sortedPoints.forEach(pt => {
                        let labelText;
                        if (labelMode3D === 'gcd') {
                            labelText = pt.gcd.toString();
                        } else if (labelMode3D === 'coords') {
                            labelText = `(${pt.x},${pt.y},${pt.z})`;
                        }
                        
                        // Create sprite for label
                        const canvas = document.createElement('canvas');
                        const context = canvas.getContext('2d');
                        canvas.width = 128;
                        canvas.height = 64;
                        
                        context.fillStyle = 'rgba(0, 0, 0, 0.8)';
                        context.fillRect(0, 0, canvas.width, canvas.height);
                        
                        context.font = 'Bold 24px Arial';
                        context.fillStyle = 'white';
                        context.textAlign = 'center';
                        context.textBaseline = 'middle';
                        context.fillText(labelText, canvas.width/2, canvas.height/2);
                        
                        const texture = new THREE.CanvasTexture(canvas);
                        const spriteMaterial = new THREE.SpriteMaterial({ map: texture });
                        const sprite = new THREE.Sprite(spriteMaterial);
                        sprite.position.set(pt.x, pt.y, pt.z);
                        sprite.scale.set(4, 2, 1);
                        scene.add(sprite);
                    });
                }
                
                const pred = Math.round(4 * Math.PI * R**3 / (3 * zeta(3)));
                const error = Math.abs(pred - prim);
                
                animateValue('p3', 0, prim);
                animateValue('t3', 0, tot);
                document.getElementById('d3').textContent = ((prim/tot)*100).toFixed(1) + '%';
                animateValue('e3', 0, error);
                
                document.getElementById('load3d').classList.remove('active');
            }, 100);
        }

        function animate3D() {
            requestAnimationFrame(animate3D);
            if (renderer && scene && camera) {
                if (autoRotate) {
                    camera.position.applyAxisAngle(new THREE.Vector3(0, 1, 0), 0.005);
                    camera.lookAt(0, 0, 0);
                }
                renderer.render(scene, camera);
            }
        }

        function reset3D() {
            if (camera) { 
                camera.position.set(50, 50, 50); 
                camera.lookAt(0, 0, 0); 
            }
        }

        function toggleRotation() {
            autoRotate = !autoRotate;
            event.target.textContent = autoRotate ? 'Stop Rotation' : 'Auto-Rotate';
        }

        function setComparisonMode(mode) {
            comparisonMode = mode;
            document.querySelectorAll('#modeFixed, #modeMulti').forEach(btn => btn.classList.remove('active'));
            document.getElementById(mode === 'fixed' ? 'modeFixed' : 'modeMulti').classList.add('active');
            
            if (mode === 'fixed') {
                document.getElementById('fixedRadiusControls').style.display = 'block';
                document.getElementById('multiRadiusControls').style.display = 'none';
            } else {
                document.getElementById('fixedRadiusControls').style.display = 'none';
                document.getElementById('multiRadiusControls').style.display = 'block';
            }
            updateComparison();
        }

        function updateComparisonRadius(value) {
            const R = parseInt(value);
            if (R < 1 || R > 200 || isNaN(R)) return;
            
            document.getElementById('crv').textContent = R;
            document.getElementById('cr').value = Math.min(R, 100);
            document.getElementById('crinput').value = R;
            updateComparison();
        }

        function updateComparison() {
            const grid = document.getElementById('compGrid');
            const showDensity = document.getElementById('showDensity').checked;
            const showVolume = document.getElementById('showVolume').checked;
            const showZeta = document.getElementById('showZeta').checked;
            const showChart = document.getElementById('showChart').checked;
            
            const dims = [];
            for (let k = 2; k <= 10; k++) {
                if (document.getElementById(`compk${k}`)?.checked) dims.push(k);
            }
            
            if (dims.length === 0) {
                grid.innerHTML = '<p style="color:var(--red);">Please select at least one dimension</p>';
                return;
            }
            
            grid.innerHTML = '';
            
            if (comparisonMode === 'fixed') {
                const R = parseInt(document.getElementById('crinput').value);
                
                dims.forEach(k => {
                    const z = zeta(k);
                    const vol = sphereVolume(k, R);
                    const pred = Math.round(vol / z);
                    const density = (1/z * 100).toFixed(2);
                    
                    let content = `
                        <div class="compare-item">
                            <h3 style="color:var(--blue); margin-bottom:15px;">Dimension k = ${k}</h3>
                            <div style="background:var(--bg); padding:10px; border-radius:6px; margin-bottom:10px;">
                                <p style="font-size:1.1em;"><b>Predicted Points:</b> ${pred.toLocaleString()}</p>
                            </div>
                    `;
                    
                    if (showZeta) {
                        content += `
                            <div style="background:var(--bg); padding:10px; border-radius:6px; margin-bottom:10px;">
                                <p><b>ζ(${k}):</b> ${z.toFixed(6)}</p>
                            </div>
                        `;
                    }
                    
                    if (showDensity) {
                        content += `
                            <div style="background:var(--bg); padding:10px; border-radius:6px; margin-bottom:10px;">
                                <p><b>Primitive Density:</b> ${density}%</p>
                                <p style="font-size:0.9em; color:var(--text2);">1/ζ(${k}) = ${(1/z).toFixed(6)}</p>
                            </div>
                        `;
                    }
                    
                    if (showVolume) {
                        content += `
                            <div style="background:var(--bg); padding:10px; border-radius:6px; margin-bottom:10px;">
                                <p><b>Sphere Volume:</b></p>
                                <p style="font-size:0.95em;">${vol.toExponential(4)}</p>
                            </div>
                        `;
                    }
                    
                    // Add growth rate info
                    content += `
                        <div style="background:var(--bg); padding:10px; border-radius:6px; margin-bottom:10px;">
                            <p><b>Growth Rate:</b> O(R^${k})</p>
                            <p style="font-size:0.9em; color:var(--text2);">Error: O(R^${k-1})</p>
                        </div>
                    `;
                    
                    content += `</div>`;
                    grid.innerHTML += content;
                });
            } else {
                // Multiple radii mode
                const radiiStr = document.getElementById('multiRadii').value;
                const radii = radiiStr.split(',').map(r => parseInt(r.trim())).filter(r => !isNaN(r) && r > 0);
                
                if (radii.length === 0) {
                    grid.innerHTML = '<p style="color:var(--red);">Please enter valid radii (e.g., 10, 20, 30)</p>';
                    return;
                }
                
                dims.forEach(k => {
                    let content = `
                        <div class="compare-item">
                            <h3 style="color:var(--blue); margin-bottom:15px;">Dimension k = ${k}</h3>
                    `;
                    
                    if (showZeta) {
                        const z = zeta(k);
                        content += `
                            <div style="background:var(--bg); padding:10px; border-radius:6px; margin-bottom:10px;">
                                <p><b>ζ(${k}):</b> ${z.toFixed(6)}</p>
                                <p><b>Density:</b> ${((1/z)*100).toFixed(2)}%</p>
                            </div>
                        `;
                    }
                    
                    content += '<table style="width:100%; font-size:0.9em;"><thead><tr><th>R</th><th>Predicted</th>';
                    if (showVolume) content += '<th>Volume</th>';
                    content += '</tr></thead><tbody>';
                    
                    radii.forEach(R => {
                        const vol = sphereVolume(k, R);
                        const pred = Math.round(vol / zeta(k));
                        content += `<tr><td>${R}</td><td>${pred.toLocaleString()}</td>`;
                        if (showVolume) content += `<td>${vol.toExponential(2)}</td>`;
                        content += '</tr>';
                    });
                    
                    content += '</tbody></table></div>';
                    grid.innerHTML += content;
                });
            }
            
            // Update chart
            if (showChart) {
                document.getElementById('comparisonChart').style.display = 'block';
                updateComparisonChart(dims);
            } else {
                document.getElementById('comparisonChart').style.display = 'none';
            }
        }

        function updateComparisonChart(dims) {
            const canvas = document.getElementById('compChart');
            const ctx = canvas.getContext('2d');
            
            if (comparisonChart) comparisonChart.destroy();
            
            const colors = ['#0066cc', '#ffc107', '#00d4ff', '#ff006e', '#28a745', '#6f42c1', '#fd7e14', '#dc3545', '#20c997'];
            
            if (comparisonMode === 'fixed') {
                const R = parseInt(document.getElementById('crinput').value);
                
                const data = dims.map(k => {
                    const vol = sphereVolume(k, R);
                    return Math.round(vol / zeta(k));
                });
                
                comparisonChart = new Chart(ctx, {
                    type: 'bar',
                    data: {
                        labels: dims.map(k => `k=${k}`),
                        datasets: [{
                            label: `Primitive Points (R=${R})`,
                            data: data,
                            backgroundColor: dims.map((k, i) => colors[i % colors.length]),
                            borderColor: dims.map((k, i) => colors[i % colors.length]),
                            borderWidth: 2
                        }]
                    },
                    options: {
                        responsive: true,
                        scales: {
                            y: {
                                type: 'logarithmic',
                                title: { display: true, text: 'Number of Primitive Points', font: { size: 14 } }
                            },
                            x: {
                                title: { display: true, text: 'Dimension', font: { size: 14 } }
                            }
                        },
                        plugins: {
                            title: {
                                display: true,
                                text: `Primitive Lattice Points Across Dimensions (R=${R})`,
                                font: { size: 16, weight: 'bold' }
                            },
                            legend: { display: true }
                        }
                    }
                });
            } else {
                // Multiple radii - show lines
                const radiiStr = document.getElementById('multiRadii').value;
                const radii = radiiStr.split(',').map(r => parseInt(r.trim())).filter(r => !isNaN(r) && r > 0);
                
                const datasets = dims.map((k, i) => {
                    const data = radii.map(R => {
                        const vol = sphereVolume(k, R);
                        return { x: R, y: Math.round(vol / zeta(k)) };
                    });
                    
                    return {
                        label: `k=${k}`,
                        data: data,
                        borderColor: colors[i % colors.length],
                        backgroundColor: colors[i % colors.length] + '33',
                        borderWidth: 2,
                        tension: 0.1,
                        fill: false
                    };
                });
                
                comparisonChart = new Chart(ctx, {
                    type: 'line',
                    data: { datasets },
                    options: {
                        responsive: true,
                        scales: {
                            y: {
                                type: 'logarithmic',
                                title: { display: true, text: 'Number of Primitive Points', font: { size: 14 } }
                            },
                            x: {
                                title: { display: true, text: 'Radius R', font: { size: 14 } }
                            }
                        },
                        plugins: {
                            title: {
                                display: true,
                                text: 'Primitive Lattice Points Growth Across Dimensions',
                                font: { size: 16, weight: 'bold' }
                            },
                            legend: { display: true }
                        }
                    }
                });
            }
        }

        function exportComparisonChart() {
            if (!comparisonChart) {
                alert('Please generate a comparison chart first');
                return;
            }
            exportCanvas('compChart', 'dimension-comparison-chart');
        }

        function updateComparison() {
            const grid = document.getElementById('compGrid');
            const showDensity = document.getElementById('showDensity').checked;
            const showVolume = document.getElementById('showVolume').checked;
            const showZeta = document.getElementById('showZeta').checked;
            const showChart = document.getElementById('showChart').checked;
            
            const dims = [];
            for (let k = 2; k <= 10; k++) {
                if (document.getElementById(`compk${k}`)?.checked) dims.push(k);
            }
            
            if (dims.length === 0) {
                grid.innerHTML = '<p style="color:var(--red);">Please select at least one dimension</p>';
                return;
            }
            
            grid.innerHTML = '';
            
            if (comparisonMode === 'fixed') {
                const R = parseInt(document.getElementById('crinput').value);
                
                dims.forEach(k => {
                    const z = zeta(k);
                    const vol = sphereVolume(k, R);
                    const pred = Math.round(vol / z);
                    const density = (1/z * 100).toFixed(2);
                    
                    let content = `
                        <div class="compare-item">
                            <h3 style="color:var(--blue); margin-bottom:15px;">Dimension k = ${k}</h3>
                            <div style="background:var(--bg); padding:10px; border-radius:6px; margin-bottom:10px;">
                                <p style="font-size:1.1em;"><b>Predicted Points:</b> ${pred.toLocaleString()}</p>
                            </div>
                    `;
                    
                    if (showZeta) {
                        content += `
                            <div style="background:var(--bg); padding:10px; border-radius:6px; margin-bottom:10px;">
                                <p><b>ζ(${k}):</b> ${z.toFixed(6)}</p>
                            </div>
                        `;
                    }
                    
                    if (showDensity) {
                        content += `
                            <div style="background:var(--bg); padding:10px; border-radius:6px; margin-bottom:10px;">
                                <p><b>Primitive Density:</b> ${density}%</p>
                                <p style="font-size:0.9em; color:var(--text2);">1/ζ(${k}) = ${(1/z).toFixed(6)}</p>
                            </div>
                        `;
                    }
                    
                    if (showVolume) {
                        content += `
                            <div style="background:var(--bg); padding:10px; border-radius:6px; margin-bottom:10px;">
                                <p><b>Sphere Volume:</b></p>
                                <p style="font-size:0.95em;">${vol.toExponential(4)}</p>
                            </div>
                        `;
                    }
                    
                    // Add growth rate info
                    content += `
                        <div style="background:var(--bg); padding:10px; border-radius:6px; margin-bottom:10px;">
                            <p><b>Growth Rate:</b> O(R^${k})</p>
                            <p style="font-size:0.9em; color:var(--text2);">Error: O(R^${k-1})</p>
                        </div>
                    `;
                    
                    content += `</div>`;
                    grid.innerHTML += content;
                });
            } else {
                // Multiple radii mode
                const radiiStr = document.getElementById('multiRadii').value;
                const radii = radiiStr.split(',').map(r => parseInt(r.trim())).filter(r => !isNaN(r) && r > 0);
                
                if (radii.length === 0) {
                    grid.innerHTML = '<p style="color:var(--red);">Please enter valid radii (e.g., 10, 20, 30)</p>';
                    return;
                }
                
                dims.forEach(k => {
                    let content = `
                        <div class="compare-item">
                            <h3 style="color:var(--blue); margin-bottom:15px;">Dimension k = ${k}</h3>
                    `;
                    
                    if (showZeta) {
                        const z = zeta(k);
                        content += `
                            <div style="background:var(--bg); padding:10px; border-radius:6px; margin-bottom:10px;">
                                <p><b>ζ(${k}):</b> ${z.toFixed(6)}</p>
                                <p><b>Density:</b> ${((1/z)*100).toFixed(2)}%</p>
                            </div>
                        `;
                    }
                    
                    content += '<table style="width:100%; font-size:0.9em;"><thead><tr><th>R</th><th>Predicted</th>';
                    if (showVolume) content += '<th>Volume</th>';
                    content += '</tr></thead><tbody>';
                    
                    radii.forEach(R => {
                        const vol = sphereVolume(k, R);
                        const pred = Math.round(vol / zeta(k));
                        content += `<tr><td>${R}</td><td>${pred.toLocaleString()}</td>`;
                        if (showVolume) content += `<td>${vol.toExponential(2)}</td>`;
                        content += '</tr>';
                    });
                    
                    content += '</tbody></table></div>';
                    grid.innerHTML += content;
                });
            }
            
            // Update chart
            if (showChart) {
                document.getElementById('comparisonChart').style.display = 'block';
                updateComparisonChart(dims);
            } else {
                document.getElementById('comparisonChart').style.display = 'none';
            }
        }

        function updateAnalysisRadius(value) {
            const R = parseInt(value);
            if (R < 10 || R > 300 || isNaN(R)) return;
            
            document.getElementById('mrv').textContent = R;
            document.getElementById('mr').value = Math.min(R, 200);
            document.getElementById('mrinput').value = R;
        }

        function runAnalysis() {
            const canvas = document.getElementById('ch');
            const ctx = canvas.getContext('2d');
            const k = parseInt(document.getElementById('analysisK').value);
            const maxR = parseInt(document.getElementById('mrinput').value);
            const minR = parseInt(document.getElementById('minr').value);
            
            const showAbsError = document.getElementById('showAbsError').checked;
            const showRelError = document.getElementById('showRelError').checked;
            const showBoundary = document.getElementById('showBoundary').checked;
            const showActualCount = document.getElementById('showActualCount').checked;
            
            document.getElementById('loadAnalysis').classList.add('active');
            
            setTimeout(() => {
                if (chart) chart.destroy();
                
                const labels = [];
                const absErrorData = [];
                const relErrorData = [];
                const boundaryData = [];
                const actualCountData = [];
                
                // Compute for each radius from minR to maxR
                for (let R = minR; R <= maxR; R++) {
                    labels.push(R);
                    
                    const vol = sphereVolume(k, R);
                    const pred = Math.round(vol / zeta(k));
                    
                    let actual = pred; // Use prediction for large values
                    
                    // Only compute actual count for small enough cases
                    if (k === 2 && R <= 100) {
                        actual = 0;
                        for (let x = -R; x <= R; x++)
                            for (let y = -R; y <= R; y++)
                                if (x*x + y*y <= R*R && gcd(Math.abs(x), Math.abs(y)) === 1) actual++;
                    } else if (k === 3 && R <= 30) {
                        actual = 0;
                        for (let x = -R; x <= R; x++)
                            for (let y = -R; y <= R; y++)
                                for (let z = -R; z <= R; z++)
                                    if (x*x + y*y + z*z <= R*R && gcdArray([Math.abs(x), Math.abs(y), Math.abs(z)]) === 1) actual++;
                    }
                    
                    const absError = Math.abs(pred - actual);
                    const relError = pred > 0 ? (absError / pred) * 100 : 0;
                    const boundary = Math.pow(R, k - 1);
                    
                    absErrorData.push(absError);
                    relErrorData.push(relError);
                    boundaryData.push(boundary);
                    actualCountData.push(actual);
                }
                
                const datasets = [];
                
                if (showActualCount) {
                    datasets.push({
                        label: `Actual Primitive Count (k=${k})`,
                        data: actualCountData,
                        backgroundColor: 'rgba(0, 102, 204, 0.5)',
                        borderColor: '#0066cc',
                        borderWidth: 1,
                        type: 'bar',
                        yAxisID: 'y1',
                        order: 4
                    });
                }
                
                if (showAbsError) {
                    datasets.push({
                        label: `Absolute Error |Pred - Actual| (k=${k})`,
                        data: absErrorData,
                        backgroundColor: 'rgba(220, 53, 69, 0.6)',
                        borderColor: '#dc3545',
                        borderWidth: 2,
                        type: 'bar',
                        yAxisID: 'y',
                        order: 3
                    });
                }
                
                if (showRelError) {
                    datasets.push({
                        label: `Relative Error % (k=${k})`,
                        data: relErrorData,
                        backgroundColor: 'rgba(255, 193, 7, 0.6)',
                        borderColor: '#ffc107',
                        borderWidth: 2,
                        pointRadius: 3,
                        pointHoverRadius: 5,
                        type: 'line',
                        yAxisID: 'y2',
                        order: 2,
                        fill: false
                    });
                }
                
                if (showBoundary) {
                    datasets.push({
                        label: `Theoretical Boundary R^${k-1}`,
                        data: boundaryData,
                        backgroundColor: 'rgba(111, 66, 193, 0.3)',
                        borderColor: '#6f42c1',
                        borderWidth: 2,
                        borderDash: [5, 5],
                        pointRadius: 2,
                        type: 'line',
                        yAxisID: 'y',
                        order: 1,
                        fill: false
                    });
                }
                
                const scales = {
                    x: { 
                        title: { display: true, text: 'Radius R', font: { size: 14 } }
                    },
                    y: {
                        type: 'logarithmic',
                        position: 'left',
                        title: { display: true, text: 'Count / Error', font: { size: 14 } },
                        display: showAbsError || showBoundary || showActualCount
                    }
                };
                
                if (showActualCount) {
                    scales.y1 = {
                        type: 'logarithmic',
                        position: 'right',
                        title: { display: true, text: 'Actual Count', font: { size: 14 } },
                        grid: { drawOnChartArea: false }
                    };
                }
                
                if (showRelError) {
                    scales.y2 = {
                        type: 'linear',
                        position: 'right',
                        title: { display: true, text: 'Relative Error %', font: { size: 14 } },
                        grid: { drawOnChartArea: false }
                    };
                }
                
                chart = new Chart(ctx, {
                    type: 'bar',
                    data: { labels, datasets },
                    options: { 
                        responsive: true,
                        maintainAspectRatio: true,
                        scales,
                        plugins: {
                            legend: { 
                                display: true,
                                position: 'top',
                                labels: { font: { size: 11 } }
                            },
                            title: {
                                display: true,
                                text: `Error Analysis per Radius (k=${k}, R=${minR} to ${maxR})`,
                                font: { size: 16, weight: 'bold' }
                            },
                            tooltip: { 
                                mode: 'index', 
                                intersect: false,
                                callbacks: {
                                    label: function(context) {
                                        let label = context.dataset.label || '';
                                        if (label) label += ': ';
                                        if (context.parsed.y !== null) {
                                            if (label.includes('%')) {
                                                label += context.parsed.y.toFixed(4) + '%';
                                            } else {
                                                label += context.parsed.y.toLocaleString(undefined, {
                                                    minimumFractionDigits: 0,
                                                    maximumFractionDigits: 2
                                                });
                                            }
                                        }
                                        return label;
                                    }
                                }
                            }
                        },
                        interaction: {
                            mode: 'index',
                            intersect: false
                        }
                    }
                });
                
                document.getElementById('loadAnalysis').classList.remove('active');
            }, 100);
        }

        function set2DPreset(preset) {
            const presets = {
                'small': 10,
                'medium': 50,
                'large': 100,
                'xlarge': 200
            };
            update2DRadius(presets[preset]);
        }

        function set3DPreset(preset) {
            const presets = {
                'tiny': 5,
                'small': 10,
                'medium': 20,
                'large': 30
            };
            document.getElementById('r3').value = presets[preset];
            document.getElementById('r3v').textContent = presets[preset];
            draw3D();
        }

        function setComparisonPreset(preset) {
            // Uncheck all dimensions first
            for (let k = 2; k <= 10; k++) {
                const checkbox = document.getElementById(`compk${k}`);
                if (checkbox) checkbox.checked = false;
            }
            
            if (preset === 'low') {
                [2, 3, 4].forEach(k => document.getElementById(`compk${k}`).checked = true);
            } else if (preset === 'mid') {
                [3, 4, 5, 6].forEach(k => document.getElementById(`compk${k}`).checked = true);
            } else if (preset === 'high') {
                [5, 6, 7, 8, 9, 10].forEach(k => document.getElementById(`compk${k}`).checked = true);
            } else if (preset === 'all') {
                for (let k = 2; k <= 10; k++) {
                    document.getElementById(`compk${k}`).checked = true;
                }
            } else if (preset === 'growth') {
                setComparisonMode('multi');
                [2, 3, 4, 5].forEach(k => document.getElementById(`compk${k}`).checked = true);
                document.getElementById('multiRadii').value = '5, 10, 15, 20, 25, 30';
            }
            
            updateComparison();
        }

        function setAnalysisPreset(preset) {
            if (preset === 'quick') {
                updateAnalysisRadius(50);
            } else if (preset === 'standard') {
                updateAnalysisRadius(100);
            } else if (preset === 'detailed') {
                updateAnalysisRadius(150);
            } else if (preset === 'absolute') {
                document.getElementById('showAbsError').checked = true;
                document.getElementById('showRelError').checked = false;
                document.getElementById('showBoundary').checked = false;
                document.getElementById('showActualCount').checked = false;
            } else if (preset === 'relative') {
                document.getElementById('showAbsError').checked = false;
                document.getElementById('showRelError').checked = true;
                document.getElementById('showBoundary').checked = false;
                document.getElementById('showActualCount').checked = false;
            } else if (preset === 'boundary') {
                document.getElementById('showAbsError').checked = false;
                document.getElementById('showRelError').checked = false;
                document.getElementById('showBoundary').checked = true;
                document.getElementById('showActualCount').checked = false;
            }
            
            runAnalysis();
        }

        function setGCDPreset(preset) {
            const presets = {
                'coprime': '15, 28',
                'common': '12, 18, 24',
                'large': '1024, 2048, 4096',
                'many': '60, 72, 90, 120, 150'
            };
            document.getElementById('gi').value = presets[preset];
            calcGCD();
        }

        function setMobiusPreset(preset) {
            const presets = {
                'squarefree': 30,
                'notsquarefree': 72,
                'prime': 17,
                'composite': 210
            };
            document.getElementById('mi').value = presets[preset];
            calcMobius();
        }

        function setPrimePreset(preset) {
            const presets = {
                'small': 60,
                'perfect': 28,
                'highly': 5040,
                'large': 65536,
                'power': 243
            };
            document.getElementById('pi').value = presets[preset];
            calcPrime();
        }

        function setCoprimePreset(preset) {
            const presets = {
                'coprime2': '35, 64',
                'notcoprime2': '24, 36',
                'coprime3': '7, 11, 13',
                'consecutive': '100, 101, 102'
            };
            document.getElementById('cci').value = presets[preset];
            checkCoprime();
        }

        function setPointPreset(preset) {
            const presets = {
                'pythagorean': '3, 4, 5',
                'primitive2d': '7, 9',
                'nonprimitive2d': '6, 8',
                'primitive3d': '1, 2, 3',
                'highd': '1, 1, 1, 1, 1'
            };
            document.getElementById('psi').value = presets[preset];
            searchPoint();
        }

        function calcGCD() {
            const inp = document.getElementById('gi').value;
            const nums = inp.split(',').map(n => parseInt(n.trim())).filter(n => !isNaN(n));
            if (nums.length < 2) {
                document.getElementById('gr').innerHTML = '<p style="color:var(--red)">Need 2+ numbers</p>';
                return;
            }
            const g = gcdArray(nums);
            const coprime = g === 1 ? '<span style="color:var(--green)">✓ Coprime</span>' : '<span style="color:var(--red)">✗ Not Coprime</span>';
            
            // Show step-by-step GCD calculation for pairs
            let steps = '<div style="background:var(--bg3); padding:15px; border-radius:8px; margin-top:10px;">';
            steps += '<b>Step-by-step calculation:</b><br>';
            let current = nums[0];
            for (let i = 1; i < nums.length; i++) {
                const prev = current;
                current = gcd(current, nums[i]);
                steps += `gcd(${prev}, ${nums[i]}) = ${current}<br>`;
            }
            steps += '</div>';
            
            // Prime factorizations
            let factorizations = '<div style="background:var(--bg3); padding:15px; border-radius:8px; margin-top:10px;">';
            factorizations += '<b>Prime factorizations:</b><br>';
            nums.forEach(n => {
                const f = primeFactors(Math.abs(n));
                const fc = {};
                f.forEach(p => fc[p] = (fc[p]||0) + 1);
                const fs = Object.entries(fc).map(([p,c]) => c>1 ? `${p}^${c}` : p).join(' × ');
                factorizations += `${n} = ${fs || '1'}<br>`;
            });
            
            // GCD factorization
            if (g > 1) {
                const gf = primeFactors(g);
                const gfc = {};
                gf.forEach(p => gfc[p] = (gfc[p]||0) + 1);
                const gfs = Object.entries(gfc).map(([p,c]) => c>1 ? `${p}^${c}` : p).join(' × ');
                factorizations += `<br><b>GCD = ${g} = ${gfs}</b>`;
            }
            factorizations += '</div>';
            
            document.getElementById('gr').innerHTML = `
                <p><b>Numbers:</b> ${nums.join(', ')}</p>
                <p><b>GCD:</b> ${g}</p>
                <p>${coprime}</p>
                ${steps}
                ${factorizations}
            `;
        }

        function calcMobius() {
            const n = parseInt(document.getElementById('mi').value);
            if (!n || n < 1) return;
            const mu = mobius(n), f = primeFactors(n);
            const u = [...new Set(f)];
            const sqfree = f.length === u.length;
            const interp = mu === 0 ? 'Not square-free (has repeated prime factors)' : mu === 1 ? 'Even number of distinct prime factors' : 'Odd number of distinct prime factors';
            
            // Build prime factorization display
            const fc = {};
            f.forEach(p => fc[p] = (fc[p]||0) + 1);
            const fs = Object.entries(fc).map(([p,c]) => c>1 ? `${p}^${c}` : p).join(' × ');
            const repeatedPrimes = Object.entries(fc).filter(([p,c]) => c > 1).map(([p,c]) => `${p} (appears ${c} times)`);
            
            let details = '<div style="background:var(--bg3); padding:15px; border-radius:8px; margin-top:10px;">';
            details += `<b>Prime factorization:</b> ${n} = ${fs || '1'}<br>`;
            details += `<b>Distinct primes:</b> {${u.join(', ')}}<br>`;
            details += `<b>Number of distinct primes:</b> ${u.length}<br>`;
            if (repeatedPrimes.length > 0) {
                details += `<b>Repeated primes:</b> ${repeatedPrimes.join(', ')}<br>`;
            }
            details += `<b>Square-free:</b> ${sqfree ? '✓ Yes' : '✗ No'}<br>`;
            details += '</div>';
            
            let formula = '<div style="background:var(--bg3); padding:15px; border-radius:8px; margin-top:10px;">';
            formula += '<b>Formula calculation:</b><br>';
            if (mu === 0) {
                formula += `μ(${n}) = 0 (not square-free)<br>`;
            } else {
                formula += `μ(${n}) = (-1)^${u.length} = (-1)^${u.length} = ${mu}<br>`;
            }
            formula += '</div>';
            
            document.getElementById('mr2').innerHTML = `
                <p style="font-size:1.3em;"><b>μ(${n}) = ${mu}</b></p>
                <p style="color:var(--blue);"><b>${interp}</b></p>
                ${details}
                ${formula}
            `;
        }

        function calcPrime() {
            const n = parseInt(document.getElementById('pi').value);
            if (!n || n < 2) return;
            const f = primeFactors(n);
            const fc = {};
            f.forEach(p => fc[p] = (fc[p]||0) + 1);
            const fs = Object.entries(fc).map(([p,c]) => c>1 ? `${p}^${c}` : p).join(' × ');
            
            let details = '<div style="background:var(--bg3); padding:15px; border-radius:8px; margin-top:10px;">';
            details += '<b>Detailed breakdown:</b><br>';
            details += `<b>All prime factors:</b> ${f.join(' × ')}<br>`;
            details += `<b>Distinct primes:</b> ${Object.keys(fc).join(', ')}<br>`;
            details += `<b>Number of distinct primes:</b> ${Object.keys(fc).length}<br>`;
            details += `<b>Total number of prime factors (with repetition):</b> ${f.length}<br>`;
            
            // Show exponent breakdown
            details += '<br><b>Exponent breakdown:</b><br>';
            Object.entries(fc).forEach(([p, c]) => {
                details += `${p} appears ${c} time${c > 1 ? 's' : ''}<br>`;
            });
            
            // Divisor information
            const numDivisors = Object.values(fc).reduce((prod, exp) => prod * (exp + 1), 1);
            details += `<br><b>Number of divisors:</b> ${numDivisors}<br>`;
            
            // Sum of divisors (for small numbers)
            if (n <= 1000) {
                let sumDiv = 0;
                for (let i = 1; i <= n; i++) {
                    if (n % i === 0) sumDiv += i;
                }
                details += `<b>Sum of divisors:</b> ${sumDiv}<br>`;
                const perfect = sumDiv === 2 * n;
                const abundant = sumDiv > 2 * n;
                const deficient = sumDiv < 2 * n;
                details += `<b>Number type:</b> ${perfect ? 'Perfect' : abundant ? 'Abundant' : 'Deficient'}<br>`;
            }
            
            details += '</div>';
            
            document.getElementById('pr').innerHTML = `
                <p style="font-size:1.3em;"><b>${n} = ${fs}</b></p>
                <p style="font-size:1.1em;">${isPrime(n) ? '<span style="color:var(--green)">✓ PRIME NUMBER</span>' : '<span style="color:var(--blue)">COMPOSITE NUMBER</span>'}</p>
                ${details}
            `;
        }

        function checkCoprime() {
            const inp = document.getElementById('cci').value;
            const nums = inp.split(',').map(n => parseInt(n.trim())).filter(n => !isNaN(n));
            if (nums.length < 2) {
                document.getElementById('ccr').innerHTML = '<p style="color:var(--red)">Need 2+ numbers</p>';
                return;
            }
            const g = gcdArray(nums);
            const coprime = g === 1;
            
            // Prime factorizations
            let factorInfo = '<div style="background:var(--bg3); padding:15px; border-radius:8px; margin-top:10px;">';
            factorInfo += '<b>Prime factorizations:</b><br>';
            nums.forEach(n => {
                const f = primeFactors(Math.abs(n));
                const fc = {};
                f.forEach(p => fc[p] = (fc[p]||0) + 1);
                const fs = Object.entries(fc).map(([p,c]) => c>1 ? `${p}^${c}` : p).join(' × ');
                factorInfo += `${n} = ${fs || '1'}<br>`;
            });
            factorInfo += '</div>';
            
            // Common factors
            let commonInfo = '<div style="background:var(--bg3); padding:15px; border-radius:8px; margin-top:10px;">';
            if (coprime) {
                commonInfo += '<b>Common factors:</b> Only 1 (coprime)<br>';
                commonInfo += 'These numbers share no prime factors.';
            } else {
                const gf = primeFactors(g);
                const gfc = {};
                gf.forEach(p => gfc[p] = (gfc[p]||0) + 1);
                const gfs = Object.entries(gfc).map(([p,c]) => c>1 ? `${p}^${c}` : p).join(' × ');
                commonInfo += `<b>Common factors:</b> Divisors of ${g}<br>`;
                commonInfo += `<b>GCD breakdown:</b> ${g} = ${gfs}<br>`;
                commonInfo += `<b>Shared primes:</b> ${Object.keys(gfc).join(', ')}`;
            }
            commonInfo += '</div>';
            
            document.getElementById('ccr').innerHTML = `
                <p><b>Numbers:</b> ${nums.join(', ')}</p>
                <p><b>GCD:</b> ${g}</p>
                <p style="font-size:1.2em; margin-top:10px">${coprime ? '<span style="color:var(--green)">✓ COPRIME (Primitive point)</span>' : '<span style="color:var(--red)">✗ NOT COPRIME (Non-primitive)</span>'}</p>
                ${factorInfo}
                ${commonInfo}
            `;
        }

        function searchPoint() {
            const inp = document.getElementById('psi').value;
            const coords = inp.split(',').map(n => parseInt(n.trim())).filter(n => !isNaN(n));
            if (coords.length < 2) {
                document.getElementById('psr').innerHTML = '<p style="color:var(--red)">Need 2+ coordinates</p>';
                return;
            }
            const g = gcdArray(coords);
            const isPrim = g === 1;
            const dist = Math.sqrt(coords.reduce((sum, x) => sum + x*x, 0));
            
            // Point factorization
            let pointInfo = '<div style="background:var(--bg3); padding:15px; border-radius:8px; margin-top:10px;">';
            pointInfo += '<b>Coordinate factorizations:</b><br>';
            coords.forEach((c, i) => {
                const label = ['x', 'y', 'z', 'w', 'v', 'u'][i] || `x${i}`;
                if (c === 0) {
                    pointInfo += `${label} = 0<br>`;
                } else {
                    const f = primeFactors(Math.abs(c));
                    const fc = {};
                    f.forEach(p => fc[p] = (fc[p]||0) + 1);
                    const fs = Object.entries(fc).map(([p,cnt]) => cnt>1 ? `${p}^${cnt}` : p).join(' × ');
                    const sign = c < 0 ? '-' : '';
                    pointInfo += `${label} = ${sign}${fs || '1'}<br>`;
                }
            });
            pointInfo += '</div>';
            
            // GCD analysis
            let gcdInfo = '<div style="background:var(--bg3); padding:15px; border-radius:8px; margin-top:10px;">';
            if (g === 1) {
                gcdInfo += '<b>GCD Analysis:</b><br>';
                gcdInfo += 'GCD = 1 → Coordinates are coprime<br>';
                gcdInfo += 'This point cannot be expressed as d·(simpler point) where d > 1';
            } else {
                const reduced = coords.map(c => c / g);
                const gf = primeFactors(g);
                const gfc = {};
                gf.forEach(p => gfc[p] = (gfc[p]||0) + 1);
                const gfs = Object.entries(gfc).map(([p,c]) => c>1 ? `${p}^${c}` : p).join(' × ');
                gcdInfo += '<b>GCD Analysis:</b><br>';
                gcdInfo += `GCD = ${g} = ${gfs}<br>`;
                gcdInfo += `<b>Reduced form:</b> (${reduced.join(', ')}) is the primitive point<br>`;
                gcdInfo += `<b>Relationship:</b> (${coords.join(', ')}) = ${g} × (${reduced.join(', ')})`;
            }
            gcdInfo += '</div>';
            
            // Geometric properties
            let geomInfo = '<div style="background:var(--bg3); padding:15px; border-radius:8px; margin-top:10px;">';
            geomInfo += '<b>Geometric Properties:</b><br>';
            geomInfo += `<b>Euclidean norm:</b> ||point|| = √(${coords.map(c => c + '²').join(' + ')}) = ${dist.toFixed(4)}<br>`;
            geomInfo += `<b>Manhattan distance:</b> ${coords.reduce((sum, c) => sum + Math.abs(c), 0)}<br>`;
            geomInfo += `<b>Max coordinate:</b> ${Math.max(...coords.map(Math.abs))}<br>`;
            const numZeros = coords.filter(c => c === 0).length;
            if (numZeros > 0) {
                geomInfo += `<b>Zero coordinates:</b> ${numZeros} (lies on ${coords.length - numZeros}D subspace)`;
            }
            geomInfo += '</div>';
            
            document.getElementById('psr').innerHTML = `
                <p><b>Point:</b> (${coords.join(', ')})</p>
                <p><b>Dimension:</b> ${coords.length}</p>
                <p><b>GCD of coordinates:</b> ${g}</p>
                <p style="font-size:1.2em; margin-top:10px">${isPrim ? '<span style="color:var(--green)">✓ PRIMITIVE LATTICE POINT</span>' : '<span style="color:var(--red)">✗ NON-PRIMITIVE LATTICE POINT</span>'}</p>
                ${pointInfo}
                ${gcdInfo}
                ${geomInfo}
            `;
        }

        function exportCanvas(canvasId, filename) {
            const canvas = document.getElementById(canvasId);
            const link = document.createElement('a');
            link.download = `${filename}.png`;
            link.href = canvas.toDataURL();
            link.click();
        }

        function exportPointData2D() {
            if (!cache.points2D) { alert('Generate 2D visualization first'); return; }
            const data = cache.points2D;
            let csv = 'x,y,type\n';
            data.primitive.forEach(p => csv += `${p.x},${p.y},primitive\n`);
            data.nonPrimitive.forEach(p => csv += `${p.x},${p.y},non-primitive\n`);
            downloadCSV(csv, '2d-lattice-points.csv');
        }

        function export3DData() {
            if (!cache.points3D) { alert('Generate 3D visualization first'); return; }
            const data = cache.points3D;
            let csv = 'x,y,z,type\n';
            data.primitive.forEach(p => csv += `${p.x},${p.y},${p.z},primitive\n`);
            data.nonPrimitive.forEach(p => csv += `${p.x},${p.y},${p.z},non-primitive\n`);
            downloadCSV(csv, '3d-lattice-points.csv');
        }

        function exportTheoryData() {
            const k = parseInt(document.getElementById('tks').value);
            const R = parseInt(document.getElementById('trs').value);
            const z = zeta(k);
            const vol = sphereVolume(k, R);
            const pred = Math.round(vol / z);
            
            let csv = 'dimension,radius,zeta,density,volume,predicted_points\n';
            csv += `${k},${R},${z},${1/z},${vol},${pred}\n`;
            downloadCSV(csv, 'theory-data.csv');
        }

        function exportChartData() {
            if (!chart) { alert('Run analysis first'); return; }
            const data = chart.data.datasets[0].data;
            let csv = 'radius,error\n';
            data.forEach(pt => csv += `${pt.x},${pt.y}\n`);
            downloadCSV(csv, 'error-analysis.csv');
        }

        function exportComparisonData() {
            const showDensity = document.getElementById('showDensity').checked;
            const showVolume = document.getElementById('showVolume').checked;
            const showZeta = document.getElementById('showZeta').checked;
            
            const dims = [];
            for (let k = 2; k <= 10; k++) {
                if (document.getElementById(`compk${k}`)?.checked) dims.push(k);
            }
            
            let csv = 'dimension,';
            if (comparisonMode === 'fixed') {
                csv += 'radius,';
            }
            if (showZeta) csv += 'zeta,';
            if (showDensity) csv += 'density,';
            csv += 'predicted_points';
            if (showVolume) csv += ',volume';
            csv += '\n';
            
            if (comparisonMode === 'fixed') {
                const R = parseInt(document.getElementById('crinput').value);
                dims.forEach(k => {
                    const z = zeta(k);
                    const vol = sphereVolume(k, R);
                    const pred = Math.round(vol / z);
                    csv += `${k},${R},`;
                    if (showZeta) csv += `${z},`;
                    if (showDensity) csv += `${1/z},`;
                    csv += `${pred}`;
                    if (showVolume) csv += `,${vol}`;
                    csv += '\n';
                });
            } else {
                const radiiStr = document.getElementById('multiRadii').value;
                const radii = radiiStr.split(',').map(r => parseInt(r.trim())).filter(r => !isNaN(r) && r > 0);
                
                dims.forEach(k => {
                    const z = zeta(k);
                    radii.forEach(R => {
                        const vol = sphereVolume(k, R);
                        const pred = Math.round(vol / z);
                        csv += `${k},${R},`;
                        if (showZeta) csv += `${z},`;
                        if (showDensity) csv += `${1/z},`;
                        csv += `${pred}`;
                        if (showVolume) csv += `,${vol}`;
                        csv += '\n';
                    });
                });
            }
            
            downloadCSV(csv, 'dimension-comparison.csv');
        }

        function downloadCSV(content, filename) {
            const blob = new Blob([content], { type: 'text/csv' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            link.download = filename;
            link.click();
            URL.revokeObjectURL(url);
        }

        function toggleDark() {
            document.body.classList.toggle('light');
            const btn = document.getElementById('darkBtn');
            btn.textContent = document.body.classList.contains('light') ? 'Dark Mode' : 'Light Mode';
            if (scene) scene.background = new THREE.Color(document.body.classList.contains('light') ? 0xffffff : 0x1a1a1a);
        }

        function showHelp() {
            document.getElementById('helpModal').classList.add('active');
        }

        function closeHelp() {
            document.getElementById('helpModal').classList.remove('active');
        }

        function showDerivationAnimation() {
            alert('Interactive animation coming soon! This would show step-by-step how Möbius inversion leads to the zeta function connection.');
        }

        function setPatternType(type) {
            patternType = type;
            document.querySelectorAll('#patternModular, #patternDensity, #patternAngular, #patternRadial').forEach(btn => btn.classList.remove('active'));
            const btnIds = {
                'modular': 'patternModular',
                'density': 'patternDensity',
                'angular': 'patternAngular',
                'radial': 'patternRadial'
            };
            document.getElementById(btnIds[type]).classList.add('active');
            
            // Show/hide appropriate controls
            document.getElementById('modularPatternControls').style.display = type === 'modular' ? 'block' : 'none';
            document.getElementById('densityPatternControls').style.display = type === 'density' ? 'block' : 'none';
            document.getElementById('angularPatternControls').style.display = type === 'angular' ? 'block' : 'none';
            document.getElementById('radialPatternControls').style.display = type === 'radial' ? 'block' : 'none';
            
            updatePatternViz();
        }

        function updatePatternViz() {
            if (patternType === 'modular') {
                const m = parseInt(document.getElementById('patternMod').value);
                const R = parseInt(document.getElementById('patternR').value);
                const showExpected = document.getElementById('showExpected').checked;
                
                document.getElementById('patternModv').textContent = m;
                document.getElementById('patternRv').textContent = R;
                
                // Count primitive points by residue class
                const counts = new Array(m).fill(0);
                let totalPrimitive = 0;
                
                for (let x = -R; x <= R; x++) {
                    for (let y = -R; y <= R; y++) {
                        if (x*x + y*y <= R*R && gcd(Math.abs(x), Math.abs(y)) === 1) {
                            const residue = ((x + y) % m + m) % m;
                            counts[residue]++;
                            totalPrimitive++;
                        }
                    }
                }
                
                // Expected uniform distribution
                const expected = totalPrimitive / m;
                
                // Display chart
                const canvas = document.getElementById('patternCanvas');
                const ctx = canvas.getContext('2d');
                
                if (patternChart) patternChart.destroy();
                
                const datasets = [{
                    label: 'Observed Count',
                    data: counts,
                    backgroundColor: 'rgba(0, 102, 204, 0.6)',
                    borderColor: '#0066cc',
                    borderWidth: 2
                }];
                
                if (showExpected) {
                    datasets.push({
                        label: 'Expected (Uniform)',
                        data: new Array(m).fill(expected),
                        type: 'line',
                        borderColor: '#dc3545',
                        borderWidth: 2,
                        borderDash: [5, 5],
                        pointRadius: 0,
                        fill: false
                    });
                }
                
                patternChart = new Chart(ctx, {
                    type: 'bar',
                    data: {
                        labels: Array.from({length: m}, (_, i) => i),
                        datasets
                    },
                    options: {
                        responsive: true,
                        scales: {
                            y: {
                                title: { display: true, text: 'Number of Primitive Points', font: { size: 14 } },
                                beginAtZero: true
                            },
                            x: {
                                title: { display: true, text: `Residue Class (x+y) mod ${m}`, font: { size: 14 } }
                            }
                        },
                        plugins: {
                            title: {
                                display: true,
                                text: `Modular Distribution: Primitive Points mod ${m} (R=${R})`,
                                font: { size: 16, weight: 'bold' }
                            },
                            legend: { display: true }
                        }
                    }
                });
                
                // Update stats
                const statsDiv = document.getElementById('patternStats');
                const maxCount = Math.max(...counts);
                const minCount = Math.min(...counts);
                const variance = counts.reduce((sum, c) => sum + Math.pow(c - expected, 2), 0) / m;
                const stdDev = Math.sqrt(variance);
                
                statsDiv.innerHTML = `
                    <div class="stat"><div class="val">${totalPrimitive}</div><div class="lbl">Total Primitive</div></div>
                    <div class="stat"><div class="val">${expected.toFixed(1)}</div><div class="lbl">Expected per Class</div></div>
                    <div class="stat"><div class="val">${maxCount}</div><div class="lbl">Max Count</div></div>
                    <div class="stat"><div class="val">${minCount}</div><div class="lbl">Min Count</div></div>
                    <div class="stat"><div class="val">${stdDev.toFixed(2)}</div><div class="lbl">Std Deviation</div></div>
                `;
                
            } else if (patternType === 'density') {
                const gridSize = parseInt(document.getElementById('gridSizeInput').value) || parseInt(document.getElementById('gridSize').value);
                const R = parseInt(document.getElementById('densityRInput').value) || parseInt(document.getElementById('densityR').value);
                
                document.getElementById('gridSizev').textContent = gridSize;
                document.getElementById('densityRv').textContent = R;
                
                const canvas = document.getElementById('densityCanvas');
                const ctx = canvas.getContext('2d');
                const cellSize = 800 / gridSize;
                
                ctx.clearRect(0, 0, 800, 800);
                
                // Compute density in each grid cell
                const cellR = R / gridSize;
                const densities = [];
                let maxDensity = 0;
                
                for (let i = 0; i < gridSize; i++) {
                    densities[i] = [];
                    for (let j = 0; j < gridSize; j++) {
                        const cx = (i - gridSize/2) * cellR;
                        const cy = (j - gridSize/2) * cellR;
                        
                        let primCount = 0, totalCount = 0;
                        
                        // Count points in this cell
                        for (let x = Math.floor(cx - cellR); x <= Math.ceil(cx + cellR); x++) {
                            for (let y = Math.floor(cy - cellR); y <= Math.ceil(cy + cellR); y++) {
                                const dx = x - cx, dy = y - cy;
                                if (dx*dx + dy*dy <= cellR*cellR) {
                                    totalCount++;
                                    if (gcd(Math.abs(x), Math.abs(y)) === 1) primCount++;
                                }
                            }
                        }
                        
                        const density = totalCount > 0 ? primCount / totalCount : 0;
                        densities[i][j] = density;
                        maxDensity = Math.max(maxDensity, density);
                    }
                }
                
                // Draw heatmap
                for (let i = 0; i < gridSize; i++) {
                    for (let j = 0; j < gridSize; j++) {
                        const density = densities[i][j];
                        const intensity = density / (maxDensity || 1);
                        const hue = 240 - intensity * 240; // Blue to red
                        ctx.fillStyle = `hsl(${hue}, 70%, 50%)`;
                        ctx.fillRect(i * cellSize, j * cellSize, cellSize, cellSize);
                        
                        // Draw border
                        ctx.strokeStyle = 'rgba(255,255,255,0.2)';
                        ctx.strokeRect(i * cellSize, j * cellSize, cellSize, cellSize);
                    }
                }
                
                // Add legend
                ctx.fillStyle = 'rgba(255,255,255,0.9)';
                ctx.fillRect(20, 720, 200, 60);
                ctx.fillStyle = '#000';
                ctx.font = '14px system-ui';
                ctx.fillText('Density Scale:', 30, 740);
                ctx.fillText(`0% → ${(maxDensity * 100).toFixed(1)}%`, 30, 760);
                
            } else if (patternType === 'angular') {
                const numSectors = parseInt(document.getElementById('numSectors').value);
                const R = parseInt(document.getElementById('angularR').value);
                
                document.getElementById('numSectorsv').textContent = numSectors;
                document.getElementById('angularRv').textContent = R;
                
                const sectorCounts = new Array(numSectors).fill(0);
                let totalPrimitive = 0;
                
                for (let x = -R; x <= R; x++) {
                    for (let y = -R; y <= R; y++) {
                        if (x*x + y*y <= R*R && gcd(Math.abs(x), Math.abs(y)) === 1) {
                            const angle = Math.atan2(y, x) + Math.PI; // 0 to 2π
                            const sector = Math.floor(angle / (2 * Math.PI / numSectors)) % numSectors;
                            sectorCounts[sector]++;
                            totalPrimitive++;
                        }
                    }
                }
                
                const expected = totalPrimitive / numSectors;
                
                const canvas = document.getElementById('angularCanvas');
                const ctx = canvas.getContext('2d');
                
                if (patternChart) patternChart.destroy();
                
                patternChart = new Chart(ctx, {
                    type: 'bar',
                    data: {
                        labels: Array.from({length: numSectors}, (_, i) => {
                            const startAngle = (i * 360 / numSectors).toFixed(0);
                            const endAngle = ((i + 1) * 360 / numSectors).toFixed(0);
                            return `${startAngle}°-${endAngle}°`;
                        }),
                        datasets: [{
                            label: 'Primitive Points',
                            data: sectorCounts,
                            backgroundColor: Array.from({length: numSectors}, (_, i) => {
                                const hue = (i / numSectors) * 360;
                                return `hsla(${hue}, 70%, 50%, 0.6)`;
                            }),
                            borderWidth: 2
                        }, {
                            label: 'Expected (Uniform)',
                            data: new Array(numSectors).fill(expected),
                            type: 'line',
                            borderColor: '#dc3545',
                            borderWidth: 2,
                            borderDash: [5, 5],
                            pointRadius: 0,
                            fill: false
                        }]
                    },
                    options: {
                        responsive: true,
                        scales: {
                            y: { title: { display: true, text: 'Count', font: { size: 14 } } },
                            x: { title: { display: true, text: 'Angular Sector', font: { size: 14 } } }
                        },
                        plugins: {
                            title: {
                                display: true,
                                text: `Angular Distribution (${numSectors} sectors, R=${R})`,
                                font: { size: 16, weight: 'bold' }
                            }
                        }
                    }
                });
                
            } else if (patternType === 'radial') {
                const shellThick = parseInt(document.getElementById('shellThick').value);
                const maxR = parseInt(document.getElementById('radialMaxR').value);
                
                document.getElementById('shellThickv').textContent = shellThick;
                document.getElementById('radialMaxRv').textContent = maxR;
                
                const numShells = Math.floor(maxR / shellThick);
                const shellCounts = [];
                const radii = [];
                
                for (let i = 0; i < numShells; i++) {
                    const innerR = i * shellThick;
                    const outerR = (i + 1) * shellThick;
                    radii.push(outerR);
                    
                    let count = 0;
                    for (let x = -outerR; x <= outerR; x++) {
                        for (let y = -outerR; y <= outerR; y++) {
                            const distSq = x*x + y*y;
                            if (distSq > innerR*innerR && distSq <= outerR*outerR && 
                                gcd(Math.abs(x), Math.abs(y)) === 1) {
                                count++;
                            }
                        }
                    }
                    shellCounts.push(count);
                }
                
                const canvas = document.getElementById('radialCanvas');
                const ctx = canvas.getContext('2d');
                
                if (patternChart) patternChart.destroy();
                
                patternChart = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: radii,
                        datasets: [{
                            label: 'Primitive Points in Shell',
                            data: shellCounts,
                            backgroundColor: 'rgba(0, 102, 204, 0.2)',
                            borderColor: '#0066cc',
                            borderWidth: 2,
                            fill: true,
                            tension: 0.3
                        }]
                    },
                    options: {
                        responsive: true,
                        scales: {
                            y: { 
                                title: { display: true, text: 'Count per Shell', font: { size: 14 } },
                                beginAtZero: true
                            },
                            x: { title: { display: true, text: 'Radius', font: { size: 14 } } }
                        },
                        plugins: {
                            title: {
                                display: true,
                                text: `Radial Shell Distribution (thickness=${shellThick})`,
                                font: { size: 16, weight: 'bold' }
                            }
                        }
                    }
                });
            }
        }

        function exportPatternData() {
            if (!patternChart) { alert('Generate a pattern visualization first'); return; }
            
            let csv = '';
            const data = patternChart.data;
            
            if (patternType === 'modular') {
                csv = 'residue_class,count\n';
                data.labels.forEach((label, i) => {
                    csv += `${label},${data.datasets[0].data[i]}\n`;
                });
            } else if (patternType === 'angular') {
                csv = 'sector,count\n';
                data.labels.forEach((label, i) => {
                    csv += `${label},${data.datasets[0].data[i]}\n`;
                });
            } else if (patternType === 'radial') {
                csv = 'radius,count\n';
                data.labels.forEach((label, i) => {
                    csv += `${label},${data.datasets[0].data[i]}\n`;
                });
            }
            
            downloadCSV(csv, `pattern-${patternType}.csv`);
        }

        function set2DLabelMode(mode) {
            labelMode2D = mode;
            document.querySelectorAll('#label2DNone, #label2DGCD, #label2DCoords, #label2DAngle').forEach(btn => btn.classList.remove('active'));
            const btnIds = { 'none': 'label2DNone', 'gcd': 'label2DGCD', 'coords': 'label2DCoords', 'angle': 'label2DAngle' };
            document.getElementById(btnIds[mode]).classList.add('active');
            document.getElementById('labelControls2D').style.display = mode === 'none' ? 'none' : 'block';
            draw2D();
        }

        function set3DLabelMode(mode) {
            labelMode3D = mode;
            document.querySelectorAll('#label3DNone, #label3DGCD, #label3DCoords').forEach(btn => btn.classList.remove('active'));
            const btnIds = { 'none': 'label3DNone', 'gcd': 'label3DGCD', 'coords': 'label3DCoords' };
            document.getElementById(btnIds[mode]).classList.add('active');
            document.getElementById('labelControls3D').style.display = mode === 'none' ? 'none' : 'block';
            draw3D();
        }

        function update3DZoom() {
            if (!camera) return;
            const zoom = parseInt(document.getElementById('zoom3D').value);
            document.getElementById('zoom3Dv').textContent = zoom;
            const angle = Math.atan2(camera.position.y, Math.sqrt(camera.position.x**2 + camera.position.z**2));
            const azimuth = Math.atan2(camera.position.x, camera.position.z);
            camera.position.x = zoom * Math.sin(azimuth) * Math.cos(angle);
            camera.position.z = zoom * Math.cos(azimuth) * Math.cos(angle);
            camera.position.y = zoom * Math.sin(angle);
            camera.lookAt(0, 0, 0);
        }

        function setGCDTablePreset(preset) {
            const presets = { 'small': 20, 'medium': 50, 'large': 100 };
            const size = presets[preset];
            document.getElementById('gcdTableSize').value = size;
            document.getElementById('gcdTableSizeInput').value = size;
            document.getElementById('gcdTableSizev').textContent = size;
            updateGCDTable();
        }

        let gcdTableColorMode = 'heat'; // 'heat', 'discrete', 'prime'

        function setGCDTableColor(mode) {
            gcdTableColorMode = mode;
            document.querySelectorAll('#gcdTableHeat, #gcdTableDiscrete, #gcdTablePrime').forEach(btn => btn.classList.remove('active'));
            const btnIds = { 'heat': 'gcdTableHeat', 'discrete': 'gcdTableDiscrete', 'prime': 'gcdTablePrime' };
            document.getElementById(btnIds[mode]).classList.add('active');
            updateGCDTable();
        }

        function updateGCDTable() {
            const size = parseInt(document.getElementById('gcdTableSizeInput').value) || parseInt(document.getElementById('gcdTableSize').value);
            const showValues = document.getElementById('showGCDValues').checked;
            const highlightDiag = document.getElementById('highlightDiagonal').checked;
            
            document.getElementById('gcdTableSizev').textContent = size;
            document.getElementById('gcdTableSize').value = Math.min(size, 150);
            document.getElementById('gcdTableSizeInput').value = size;
            
            const canvas = document.getElementById('gcdTableCanvas');
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            const cellSize = Math.min(canvas.width / (size + 1), 30); // +1 for labels
            const startX = 40, startY = 40;
            
            // Compute max GCD for normalization
            let maxGCD = 0;
            for (let i = 1; i <= size; i++) {
                for (let j = 1; j <= size; j++) {
                    maxGCD = Math.max(maxGCD, gcd(i, j));
                }
            }
            
            // Store data for click detection
            window.gcdTableData = [];
            
            // Draw cells
            for (let i = 1; i <= size; i++) {
                for (let j = 1; j <= size; j++) {
                    const g = gcd(i, j);
                    const x = startX + (j - 1) * cellSize;
                    const y = startY + (i - 1) * cellSize;
                    
                    let color;
                    if (gcdTableColorMode === 'heat') {
                        const intensity = g / maxGCD;
                        const hue = 240 - intensity * 240; // Blue to red
                        color = `hsl(${hue}, 70%, 50%)`;
                    } else if (gcdTableColorMode === 'discrete') {
                        const colors = ['#0066cc', '#dc3545', '#28a745', '#ffc107', '#6f42c1', '#fd7e14', '#00d4ff', '#ff006e'];
                        color = colors[Math.min(g - 1, 7)];
                    } else if (gcdTableColorMode === 'prime') {
                        color = isPrime(g) ? '#6f42c1' : (g === 1 ? '#0066cc' : '#dc3545');
                    }
                    
                    ctx.fillStyle = color;
                    ctx.fillRect(x, y, cellSize, cellSize);
                    
                    // Highlight diagonal
                    if (highlightDiag && i === j) {
                        ctx.strokeStyle = '#fff';
                        ctx.lineWidth = 2;
                        ctx.strokeRect(x, y, cellSize, cellSize);
                    }
                    
                    // Draw border
                    ctx.strokeStyle = 'rgba(255,255,255,0.1)';
                    ctx.lineWidth = 1;
                    ctx.strokeRect(x, y, cellSize, cellSize);
                    
                    // Draw value
                    if (showValues && cellSize > 12) {
                        ctx.fillStyle = '#fff';
                        ctx.font = `${Math.min(cellSize * 0.4, 12)}px system-ui`;
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText(g, x + cellSize/2, y + cellSize/2);
                    }
                    
                    // Store for click detection
                    window.gcdTableData.push({ i, j, g, x, y, size: cellSize });
                }
            }
            
            // Draw row/column labels
            ctx.fillStyle = getComputedStyle(document.body).getPropertyValue('--text');
            ctx.font = 'bold 10px system-ui';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            
            const labelStep = Math.max(1, Math.floor(size / 20));
            for (let i = 1; i <= size; i += labelStep) {
                // Row labels
                ctx.fillText(i, 20, startY + (i - 0.5) * cellSize);
                // Column labels
                ctx.fillText(i, startX + (i - 0.5) * cellSize, 20);
            }
        }

        function exportGCDTableData() {
            const size = parseInt(document.getElementById('gcdTableSizeInput').value);
            let csv = 'row,column,gcd\n';
            for (let i = 1; i <= size; i++) {
                for (let j = 1; j <= size; j++) {
                    csv += `${i},${j},${gcd(i, j)}\n`;
                }
            }
            downloadCSV(csv, 'gcd-table-data.csv');
        }

        function updateGridSize() {
            const val = parseInt(document.getElementById('gridSizeInput').value) || parseInt(document.getElementById('gridSize').value);
            document.getElementById('gridSizev').textContent = val;
            document.getElementById('gridSize').value = Math.min(val, 50);
            document.getElementById('gridSizeInput').value = val;
        }

        function updateDensityR() {
            const val = parseInt(document.getElementById('densityRInput').value) || parseInt(document.getElementById('densityR').value);
            document.getElementById('densityRv').textContent = val;
            document.getElementById('densityR').value = Math.min(val, 200);
            document.getElementById('densityRInput').value = val;
        }

        function updateHeatmapR() {
            const val = parseInt(document.getElementById('heatmapRinput').value) || parseInt(document.getElementById('heatmapR').value);
            document.getElementById('heatmapRv').textContent = val;
            document.getElementById('heatmapR').value = Math.min(val, 100);
            document.getElementById('heatmapRinput').value = val;
            updateGCDHeatmap();
        }

        function updateCriticalMaxR() {
            const val = parseInt(document.getElementById('criticalMaxRinput').value) || parseInt(document.getElementById('criticalMaxR').value);
            document.getElementById('criticalMaxRv').textContent = val;
            document.getElementById('criticalMaxR').value = Math.min(val, 500);
            document.getElementById('criticalMaxRinput').value = val;
        }

        function updateCriticalStep() {
            const val = parseInt(document.getElementById('criticalStepInput').value) || parseInt(document.getElementById('criticalStep').value);
            document.getElementById('criticalStepv').textContent = val;
            document.getElementById('criticalStep').value = Math.min(val, 10);
            document.getElementById('criticalStepInput').value = val;
        }

        function update2DZoom() {
            zoom2D = parseInt(document.getElementById('zoom2D').value);
            document.getElementById('zoom2Dv').textContent = zoom2D;
            draw2D();
        }

        function formatPrecise(num, maxDecimals = 17) {
            if (Number.isInteger(num)) return num.toString();
            const str = num.toFixed(maxDecimals);
            // Remove trailing zeros
            return str.replace(/\.?0+$/, '');
        }

        let exportResolution = '1k';

        function setExportRes(res) {
            exportResolution = res;
            document.querySelectorAll('#res1k, #res2k, #res4k, #res8k').forEach(btn => btn.classList.remove('active'));
            document.getElementById(`res${res}`).classList.add('active');
        }

        function getExportDimensions() {
            const dims = {
                '1k': [1920, 1080],
                '2k': [2560, 1440],
                '4k': [3840, 2160],
                '8k': [7680, 4320]
            };
            return dims[exportResolution] || [1920, 1080];
        }

        function performAdvancedExport() {
            const canvasId = document.getElementById('exportCanvas').value;
            const sourceCanvas = document.getElementById(canvasId);
            
            if (!sourceCanvas) {
                alert('Please generate the visualization first before exporting');
                return;
            }
            
            const includeMetadata = document.getElementById('includeMetadata').checked;
            const includeTimestamp = document.getElementById('includeTimestamp').checked;
            const includeWatermark = document.getElementById('includeWatermark').checked;
            const title = document.getElementById('exportTitle').value || 'Primitive Lattice Point Analysis';
            const subtitle = document.getElementById('exportSubtitle').value;
            const legend = document.getElementById('exportLegend').value;
            
            const [width, height] = getExportDimensions();
            
            // Create high-res canvas
            const exportCanvas = document.createElement('canvas');
            exportCanvas.width = width;
            exportCanvas.height = height;
            const ctx = exportCanvas.getContext('2d');
            
            // White background
            ctx.fillStyle = document.body.classList.contains('light') ? '#ffffff' : '#1a1a1a';
            ctx.fillRect(0, 0, width, height);
            
            // Calculate layout
            const padding = Math.floor(width * 0.03);
            const titleHeight = includeMetadata ? Math.floor(height * 0.12) : 0;
            const legendWidth = legend && includeMetadata ? Math.floor(width * 0.25) : 0;
            const footerHeight = includeWatermark || includeTimestamp ? Math.floor(height * 0.04) : 0;
            
            const contentWidth = width - 2 * padding - legendWidth;
            const contentHeight = height - titleHeight - footerHeight - 2 * padding;
            const contentX = padding;
            const contentY = titleHeight + padding;
            
            // Draw title
            if (includeMetadata && title) {
                ctx.fillStyle = document.body.classList.contains('light') ? '#212529' : '#e0e0e0';
                ctx.font = `bold ${Math.floor(height * 0.04)}px system-ui`;
                ctx.textAlign = 'center';
                ctx.fillText(title, width / 2, padding + Math.floor(height * 0.035));
                
                if (subtitle) {
                    ctx.font = `${Math.floor(height * 0.025)}px system-ui`;
                    ctx.fillStyle = document.body.classList.contains('light') ? '#495057' : '#b0b0b0';
                    ctx.fillText(subtitle, width / 2, padding + Math.floor(height * 0.07));
                }
            }
            
            // Draw source canvas (scaled to fit)
            const scale = Math.min(contentWidth / sourceCanvas.width, contentHeight / sourceCanvas.height);
            const scaledWidth = sourceCanvas.width * scale;
            const scaledHeight = sourceCanvas.height * scale;
            const centerX = contentX + (contentWidth - scaledWidth) / 2;
            const centerY = contentY + (contentHeight - scaledHeight) / 2;
            
            ctx.drawImage(sourceCanvas, centerX, centerY, scaledWidth, scaledHeight);
            
            // Draw legend
            if (legend && includeMetadata && legendWidth > 0) {
                const legendX = width - legendWidth - padding;
                const legendY = contentY;
                
                ctx.fillStyle = document.body.classList.contains('light') ? '#f8f9fa' : '#2d2d2d';
                ctx.fillRect(legendX, legendY, legendWidth - padding, contentHeight);
                
                ctx.fillStyle = document.body.classList.contains('light') ? '#212529' : '#e0e0e0';
                ctx.font = `bold ${Math.floor(height * 0.02)}px system-ui`;
                ctx.textAlign = 'left';
                ctx.fillText('Legend', legendX + padding / 2, legendY + padding);
                
                const lines = legend.split('\n');
                ctx.font = `${Math.floor(height * 0.016)}px monospace`;
                let yPos = legendY + padding * 2;
                lines.forEach(line => {
                    if (yPos < legendY + contentHeight - padding) {
                        ctx.fillText(line, legendX + padding / 2, yPos);
                        yPos += Math.floor(height * 0.025);
                    }
                });
            }
            
            // Draw footer
            if (includeWatermark || includeTimestamp) {
                const footerY = height - footerHeight;
                ctx.fillStyle = document.body.classList.contains('light') ? '#212529' : '#e0e0e0';
                ctx.font = `${Math.floor(height * 0.018)}px system-ui`;
                ctx.textAlign = 'left';
                
                if (includeWatermark) {
                    ctx.fillText('By Wessen Getachew | @7dview | wessengetachew.github.io', padding, footerY + footerHeight * 0.6);
                }
                
                if (includeTimestamp) {
                    ctx.textAlign = 'right';
                    const timestamp = new Date().toLocaleString();
                    ctx.fillText(`Generated: ${timestamp}`, width - padding, footerY + footerHeight * 0.6);
                }
            }
            
            // Download
            const link = document.createElement('a');
            const filename = `${title.replace(/\s+/g, '-').toLowerCase()}-${exportResolution}.png`;
            link.download = filename;
            link.href = exportCanvas.toDataURL('image/png');
            link.click();
            
            // Show preview
            const previewCanvas = document.getElementById('exportPreviewCanvas');
            previewCanvas.width = 800;
            previewCanvas.height = 450;
            const previewCtx = previewCanvas.getContext('2d');
            previewCtx.drawImage(exportCanvas, 0, 0, 800, 450);
            previewCanvas.style.display = 'block';
            document.getElementById('exportPreview').querySelector('p').style.display = 'none';
        }

        function quickExport2D() {
            document.getElementById('exportCanvas').value = 'c2d';
            const R = document.getElementById('r2input').value;
            document.getElementById('exportTitle').value = '2D Primitive Lattice Points';
            document.getElementById('exportSubtitle').value = `Radius R=${R}, showing ${colorMode2D} coloring`;
            document.getElementById('exportLegend').value = `View Mode: ${view2D}
Color Mode: ${colorMode2D}
Radius: ${R}
Total Points: ${document.getElementById('t2').textContent}
Primitive Points: ${document.getElementById('p2').textContent}
Density: ${document.getElementById('d2').textContent}`;
            showTab('export');
        }

        function quickExport3D() {
            alert('3D export requires screenshot. Use browser screenshot or screen capture tool.');
        }

        function quickExportHeatmap() {
            document.getElementById('exportCanvas').value = 'heatmapCanvas';
            const R = document.getElementById('heatmapRinput').value;
            document.getElementById('exportTitle').value = 'GCD Heatmap Visualization';
            document.getElementById('exportSubtitle').value = `Radius R=${R}, ${heatmapMode} mode`;
            document.getElementById('exportLegend').value = `Display Mode: ${heatmapMode}
Radius: ${R}
Total Points: ${document.getElementById('heatmapTotal').textContent}
GCD=1: ${document.getElementById('heatmapPrim').textContent}
GCD=2: ${document.getElementById('heatmapGCD2').textContent}
GCD=3: ${document.getElementById('heatmapGCD3').textContent}`;
            showTab('export');
        }

        function quickExportCritical() {
            document.getElementById('exportCanvas').value = 'criticalCanvas';
            const maxR = document.getElementById('criticalMaxRinput').value;
            document.getElementById('exportTitle').value = 'Critical Strip Error Analysis';
            document.getElementById('exportSubtitle').value = `${criticalProblem === 'all' ? 'Gauss Circle Problem' : 'Primitive Points'}, ${criticalViz} visualization, Max R=${maxR}`;
            document.getElementById('exportLegend').value = `Problem: ${criticalProblem}
Visualization: ${criticalViz}
Max Radius: ${maxR}
Data Points: ${document.getElementById('criticalPoints').textContent}
Max Error: ${document.getElementById('criticalMaxErr').textContent}
Avg Error: ${document.getElementById('criticalAvgErr').textContent}`;
            showTab('export');
        }

        function quickExportTable() {
            document.getElementById('exportCanvas').value = 'gcdTableCanvas';
            const size = document.getElementById('gcdTableSizeInput').value;
            document.getElementById('exportTitle').value = 'GCD Multiplication Table';
            document.getElementById('exportSubtitle').value = `${size}×${size} grid, ${gcdTableColorMode} coloring`;
            document.getElementById('exportLegend').value = `Grid Size: ${size}×${size}
Color Scheme: ${gcdTableColorMode}
Each cell shows: GCD(row, col)`;
            showTab('export');
        }

        function quickExportAnalysis() {
            document.getElementById('exportCanvas').value = 'ch';
            const k = document.getElementById('analysisK').value;
            const maxR = document.getElementById('mrinput').value;
            document.getElementById('exportTitle').value = 'Error Analysis';
            document.getElementById('exportSubtitle').value = `Dimension k=${k}, Max Radius R=${maxR}`;
            document.getElementById('exportLegend').value = `Dimension: k=${k}
Max Radius: ${maxR}
Shows error term growth
as predicted by theory`;
            showTab('export');
        }

        function setGCDHeatmapPreset(preset) {
            const presets = { 'small': 15, 'medium': 30, 'large': 50 };
            const R = presets[preset];
            document.getElementById('heatmapR').value = R;
            document.getElementById('heatmapRinput').value = R;
            document.getElementById('heatmapRv').textContent = R;
            updateGCDHeatmap();
        }

        function setHeatmapMode(mode) {
            heatmapMode = mode;
            document.querySelectorAll('#heatmapGCD, #heatmapPrimitive, #heatmapGradient').forEach(btn => btn.classList.remove('active'));
            const btnIds = { 'gcd': 'heatmapGCD', 'primitive': 'heatmapPrimitive', 'gradient': 'heatmapGradient' };
            document.getElementById(btnIds[mode]).classList.add('active');
            updateGCDHeatmap();
        }

        function updateGCDHeatmap() {
            const R = parseInt(document.getElementById('heatmapRinput').value) || parseInt(document.getElementById('heatmapR').value);
            const pointSize = parseInt(document.getElementById('heatmapPS').value);
            
            document.getElementById('heatmapRv').textContent = R;
            document.getElementById('heatmapPSv').textContent = pointSize;
            document.getElementById('heatmapR').value = Math.min(R, 80);
            document.getElementById('heatmapRinput').value = R;
            
            const canvas = document.getElementById('heatmapCanvas');
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            const cx = canvas.width / 2, cy = canvas.height / 2;
            const scale = Math.min(canvas.width, canvas.height) / (2.2 * R);
            
            // Draw axes
            ctx.strokeStyle = getComputedStyle(document.body).getPropertyValue('--border');
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(0, cy); ctx.lineTo(canvas.width, cy);
            ctx.moveTo(cx, 0); ctx.lineTo(cx, canvas.height);
            ctx.stroke();
            
            // Draw circle boundary
            ctx.beginPath();
            ctx.arc(cx, cy, R * scale, 0, 2 * Math.PI);
            ctx.stroke();
            
            // Collect and categorize points
            heatmapPointsData = [];
            let counts = { total: 0, gcd1: 0, gcd2: 0, gcd3: 0, gcdOther: 0 };
            
            const filterGCD1 = document.getElementById('filterGCD1').checked;
            const filterGCD2 = document.getElementById('filterGCD2').checked;
            const filterGCD3 = document.getElementById('filterGCD3').checked;
            const filterGCDOther = document.getElementById('filterGCDOther').checked;
            
            for (let x = -R; x <= R; x++) {
                for (let y = -R; y <= R; y++) {
                    const distSq = x*x + y*y;
                    if (distSq <= R*R) {
                        counts.total++;
                        const g = gcd(Math.abs(x), Math.abs(y));
                        const dist = Math.sqrt(distSq);
                        
                        if (g === 1) counts.gcd1++;
                        else if (g === 2) counts.gcd2++;
                        else if (g === 3) counts.gcd3++;
                        else counts.gcdOther++;
                        
                        // Apply filters
                        let shouldDisplay = false;
                        if (g === 1 && filterGCD1) shouldDisplay = true;
                        if (g === 2 && filterGCD2) shouldDisplay = true;
                        if (g === 3 && filterGCD3) shouldDisplay = true;
                        if (g > 3 && filterGCDOther) shouldDisplay = true;
                        
                        if (shouldDisplay) {
                            heatmapPointsData.push({ x, y, gcd: g, dist, screenX: cx + x*scale, screenY: cy - y*scale });
                        }
                    }
                }
            }
            
            // Draw points based on mode
            heatmapPointsData.forEach(pt => {
                let color;
                
                if (heatmapMode === 'gcd') {
                    const gcdColors = {
                        1: '#0066cc', 2: '#dc3545', 3: '#28a745', 4: '#ffc107',
                        5: '#6f42c1', 6: '#fd7e14', 7: '#00d4ff', 8: '#ff006e'
                    };
                    color = gcdColors[Math.min(pt.gcd, 8)] || '#999';
                } else if (heatmapMode === 'primitive') {
                    color = pt.gcd === 1 ? '#0066cc' : '#e0e0e0';
                } else if (heatmapMode === 'gradient') {
                    const ratio = pt.dist / R;
                    const hue = 240 - ratio * 240; // Blue to red
                    color = `hsl(${hue}, 70%, 50%)`;
                }
                
                ctx.fillStyle = color;
                ctx.beginPath();
                ctx.arc(pt.screenX, pt.screenY, pointSize, 0, 2*Math.PI);
                ctx.fill();
            });
            
            // Update stats
            animateValue('heatmapTotal', 0, counts.total);
            animateValue('heatmapPrim', 0, counts.gcd1);
            animateValue('heatmapGCD2', 0, counts.gcd2);
            animateValue('heatmapGCD3', 0, counts.gcd3);
            animateValue('heatmapGCDOther', 0, counts.gcdOther);
        }

        function exportHeatmapData() {
            if (heatmapPointsData.length === 0) { alert('Generate heatmap first'); return; }
            let csv = 'x,y,gcd,distance\n';
            heatmapPointsData.forEach(pt => csv += `${pt.x},${pt.y},${pt.gcd},${pt.dist.toFixed(4)}\n`);
            downloadCSV(csv, 'gcd-heatmap-data.csv');
        }

        function setCriticalStripPreset(preset) {
            if (preset === 'standard') {
                document.getElementById('criticalMaxR').value = 100;
                document.getElementById('criticalMaxRinput').value = 100;
                document.getElementById('criticalStep').value = 1;
            } else if (preset === 'detailed') {
                document.getElementById('criticalMaxR').value = 200;
                document.getElementById('criticalMaxRinput').value = 200;
                document.getElementById('criticalStep').value = 1;
            } else if (preset === 'extended') {
                document.getElementById('criticalMaxR').value = 300;
                document.getElementById('criticalMaxRinput').value = 300;
                document.getElementById('criticalStep').value = 2;
            }
            document.getElementById('criticalStepv').textContent = document.getElementById('criticalStep').value;
            updateCriticalStrip();
        }

        function setCriticalProblem(type) {
            criticalProblem = type;
            document.querySelectorAll('#criticalAllPoints, #criticalPrimitive').forEach(btn => btn.classList.remove('active'));
            document.getElementById(type === 'all' ? 'criticalAllPoints' : 'criticalPrimitive').classList.add('active');
            updateCriticalStrip();
        }

        function setCriticalViz(type) {
            criticalViz = type;
            document.querySelectorAll('#criticalVizError, #criticalVizNormalized, #criticalVizLog, #criticalVizBounds').forEach(btn => btn.classList.remove('active'));
            const btnIds = {
                'error': 'criticalVizError',
                'normalized': 'criticalVizNormalized',
                'loglog': 'criticalVizLog',
                'bounds': 'criticalVizBounds'
            };
            document.getElementById(btnIds[type]).classList.add('active');
            updateCriticalStrip();
        }

        function updateCriticalStrip() {
            const maxR = parseInt(document.getElementById('criticalMaxRinput').value) || parseInt(document.getElementById('criticalMaxR').value);
            const step = parseInt(document.getElementById('criticalStep').value);
            
            document.getElementById('criticalMaxRv').textContent = maxR;
            document.getElementById('criticalStepv').textContent = step;
            document.getElementById('criticalMaxR').value = Math.min(maxR, 300);
            document.getElementById('criticalMaxRinput').value = maxR;
            
            const showZeroLine = document.getElementById('showZeroLine').checked;
            const showRHBound = document.getElementById('showRHBound').checked;
            const showClassicalBound = document.getElementById('showClassicalBound').checked;
            const colorBySign = document.getElementById('colorBySign').checked;
            
            document.getElementById('loadCritical').classList.add('active');
            
            setTimeout(() => {
                const canvas = document.getElementById('criticalCanvas');
                const ctx = canvas.getContext('2d');
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                // Setup coordinate system
                const padding = 80;
                const plotWidth = canvas.width - 2*padding;
                const plotHeight = canvas.height - 2*padding;
                
                // Collect error data
                const errorData = [];
                let maxAbsError = 0, sumAbsError = 0, sumSqError = 0;
                let maxNormalizedError = 0;
                
                for (let R = step; R <= maxR; R += step) {
                    // Calculate actual count
                    let actualCount = 0;
                    
                    if (R <= 80) {
                        // Exact computation for small R
                        for (let x = -R; x <= R; x++) {
                            for (let y = -R; y <= R; y++) {
                                const distSq = x*x + y*y;
                                if (distSq <= R*R) {
                                    if (criticalProblem === 'all') {
                                        actualCount++;
                                    } else if (gcd(Math.abs(x), Math.abs(y)) === 1) {
                                        actualCount++;
                                    }
                                }
                            }
                        }
                    } else {
                        // Approximation for large R
                        if (criticalProblem === 'all') {
                            actualCount = Math.round(Math.PI * R * R);
                        } else {
                            actualCount = Math.round(Math.PI * R * R / zeta(2));
                        }
                    }
                    
                    // Predicted value
                    let predicted;
                    if (criticalProblem === 'all') {
                        predicted = Math.PI * R * R;
                    } else {
                        predicted = Math.PI * R * R / zeta(2);
                    }
                    
                    const error = actualCount - predicted;
                    const absError = Math.abs(error);
                    const normalizedError = absError / Math.sqrt(R);
                    
                    maxAbsError = Math.max(maxAbsError, absError);
                    sumAbsError += absError;
                    sumSqError += error * error;
                    maxNormalizedError = Math.max(maxNormalizedError, normalizedError);
                    
                    errorData.push({ 
                        R, 
                        error, 
                        absError, 
                        normalizedError,
                        actualCount,
                        predicted
                    });
                }
                
                // Determine axis ranges based on visualization type
                let xMin, xMax, yMin, yMax, xLabel, yLabel;
                
                if (criticalViz === 'error') {
                    xMin = 0; xMax = maxR;
                    const maxErrorForPlot = Math.max(...errorData.map(d => Math.abs(d.error)));
                    yMin = -maxErrorForPlot * 1.1;
                    yMax = maxErrorForPlot * 1.1;
                    xLabel = 'Radius R';
                    yLabel = 'Error Δ(R)';
                } else if (criticalViz === 'normalized') {
                    xMin = 0; xMax = maxR;
                    yMin = -maxNormalizedError * 1.2;
                    yMax = maxNormalizedError * 1.2;
                    xLabel = 'Radius R';
                    yLabel = 'Normalized Error Δ(R)/R^(1/2)';
                } else if (criticalViz === 'loglog') {
                    xMin = Math.log10(step);
                    xMax = Math.log10(maxR);
                    yMin = Math.log10(Math.min(...errorData.filter(d => d.absError > 0).map(d => d.absError)));
                    yMax = Math.log10(maxAbsError) * 1.1;
                    xLabel = 'log₁₀(R)';
                    yLabel = 'log₁₀(|Δ(R)|)';
                } else if (criticalViz === 'bounds') {
                    xMin = 0; xMax = maxR;
                    yMin = 0;
                    yMax = Math.max(
                        maxAbsError,
                        Math.pow(maxR, 2/3) * 2,
                        Math.sqrt(maxR) * 10
                    ) * 1.1;
                    xLabel = 'Radius R';
                    yLabel = '|Δ(R)|';
                }
                
                // Draw axes
                ctx.strokeStyle = getComputedStyle(document.body).getPropertyValue('--text2');
                ctx.lineWidth = 2;
                
                // X-axis
                ctx.beginPath();
                ctx.moveTo(padding, canvas.height - padding);
                ctx.lineTo(canvas.width - padding, canvas.height - padding);
                ctx.stroke();
                
                // Y-axis
                ctx.beginPath();
                ctx.moveTo(padding, padding);
                ctx.lineTo(padding, canvas.height - padding);
                ctx.stroke();
                
                // Helper function to map data to screen coordinates
                function mapX(val) {
                    if (criticalViz === 'loglog') val = Math.log10(val);
                    return padding + ((val - xMin) / (xMax - xMin)) * plotWidth;
                }
                
                function mapY(val) {
                    if (criticalViz === 'loglog' && val > 0) val = Math.log10(val);
                    return canvas.height - padding - ((val - yMin) / (yMax - yMin)) * plotHeight;
                }
                
                // Draw zero line
                if (showZeroLine && (criticalViz === 'error' || criticalViz === 'normalized')) {
                    ctx.strokeStyle = 'rgba(128, 128, 128, 0.5)';
                    ctx.lineWidth = 1;
                    ctx.setLineDash([5, 5]);
                    ctx.beginPath();
                    ctx.moveTo(padding, mapY(0));
                    ctx.lineTo(canvas.width - padding, mapY(0));
                    ctx.stroke();
                    ctx.setLineDash([]);
                }
                
                // Draw theoretical bounds
                if (showRHBound && (criticalViz === 'bounds' || criticalViz === 'loglog')) {
                    ctx.strokeStyle = 'rgba(111, 66, 193, 0.7)';
                    ctx.lineWidth = 3;
                    ctx.setLineDash([10, 5]);
                    ctx.beginPath();
                    
                    for (let R = step; R <= maxR; R += Math.max(1, step)) {
                        const bound = Math.sqrt(R) * (criticalViz === 'loglog' ? 3 : 5);
                        const x = mapX(R);
                        const y = mapY(bound);
                        if (R === step) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                    ctx.stroke();
                    ctx.setLineDash([]);
                    
                    // Add label
                    ctx.fillStyle = 'rgba(111, 66, 193, 0.9)';
                    ctx.font = 'bold 12px system-ui';
                    const labelText = criticalViz === 'loglog' ? 'Slope 1/2 (RH)' : 'RH Bound';
                    ctx.fillText(labelText, canvas.width - padding - 80, padding + 30);
                }
                
                if (showClassicalBound && (criticalViz === 'bounds' || criticalViz === 'loglog')) {
                    ctx.strokeStyle = 'rgba(220, 53, 69, 0.7)';
                    ctx.lineWidth = 3;
                    ctx.setLineDash([5, 10]);
                    ctx.beginPath();
                    
                    for (let R = step; R <= maxR; R += Math.max(1, step)) {
                        const bound = Math.pow(R, 2/3) * (criticalViz === 'loglog' ? 1.5 : 2);
                        const x = mapX(R);
                        const y = mapY(bound);
                        if (R === step) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                    ctx.stroke();
                    ctx.setLineDash([]);
                    
                    // Add label
                    ctx.fillStyle = 'rgba(220, 53, 69, 0.9)';
                    ctx.font = 'bold 12px system-ui';
                    const labelText = criticalViz === 'loglog' ? 'Slope 2/3' : 'Classical Bound';
                    ctx.fillText(labelText, canvas.width - padding - 80, padding + 50);
                }
                
                // Draw data points
                errorData.forEach((d, i) => {
                    let x, y, color, pointSize = 4;
                    
                    if (criticalViz === 'error') {
                        x = mapX(d.R);
                        y = mapY(d.error);
                        color = colorBySign ? (d.error > 0 ? 'rgba(0, 102, 204, 0.7)' : 'rgba(220, 53, 69, 0.7)') : 'rgba(0, 102, 204, 0.7)';
                    } else if (criticalViz === 'normalized') {
                        x = mapX(d.R);
                        y = mapY(d.error / Math.sqrt(d.R));
                        color = colorBySign ? (d.error > 0 ? 'rgba(0, 102, 204, 0.7)' : 'rgba(220, 53, 69, 0.7)') : 'rgba(0, 102, 204, 0.7)';
                    } else if (criticalViz === 'loglog') {
                        if (d.absError > 0) {
                            x = mapX(d.R);
                            y = mapY(d.absError);
                            const ratio = d.normalizedError / maxNormalizedError;
                            const hue = 240 - ratio * 240;
                            color = `hsla(${hue}, 70%, 50%, 0.7)`;
                        } else return;
                    } else if (criticalViz === 'bounds') {
                        x = mapX(d.R);
                        y = mapY(d.absError);
                        const ratio = d.absError / maxAbsError;
                        const hue = 240 - ratio * 240;
                        color = `hsla(${hue}, 70%, 50%, 0.7)`;
                    }
                    
                    ctx.fillStyle = color;
                    ctx.beginPath();
                    ctx.arc(x, y, pointSize, 0, 2*Math.PI);
                    ctx.fill();
                    
                    // Store screen coordinates for click detection
                    d.screenX = x;
                    d.screenY = y;
                });
                
                // Store data globally
                window.criticalStripData = errorData;
                
                // Axis labels
                ctx.fillStyle = getComputedStyle(document.body).getPropertyValue('--text');
                ctx.font = 'bold 14px system-ui';
                ctx.textAlign = 'center';
                
                ctx.fillText(xLabel, canvas.width / 2, canvas.height - 20);
                
                ctx.save();
                ctx.translate(20, canvas.height / 2);
                ctx.rotate(-Math.PI/2);
                ctx.fillText(yLabel, 0, 0);
                ctx.restore();
                
                // Title
                ctx.font = 'bold 16px system-ui';
                const problemTitle = criticalProblem === 'all' ? 'Gauss Circle Problem' : 'Primitive Lattice Points';
                const vizTitle = {
                    'error': 'Error Term',
                    'normalized': 'Normalized Error',
                    'loglog': 'Log-Log Error',
                    'bounds': 'Error with Bounds'
                }[criticalViz];
                ctx.fillText(`${problemTitle}: ${vizTitle}`, canvas.width / 2, padding - 40);
                
                // Tick marks and labels
                ctx.font = '12px system-ui';
                ctx.fillStyle = getComputedStyle(document.body).getPropertyValue('--text2');
                
                // X-axis ticks
                const numXTicks = 5;
                for (let i = 0; i <= numXTicks; i++) {
                    const val = xMin + (xMax - xMin) * i / numXTicks;
                    const x = mapX(criticalViz === 'loglog' ? Math.pow(10, val) : val);
                    ctx.beginPath();
                    ctx.moveTo(x, canvas.height - padding);
                    ctx.lineTo(x, canvas.height - padding + 5);
                    ctx.stroke();
                    
                    const label = criticalViz === 'loglog' ? 
                        Math.pow(10, val).toFixed(0) : 
                        val.toFixed(criticalViz === 'normalized' || criticalViz === 'error' ? 0 : 1);
                    ctx.fillText(label, x, canvas.height - padding + 20);
                }
                
                // Y-axis ticks
                const numYTicks = 5;
                for (let i = 0; i <= numYTicks; i++) {
                    const val = yMin + (yMax - yMin) * i / numYTicks;
                    const y = mapY(criticalViz === 'loglog' ? Math.pow(10, val) : val);
                    ctx.beginPath();
                    ctx.moveTo(padding - 5, y);
                    ctx.lineTo(padding, y);
                    ctx.stroke();
                    
                    const label = criticalViz === 'loglog' ? 
                        Math.pow(10, val).toExponential(0) : 
                        val.toFixed(1);
                    ctx.textAlign = 'right';
                    ctx.fillText(label, padding - 10, y + 4);
                    ctx.textAlign = 'center';
                }
                
                // Update stats
                const rmsError = Math.sqrt(sumSqError / errorData.length);
                const avgError = sumAbsError / errorData.length;
                
                document.getElementById('criticalPoints').textContent = errorData.length;
                animateValue('criticalMaxErr', 0, maxAbsError);
                animateValue('criticalAvgErr', 0, avgError);
                animateValue('criticalRMSErr', 0, rmsError);
                document.getElementById('criticalMaxNorm').textContent = maxNormalizedError.toFixed(3);
                
                document.getElementById('loadCritical').classList.remove('active');
            }, 100);
        }

        function exportCriticalData() {
            if (!window.criticalStripData) { alert('Generate critical strip analysis first'); return; }
            const problemType = criticalProblem === 'all' ? 'all_points' : 'primitive_points';
            let csv = 'radius,actual_count,predicted_count,error,abs_error,normalized_error\n';
            window.criticalStripData.forEach(d => {
                csv += `${d.R},${d.actualCount},${d.predicted.toFixed(4)},${d.error.toFixed(4)},${d.absError.toFixed(4)},${d.normalizedError.toFixed(6)}\n`;
            });
            downloadCSV(csv, `critical-strip-${problemType}-data.csv`);
        }

        // Init
        updateTheory();
        const tb = document.getElementById('tbl');
        for (let k = 2; k <= 12; k++) {
            const z = zeta(k);
            const precision = k > 6 ? 17 : 6;
            const v = k % 2 === 0 ? 
                (Math.PI**(k/2) / factorial(k/2)) :
                (2 * factorial((k-1)/2) * Math.PI**((k-1)/2) / factorial(k));
            tb.innerHTML += `<tr><td>${k}</td><td>${formatPrecise(z, precision)}</td><td>${formatPrecise(1/z, precision)}</td><td>${formatPrecise(v, precision)}</td></tr>`;
        }
        
        document.getElementById('helpModal').addEventListener('click', e => {
            if (e.target.id === 'helpModal') closeHelp();
        });
    </script>
</body>
    </html>


<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Enhanced Modular Lifting Rings ‚Äî M√∂bius Shell Sieve</title>
<script src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>
<style>
:root{--bg:#0d1321;--bg2:#151b2d;--txt:#e0e6ed;--txt2:#a0aab8;--bord:#2a3a50;--acc:#00d9ff;--gold:#ffd700}
*{box-sizing:border-box;margin:0;padding:0}
body{font-family:'Segoe UI',system-ui,sans-serif;background:var(--bg);color:var(--txt);line-height:1.5;min-height:100vh}
body.light{--bg:#f5f5f5;--bg2:#fff;--txt:#1a1a2e;--txt2:#555;--bord:#ddd;--acc:#0066cc}
header{background:linear-gradient(135deg,#151b2d 0%,#1a2540 100%);padding:1rem;border-bottom:2px solid var(--gold);text-align:center}
header h1{font-size:1.6rem;background:linear-gradient(90deg,#ffd700,#00d9ff);-webkit-background-clip:text;-webkit-text-fill-color:transparent;background-clip:text}
header p{font-size:.85rem;color:var(--txt2);margin-top:.3rem}
.container{max-width:1600px;margin:0 auto;padding:1rem}
.ctrl{display:flex;flex-wrap:wrap;gap:.5rem;margin:.5rem 0}
.cg{display:flex;flex-direction:column;gap:.2rem;min-width:120px}
.cg label{font-size:.75rem;color:var(--txt2)}
.cg input,.cg select{padding:6px 10px;border:1px solid var(--bord);border-radius:4px;background:var(--bg);color:var(--txt);font-size:.85rem}
.cg input:focus,.cg select:focus{outline:none;border-color:var(--acc)}
.cg input[type="checkbox"]{width:auto}
button{padding:8px 16px;border:1px solid var(--bord);border-radius:4px;background:var(--bg2);color:var(--txt);cursor:pointer;font-size:.85rem;transition:all .2s}
button:hover{background:var(--acc);color:#000;border-color:var(--acc)}
.bg{display:flex;flex-wrap:wrap;gap:.5rem;margin:.75rem 0}
.bg button.s{background:rgba(0,217,255,.15);border-color:#00d9ff;color:#00d9ff;font-size:.75rem}
canvas{border:1px solid var(--bord);border-radius:4px;background:#000;display:block;max-width:100%}
.viz{margin:1rem 0}
.viz h3{color:var(--acc);font-size:1rem;margin-bottom:.5rem}
.stats{background:var(--bg2);border:1px solid var(--bord);border-radius:8px;padding:1rem;font-size:.8rem}
.stats h4{color:var(--gold);margin-bottom:.5rem;font-size:.9rem}
.stats-grid{display:grid;grid-template-columns:repeat(auto-fit,minmax(150px,1fr));gap:.5rem}
.stat-item{background:rgba(0,217,255,.08);padding:.5rem;border-radius:4px;border-left:3px solid var(--acc)}
.stat-item .label{font-size:.7rem;color:var(--txt2)}
.stat-item .value{font-size:1rem;color:var(--gold);font-weight:bold}
.legend{display:flex;flex-wrap:wrap;gap:.5rem;margin:.5rem 0;font-size:.75rem}
.legend span{padding:3px 8px;border-radius:4px;background:var(--bg2);border:1px solid var(--bord)}
.flex-row{display:flex;gap:1rem;flex-wrap:wrap}
.flex-row>*{flex:1;min-width:300px}
.collapsible{cursor:pointer;user-select:none}
.theme-toggle{position:fixed;top:1rem;right:1rem;z-index:1000;padding:8px 12px;border-radius:20px;background:var(--bg2);border:1px solid var(--bord);color:var(--txt);cursor:pointer}
@media(max-width:768px){.flex-row>*{min-width:100%}}
</style>
</head>
<body>
<button class="theme-toggle" onclick="toggleTheme()">üåì Theme</button>
<header>
<h1>Enhanced Modular Lifting Rings</h1>
<p>Interactive ring visualization with gap analysis, power families, lift dynamics, Smith Chart transform & Stern-Brocot tree</p>
</header>
<div class="container">

<div style="background:linear-gradient(135deg,rgba(255,215,0,.15),rgba(72,187,120,.1));padding:1rem;border-radius:8px;margin-bottom:1rem;border-left:4px solid #ffd700">
<h3 style="color:#ffd700;margin-bottom:.5rem">Quick Presets</h3>
<div style="display:flex;flex-wrap:wrap;gap:.5rem">
<button onclick="enhSetRange(1,12)">M‚â§12</button>
<button onclick="enhSetRange(1,30)">M‚â§30</button>
<button onclick="enhSetRange(1,60)">M‚â§60</button>
<button onclick="enhSetPower(2,10)" style="background:#2a4a6a;color:#fff">2^n (n‚â§10)</button>
<button onclick="enhSetPower(3,8)" style="background:#4a2a6a;color:#fff">3^n (n‚â§8)</button>
<button onclick="enhSetPrimorials()" style="background:#1a472a;color:#fff">Primorials</button>
</div>
</div>

<!-- Controls -->
<div style="background:var(--bg2);border:1px solid var(--bord);border-radius:8px;padding:1rem;margin-bottom:1rem">

<!-- Modulus Selection -->
<div class="ctrl" style="background:rgba(0,217,255,.08);border-radius:6px;padding:.75rem;margin-bottom:.5rem">
<div class="cg"><label><strong style="color:#00d9ff">Mode</strong></label>
<select id="enhMode" onchange="enhModeChange();drawEnhanced()">
<option value="range">Consecutive Range (M‚ÇÅ to M‚ÇÇ)</option>
<option value="power">Power Family (a·µá for b=0..n)</option>
<option value="custom">Custom List</option>
</select></div>
</div>

<div id="enhRangeControls" class="ctrl">
<div class="cg"><label>Min Modulus</label><input type="number" id="enhMin" value="1" min="1" max="500" onchange="drawEnhanced()"></div>
<div class="cg"><label>Max Modulus</label><input type="number" id="enhMax" value="30" min="1" max="500" onchange="drawEnhanced()"></div>
</div>

<div id="enhPowerControls" style="display:none" class="ctrl">
<div class="cg"><label>Base a</label><input type="number" id="enhBase" value="2" min="2" max="20" onchange="drawEnhanced()"></div>
<div class="cg"><label>Max Exponent n</label><input type="number" id="enhMaxExp" value="10" min="1" max="20" onchange="drawEnhanced()"></div>
<div class="cg"><label>Start Exponent</label><input type="number" id="enhMinExp" value="0" min="0" max="10" onchange="drawEnhanced()"></div>
</div>

<div id="enhCustomControls" style="display:none" class="ctrl">
<div class="cg" style="flex:1"><label>Custom Moduli (comma-separated)</label>
<input type="text" id="enhCustomList" value="1,2,4,8,16,32" onchange="drawEnhanced()" style="width:100%"></div>
</div>

<!-- Visual Controls -->
<div class="ctrl" style="background:rgba(255,215,0,.08);border-radius:6px;padding:.75rem;margin-bottom:.5rem">
<div class="cg"><label><strong style="color:#ffd700">Color Mode</strong></label>
<select id="enhColor" onchange="drawEnhanced()">
<option value="angular">Angular (by position)</option>
<option value="gcd">GCD (gold=coprime)</option>
<option value="ring">Ring Index</option>
<option value="coprime">Coprime Highlight</option>
<option value="spectrum">Totient Spectrum</option>
<option value="sector">Sector Focus</option>
</select></div>
<div class="cg"><label>Point Scale</label>
<input type="range" id="enhPtScale" min="0.3" max="3" step="0.1" value="1" oninput="drawEnhanced()"></div>
<div class="cg"><label>Rotation</label>
<div style="display:flex;gap:.3rem;align-items:center">
<input type="range" id="enhRot" min="0" max="360" step="1" value="0" oninput="document.getElementById('enhRotNum').value=this.value;drawEnhanced()" style="flex:1">
<input type="number" id="enhRotNum" value="0" min="0" max="360" style="width:50px" onchange="document.getElementById('enhRot').value=this.value;drawEnhanced()">
</div></div>
</div>

<!-- Ring Rotation -->
<div class="ctrl">
<div class="cg"><label>Ring Increment (¬∞)</label><input type="number" id="enhRingInc" value="0" step="0.5" onchange="drawEnhanced()"></div>
<div class="cg"><label>Phase Offset (¬∞)</label><input type="number" id="enhPhase" value="0" step="1" onchange="drawEnhanced()"></div>
<div class="cg"><label style="display:flex;gap:.5rem;align-items:center">
<input type="checkbox" id="enhInvertRings" onchange="drawEnhanced()"> Invert Ring Order</label></div>
</div>

<!-- Sector Highlight -->
<div class="ctrl" style="background:rgba(150,100,255,.1);border-radius:6px;padding:.75rem">
<div class="cg"><label style="display:flex;gap:.5rem;align-items:center">
<input type="checkbox" id="enhHighlightSector" onchange="drawEnhanced()"> <strong style="color:#9664ff">Highlight Sector 1/a to 1/b</strong></label></div>
<div class="cg"><label>From 1/</label><input type="number" id="enhSectorFrom" value="3" min="2" max="100" onchange="drawEnhanced()"></div>
<div class="cg"><label>To 1/</label><input type="number" id="enhSectorTo" value="2" min="1" max="100" onchange="drawEnhanced()"></div>
<div class="cg"><label>Sector Color Mode</label>
<select id="enhSectorColorMode" onchange="drawEnhanced()">
<option value="preserve">Preserve Original</option>
<option value="highlight">Purple Highlight</option>
<option value="isolate">Isolate (dim others)</option>
</select></div>
</div>

<!-- Features -->
<div class="ctrl">
<div class="cg"><label style="display:flex;gap:.5rem;align-items:center">
<input type="checkbox" id="enhShowLabels" onchange="drawEnhanced()"> Show Labels</label></div>
<div class="cg"><label style="display:flex;gap:.5rem;align-items:center">
<input type="checkbox" id="enhShowUnit" checked onchange="drawEnhanced()"> Show Unit Circle</label></div>
<div class="cg"><label style="display:flex;gap:.5rem;align-items:center">
<input type="checkbox" id="enhSmith" onchange="drawEnhanced()"> Smith Chart Transform</label></div>
<div class="cg"><label>Smith Œ±</label><input type="range" id="enhSmithAlpha" min="0.1" max="2" step="0.1" value="1" oninput="drawEnhanced()"></div>
</div>

</div>

<!-- Action Buttons -->
<div class="bg">
<button onclick="drawEnhanced()">Redraw</button>
<button onclick="toggleEnhRotation()" id="enhRotBtn">‚ñ∂ Animate</button>
<button onclick="screenshotEnhanced()">üì∑ Screenshot</button>
<button onclick="exportAllEnhanced()" style="background:#1a472a">üì¶ Export All</button>
<button class="s" onclick="csvEnhanced()">CSV Export</button>
</div>

<!-- Main Visualization Area -->
<div class="flex-row">
<div class="viz" style="flex:2;min-width:500px">
<h3>Modular Ring Visualization</h3>
<canvas id="cenhanced" width="700" height="700"></canvas>
<div id="alenhanced" class="legend"></div>
</div>
<div style="flex:1;min-width:300px">
<div id="enhLiveStats" class="stats">
<h4>üìä Live Statistics</h4>
<div id="enhStatsContent" class="stats-grid"></div>
</div>
<div id="enhPointInfo" style="margin-top:1rem;background:var(--bg2);border:1px solid var(--bord);border-radius:8px;padding:1rem;display:none">
<h4 style="color:#00ff88;margin-bottom:.5rem">Selected Point</h4>
<div id="enhPointDetails"></div>
</div>
<div id="enhSectorStats" style="margin-top:1rem;background:var(--bg2);border:1px solid var(--bord);border-radius:8px;padding:1rem;display:none">
<h4 style="color:#9664ff;margin-bottom:.5rem">Sector Analysis</h4>
<div id="enhSectorContent"></div>
</div>
</div>
</div>

<!-- Stern-Brocot Tree -->
<div class="viz" style="margin-top:1.5rem">
<h3 style="color:#00ff88">Stern-Brocot Tree <span style="font-size:.8rem;color:var(--txt2)">(for sector fractions)</span></h3>
<div class="ctrl" style="margin-bottom:.5rem">
<div class="cg"><label>Tree Depth</label><input type="number" id="enhTreeDepth" value="5" min="2" max="10" onchange="updateSBTree()"></div>
<div class="cg"><label>Node Size</label><input type="range" id="enhTreeSz" min="4" max="20" value="10" oninput="updateSBTree()"></div>
<div class="cg"><label>Label Format</label>
<select id="enhTreeLblFmt" onchange="updateSBTree()">
<option value="fraction">Fraction (p/q)</option>
<option value="decimal">Decimal</option>
<option value="angle">Angle (¬∞)</option>
</select></div>
</div>
<canvas id="cSternBrocot" width="800" height="400"></canvas>
<div id="enhTreePath" style="margin-top:.5rem;padding:.5rem;background:var(--bg2);border-radius:4px;font-size:.85rem;display:none"></div>
</div>

</div>

<script>
// Theme toggle
function toggleTheme(){document.body.classList.toggle('light');drawEnhanced();}
function isDark(){return !document.body.classList.contains('light');}

// Utilities
const gcd=(a,b)=>{a=Math.abs(Math.round(a));b=Math.abs(Math.round(b));while(b)[a,b]=[b,a%b];return a||1;};
function reduceFraction(a,b){const g=gcd(a,b);return `${a/g}/${b/g}`;}

// Global state
let enhRingsData=[];
let enhSelectedPoint=null;
let enhAnimFrame=0;
let enhAnimating=false;
let enhAnimId=null;
let treeZoom=1, treePanX=0, treePanY=0;

// Mode change
function enhModeChange(){
  const mode=document.getElementById('enhMode').value;
  document.getElementById('enhRangeControls').style.display=mode==='range'?'flex':'none';
  document.getElementById('enhPowerControls').style.display=mode==='power'?'flex':'none';
  document.getElementById('enhCustomControls').style.display=mode==='custom'?'flex':'none';
}

// Presets
function enhSetRange(min,max){
  document.getElementById('enhMode').value='range';
  document.getElementById('enhMin').value=min;
  document.getElementById('enhMax').value=max;
  enhModeChange();
  drawEnhanced();
}
function enhSetPower(base,maxExp){
  document.getElementById('enhMode').value='power';
  document.getElementById('enhBase').value=base;
  document.getElementById('enhMaxExp').value=maxExp;
  document.getElementById('enhMinExp').value=0;
  enhModeChange();
  drawEnhanced();
}
function enhSetPrimorials(){
  document.getElementById('enhMode').value='custom';
  document.getElementById('enhCustomList').value='1,2,6,30,210,2310';
  enhModeChange();
  drawEnhanced();
}

// Get moduli based on mode
function enhGetModuli(){
  const mode=document.getElementById('enhMode').value;
  let moduli=[];
  if(mode==='range'){
    const min=+document.getElementById('enhMin').value||1;
    const max=+document.getElementById('enhMax').value||30;
    for(let m=min;m<=max;m++)moduli.push(m);
  }else if(mode==='power'){
    const base=+document.getElementById('enhBase').value||2;
    const maxExp=+document.getElementById('enhMaxExp').value||10;
    const minExp=+document.getElementById('enhMinExp').value||0;
    for(let e=minExp;e<=maxExp;e++)moduli.push(Math.pow(base,e));
  }else{
    const list=document.getElementById('enhCustomList').value||'';
    moduli=list.split(',').map(s=>+s.trim()).filter(n=>n>0&&!isNaN(n));
  }
  return moduli.filter(m=>m>=1);
}

// Main draw function
function drawEnhanced(){
  const c=document.getElementById('cenhanced');
  if(!c)return;
  const ctx=c.getContext('2d');
  const w=c.width, h=c.height;
  const cx=w/2, cy=h/2;
  const isDk=isDark();
  
  // Clear
  ctx.fillStyle=isDk?'#0a0e14':'#fff';
  ctx.fillRect(0,0,w,h);
  
  // Get moduli
  const moduli=enhGetModuli();
  if(moduli.length===0)return;
  
  // Build ring data
  enhRingsData=moduli.map(m=>{
    const allRes=[];
    const coprimes=[];
    for(let r=0;r<m;r++){
      allRes.push(r);
      if(gcd(r,m)===1)coprimes.push(r);
    }
    return {mod:m, allRes, coprimes, isUnit:m===1};
  });
  
  // Visual params
  const colMode=document.getElementById('enhColor')?.value||'angular';
  const ptScale=+document.getElementById('enhPtScale')?.value||1;
  const rot=((+document.getElementById('enhRot')?.value||0)+enhAnimFrame)*Math.PI/180;
  const ringInc=(+document.getElementById('enhRingInc')?.value||0)*Math.PI/180;
  const phase=(+document.getElementById('enhPhase')?.value||0)*Math.PI/180;
  const invertRings=document.getElementById('enhInvertRings')?.checked;
  const showLabels=document.getElementById('enhShowLabels')?.checked;
  const showUnit=document.getElementById('enhShowUnit')?.checked;
  const smithEnabled=document.getElementById('enhSmith')?.checked;
  const smithAlpha=+document.getElementById('enhSmithAlpha')?.value||1;
  const highlightSector=document.getElementById('enhHighlightSector')?.checked;
  const sectorFrom=+document.getElementById('enhSectorFrom')?.value||3;
  const sectorTo=+document.getElementById('enhSectorTo')?.value||2;
  const sectorColorMode=document.getElementById('enhSectorColorMode')?.value||'preserve';
  
  // Calculate radii
  const innerR=30;
  const outerR=Math.min(cx,cy)-40;
  const numRings=enhRingsData.length;
  
  // Apply global rotation
  ctx.save();
  ctx.translate(cx,cy);
  ctx.rotate(rot);
  
  // Draw unit circle
  if(showUnit){
    ctx.beginPath();
    ctx.arc(0,0,outerR,0,2*Math.PI);
    ctx.strokeStyle=isDk?'rgba(0,255,136,.3)':'rgba(0,170,85,.3)';
    ctx.lineWidth=2;
    ctx.stroke();
  }
  
  // Draw sector highlight
  if(highlightSector){
    const fromAngle=2*Math.PI*(1-1/sectorFrom);
    const toAngle=2*Math.PI*(1-1/sectorTo);
    ctx.beginPath();
    ctx.moveTo(0,0);
    ctx.arc(0,0,outerR+10,fromAngle,toAngle);
    ctx.closePath();
    ctx.fillStyle='rgba(150,100,255,.15)';
    ctx.fill();
    ctx.strokeStyle='rgba(150,100,255,.5)';
    ctx.lineWidth=2;
    ctx.stroke();
    
    // Update Stern-Brocot tree
    window.enhSBTreeBounds={fromN:sectorFrom,toN:sectorTo};
    updateSBTree();
  }
  
  // Stats
  let totalPoints=0, totalCoprimes=0;
  
  // Draw each ring
  enhRingsData.forEach((ring,ringIdx)=>{
    const radius=innerR+(outerR-innerR)*ringIdx/(numRings-1||1);
    ring.radius=radius;
    const actualRingIdx=invertRings?(numRings-1-ringIdx):ringIdx;
    const ringRotation=actualRingIdx*ringInc+phase;
    
    ring.allRes.forEach(r=>{
      const gcd1=gcd(r,ring.mod)===1;
      const angle=2*Math.PI*(ring.mod-r)/ring.mod+ringRotation;
      let px=radius*Math.cos(angle);
      let py=radius*Math.sin(angle);
      
      // Smith transform
      if(smithEnabled){
        const dist=radius/outerR;
        const z_re=0.5+dist*1.5*Math.cos(angle);
        const z_im=dist*1.5*Math.sin(angle);
        const denom=(1-z_re)**2+z_im**2;
        if(denom>0.001){
          const w_re=((1-z_re**2-z_im**2)/denom)*smithAlpha;
          const w_im=(2*z_im/denom)*smithAlpha;
          px=w_re*outerR*0.4;
          py=-w_im*outerR*0.4;
        }
      }
      
      // Check sector
      const frac=r/ring.mod;
      const inSector=highlightSector&&frac>1/sectorFrom&&frac<1/sectorTo;
      
      // Size
      let ptSz=(ring.isUnit?7:(radius>200?5:4))*ptScale*(smithEnabled?0.7:1);
      if(inSector&&gcd1)ptSz*=1.3;
      
      // Color
      let clr;
      if(colMode==='angular'){const hue=(r/ring.mod)*360;clr=`hsl(${hue},80%,60%)`;}
      else if(colMode==='gcd'){clr=gcd1?'#ffd700':'#555';}
      else if(colMode==='ring'){const hue=(ringIdx/numRings)*300;clr=`hsl(${hue},70%,55%)`;}
      else if(colMode==='coprime'){clr=gcd1?'#00ff88':'#ff4040';}
      else if(colMode==='spectrum'){clr=gcd1?`hsl(${(ring.coprimes.length/ring.mod)*240},80%,60%)`:'#333';}
      else if(colMode==='sector'){
        if(inSector&&gcd1)clr='#9664ff';
        else clr=gcd1?'#ffd700':'#444';
      }
      
      // Dim non-sector if isolate mode
      if(sectorColorMode==='isolate'&&highlightSector&&!inSector){
        clr=isDk?'#222':'#ddd';
        ptSz*=0.6;
      }
      
      // Draw point
      ctx.beginPath();
      ctx.arc(px,py,ptSz,0,2*Math.PI);
      ctx.fillStyle=clr;
      ctx.fill();
      
      // Label
      if(showLabels&&ring.mod<=12&&gcd1){
        ctx.fillStyle=isDk?'#fff':'#000';
        ctx.font='9px sans-serif';
        ctx.textAlign='center';
        ctx.fillText(`${r}`,px,py-ptSz-3);
      }
      
      totalPoints++;
      if(gcd1)totalCoprimes++;
    });
  });
  
  ctx.restore();
  
  // Update stats
  updateEnhStats(totalPoints,totalCoprimes);
  updateEnhLegend();
  
  // Update sector stats
  if(highlightSector)updateSectorStats(sectorFrom,sectorTo);
}

// Update statistics display
function updateEnhStats(total,coprimes){
  const content=document.getElementById('enhStatsContent');
  if(!content)return;
  const moduli=enhGetModuli();
  const density=total>0?(coprimes/total*100).toFixed(1):'0';
  
  content.innerHTML=`
    <div class="stat-item"><div class="label">Total Rings</div><div class="value">${moduli.length}</div></div>
    <div class="stat-item"><div class="label">Total Points</div><div class="value">${total.toLocaleString()}</div></div>
    <div class="stat-item"><div class="label">Coprime Points</div><div class="value">${coprimes.toLocaleString()}</div></div>
    <div class="stat-item"><div class="label">Coprime Density</div><div class="value">${density}%</div></div>
    <div class="stat-item"><div class="label">Max Modulus</div><div class="value">${Math.max(...moduli)}</div></div>
    <div class="stat-item"><div class="label">Œ£œÜ(m)</div><div class="value">${enhRingsData.reduce((s,r)=>s+r.coprimes.length,0).toLocaleString()}</div></div>
  `;
}

// Update legend
function updateEnhLegend(){
  const el=document.getElementById('alenhanced');
  if(!el)return;
  const colMode=document.getElementById('enhColor')?.value||'angular';
  let html='';
  if(colMode==='gcd')html='<span style="color:#ffd700">‚óè Coprime (GCD=1)</span><span style="color:#555">‚óè Non-coprime</span>';
  else if(colMode==='coprime')html='<span style="color:#00ff88">‚óè Coprime</span><span style="color:#ff4040">‚óè Non-coprime</span>';
  else if(colMode==='sector')html='<span style="color:#9664ff">‚óè In Sector</span><span style="color:#ffd700">‚óè Coprime</span><span style="color:#444">‚óè Other</span>';
  else html='<span>Color by '+colMode+'</span>';
  el.innerHTML=html;
}

// Sector stats
function updateSectorStats(from,to){
  const el=document.getElementById('enhSectorStats');
  const content=document.getElementById('enhSectorContent');
  if(!el||!content)return;
  
  let inSector=0, inSectorCoprime=0;
  enhRingsData.forEach(ring=>{
    ring.allRes.forEach(r=>{
      const frac=r/ring.mod;
      if(frac>1/from&&frac<1/to){
        inSector++;
        if(gcd(r,ring.mod)===1)inSectorCoprime++;
      }
    });
  });
  
  el.style.display='block';
  content.innerHTML=`
    <div style="margin-bottom:.5rem"><strong>Sector:</strong> 1/${from} to 1/${to}</div>
    <div style="margin-bottom:.3rem">Points in sector: <strong style="color:#9664ff">${inSector}</strong></div>
    <div style="margin-bottom:.3rem">Coprimes in sector: <strong style="color:#00ff88">${inSectorCoprime}</strong></div>
    <div>Sector density: <strong>${inSector>0?(inSectorCoprime/inSector*100).toFixed(1):0}%</strong></div>
  `;
}

// Animation
function toggleEnhRotation(){
  enhAnimating=!enhAnimating;
  const btn=document.getElementById('enhRotBtn');
  if(enhAnimating){
    btn.textContent='‚è∏ Pause';
    animateEnhanced();
  }else{
    btn.textContent='‚ñ∂ Animate';
    if(enhAnimId)cancelAnimationFrame(enhAnimId);
  }
}

function animateEnhanced(){
  if(!enhAnimating)return;
  enhAnimFrame=(enhAnimFrame+0.5)%360;
  drawEnhanced();
  enhAnimId=requestAnimationFrame(animateEnhanced);
}

// Click handler
document.getElementById('cenhanced')?.addEventListener('click',function(e){
  const c=this;
  const rect=c.getBoundingClientRect();
  const clickX=(e.clientX-rect.left)*(c.width/rect.width);
  const clickY=(e.clientY-rect.top)*(c.height/rect.height);
  const cx=c.width/2, cy=c.height/2;
  let x=clickX-cx, y=clickY-cy;
  
  const rot=((+document.getElementById('enhRot')?.value||0)+enhAnimFrame)*Math.PI/180;
  const cosR=Math.cos(-rot), sinR=Math.sin(-rot);
  const ux=x*cosR-y*sinR, uy=x*sinR+y*cosR;
  
  let closest=null, minDist=Infinity;
  const numRings=enhRingsData.length;
  const outerR=Math.min(cx,cy)-40, innerR=30;
  const ringInc=(+document.getElementById('enhRingInc')?.value||0)*Math.PI/180;
  const phase=(+document.getElementById('enhPhase')?.value||0)*Math.PI/180;
  const invertRings=document.getElementById('enhInvertRings')?.checked;
  
  enhRingsData.forEach((ring,ringIdx)=>{
    const radius=innerR+(outerR-innerR)*ringIdx/(numRings-1||1);
    const actualRingIdx=invertRings?(numRings-1-ringIdx):ringIdx;
    const ringRotation=actualRingIdx*ringInc+phase;
    
    ring.allRes.forEach(r=>{
      const angle=2*Math.PI*(ring.mod-r)/ring.mod+ringRotation;
      const px=radius*Math.cos(angle), py=radius*Math.sin(angle);
      const dist=Math.sqrt((ux-px)**2+(uy-py)**2);
      if(dist<minDist&&dist<25){
        minDist=dist;
        closest={residue:r,mod:ring.mod,gcd:gcd(r,ring.mod),isCoprime:gcd(r,ring.mod)===1,fraction:`${r}/${ring.mod}`,reduced:reduceFraction(r,ring.mod)};
      }
    });
  });
  
  if(closest){
    enhSelectedPoint=closest;
    showPointDetails(closest);
    if(closest.isCoprime)highlightInSBTree(closest.residue,closest.mod);
    drawEnhanced();
  }
});

function showPointDetails(pt){
  const el=document.getElementById('enhPointInfo');
  const details=document.getElementById('enhPointDetails');
  if(!el||!details)return;
  el.style.display='block';
  details.innerHTML=`
    <div><strong>Residue:</strong> ${pt.residue} mod ${pt.mod}</div>
    <div><strong>Fraction:</strong> ${pt.fraction} = ${pt.reduced}</div>
    <div><strong>GCD:</strong> ${pt.gcd}</div>
    <div><strong>Coprime:</strong> ${pt.isCoprime?'<span style="color:#00ff88">Yes</span>':'<span style="color:#ff4040">No</span>'}</div>
    <div><strong>Value:</strong> ${(pt.residue/pt.mod).toFixed(6)}</div>
  `;
}

// Stern-Brocot Tree
window.enhSBTreeNodes=[];
window.enhSBHighlightPath=[];
window.enhSBSelectedNode=null;

function updateSBTree(){
  if(!window.enhSBTreeBounds)return;
  const{fromN,toN}=window.enhSBTreeBounds;
  drawSternBrocotTree(fromN,toN);
}

function drawSternBrocotTree(fromN,toN){
  const c=document.getElementById('cSternBrocot');
  if(!c)return;
  const ctx=c.getContext('2d');
  const w=c.width, h=c.height;
  const isDk=isDark();
  
  ctx.fillStyle=isDk?'#0a0e14':'#fff';
  ctx.fillRect(0,0,w,h);
  
  const depth=+document.getElementById('enhTreeDepth')?.value||5;
  const nodeSz=+document.getElementById('enhTreeSz')?.value||10;
  const lblFmt=document.getElementById('enhTreeLblFmt')?.value||'fraction';
  
  const nodes=[];
  const edges=[];
  
  // Build tree for sector 1/fromN to 1/toN
  function buildTree(left,right,d,parentX,parentY,dir){
    if(d>depth)return;
    const p=left.p+right.p;
    const q=left.q+right.q;
    const val=p/q;
    if(val<=1/fromN||val>=1/toN)return;
    
    const x=w*(val-1/fromN)/(1/toN-1/fromN);
    const y=30+d*(h-60)/depth;
    
    nodes.push({p,q,x,y,depth:d});
    if(parentX!==null)edges.push({x1:parentX,y1:parentY,x2:x,y2:y});
    
    buildTree(left,{p,q},d+1,x,y,'L');
    buildTree({p,q},right,d+1,x,y,'R');
  }
  
  buildTree({p:0,q:1},{p:1,q:fromN},1,null,null,null);
  buildTree({p:1,q:toN},{p:1,q:1},1,null,null,null);
  
  // Add boundary nodes
  nodes.push({p:1,q:fromN,x:0,y:15,depth:0,boundary:true});
  nodes.push({p:1,q:toN,x:w,y:15,depth:0,boundary:true});
  
  window.enhSBTreeNodes=nodes;
  
  // Draw edges
  ctx.strokeStyle=isDk?'rgba(0,217,255,.3)':'rgba(0,102,204,.2)';
  ctx.lineWidth=1;
  edges.forEach(e=>{
    ctx.beginPath();
    ctx.moveTo(e.x1,e.y1);
    ctx.lineTo(e.x2,e.y2);
    ctx.stroke();
  });
  
  // Draw highlight path
  const highlightPath=window.enhSBHighlightPath||[];
  if(highlightPath.length>1){
    ctx.strokeStyle='#00ff88';
    ctx.lineWidth=3;
    ctx.beginPath();
    for(let i=0;i<highlightPath.length;i++){
      const node=nodes.find(n=>n.p===highlightPath[i].p&&n.q===highlightPath[i].q);
      if(node){
        if(i===0)ctx.moveTo(node.x,node.y);
        else ctx.lineTo(node.x,node.y);
      }
    }
    ctx.stroke();
  }
  
  // Draw nodes
  nodes.forEach(node=>{
    const isSelected=window.enhSBSelectedNode&&window.enhSBSelectedNode.p===node.p&&window.enhSBSelectedNode.q===node.q;
    const isOnPath=highlightPath.some(n=>n.p===node.p&&n.q===node.q);
    
    ctx.beginPath();
    ctx.arc(node.x,node.y,nodeSz,0,2*Math.PI);
    if(isSelected){
      ctx.fillStyle='#ffd700';
      ctx.strokeStyle='#fff';
      ctx.lineWidth=2;
    }else if(isOnPath){
      ctx.fillStyle='#00ff88';
      ctx.strokeStyle='#fff';
      ctx.lineWidth=1;
    }else{
      ctx.fillStyle=node.boundary?'#9664ff':(isDk?'#00d9ff':'#0066cc');
      ctx.strokeStyle='transparent';
    }
    ctx.fill();
    if(isSelected||isOnPath)ctx.stroke();
    
    // Label
    if(nodeSz>=8){
      let lbl;
      if(lblFmt==='decimal')lbl=(node.p/node.q).toFixed(3);
      else if(lblFmt==='angle')lbl=((node.p/node.q)*360).toFixed(0)+'¬∞';
      else lbl=`${node.p}/${node.q}`;
      ctx.fillStyle=isDk?'#fff':'#000';
      ctx.font=`${Math.max(8,nodeSz-2)}px sans-serif`;
      ctx.textAlign='center';
      ctx.fillText(lbl,node.x,node.y-nodeSz-4);
    }
  });
}

function findSBTreePath(p,q,fromN,toN){
  const path=[];
  let left={p:0,q:1}, right={p:1,q:1};
  
  for(let i=0;i<50;i++){
    const mp=left.p+right.p;
    const mq=left.q+right.q;
    path.push({p:mp,q:mq});
    
    if(mp===p&&mq===q)return path;
    
    if(p*mq<mp*q)right={p:mp,q:mq};
    else left={p:mp,q:mq};
  }
  return path;
}

function highlightInSBTree(p,q){
  const pathEl=document.getElementById('enhTreePath');
  if(!window.enhSBTreeBounds){
    if(pathEl){pathEl.style.display='block';pathEl.innerHTML='<span style="color:#888">Enable sector highlight first</span>';}
    return;
  }
  
  const{fromN,toN}=window.enhSBTreeBounds;
  const frac=p/q;
  
  if(frac<=1/fromN||frac>=1/toN){
    if(pathEl){pathEl.style.display='block';pathEl.innerHTML=`<span style="color:#ff8c00">${p}/${q} is outside sector</span>`;}
    window.enhSBHighlightPath=[];
    window.enhSBSelectedNode=null;
    updateSBTree();
    return;
  }
  
  window.enhSBHighlightPath=findSBTreePath(p,q,fromN,toN);
  window.enhSBSelectedNode={p,q};
  
  if(pathEl){
    pathEl.style.display='block';
    const pathStr=window.enhSBHighlightPath.map(n=>`${n.p}/${n.q}`).join(' ‚Üí ');
    pathEl.innerHTML=`<strong style="color:#00ff88">Path to ${p}/${q}:</strong> ${pathStr}`;
  }
  
  updateSBTree();
}

// Tree click handler
document.getElementById('cSternBrocot')?.addEventListener('click',function(e){
  const c=this;
  const rect=c.getBoundingClientRect();
  const mx=(e.clientX-rect.left)*(c.width/rect.width);
  const my=(e.clientY-rect.top)*(c.height/rect.height);
  
  const nodeSz=+document.getElementById('enhTreeSz')?.value||10;
  let closest=null, minDist=nodeSz*2;
  
  (window.enhSBTreeNodes||[]).forEach(node=>{
    const dist=Math.sqrt((node.x-mx)**2+(node.y-my)**2);
    if(dist<minDist){minDist=dist;closest=node;}
  });
  
  if(closest)highlightInSBTree(closest.p,closest.q);
});

// Screenshot
async function screenshotEnhanced(){
  const c=document.getElementById('cenhanced');
  if(!c)return;
  
  const scale=2;
  const isDk=isDark();
  const mode=document.getElementById('enhMode')?.value||'range';
  let title='Enhanced Modular Rings';
  if(mode==='range'){
    const min=document.getElementById('enhMin')?.value||'1';
    const max=document.getElementById('enhMax')?.value||'30';
    title=`Enhanced Modular Rings (M${min}-M${max})`;
  }else if(mode==='power'){
    const base=document.getElementById('enhBase')?.value||'2';
    title=`Enhanced Modular Rings (${base}^n family)`;
  }
  
  const pad=40, titleH=55, footerH=35;
  const canvW=c.width, canvH=c.height;
  const totalW=canvW+pad*2;
  const totalH=canvH+titleH+footerH+pad;
  
  const out=document.createElement('canvas');
  out.width=totalW*scale;
  out.height=totalH*scale;
  const ctx=out.getContext('2d');
  ctx.scale(scale,scale);
  
  ctx.fillStyle=isDk?'#0d1321':'#fff';
  ctx.fillRect(0,0,totalW,totalH);
  
  const grad=ctx.createLinearGradient(0,0,totalW,0);
  grad.addColorStop(0,isDk?'#151b2d':'#e8e8e8');
  grad.addColorStop(1,isDk?'#1a2540':'#f5f5f5');
  ctx.fillStyle=grad;
  ctx.fillRect(0,0,totalW,titleH);
  ctx.fillStyle=isDk?'#00d9ff':'#0066cc';
  ctx.font='bold 20px Segoe UI';
  ctx.textAlign='center';
  ctx.fillText(title,totalW/2,35);
  
  const canvX=pad, canvY=titleH+10;
  ctx.strokeStyle=isDk?'rgba(0,217,255,.4)':'rgba(0,102,204,.3)';
  ctx.lineWidth=2;
  ctx.strokeRect(canvX-2,canvY-2,canvW+4,canvH+4);
  ctx.drawImage(c,canvX,canvY,canvW,canvH);
  
  // Path info
  if(window.enhSBHighlightPath&&window.enhSBHighlightPath.length>0&&window.enhSBSelectedNode){
    ctx.save();
    const pathW=180, pathH=Math.min(200,40+window.enhSBHighlightPath.length*18);
    const pathX=canvX+15, pathY=canvY+15;
    ctx.fillStyle=isDk?'rgba(13,19,33,.95)':'rgba(255,255,255,.95)';
    ctx.fillRect(pathX,pathY,pathW,pathH);
    ctx.strokeStyle='rgba(0,255,136,.6)';
    ctx.lineWidth=2;
    ctx.strokeRect(pathX,pathY,pathW,pathH);
    ctx.fillStyle='#00ff88';
    ctx.font='bold 11px Segoe UI';
    ctx.textAlign='left';
    ctx.fillText('STERN-BROCOT PATH',pathX+10,pathY+18);
    ctx.fillStyle='#ffd700';
    ctx.font='bold 12px Segoe UI';
    ctx.fillText(`‚Üí ${window.enhSBSelectedNode.p}/${window.enhSBSelectedNode.q}`,pathX+10,pathY+36);
    ctx.fillStyle='#00d9ff';
    ctx.font='10px Segoe UI';
    let py=pathY+54;
    window.enhSBHighlightPath.forEach((node,i)=>{
      if(py<pathY+pathH-10){
        const arrow=i===window.enhSBHighlightPath.length-1?'‚óè':'‚Üí';
        ctx.fillText(`${arrow} ${node.p}/${node.q}`,pathX+10,py);
        py+=16;
      }
    });
    ctx.restore();
  }
  
  // Legend
  ctx.save();
  const legW=160, legH=100;
  const legX=canvX+canvW-legW-15, legY=canvY+15;
  ctx.fillStyle=isDk?'rgba(13,19,33,.92)':'rgba(255,255,255,.92)';
  ctx.fillRect(legX,legY,legW,legH);
  ctx.strokeStyle=isDk?'rgba(0,217,255,.5)':'rgba(0,102,204,.5)';
  ctx.lineWidth=1;
  ctx.strokeRect(legX,legY,legW,legH);
  ctx.fillStyle=isDk?'#00d9ff':'#0066cc';
  ctx.font='bold 12px Segoe UI';
  ctx.textAlign='left';
  ctx.fillText('LEGEND',legX+10,legY+17);
  ctx.font='12px Segoe UI';
  ctx.fillStyle=isDk?'#ffd700':'#cc8800';
  ctx.fillText('‚óè Coprime (GCD=1)',legX+10,legY+34);
  ctx.fillStyle=isDk?'#666':'#999';
  ctx.fillText('‚óã Non-coprime',legX+10,legY+50);
  ctx.fillStyle=isDk?'#9664ff':'#7744dd';
  ctx.fillText('‚ñ∞ Highlighted sector',legX+10,legY+67);
  ctx.fillStyle=isDk?'#00ff88':'#00aa55';
  ctx.fillText('‚óØ Unit circle',legX+10,legY+84);
  ctx.restore();
  
  ctx.fillStyle=isDk?'#506080':'#888';
  ctx.font='11px Segoe UI';
  ctx.textAlign='center';
  ctx.fillText('Enhanced Modular Rings ‚Äî @7dview',totalW/2,totalH-12);
  
  out.toBlob(b=>{
    const a=document.createElement('a');
    a.href=URL.createObjectURL(b);
    a.download='enhanced_modular.png';
    a.click();
  },'image/png',1.0);
}

function exportAllEnhanced(){
  screenshotEnhanced();
  csvEnhanced();
}

// CSV export
function csvEnhanced(){
  let csv='Modulus,Residue,GCD,Coprime,Fraction,Decimal\n';
  enhRingsData.forEach(ring=>{
    ring.allRes.forEach(r=>{
      const g=gcd(r,ring.mod);
      csv+=`${ring.mod},${r},${g},${g===1?'Yes':'No'},${r}/${ring.mod},${(r/ring.mod).toFixed(6)}\n`;
    });
  });
  const blob=new Blob([csv],{type:'text/csv'});
  const a=document.createElement('a');
  a.href=URL.createObjectURL(blob);
  a.download='enhanced_modular_data.csv';
  a.click();
}

// Initialize
document.addEventListener('DOMContentLoaded',()=>{
  enhModeChange();
  drawEnhanced();
});
</script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Enhanced Modular Rings — Interactive Visualization</title>
<meta name="description" content="Interactive visualization of Enhanced Modular Rings with Farey sequences, Stern-Brocot trees, Ford circles, and modular arithmetic structures.">
<meta name="author" content="Wessen Getachew">
<meta name="keywords" content="number theory, Möbius function, prime numbers, lattice points, Riemann zeta, Hardy-Littlewood, Chinese Remainder Theorem, sieve theory">
<style>
*{margin:0;padding:0;box-sizing:border-box}
:root{--bg:#1a1f3a;--bg2:#252d4a;--acc:#0084d1;--acc2:#ff4081;--acc3:#26c485;--txt:#fff;--txt2:#b0b8d8;--plot:rgba(10,14,39,0.8);--bord:rgba(0,217,255,0.3)}
body.light{--bg:#f5f7fa;--bg2:#fff;--acc:#0066cc;--acc2:#d32f2f;--acc3:#388e3c;--txt:#1a1a1a;--txt2:#4a5568;--plot:rgba(245,247,250,0.95);--bord:rgba(0,102,204,0.3)}
/* Theme: Midnight */
body.theme-midnight{--bg:#0d1117;--bg2:#161b22;--acc:#58a6ff;--acc2:#f78166;--acc3:#3fb950;--txt:#c9d1d9;--txt2:#8b949e;--plot:rgba(13,17,23,0.95);--bord:rgba(88,166,255,0.3)}
/* Theme: Sepia */
body.theme-sepia{--bg:#f4ecd8;--bg2:#faf6eb;--acc:#8b4513;--acc2:#cd5c5c;--acc3:#228b22;--txt:#3c2415;--txt2:#5d4e37;--plot:rgba(244,236,216,0.95);--bord:rgba(139,69,19,0.3)}
/* Theme: Ocean */
body.theme-ocean{--bg:#0a1628;--bg2:#0f2744;--acc:#00d4ff;--acc2:#ff6b9d;--acc3:#00ffa3;--txt:#e0f4ff;--txt2:#7eb8da;--plot:rgba(10,22,40,0.95);--bord:rgba(0,212,255,0.3)}
/* Theme: Forest */
body.theme-forest{--bg:#1a2f1a;--bg2:#243524;--acc:#7cb342;--acc2:#ffb74d;--acc3:#4db6ac;--txt:#e8f5e9;--txt2:#a5d6a7;--plot:rgba(26,47,26,0.95);--bord:rgba(124,179,66,0.3)}
/* Theme: Sunset */
body.theme-sunset{--bg:#2d1b2e;--bg2:#3d2a3e;--acc:#ff7043;--acc2:#ffca28;--acc3:#ab47bc;--txt:#fce4ec;--txt2:#ce93d8;--plot:rgba(45,27,46,0.95);--bord:rgba(255,112,67,0.3)}
body{font-family:'Segoe UI',sans-serif;background:linear-gradient(135deg,var(--bg),#1a2a4a);color:var(--txt);line-height:1.6}
header{background:var(--bg2);border-bottom:2px solid var(--acc);padding:1rem 2rem}
h1{font-size:1.8rem;color:var(--acc)}
.hdr{display:flex;justify-content:space-between;align-items:center;flex-wrap:wrap;gap:1rem}
.container{max-width:1800px;margin:0 auto;padding:0 1rem 2rem}
.snav{background:var(--bg2);padding:1rem;border-radius:8px;margin-bottom:1.5rem;display:flex;gap:.5rem;flex-wrap:wrap}
.nbtn{background:rgba(0,217,255,.1);color:var(--acc);border:2px solid var(--acc);padding:.7rem 1.2rem;border-radius:4px;cursor:pointer;font-weight:600;font-size:.95rem}
.nbtn:hover,.nbtn.active{background:var(--acc);color:var(--bg)}
.sec{display:none}.sec.active{display:block}
.mainSec{display:none}
.tabs{display:flex;gap:.5rem;margin-bottom:1.5rem;border-bottom:2px solid rgba(0,217,255,.2);flex-wrap:wrap}
.tbtn{background:transparent;color:var(--txt2);border:none;padding:.7rem 1.2rem;cursor:pointer;font-size:.95rem;border-bottom:3px solid transparent;border-radius:6px 6px 0 0;transition:all .2s}
.tbtn:hover{color:var(--acc);background:rgba(255,255,255,.05)}.tbtn.active{color:var(--acc);border-bottom-color:var(--acc)}
/* UNIQUE/ORIGINAL - Key observations (magenta glow) */
.tbtn.cat-unique{border-left:3px solid #ff6496;background:linear-gradient(90deg,rgba(255,100,150,.12),transparent)}
.tbtn.cat-unique:hover,.tbtn.cat-unique.active{background:linear-gradient(90deg,rgba(255,100,150,.25),transparent);box-shadow:0 0 8px rgba(255,100,150,.4)}
/* ZETA/L-FUNCTIONS (gold) */
.tbtn.cat-zeta{border-left:3px solid #ffd700;background:linear-gradient(90deg,rgba(255,215,0,.08),transparent)}
.tbtn.cat-zeta:hover,.tbtn.cat-zeta.active{background:linear-gradient(90deg,rgba(255,215,0,.18),transparent)}
/* PRIME STRUCTURE (cyan) */
.tbtn.cat-prime{border-left:3px solid #00d9ff;background:linear-gradient(90deg,rgba(0,217,255,.08),transparent)}
.tbtn.cat-prime:hover,.tbtn.cat-prime.active{background:linear-gradient(90deg,rgba(0,217,255,.18),transparent)}
/* ARITHMETIC FUNCTIONS (green) */
.tbtn.cat-arith{border-left:3px solid #00ff88;background:linear-gradient(90deg,rgba(0,255,136,.08),transparent)}
.tbtn.cat-arith:hover,.tbtn.cat-arith.active{background:linear-gradient(90deg,rgba(0,255,136,.18),transparent)}
/* COPRIMALITY/MODULAR (blue) */
.tbtn.cat-coprime{border-left:3px solid #4488ff;background:linear-gradient(90deg,rgba(68,136,255,.08),transparent)}
.tbtn.cat-coprime:hover,.tbtn.cat-coprime.active{background:linear-gradient(90deg,rgba(68,136,255,.18),transparent)}
/* ALGEBRAIC/SEQUENCES (orange) */
.tbtn.cat-algebra{border-left:3px solid #ff8c00;background:linear-gradient(90deg,rgba(255,140,0,.08),transparent)}
.tbtn.cat-algebra:hover,.tbtn.cat-algebra.active{background:linear-gradient(90deg,rgba(255,140,0,.18),transparent)}
/* SPECIAL NUMBERS (purple) */
.tbtn.cat-special{border-left:3px solid #9664ff;background:linear-gradient(90deg,rgba(150,100,255,.08),transparent)}
.tbtn.cat-special:hover,.tbtn.cat-special.active{background:linear-gradient(90deg,rgba(150,100,255,.18),transparent)}
/* SPIRALS/VISUAL (teal) */
.tbtn.cat-visual{border-left:3px solid #00cca3;background:linear-gradient(90deg,rgba(0,204,163,.08),transparent)}
.tbtn.cat-visual:hover,.tbtn.cat-visual.active{background:linear-gradient(90deg,rgba(0,204,163,.18),transparent)}
.tab{display:none}.tab.active{display:block}
.ctrl{background:var(--bg2);padding:1rem;border-radius:8px;margin-bottom:1rem;display:grid;grid-template-columns:repeat(auto-fit,minmax(240px,1fr));gap:.8rem}
.toolSec{border-radius:6px;margin-bottom:.3rem;padding:.5rem}
.toolSecHead{cursor:pointer;display:flex;justify-content:space-between;align-items:center;padding:4px 0}
.toolSecHead:hover{opacity:0.85}
.toolSecBody{padding-top:.5rem}
.secToggleBar{display:flex;gap:.3rem;margin-bottom:.5rem}
.secToggleBar button{padding:3px 8px;font-size:.7rem;border-radius:4px;cursor:pointer}
.cg{display:flex;flex-direction:column}
.cg label{color:var(--acc);margin-bottom:.3rem;font-weight:600;font-size:.85rem;display:flex;align-items:center;gap:.3rem}
.tip{width:16px;height:16px;background:var(--acc);color:var(--bg);border-radius:50%;display:inline-flex;align-items:center;justify-content:center;font-size:.7rem;font-weight:bold;cursor:help}
.cg input,.cg select{background:var(--bg);color:var(--txt);border:2px solid var(--acc);padding:.5rem;border-radius:4px}
.sig{display:flex;gap:.4rem;align-items:center}
.sig input[type="range"]{flex:1}.sig input[type="number"]{width:70px}
button{background:var(--acc2);color:#fff;border:none;padding:.5rem .8rem;border-radius:4px;cursor:pointer;font-weight:600;white-space:nowrap}
button:hover{background:var(--acc)}
button.s{background:var(--acc3);color:#000}
.bg{display:flex;flex-wrap:wrap;gap:.4rem;margin-bottom:1rem;align-items:center}
@media(min-width:900px){.bg{flex-wrap:wrap;justify-content:flex-start}}
.viz{background:var(--bg2);border-radius:8px;padding:1rem;margin-bottom:1rem;border:1px solid rgba(0,217,255,.2)}
.viz h3{color:var(--acc);margin-bottom:.8rem;font-size:1.1rem}
canvas{display:block;border:2px solid var(--acc);border-radius:6px;width:100%;max-width:800px;height:auto;margin:0 auto .8rem;cursor:crosshair}
.pc{width:100%;height:400px}
.g2{display:grid;grid-template-columns:1fr 1fr;gap:1rem}
@media(max-width:1200px){.g2{grid-template-columns:1fr}}
.sg{display:grid;grid-template-columns:repeat(auto-fit,minmax(110px,1fr));gap:.5rem;margin-top:.5rem}
.sb{background:rgba(0,217,255,.1);border:1px solid var(--acc);padding:.5rem;border-radius:4px;text-align:center}
.sl{color:var(--txt2);font-size:.75rem}.sv{color:var(--acc);font-size:1.1rem;font-weight:700;font-family:monospace}
table{width:100%;border-collapse:collapse;font-size:.85rem;margin-top:.8rem}
th,td{padding:.5rem;text-align:left;border-bottom:1px solid rgba(0,217,255,.2)}
th{color:var(--acc);background:rgba(0,217,255,.1)}
.al{background:rgba(0,217,255,.05);padding:.8rem;border-radius:4px;margin-top:.8rem;border:1px solid rgba(0,217,255,.2)}
.al h4{color:var(--acc);margin-bottom:.5rem;font-size:.95rem}
.lg{display:grid;grid-template-columns:repeat(auto-fit,minmax(150px,1fr));gap:.5rem}
.li{background:var(--bg);padding:.5rem;border-radius:4px;border-left:4px solid var(--acc);font-size:.75rem}
.li strong{color:var(--acc);display:block}.li .v{color:var(--txt2);font-family:monospace}
.ts{background:var(--bg2);padding:2rem;border-radius:8px;margin-bottom:1.5rem;border-left:4px solid var(--acc2)}
.ts h2{color:var(--acc);margin:1.5rem 0 1rem;font-size:1.5rem}.ts h2:first-child{margin-top:0}
.ts h3{color:var(--acc2);margin:1rem 0 .5rem;font-size:1.2rem}
.ts p,.ts li{color:var(--txt2);margin-bottom:.8rem;line-height:1.8}
.ts ul{margin-left:2rem}
.fm{background:rgba(0,0,0,.4);padding:1rem;font-family:monospace;margin:1rem 0;border-left:3px solid var(--acc2);border-radius:4px;overflow-x:auto}
body.light .fm{background:rgba(0,0,0,.08)}
.rs{background:var(--bg2);padding:1.5rem;border-radius:8px;margin-bottom:1.5rem;border-left:4px solid var(--acc)}
.rs h3{color:var(--acc);margin-bottom:.8rem;font-size:1.15rem}
.rs h4{color:var(--acc2);margin:1rem 0 .5rem}
.rs p,.rs li{color:var(--txt2);margin-bottom:.6rem;line-height:1.7}
.rs ul,.rs ol{margin-left:1.5rem}
.fb{background:rgba(0,217,255,.08);padding:1rem;border-radius:4px;margin:.8rem 0;border:1px solid rgba(0,217,255,.3);border-left:4px solid var(--acc2)}
.fb strong{color:var(--acc)}
.modal{display:none;position:fixed;z-index:2000;left:0;top:0;width:100%;height:100%;background:rgba(0,0,0,.7);overflow-y:auto}
.modal.active{display:flex;align-items:center;justify-content:center}
.mc{background:var(--bg2);padding:2rem;border:2px solid var(--acc);border-radius:8px;width:90%;max-width:600px;max-height:80vh;overflow-y:auto}
.mc h2{color:var(--acc);margin-bottom:1rem}
.ds{background:rgba(0,217,255,.1);padding:1rem;border-radius:4px;margin:.5rem 0;border-left:3px solid var(--acc)}
.dr{display:flex;justify-content:space-between;padding:.3rem 0;font-family:monospace}
.dl{color:var(--acc2);font-weight:600}.dv{color:var(--acc);font-weight:700}
.mx{color:var(--acc);float:right;font-size:2rem;cursor:pointer}
.prec{display:flex;align-items:center;gap:.5rem}
.prec label{color:var(--acc);font-weight:600}
.prec select{background:var(--bg);color:var(--acc);border:1px solid var(--acc);padding:.4rem}
.thm{background:var(--bg2);color:var(--acc);border:2px solid var(--acc);padding:.6rem .9rem;border-radius:4px;font-size:1.2rem;cursor:pointer;min-width:44px}
footer{text-align:center;padding:2rem;color:var(--txt2);border-top:1px solid rgba(0,217,255,.2);margin-top:2rem}
.zeroTable{font-size:.85rem;margin-top:.8rem}
.zeroTable th,.zeroTable td{padding:.5rem;text-align:left;border-bottom:1px solid rgba(0,217,255,.2)}
.zeroTable th{color:var(--acc);background:rgba(0,217,255,.1)}
</style>
</head>
<body class="theme-midnight">
<header>
<div class="hdr">
<div>
<h1 style="font-size:1.6rem">Enhanced Modular Rings — Interactive Visualization</h1>
<p style="color:var(--txt2);font-size:.85rem;font-style:italic;margin-top:.25rem">Farey sequences, Stern-Brocot trees, and modular arithmetic visualization</p>
</div>
<div style="display:flex;gap:.75rem;align-items:center;flex-wrap:wrap">
<div class="prec" style="display:flex;align-items:center;gap:.4rem">
<label style="font-size:.8rem;color:var(--txt2)">Theme:</label>
<select id="themeSelect" onchange="setTheme(this.value)" style="padding:6px 10px;border-radius:4px;background:var(--bg2);color:var(--txt);border:1px solid var(--bord);font-size:.85rem">
<option value="dark"> Dark</option>
<option value="light">️ Light</option>
<option value="midnight" selected>Midnight</option>
<option value="ocean"> Ocean</option>
<option value="forest"> Forest</option>
<option value="sunset"> Sunset</option>
<option value="sepia"> Sepia</option>
</select>
</div>
<div class="prec"><label>Decimals:</label><select id="prec" onchange="P=+this.value;redrawAll()">
<option value="2">2</option><option value="4" selected>4</option><option value="6">6</option><option value="8">8</option><option value="10">10</option><option value="12">12</option><option value="14">14</option><option value="16">16</option>
</select></div>
<label style="display:flex;align-items:center;gap:.4rem;cursor:pointer;padding:6px 12px;background:var(--bg2);border-radius:6px;border:1px solid var(--bord)">
<input type="checkbox" id="globalFractionToggle" onchange="showFractions=this.checked;redrawAll()" style="width:16px;height:16px">
<span style="font-size:.85rem;color:#ffd700">Fractions</span>
</label>
<div style="display:flex;gap:.5rem;margin-left:.5rem">
<a href="https://www.paypal.com/donate?business=getachewwessen%40gmail.com&currency_code=USD" target="_blank" style="display:flex;align-items:center;gap:4px;padding:6px 12px;background:linear-gradient(135deg,#0070ba,#003087);color:#fff;border-radius:6px;text-decoration:none;font-size:.8rem;font-weight:600;border:none;cursor:pointer;transition:transform .2s,box-shadow .2s" onmouseover="this.style.transform='translateY(-2px)';this.style.boxShadow='0 4px 12px rgba(0,112,186,.4)'" onmouseout="this.style.transform='';this.style.boxShadow=''">
<svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor"><path d="M7.076 21.337H2.47a.641.641 0 0 1-.633-.74L4.944.901C5.026.382 5.474 0 5.998 0h7.46c2.57 0 4.578.543 5.69 1.81 1.01 1.15 1.304 2.42 1.012 4.287-.023.143-.047.288-.077.437-.983 5.05-4.349 6.797-8.647 6.797h-2.19c-.524 0-.968.382-1.05.9l-1.12 7.106z"/></svg>
PayPal
</a>
<button onclick="showBtcDonate()" style="display:flex;align-items:center;gap:4px;padding:6px 12px;background:linear-gradient(135deg,#f7931a,#e08916);color:#fff;border-radius:6px;font-size:.8rem;font-weight:600;border:none;cursor:pointer;transition:transform .2s,box-shadow .2s" onmouseover="this.style.transform='translateY(-2px)';this.style.boxShadow='0 4px 12px rgba(247,147,26,.4)'" onmouseout="this.style.transform='';this.style.boxShadow=''">
<svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor"><path d="M23.638 14.904c-1.602 6.43-8.113 10.34-14.542 8.736C2.67 22.05-1.244 15.525.362 9.105 1.962 2.67 8.475-1.243 14.9.358c6.43 1.605 10.342 8.115 8.738 14.546z"/><path fill="#fff" d="M14.271 12.147c.188-1.268-.777-1.951-2.099-2.405l.429-1.72-1.047-.261-.418 1.674c-.275-.069-.558-.133-.839-.197l.421-1.686-1.047-.261-.429 1.72c-.228-.052-.452-.103-.668-.157l.001-.005-1.444-.361-.278 1.118s.777.178.761.189c.425.106.502.388.489.611l-.49 1.965c.029.008.067.019.109.036l-.111-.028-.687 2.754c-.052.129-.184.323-.482.249.01.015-.762-.19-.762-.19l-.52 1.199 1.363.34c.253.064.502.13.746.193l-.434 1.74 1.046.261.429-1.72c.286.078.564.149.836.215l-.427 1.711 1.047.261.433-1.736c1.79.339 3.134.202 3.7-1.416.457-1.303-.023-2.055-1.069-2.545.76-.175 1.333-.674 1.486-1.704z"/></svg>
BTC
</button>
</div>
</div>
</div>
<!-- Bitcoin donation modal -->
<div id="btcModal" style="display:none;position:fixed;top:0;left:0;right:0;bottom:0;background:rgba(0,0,0,.8);z-index:10000;justify-content:center;align-items:center">
<div style="background:var(--bg1);border-radius:16px;padding:2rem;max-width:450px;text-align:center;border:2px solid #f7931a;box-shadow:0 20px 60px rgba(0,0,0,.5)">
<h3 style="color:#f7931a;margin-bottom:1rem;font-size:1.4rem">₿ Bitcoin Donation</h3>
<p style="color:var(--txt2);margin-bottom:1rem;font-size:.9rem">Support mathematical research and open-source development</p>
<div style="background:var(--bg2);padding:1rem;border-radius:8px;font-family:monospace;font-size:.85rem;word-break:break-all;color:var(--txt);border:1px solid var(--bord);margin-bottom:1rem">bc1qtsuj9x372slcgead3tlnrpw0r6tu7y7y0xwuk4</div>
<div style="display:flex;gap:.5rem;justify-content:center">
<button onclick="copyBtcAddress()" style="padding:10px 20px;background:#f7931a;color:#fff;border:none;border-radius:8px;cursor:pointer;font-weight:600">Copy Address</button>
<button onclick="document.getElementById('btcModal').style.display='none'" style="padding:10px 20px;background:var(--bg2);color:var(--txt);border:1px solid var(--bord);border-radius:8px;cursor:pointer">Close</button>
</div>
<p style="color:var(--txt2);font-size:.8rem;margin-top:1rem;font-style:italic">Thank you for supporting open mathematical tools!</p>
</div>
</div>
</header>
<div class="container" style="max-width:100%">
<!-- Main Navigation Tabs -->
<div class="snav" style="margin-bottom:1rem">
<button class="nbtn active" onclick="showMainSec('tool',this)">Interactive Tool</button>
<button class="nbtn" onclick="showMainSec('theory',this)">Theory</button>
<button class="nbtn" onclick="showMainSec('reference',this)">Reference</button>
<button class="nbtn" onclick="showMainSec('boundary',this)" style="border-color:#ff6b9d;color:#ff6b9d">Boundary Cancellation</button>
</div>

<!-- TOOL SECTION -->
<div id="secTool" class="mainSec" style="display:block">
<div style="padding:0">
<div id="tenhanced">
<div style="background:linear-gradient(135deg,rgba(255,215,0,.15),rgba(72,187,120,.1));padding:1rem;border-radius:8px;margin-bottom:1rem;border-left:4px solid #ffd700">
<h3 style="color:#ffd700;margin-bottom:.5rem">Enhanced Modular Lifting Rings</h3>
<p style="color:var(--txt2);font-size:.9rem;margin-bottom:.75rem">Interactive ring visualization with gap analysis, power families (a^b), lift dynamics, Smith Chart transform, <strong style="color:#9664ff">Multiplication Table</strong>, <strong style="color:#ff8c00">Arnold Tongues</strong> (phase-locking regions), and frequency distribution analysis. Explore units, zero divisors, Stern-Brocot trees, and Farey sequences.</p>
<div style="display:flex;flex-wrap:wrap;gap:.5rem">
<button onclick="showEnhancedTab()" style="padding:4px 10px;border-radius:4px;border:1px solid var(--bord);background:var(--bg2);color:var(--txt);cursor:pointer"> Modular Rings</button>
<button onclick="showZetaTab()" style="padding:4px 10px;border-radius:4px;border:1px solid #ffd700;background:rgba(255,215,0,.15);color:#ffd700;cursor:pointer;font-weight:600"> Z-Function</button>
</div>
<button onclick="enhSetRange(1,30)" style="padding:4px 10px;border-radius:4px;border:1px solid var(--bord);background:var(--bg2);color:var(--txt);cursor:pointer">M≤30</button>
<button onclick="enhSetRange(1,60)" style="padding:4px 10px;border-radius:4px;border:1px solid var(--bord);background:var(--bg2);color:var(--txt);cursor:pointer">M≤60</button>
<button onclick="enhSetPower(2,10)" style="padding:4px 10px;border-radius:4px;border:1px solid var(--bord);background:#2a4a6a;color:#fff;cursor:pointer">2^n (n≤10)</button>
<button onclick="enhSetPower(3,8)" style="padding:4px 10px;border-radius:4px;border:1px solid var(--bord);background:#4a2a6a;color:#fff;cursor:pointer">3^n (n≤8)</button>
<button onclick="enhSetPrimorials()" style="padding:4px 10px;border-radius:4px;border:1px solid var(--bord);background:#1a472a;color:#fff;cursor:pointer">Primorials</button>
<button onclick="enhSetPrimes()" style="padding:4px 10px;border-radius:4px;border:1px solid var(--bord);background:#6a1a4a;color:#fff;cursor:pointer">Primes</button>
</div>
<div style="margin-top:.75rem;display:flex;flex-wrap:wrap;gap:.3rem">
<button onclick="toggleEnhSection('all')" style="padding:3px 8px;font-size:.75rem;border-radius:4px;border:1px solid #00d9ff;background:rgba(0,217,255,.15);color:#00d9ff;cursor:pointer">Expand All</button>
<button onclick="toggleEnhSection('none')" style="padding:3px 8px;font-size:.75rem;border-radius:4px;border:1px solid #ff6496;background:rgba(255,100,150,.15);color:#ff6496;cursor:pointer">Collapse All</button>
</div>
</div>

<!-- All Control Sections -->
<div style="background:var(--bg2);border:1px solid var(--bord);border-radius:8px;padding:1rem;margin-bottom:1rem">

<!-- ===== CORE SETTINGS ===== -->
<div style="margin-bottom:.75rem;padding-bottom:.5rem;border-bottom:1px solid var(--bord)">
<span style="font-size:.7rem;text-transform:uppercase;letter-spacing:1px;color:#00d9ff">Core Settings</span>
</div>

<!-- Section 1: Modulus Selection -->
<div class="ctrl" style="background:rgba(0,217,255,.08);border-radius:6px;padding:.5rem;margin-bottom:.5rem">
<div class="cg" style="cursor:pointer" onclick="toggleEnhSection('enhSecModulus')">
<label style="display:flex;justify-content:space-between;align-items:center;cursor:pointer">
<strong style="color:#00d9ff"> Modulus Selection</strong>
<span id="enhSecModulusIcon" style="color:#00d9ff">−</span>
</label>
</div>
<div id="enhSecModulus" style="display:block">
<div class="cg"><label><strong>Mode</strong></label><select id="enhMode" onchange="enhModeChange();drawEnhanced()">
<option value="range">Consecutive Range (M₁ to M₂)</option>
<option value="power">Power Family (aᵇ for b=0..n)</option>
<option value="custom">Custom List</option>
</select></div>
</div>
<div id="enhRangeControls">
<div class="ctrl">
<div class="cg"><label>Min Modulus</label><input type="number" id="enhMin" value="1" min="1" max="500" onchange="drawEnhanced()"></div>
<div class="cg"><label>Max Modulus</label><input type="number" id="enhMax" value="30" min="1" max="500" onchange="drawEnhanced()"></div>
</div>
</div>
<div id="enhPowerControls" style="display:none">
<div class="ctrl">
<div class="cg"><label>Base a</label><input type="number" id="enhBase" value="2" min="2" max="20" onchange="drawEnhanced()"></div>
<div class="cg"><label>Max Exponent n</label><input type="number" id="enhMaxExp" value="10" min="1" max="20" onchange="drawEnhanced()"></div>
<div class="cg"><label>Start Exponent</label><input type="number" id="enhMinExp" value="0" min="0" max="10" onchange="drawEnhanced()"></div>
<div class="cg"><label style="display:flex;gap:.3rem;flex-wrap:wrap">
<button onclick="enhSetPower(2,10)" style="padding:2px 8px;font-size:.8rem;border-radius:4px;border:1px solid var(--bord);background:var(--bg2);color:var(--txt);cursor:pointer">2^n</button>
<button onclick="enhSetPower(3,8)" style="padding:2px 8px;font-size:.8rem;border-radius:4px;border:1px solid var(--bord);background:var(--bg2);color:var(--txt);cursor:pointer">3^n</button>
<button onclick="enhSetPower(5,6)" style="padding:2px 8px;font-size:.8rem;border-radius:4px;border:1px solid var(--bord);background:var(--bg2);color:var(--txt);cursor:pointer">5^n</button>
<button onclick="enhSetPower(6,5)" style="padding:2px 8px;font-size:.8rem;border-radius:4px;border:1px solid var(--bord);background:var(--bg2);color:var(--txt);cursor:pointer">6^n</button>
<button onclick="enhSetPower(10,5)" style="padding:2px 8px;font-size:.8rem;border-radius:4px;border:1px solid var(--bord);background:var(--bg2);color:var(--txt);cursor:pointer">10^n</button>
</label></div>
</div>
</div>
<div id="enhCustomControls" style="display:none">
<div class="ctrl">
<div class="cg"><label>Custom Moduli (comma-separated)</label><input type="text" id="enhCustomList" value="1,2,4,8,16,32" onchange="drawEnhanced()" style="width:100%"></div>
</div>
</div>
</div>

<!-- Section 2: Visualization Mode -->
<div class="ctrl" style="border-radius:6px;padding:.5rem;margin-bottom:.5rem">
<div class="cg" style="cursor:pointer" onclick="toggleEnhSection('enhSecViz')">
<label style="display:flex;justify-content:space-between;align-items:center;cursor:pointer">
<strong style="color:#ffd700"> Visualization Mode</strong>
<span id="enhSecVizIcon" style="color:#ffd700">−</span>
</label>
</div>
<div id="enhSecViz" style="display:block">
<div class="cg"><label><strong>Visualization Mode</strong></label><select id="enhVizMode" onchange="drawEnhanced()">
<option value="rings">2D Concentric Rings</option>
<option value="farey3d">3D Farey Lattice</option>
<option value="composite">Composite Structure</option>
<option value="multtable">Multiplication Table</option>
<option value="heatmap">GCD Landscape Heatmap</option>
<option value="totient">Totient Ratio φ(M)/M</option>
<option value="orbit">Multiplicative Orbits</option>
<option value="fordcircles">Ford Circles</option>
<option value="trajectory">Trajectory Coherence Analysis</option>
</select></div>
</div></div>

<!-- ===== VISUAL CONTROLS ===== -->
<div style="margin:1rem 0 .75rem;padding-bottom:.5rem;border-bottom:1px solid var(--bord)">
<span style="font-size:.7rem;text-transform:uppercase;letter-spacing:1px;color:#ffd700">Visual Controls</span>
</div>

<!-- Section 3: Per-Ring Rotation -->
<div class="ctrl" style="background:rgba(255,215,0,.08);border-radius:6px;padding:.5rem;margin-bottom:.5rem">
<div class="cg" style="cursor:pointer" onclick="toggleEnhSection('enhSecRotation')">
<label style="display:flex;justify-content:space-between;align-items:center;cursor:pointer">
<strong style="color:#ffd700"> Per-Ring Rotation</strong>
<span id="enhSecRotationIcon" style="color:#ffd700">+</span>
</label>
</div>
<div id="enhSecRotation" style="display:none">
<div class="cg"><label>Ring Inc Δθ <span id="enhRingIncV" style="color:var(--txt2)">0°</span></label><div class="sig"><input type="range" id="enhRingInc" min="0" max="180" value="0" step="0.5" oninput="document.getElementById('enhRingIncV').textContent=this.value+'°';drawEnhanced()"></div></div>
<div class="cg"><label>Fraction a/m</label><div style="display:flex;gap:.3rem;align-items:center"><input type="text" id="enhRingFrac" value="" placeholder="1/2, 1/3, 2/5..." style="width:70px;padding:3px 6px;border-radius:4px;border:1px solid var(--bord);background:var(--bg2);color:var(--txt)" onchange="applyEnhFraction()"><button onclick="applyEnhFraction()" style="padding:3px 8px;border-radius:4px;border:1px solid #ffd700;background:rgba(255,215,0,.2);color:#ffd700;cursor:pointer;font-size:.8rem">Apply</button><span id="enhFracDeg" style="color:var(--txt2);font-size:.8rem;margin-left:.3rem"></span></div></div>
<div class="cg"><label>Global Phase <span id="enhPhaseV" style="color:var(--txt2)">0°</span></label><div class="sig"><input type="range" id="enhPhase" min="0" max="360" value="0" step="1" oninput="document.getElementById('enhPhaseV').textContent=this.value+'°';drawEnhanced()"></div></div>
<div class="cg"><label>Rotation Presets</label><div style="display:flex;gap:.3rem;flex-wrap:wrap">
<button onclick="setEnhRingInc(0)" style="padding:2px 6px;border-radius:3px;border:1px solid var(--bord);background:var(--bg2);color:var(--txt);cursor:pointer;font-size:.75rem">0°</button>
<button onclick="setEnhRingFrac('1/12')" style="padding:2px 6px;border-radius:3px;border:1px solid var(--bord);background:var(--bg2);color:var(--txt);cursor:pointer;font-size:.75rem">1/12 (30°)</button>
<button onclick="setEnhRingFrac('1/6')" style="padding:2px 6px;border-radius:3px;border:1px solid var(--bord);background:var(--bg2);color:var(--txt);cursor:pointer;font-size:.75rem">1/6 (60°)</button>
<button onclick="setEnhRingFrac('1/4')" style="padding:2px 6px;border-radius:3px;border:1px solid #00d9ff;background:rgba(0,217,255,.2);color:#00d9ff;cursor:pointer;font-size:.75rem">1/4 (90°)</button>
<button onclick="setEnhRingFrac('1/3')" style="padding:2px 6px;border-radius:3px;border:1px solid var(--bord);background:var(--bg2);color:var(--txt);cursor:pointer;font-size:.75rem">1/3 (120°)</button>
<button onclick="setEnhRingFrac('1/2')" style="padding:2px 6px;border-radius:3px;border:1px solid #ff6496;background:rgba(255,100,150,.2);color:#ff6496;cursor:pointer;font-size:.75rem">1/2 (180°)</button>
<button onclick="setEnhRingFrac('137.5/360')" style="padding:2px 6px;border-radius:3px;border:1px solid #ffd700;background:rgba(255,215,0,.2);color:#ffd700;cursor:pointer;font-size:.75rem;font-weight:bold" title="Golden Angle">φ 137.5°</button>
</div></div>
<div class="cg"><label style="display:flex;gap:.5rem;flex-wrap:wrap">
<label><input type="checkbox" id="enhShowLabels" onchange="drawEnhanced()"> Ring Labels</label>
</label></div>
</div></div>

<!-- Mode-specific controls (3D, Composite, MultTable) -->
<div class="ctrl">
<div id="enhRingsControls"></div>
<div id="enh3DControls" style="display:none">
<div class="cg"><label>X Tilt <span id="enh3DXV" style="color:var(--txt2)">30°</span></label><input type="range" id="enh3DX" min="0" max="90" value="30" oninput="document.getElementById('enh3DXV').textContent=this.value+'°';drawEnhanced()"></div>
<div class="cg"><label>Y Rotate <span id="enh3DYV" style="color:var(--txt2)">0°</span></label><input type="range" id="enh3DY" min="0" max="360" value="0" oninput="document.getElementById('enh3DYV').textContent=this.value+'°';drawEnhanced()"></div>
<div class="cg"><label>Z Spin <span id="enh3DZV" style="color:var(--txt2)">0°</span></label><input type="range" id="enh3DZ" min="0" max="360" value="0" oninput="document.getElementById('enh3DZV').textContent=this.value+'°';drawEnhanced()"></div>
<div class="cg"><label style="display:flex;gap:.5rem;flex-wrap:wrap">
<label><input type="checkbox" id="enh3DChains" checked onchange="drawEnhanced()"> Farey Chains</label>
<label><input type="checkbox" id="enh3DLabels" onchange="drawEnhanced()"> Level Labels</label>
</label></div>
</div>
<div id="enhCompControls" style="display:none">
<div class="cg"><label style="display:flex;gap:.5rem;flex-wrap:wrap">
<label><input type="checkbox" id="enhCompProj" checked onchange="drawEnhanced()"> Projection Lines</label>
<label><input type="checkbox" id="enhCompChannels" checked onchange="drawEnhanced()"> Channel Rings</label>
</label></div>
<div class="cg"><label>Projection Opacity <span id="enhCompOpV" style="color:var(--txt2)">0.5</span></label><input type="range" id="enhCompOp" min="0.1" max="1" step="0.1" value="0.5" oninput="document.getElementById('enhCompOpV').textContent=this.value;drawEnhanced()"></div>
</div>
<div id="enhMultTableControls" style="display:none">
<div class="cg"><label>Table Type</label><select id="multTableType" onchange="drawEnhanced()">
<option value="mult">Multiplication (a x b mod m)</option>
<option value="cayley">Cayley Table (Units Only)</option>
<option value="add">Addition (a + b mod m)</option>
</select></div>
<div class="cg"><label>Color Scheme</label><select id="multTableColor" onchange="drawEnhanced()">
<option value="rainbow">Rainbow (by value)</option>
<option value="modular">Modular Hue</option>
<option value="divisibility">Divisibility Count</option>
<option value="zerodiv">Zero Divisors</option>
<option value="idempotent">Idempotents</option>
<option value="order">Element Order</option>
<option value="gcd">GCD with m</option>
<option value="quadres">Quadratic Residues</option>
<option value="plasma">Plasma</option>
<option value="viridis">Viridis</option>
<option value="thermal">Thermal</option>
<option value="grayscale">Grayscale</option>
</select></div>
<div class="cg"><label>Labels</label><select id="multLabelMode" onchange="drawEnhanced()">
<option value="value">Show Values</option>
<option value="none">No Labels</option>
<option value="small">Small Values</option>
<option value="order">Show Order</option>
</select></div>
<div class="cg"><label style="display:flex;gap:.5rem;flex-wrap:wrap">
<label><input type="checkbox" id="multShowSymmetry" onchange="drawEnhanced()"> Highlight Symmetry</label>
<label><input type="checkbox" id="multShowDiag" onchange="drawEnhanced()"> Highlight Diagonal</label>
</label></div>
<div class="cg"><label>Inspect Element</label><div style="display:flex;gap:.5rem;align-items:center"><input type="number" id="multInspect" value="1" min="0" max="999" style="width:60px" onchange="inspectMultElement()"><button onclick="inspectMultElement()" style="padding:4px 10px;border-radius:4px;border:1px solid var(--bord);background:var(--bg2);color:var(--txt);cursor:pointer">Analyze</button></div></div>
<div class="cg"><label>Presets</label><div style="display:flex;gap:.3rem;flex-wrap:wrap">
<button onclick="setMultMod(6)" style="padding:3px 8px;font-size:.8rem;border-radius:4px;border:1px solid var(--bord);background:var(--bg2);color:var(--txt);cursor:pointer">m=6</button>
<button onclick="setMultMod(12)" style="padding:3px 8px;font-size:.8rem;border-radius:4px;border:1px solid var(--bord);background:var(--bg2);color:var(--txt);cursor:pointer">m=12</button>
<button onclick="setMultMod(17)" style="padding:3px 8px;font-size:.8rem;border-radius:4px;border:1px solid var(--bord);background:linear-gradient(45deg,#ffd700,#ff6496);color:#000;cursor:pointer">m=17 (prime)</button>
<button onclick="setMultMod(30)" style="padding:3px 8px;font-size:.8rem;border-radius:4px;border:1px solid var(--bord);background:var(--bg2);color:var(--txt);cursor:pointer">m=30</button>
<button onclick="setMultMod(60)" style="padding:3px 8px;font-size:.8rem;border-radius:4px;border:1px solid var(--bord);background:var(--bg2);color:var(--txt);cursor:pointer">m=60</button>
</div></div>
<div id="multInspectResult" style="margin-top:8px;padding:10px;background:var(--bg1);border-radius:6px;font-size:.8rem;display:none"></div>
</div>

<!-- Section: Display Settings -->
<div class="ctrl" style="border-radius:6px;margin-bottom:.3rem">
<div class="cg" style="cursor:pointer" onclick="toggleEnhSection('enhSecDisplaySettings')">
<label style="display:flex;justify-content:space-between;align-items:center;cursor:pointer">
<strong style="color:#00ff88"> Display Settings</strong>
<span id="enhSecDisplaySettingsIcon" style="color:#00ff88">+</span>
</label>
</div>
<div id="enhSecDisplaySettings" style="display:none">
<div class="cg"><label>Ring Spacing</label><select id="enhScale" onchange="drawEnhanced()">
<option value="uniform" selected>Uniform</option>
<option value="linear">Linear (c·m)</option>
<option value="sqrt">Square Root (√m)</option>
<option value="log">Logarithmic</option>
<option value="phi">Totient φ(m)</option>
</select>
<label style="margin-left:1rem"><input type="checkbox" id="enhInvertRings" onchange="drawEnhanced()"> <strong style="color:#ff6496">Invert</strong> (outer→inner)</label></div>
<div class="cg"><label>Color Scheme</label><select id="enhCol" onchange="drawEnhanced()">
<option value="angular">Angular (Rainbow)</option>
<option value="gcd">By GCD (Gold=1)</option>
<option value="ring">By Ring Index</option>
<option value="coprime">Coprime Classes</option>
<option value="harmonic">Harmonic (by q)</option>
<option value="primelimit">Prime Limit (3/5/7...)</option>
<option value="tenney">Tenney Height (Complexity)</option>
<option value="consonance">Consonance Type</option>
<option value="spectrum">GCD Spectrum</option>
<option value="sector">Farey Sector</option>
<option value="depth">Stern-Brocot Depth</option>
<option value="primality">Primality (GCD·r)</option>
<option value="quadres">Quadratic Residues</option>
<option value="discrete">Discrete GCD (20 Colors)</option>
<option value="multtable">Mult Table (r×M mod M)</option>
<option value="zerodiv">Zero Divisors</option>
<option value="idempotent">Idempotents</option>
<option value="fire">Fire Gradient</option>
<option value="plasma">Plasma</option>
<option value="viridis">Viridis</option>
<option value="ocean">Ocean</option>
<option value="totient">By φ(M)</option>
<option value="numerator">Numerator Family</option>
</select></div>
<div class="cg"><label>Zoom</label><div style="display:flex;gap:.5rem;align-items:center"><input type="range" id="enhZoom" min="0.1" max="5" step="0.1" value="1" oninput="document.getElementById('enhZoomNum').value=this.value;drawEnhanced()" style="flex:1"><input type="number" id="enhZoomNum" value="1" min="0.1" max="10" step="0.1" style="width:55px" onchange="document.getElementById('enhZoom').value=Math.min(5,this.value);drawEnhanced()"><span>×</span></div></div>
<div class="cg"><label>Rotation</label><div style="display:flex;gap:.5rem;align-items:center"><input type="range" id="enhRot" min="0" max="360" step="1" value="0" oninput="document.getElementById('enhRotNum').value=this.value;drawEnhanced()" style="flex:1"><input type="number" id="enhRotNum" value="0" min="0" max="360" style="width:55px" onchange="document.getElementById('enhRot').value=this.value;drawEnhanced()"><span>°</span></div></div>
<div class="cg"><label>Point Size <span id="enhPtSzV" style="color:var(--txt2)">1.0</span></label><div style="display:flex;gap:4px;align-items:center"><input type="range" id="enhPtSz" min="0.1" max="2" step="0.1" value="1" oninput="document.getElementById('enhPtSzV').textContent=this.value;document.getElementById('enhPtSzNum').value=this.value;drawEnhanced()"><input type="number" id="enhPtSzNum" min="0.001" max="10" step="0.001" value="1" style="width:55px" onchange="document.getElementById('enhPtSzV').textContent=this.value;document.getElementById('enhPtSz').value=Math.min(2,Math.max(0.1,this.value));drawEnhanced()"><label style="margin-left:6px;font-size:.7rem"><input type="checkbox" id="autoScaleEnh" checked onchange="drawEnhanced()"> Auto</label></div></div>
<div class="cg"><label>Canvas Size</label><select id="enhCanvSz" onchange="resizeCanvasEnh()">
<option value="800">800×800 (Default)</option>
<option value="1000">1000×1000</option>
<option value="1200">1200×1200</option>
<option value="1600">1600×1600 (Large)</option>
<option value="2000">2000×2000 (XL)</option>
</select></div>
<div class="cg"><label>Label Size <span id="enhLblSzV" style="color:var(--txt2)">9px</span></label><div class="sig"><input type="range" id="enhLblSz" min="6" max="18" step="1" value="9" oninput="document.getElementById('enhLblSzV').textContent=this.value+'px';document.getElementById('enhLblSzNum').value=this.value;drawEnhanced()"><input type="number" id="enhLblSzNum" value="9" min="4" max="24" style="width:45px" onchange="document.getElementById('enhLblSz').value=Math.min(18,this.value);document.getElementById('enhLblSzV').textContent=this.value+'px';drawEnhanced()"></div></div>
</div></div>

<div class="ctrl" style="border-top:1px solid var(--bord);padding-top:.5rem;margin-top:.5rem;background:rgba(255,215,0,.08)">
<div class="cg" style="cursor:pointer" onclick="toggleEnhSection('enhSecSweep')">
<label style="display:flex;justify-content:space-between;align-items:center;cursor:pointer">
<strong style="color:#ffd700"> Sweep & Ray Overlays</strong>
<span id="enhSecSweepIcon" style="color:#ffd700">+</span>
</label>
</div>
<div id="enhSecSweep" style="display:none">
<div class="cg"><label style="display:flex;gap:.5rem;flex-wrap:wrap">
<label><input type="checkbox" id="enhShowRays" onchange="drawEnhanced()"> Light Rays</label>
<label><input type="checkbox" id="enhShowSectors" onchange="drawEnhanced()"> Sector Bounds</label>
<label><input type="checkbox" id="enhShowMediants" onchange="drawEnhanced()"> Mediant Lines</label>
</label></div>
<div class="cg"><label>Ray Opacity <span id="enhRayOpV" style="color:var(--txt2)">0.3</span></label><input type="range" id="enhRayOp" min="0.05" max="0.8" step="0.05" value="0.3" oninput="document.getElementById('enhRayOpV').textContent=this.value;drawEnhanced()"></div>
<div class="cg"><label>Ray Mode</label><select id="enhRayMode" onchange="drawEnhanced()">
<option value="all">All Points</option>
<option value="coprime">Coprime Only</option>
<option value="outer">Outer Ring Only</option>
<option value="farey">Farey Neighbors</option>
</select></div>
</div></div>

<!-- ===== ANALYSIS TOOLS ===== -->
<div style="margin:1rem 0 .75rem;padding-bottom:.5rem;border-bottom:1px solid var(--bord)">
<span style="font-size:.7rem;text-transform:uppercase;letter-spacing:1px;color:#9664ff">Analysis Tools</span>
</div>

<!-- Section 5: Farey Sector Analysis -->
<div class="ctrl" style="border-top:1px solid var(--bord);padding-top:.5rem;margin-top:.5rem;background:rgba(150,100,255,.1)">
<div class="cg" style="cursor:pointer" onclick="toggleEnhSection('enhSecFarey')">
<label style="display:flex;justify-content:space-between;align-items:center;cursor:pointer">
<strong style="color:#9664ff"> Farey Sector Analysis</strong>
<span id="enhSecFareyIcon" style="color:#9664ff">+</span>
</label>
</div>
<div id="enhSecFarey" style="display:none">
<div style="background:rgba(150,100,255,.15);padding:8px;border-radius:6px;margin-bottom:8px;font-size:.7rem;border-left:3px solid #9664ff">
<strong style="color:#9664ff">Novel Framework (Getachew, 2025)</strong>: While Farey sequences F_n and Stern-Brocot trees are classical, the <em>circular sector organization</em> mapping fractions p/q to angles θ=2πp/q and analyzing coprime density per sector S_n=(1/(n+1),1/n) is new. The asymptotic formula C(n,N)≈3N²/(π²·n(n+1)) for sector counts appears to be original.
</div>
<div class="cg"><label>Sector Boundaries</label>
<div style="display:flex;gap:.3rem;align-items:center;flex-wrap:wrap">
<span style="color:var(--txt2);font-size:.8rem">From 1/</span>
<input type="number" id="enhSectorFrom" value="3" min="2" max="100" style="width:45px" onchange="updateEnhSector()">
<span style="color:var(--txt2);font-size:.8rem">to 1/</span>
<input type="number" id="enhSectorTo" value="2" min="1" max="99" style="width:45px" onchange="updateEnhSector()">
<span style="color:var(--txt2);font-size:.75rem;margin-left:4px" id="enhSectorAngleRange">(120° – 180°)</span>
</div></div>
<div class="cg"><label style="display:flex;gap:.5rem;flex-wrap:wrap">
<label><input type="checkbox" id="enhHighlightSector" checked onchange="drawEnhanced()"> Highlight Sector</label>
<label><input type="checkbox" id="enhShowFareySectors" onchange="drawEnhanced()"> Show All 1/n Lines</label>
<label><input type="checkbox" id="enhConsecutiveOnly" checked onchange="updateEnhSector()"> Consecutive Only</label>
</label></div>
<div class="cg"><label>Sector Color Mode</label><select id="enhSectorColorMode" onchange="drawEnhanced()">
<option value="preserve">Preserve Color Scheme</option>
<option value="dim">Dim Outside Sector</option>
<option value="inout">In/Out Only (Gold/Gray)</option>
<option value="enhance">Enhance Inside (Brighter)</option>
</select></div>
<div class="cg"><label>Analysis Mode</label><select id="enhSectorAnalysisMode" onchange="updateEnhSectorAnalysis()">
<option value="count">Count Primitives (GCD=1)</option>
<option value="density">Density vs 1/ζ(2)</option>
<option value="compare">Compare All Sectors</option>
<option value="convergence">Convergence to Asymptotic</option>
</select></div>
<div class="cg"><label>Sector Depth N</label><div style="display:flex;gap:.3rem;align-items:center">
<input type="number" id="enhSectorDepth" value="6" min="2" max="100" style="width:50px" onchange="drawEnhanced()">
<button onclick="setEnhSector(3)" style="padding:2px 5px;font-size:.7rem;border-radius:3px;border:1px solid var(--bord);background:var(--bg2);color:var(--txt);cursor:pointer">3</button>
<button onclick="setEnhSector(6)" style="padding:2px 5px;font-size:.7rem;border-radius:3px;border:1px solid #9664ff;background:rgba(150,100,255,.2);color:#9664ff;cursor:pointer">6</button>
<button onclick="setEnhSector(12)" style="padding:2px 5px;font-size:.7rem;border-radius:3px;border:1px solid var(--bord);background:var(--bg2);color:var(--txt);cursor:pointer">12</button>
</div></div>
<div class="cg"><label>Quick Sectors</label><div style="display:flex;gap:.3rem;flex-wrap:wrap">
<button onclick="setEnhSectorRange(2,1)" style="padding:2px 6px;font-size:.7rem;border-radius:3px;border:1px solid #ff6496;background:rgba(255,100,150,.15);color:#ff6496;cursor:pointer">S₁ ½→1</button>
<button onclick="setEnhSectorRange(3,2)" style="padding:2px 6px;font-size:.7rem;border-radius:3px;border:1px solid #ffd700;background:rgba(255,215,0,.15);color:#ffd700;cursor:pointer">S₂ ⅓→½</button>
<button onclick="setEnhSectorRange(4,3)" style="padding:2px 6px;font-size:.7rem;border-radius:3px;border:1px solid #00ff88;background:rgba(0,255,136,.15);color:#00ff88;cursor:pointer">S₃ ¼→⅓</button>
<button onclick="setEnhSectorRange(5,4)" style="padding:2px 6px;font-size:.7rem;border-radius:3px;border:1px solid #00d9ff;background:rgba(0,217,255,.15);color:#00d9ff;cursor:pointer">S₄ ⅕→¼</button>
<button onclick="setEnhSectorRange(6,5)" style="padding:2px 6px;font-size:.7rem;border-radius:3px;border:1px solid var(--bord);background:var(--bg2);color:var(--txt);cursor:pointer">S₅ ⅙→⅕</button>
</div></div>
<div id="enhSectorStats" style="margin-top:8px;padding:10px;background:var(--bg1);border-radius:6px;font-size:.75rem">
<div style="color:#9664ff;font-weight:bold;margin-bottom:6px">Sector: 1/3 → 1/2 (120° – 180°)</div>
<div style="display:grid;grid-template-columns:repeat(3,1fr);gap:4px;margin-bottom:8px">
<span>Coprime (GCD=1): <strong id="enhSectorCoprime" style="color:#ffd700">0</strong></span>
<span>Non-coprime: <strong id="enhSectorNonCoprime" style="color:#888">0</strong></span>
<span>Total: <strong id="enhSectorTotal" style="color:#00d9ff">0</strong></span>
</div>
<div style="display:grid;grid-template-columns:repeat(2,1fr);gap:4px;margin-bottom:6px">
<span>Density: <strong id="enhSectorDensity" style="color:#00ff88">0%</strong></span>
<span>vs 1/ζ(2): <strong id="enhSectorVsZeta" style="color:#9664ff">—</strong></span>
</div>
<div style="display:grid;grid-template-columns:repeat(4,1fr);gap:4px;margin-bottom:6px;font-size:.65rem">
<span>Asymptotic: <strong id="enhSectorAsymp" style="color:#888">0</strong></span>
<span>Abs Err: <strong id="enhSectorAbsErr" style="color:#00d9ff">0</strong></span>
<span>Rel Err: <strong id="enhSectorRelErr" style="color:#00ff88">0%</strong></span>
<span>CI 95%: <strong id="enhSectorCI" style="color:#9664ff">±0</strong></span>
</div>
<div style="display:grid;grid-template-columns:repeat(2,1fr);gap:4px;margin-bottom:6px;font-size:.65rem">
<span>Rating: <strong id="enhSectorRating" style="color:#00ff88">—</strong></span>
<span>Angular: <strong id="enhSectorWidth">60°</strong></span>
</div>
<div style="display:grid;grid-template-columns:1fr;gap:4px;font-size:.65rem">
<span>Root mediant: <strong id="enhSectorRoot" style="color:#00ff88">2/5 @ 144°</strong></span>
</div>
<div id="enhSectorPicksStats" style="display:none;margin-top:6px;padding:6px;background:rgba(0,217,255,.1);border-radius:4px;border-left:3px solid #00d9ff">
<div style="font-weight:bold;color:#00d9ff;font-size:.7rem;margin-bottom:4px">Modular Picks (Sector Triangle)</div>
<div style="display:grid;grid-template-columns:repeat(4,1fr);gap:4px;font-size:.65rem">
<span>Interior i: <strong id="enhSectorPicksI" style="color:#ffd700">0</strong></span>
<span>Boundary b: <strong id="enhSectorPicksB" style="color:#00ff88">0</strong></span>
<span>Area A: <strong id="enhSectorPicksA" style="color:#00d9ff">0</strong></span>
<span>Verify: <strong id="enhSectorPicksV" style="color:#9664ff">—</strong></span>
</div>
</div>
<div style="color:var(--txt2);font-size:.6rem;margin-top:6px">Formula: C(n,N) ≈ 3N²/(π²·n(n+1)) — Circular Farey Sector Theorem (Getachew)</div>
</div>
<div class="cg" style="margin-top:4px"><label><input type="checkbox" id="enhSectorPicks" onchange="updateEnhSector()"> Show Modular Picks</label></div>
</div></div>

<!-- Section 6: Lift Dynamics -->
<div class="ctrl" style="border-top:1px solid var(--bord);padding-top:.5rem;margin-top:.5rem">
<div class="cg" style="cursor:pointer" onclick="toggleEnhSection('enhSecLift')">
<label style="display:flex;justify-content:space-between;align-items:center;cursor:pointer">
<strong style="color:#00d9ff"> Lift Dynamics</strong>
<span id="enhSecLiftIcon" style="color:#00d9ff">+</span>
</label>
</div>
<div id="enhSecLift" style="display:none">
<div style="margin-bottom:.5rem;padding:.5rem;background:rgba(0,217,255,.08);border-radius:6px">
<div style="color:#00d9ff;font-size:.75rem;font-weight:bold;margin-bottom:.3rem">Cross-Ring Lifts</div>
<div class="cg"><label style="display:flex;gap:.5rem;flex-wrap:wrap">
<label><input type="checkbox" id="enhDirectLifts" onchange="drawEnhanced()"> Direct (r→r)</label>
<label><input type="checkbox" id="enhModLifts" onchange="drawEnhanced()"> Modular (r→r+M)</label>
<label><input type="checkbox" id="enhSkipLifts" onchange="drawEnhanced()"> Skip-Level</label>
<label><input type="checkbox" id="enhAllLifts" onchange="drawEnhanced()"> All Pairs</label>
</label></div>
</div>
<div style="margin-bottom:.5rem;padding:.5rem;background:rgba(0,255,136,.08);border-radius:6px">
<div style="color:#00ff88;font-size:.75rem;font-weight:bold;margin-bottom:.3rem">Same-Ring Connections</div>
<div class="cg"><label style="display:flex;gap:.5rem;flex-wrap:wrap">
<label><input type="checkbox" id="enhSameModConn" onchange="drawEnhanced()"> Same Mod (r↔r')</label>
<label><input type="checkbox" id="enhSameModAdj" onchange="drawEnhanced()"> Adjacent Only</label>
<label><input type="checkbox" id="enhSameModGap" onchange="drawEnhanced()"> By Gap Class</label>
</label></div>
<div class="cg" style="margin-top:.3rem"><label>Connection Pattern</label><select id="enhSameModPattern" onchange="drawEnhanced()" style="font-size:.75rem;padding:2px">
<option value="all">All Coprimes</option>
<option value="neighbors">Farey Neighbors</option>
<option value="quadratic">Quadratic Residues</option>
<option value="primitive">Primitive Roots</option>
</select></div>
</div>
<div style="margin-bottom:.5rem;padding:.5rem;background:rgba(150,100,255,.08);border-radius:6px">
<div style="color:#9664ff;font-size:.75rem;font-weight:bold;margin-bottom:.3rem">Custom Connection</div>
<div class="cg"><label style="display:flex;gap:.3rem;align-items:center;flex-wrap:wrap">
<input type="checkbox" id="enhCustomConn" onchange="drawEnhanced()">
<span>Custom:</span>
<input type="text" id="enhCustomConnExpr" value="(r+1) % M" placeholder="(r+1) % M" style="width:100px;font-size:.75rem;padding:2px 4px" onchange="drawEnhanced()">
<button onclick="applyEnhCustomConn()" style="padding:2px 6px;font-size:.7rem;border-radius:3px;border:1px solid #9664ff;background:rgba(150,100,255,.15);color:#9664ff;cursor:pointer">Apply</button>
</label></div>
<div class="cg"><label>Presets</label><div style="display:flex;gap:.2rem;flex-wrap:wrap">
<button onclick="setEnhCustomConn('(r+1)%M')" style="padding:2px 5px;font-size:.65rem;border-radius:3px;border:1px solid var(--bord);background:var(--bg2);color:var(--txt);cursor:pointer">r+1</button>
<button onclick="setEnhCustomConn('(r*2)%M')" style="padding:2px 5px;font-size:.65rem;border-radius:3px;border:1px solid var(--bord);background:var(--bg2);color:var(--txt);cursor:pointer">r×2</button>
<button onclick="setEnhCustomConn('(M-r)%M')" style="padding:2px 5px;font-size:.65rem;border-radius:3px;border:1px solid var(--bord);background:var(--bg2);color:var(--txt);cursor:pointer">M-r</button>
<button onclick="setEnhCustomConn('(r*r)%M')" style="padding:2px 5px;font-size:.65rem;border-radius:3px;border:1px solid var(--bord);background:var(--bg2);color:var(--txt);cursor:pointer">r²</button>
<button onclick="setEnhCustomConn('modInverse(r,M)')" style="padding:2px 5px;font-size:.65rem;border-radius:3px;border:1px solid var(--bord);background:var(--bg2);color:var(--txt);cursor:pointer">r⁻¹</button>
</div></div>
</div>
<div style="margin-bottom:.5rem;padding:.5rem;background:rgba(255,140,0,.08);border-radius:6px">
<div style="color:#ff8c00;font-size:.75rem;font-weight:bold;margin-bottom:.3rem">Sector Dynamics</div>
<div class="cg"><label style="display:flex;gap:.5rem;flex-wrap:wrap">
<label><input type="checkbox" id="enhSectorDynamics" onchange="drawEnhanced()"> Enable Sector Filter</label>
<label><input type="checkbox" id="enhSectorCrossOnly" onchange="drawEnhanced()"> Cross-Sector Only</label>
</label></div>
<div class="cg"><label>Sector Mode</label><select id="enhSectorDynMode" onchange="drawEnhanced()" style="font-size:.75rem;padding:2px">
<option value="within">Within Current Sector</option>
<option value="boundary">Sector Boundary</option>
<option value="mediant">Mediant Chains</option>
<option value="farey">Farey Sequence Order</option>
</select></div>
</div>
<div class="cg"><label>Lift Thickness <span id="enhLiftWV" style="color:var(--txt2)">1.0</span></label><input type="range" id="enhLiftW" min="0.3" max="3" step="0.1" value="1" oninput="document.getElementById('enhLiftWV').textContent=this.value;drawEnhanced()"></div>
<div class="cg"><label>Direct Lift Color</label><input type="color" id="enhLiftCol" value="#00d9ff" onchange="drawEnhanced()"></div>
<div class="cg"><label>Modular Lift Color</label><input type="color" id="enhModLiftCol" value="#ff6496" onchange="drawEnhanced()"></div>
<div class="cg"><label>Same-Ring Color</label><input type="color" id="enhSameModCol" value="#00ff88" onchange="drawEnhanced()"></div>
</div></div>

<!-- Section 7: Gap Analysis -->
<div class="ctrl" style="border-top:1px solid var(--bord);padding-top:.5rem;margin-top:.5rem;background:rgba(255,100,150,.08)">
<div class="cg" style="cursor:pointer" onclick="toggleEnhSection('enhSecGaps')">
<label style="display:flex;justify-content:space-between;align-items:center;cursor:pointer">
<strong style="color:#ff6496"> Gap Analysis (2n Gaps)</strong>
<span id="enhSecGapsIcon" style="color:#ff6496">+</span>
</label>
</div>
<div id="enhSecGaps" style="display:none">
<div class="cg"><label style="display:flex;gap:.3rem;flex-wrap:wrap">
<label><input type="checkbox" id="enhGap2" onchange="drawEnhanced()"> 2 (Twin)</label>
<label><input type="checkbox" id="enhGap4" onchange="drawEnhanced()"> 4 (Cousin)</label>
<label><input type="checkbox" id="enhGap6" onchange="drawEnhanced()"> 6 (Sexy)</label>
<label><input type="checkbox" id="enhGap8" onchange="drawEnhanced()"> 8</label>
<label><input type="checkbox" id="enhGap10" onchange="drawEnhanced()"> 10</label>
<label><input type="checkbox" id="enhGap12" onchange="drawEnhanced()"> 12</label>
</label></div>
<div class="cg"><label>Add Custom Gap 2n</label><div style="display:flex;gap:.3rem;align-items:center;flex-wrap:wrap">
<input type="number" id="enhCustomGapInput" value="14" min="2" max="200" step="2" style="width:55px">
<button onclick="addEnhCustomGap()" style="padding:3px 8px;font-size:.75rem;border-radius:4px;border:1px solid #00ff88;background:rgba(0,255,136,.15);color:#00ff88;cursor:pointer">+ Add</button>
<button onclick="clearEnhCustomGaps()" style="padding:3px 8px;font-size:.75rem;border-radius:4px;border:1px solid #ff6496;background:rgba(255,100,150,.15);color:#ff6496;cursor:pointer">Clear</button>
</div></div>
<div class="cg"><label>Active Custom Gaps</label><div id="enhCustomGapsList" style="display:flex;gap:.2rem;flex-wrap:wrap;min-height:20px;padding:4px;background:var(--bg1);border-radius:4px;font-size:.75rem"><span style="color:var(--txt2)">None added</span></div></div>
<div class="cg"><label>Quick Add</label><div style="display:flex;gap:.2rem;flex-wrap:wrap">
<button onclick="addEnhCustomGap(14)" style="padding:2px 5px;font-size:.7rem;border-radius:3px;border:1px solid var(--bord);background:var(--bg2);color:var(--txt);cursor:pointer">14</button>
<button onclick="addEnhCustomGap(18)" style="padding:2px 5px;font-size:.7rem;border-radius:3px;border:1px solid var(--bord);background:var(--bg2);color:var(--txt);cursor:pointer">18</button>
<button onclick="addEnhCustomGap(20)" style="padding:2px 5px;font-size:.7rem;border-radius:3px;border:1px solid var(--bord);background:var(--bg2);color:var(--txt);cursor:pointer">20</button>
<button onclick="addEnhCustomGap(30)" style="padding:2px 5px;font-size:.7rem;border-radius:3px;border:1px solid var(--bord);background:var(--bg2);color:var(--txt);cursor:pointer">30</button>
<button onclick="addEnhCustomGap(42)" style="padding:2px 5px;font-size:.7rem;border-radius:3px;border:1px solid var(--bord);background:var(--bg2);color:var(--txt);cursor:pointer">42</button>
<button onclick="addEnhCustomGap(70)" style="padding:2px 5px;font-size:.7rem;border-radius:3px;border:1px solid #ffd700;background:rgba(255,215,0,.15);color:#ffd700;cursor:pointer">70</button>
<button onclick="addEnhCustomGap(100)" style="padding:2px 5px;font-size:.7rem;border-radius:3px;border:1px solid #9664ff;background:rgba(150,100,255,.15);color:#9664ff;cursor:pointer">100</button>
</div></div>
<div class="cg"><label>Gap Line Width <span id="enhGapWV" style="color:var(--txt2)">1.0</span></label><input type="range" id="enhGapW" min="0.5" max="3" step="0.1" value="1" oninput="document.getElementById('enhGapWV').textContent=this.value;drawEnhanced()"></div>
<div class="cg"><label>Gap Color Mode</label><select id="enhGapColorMode" onchange="drawEnhanced()">
<option value="fixed">Fixed per Gap</option>
<option value="rainbow">Rainbow Gradient</option>
<option value="ring">By Ring</option>
</select></div>
</div></div>

<!-- Section 8: Display Options -->
<div class="ctrl" style="border-top:1px solid var(--bord);padding-top:.5rem;margin-top:.5rem">
<div class="cg" style="cursor:pointer" onclick="toggleEnhSection('enhSecDisplay')">
<label style="display:flex;justify-content:space-between;align-items:center;cursor:pointer">
<strong style="color:#888"> Display Options</strong>
<span id="enhSecDisplayIcon" style="color:#888">+</span>
</label>
</div>
<div id="enhSecDisplay" style="display:none">
<div class="cg"><label style="display:flex;gap:.5rem;flex-wrap:wrap">
<label><input type="checkbox" id="enhShowGcd1" checked onchange="drawEnhanced()"> Coprime (GCD=1)</label>
<label><input type="checkbox" id="enhShowNonGcd1" checked onchange="drawEnhanced()"> Non-coprime</label>
<label><input type="checkbox" id="enhShowUnit" checked onchange="drawEnhanced()"> Unit Circle</label>
</label></div>
<div class="cg"><label>Non-GCD Opacity <span id="enhNonGcdOpV" style="color:var(--txt2)">0.4</span></label><input type="range" id="enhNonGcdOp" min="0.1" max="1" step="0.1" value="0.4" oninput="document.getElementById('enhNonGcdOpV').textContent=this.value;drawEnhanced()"></div>
<div class="cg"><label>Labels</label><select id="enhLblFmt" onchange="drawEnhanced()">
<option value="none">None</option>
<option value="number">Residue r</option>
<option value="fraction">Fraction r/M</option>
<option value="decimal">Decimal</option>
<option value="farey">Farey (reduced)</option>
<option value="angle">Angle θ°</option>
<option value="gcd">GCD Value</option>
<option value="coprime">Y/N</option>
</select></div>
<div class="cg"><label>Label Which</label><select id="enhLblWhich" onchange="drawEnhanced()">
<option value="all">All Points</option>
<option value="gcd1">Coprime Only</option>
<option value="outer">Outer Ring Only</option>
<option value="unit">Unit Circle Only</option>
</select></div>
<div class="cg"><label>Stats Font Size <span id="enhStatsFontV" style="color:var(--txt2)">0.85rem</span></label><select id="enhStatsFont" onchange="updateEnhStatsFont()">
<option value="0.7rem">Small (0.7rem)</option>
<option value="0.85rem" selected>Default (0.85rem)</option>
<option value="1rem">Medium (1rem)</option>
<option value="1.1rem">Large (1.1rem)</option>
<option value="1.25rem">X-Large (1.25rem)</option>
</select></div>
</div></div>

<!-- ===== ADVANCED OPTIONS ===== -->
<div style="margin:1rem 0 .75rem;padding-bottom:.5rem;border-bottom:1px solid var(--bord)">
<span style="font-size:.7rem;text-transform:uppercase;letter-spacing:1px;color:#ff6496">Advanced Options</span>
</div>

<!-- Section 9: Smith Chart Transform -->
<div class="ctrl" style="border-top:1px solid var(--bord);padding-top:.5rem;margin-top:.5rem">
<div class="cg" style="cursor:pointer" onclick="toggleEnhSection('enhSecSmith')">
<label style="display:flex;justify-content:space-between;align-items:center;cursor:pointer">
<strong style="color:#00ff88"> Smith Chart Transform</strong>
<span id="enhSecSmithIcon" style="color:#00ff88">+</span>
</label>
</div>
<div id="enhSecSmith" style="display:none">
<div class="cg"><label>Enable Smith Chart</label><input type="checkbox" id="enhSmith" onchange="drawEnhanced()"></div>

<div style="display:grid;grid-template-columns:1fr 1fr;gap:.5rem;margin:.5rem 0">
<div class="cg"><label>Phase α <span id="enhSmithAV" style="color:#00ff88">90°</span></label><div style="display:flex;gap:.3rem;align-items:center"><input type="range" id="enhSmithA" min="0" max="360" value="90" oninput="document.getElementById('enhSmithANum').value=this.value;document.getElementById('enhSmithAV').textContent=this.value+'°';drawEnhanced()" style="flex:1"><input type="number" id="enhSmithANum" value="90" min="0" max="360" style="width:50px" onchange="document.getElementById('enhSmithA').value=this.value;document.getElementById('enhSmithAV').textContent=this.value+'°';drawEnhanced()"></div></div>
<div class="cg"><label>Zoom <span id="enhSmithZoomV" style="color:#00d9ff">1.0×</span></label><div style="display:flex;gap:.3rem;align-items:center"><input type="range" id="enhSmithZoom" min="0.2" max="5" step="0.1" value="1" oninput="document.getElementById('enhSmithZoomV').textContent=this.value+'×';drawEnhanced()" style="flex:1"><input type="number" id="enhSmithZoomNum" value="1" min="0.2" max="5" step="0.1" style="width:50px" onchange="document.getElementById('enhSmithZoom').value=this.value;document.getElementById('enhSmithZoomV').textContent=this.value+'×';drawEnhanced()"></div></div>
</div>

<div style="display:flex;flex-wrap:wrap;gap:.4rem;margin:.4rem 0;padding:.4rem;background:rgba(0,255,136,.08);border-radius:4px;border:1px solid rgba(0,255,136,.2)">
<span style="font-size:.7rem;color:#00ff88;font-weight:bold">Auto-Rotate:</span>
<button onclick="startSmithRotation()" style="padding:2px 8px;font-size:.7rem;border-radius:3px;border:1px solid #00ff88;background:rgba(0,255,136,.1);color:#00ff88;cursor:pointer"> Start</button>
<button onclick="stopSmithRotation()" style="padding:2px 8px;font-size:.7rem;border-radius:3px;border:1px solid #ff6496;background:rgba(255,100,150,.1);color:#ff6496;cursor:pointer"> Stop</button>
<button onclick="resetSmithPhase()" style="padding:2px 8px;font-size:.7rem;border-radius:3px;border:1px solid #ffd700;background:rgba(255,215,0,.1);color:#ffd700;cursor:pointer">↺ Reset</button>
<div class="cg" style="margin:0"><label style="font-size:.65rem">Speed</label><select id="enhSmithRotSpeed" style="font-size:.7rem;padding:1px 3px">
<option value="0.5">Slow</option>
<option value="1" selected>Normal</option>
<option value="2">Fast</option>
<option value="5">Very Fast</option>
</select></div>
</div>

<div style="display:flex;flex-wrap:wrap;gap:.4rem;margin:.4rem 0;padding:.4rem;background:rgba(0,217,255,.08);border-radius:4px;border:1px solid rgba(0,217,255,.2)">
<span style="font-size:.7rem;color:#00d9ff;font-weight:bold">Zoom:</span>
<button onclick="smithZoomIn()" style="padding:2px 10px;font-size:.75rem;border-radius:3px;border:1px solid #00d9ff;background:rgba(0,217,255,.1);color:#00d9ff;cursor:pointer;font-weight:bold">+</button>
<button onclick="smithZoomOut()" style="padding:2px 10px;font-size:.75rem;border-radius:3px;border:1px solid #00d9ff;background:rgba(0,217,255,.1);color:#00d9ff;cursor:pointer;font-weight:bold">−</button>
<button onclick="smithZoomReset()" style="padding:2px 8px;font-size:.7rem;border-radius:3px;border:1px solid #9664ff;background:rgba(150,100,255,.1);color:#9664ff;cursor:pointer">1:1</button>
<button onclick="smithZoomFit()" style="padding:2px 8px;font-size:.7rem;border-radius:3px;border:1px solid #ffd700;background:rgba(255,215,0,.1);color:#ffd700;cursor:pointer">Fit</button>
</div>

<div style="display:grid;grid-template-columns:1fr 1fr;gap:.5rem;margin:.4rem 0">
<div class="cg"><label>Offset X <span id="enhSmithOffXV" style="color:var(--txt2)">0</span></label><input type="range" id="enhSmithOffX" min="-200" max="200" value="0" oninput="document.getElementById('enhSmithOffXV').textContent=this.value;drawEnhanced()"></div>
<div class="cg"><label>Offset Y <span id="enhSmithOffYV" style="color:var(--txt2)">0</span></label><input type="range" id="enhSmithOffY" min="-200" max="200" value="0" oninput="document.getElementById('enhSmithOffYV').textContent=this.value;drawEnhanced()"></div>
</div>

<div class="cg"><label style="display:flex;gap:.5rem;flex-wrap:wrap">
<label><input type="checkbox" id="enhSmithInvert" onchange="drawEnhanced()"> Invert</label>
<label><input type="checkbox" id="enhSmithReflect" onchange="drawEnhanced()"> Reflect</label>
<label><input type="checkbox" id="enhSmithGrid" checked onchange="drawEnhanced()"> Grid</label>
<label><input type="checkbox" id="enhSmithConstR" checked onchange="drawEnhanced()"> Const-R</label>
<label><input type="checkbox" id="enhSmithConstX" checked onchange="drawEnhanced()"> Const-X</label>
<label><input type="checkbox" id="enhSmithLifts" checked onchange="drawEnhanced()"> Lifts</label>
<label><input type="checkbox" id="enhSmithGaps" checked onchange="drawEnhanced()"> Gaps</label>
<label><input type="checkbox" id="enhSmithUnitCircle" checked onchange="drawEnhanced()"> Unit Circle</label>
</label></div>

<div style="display:grid;grid-template-columns:1fr 1fr;gap:.5rem;margin:.4rem 0">
<div class="cg"><label>Point Scale <span id="enhSmithPtScaleV" style="color:var(--txt2)">1.0</span></label><input type="range" id="enhSmithPtScale" min="0.3" max="3" step="0.1" value="1" oninput="document.getElementById('enhSmithPtScaleV').textContent=this.value;drawEnhanced()"></div>
<div class="cg"><label>Line Width <span id="enhSmithLineWV" style="color:var(--txt2)">1</span></label><input type="range" id="enhSmithLineW" min="0.5" max="4" step="0.5" value="1" oninput="document.getElementById('enhSmithLineWV').textContent=this.value;drawEnhanced()"></div>
</div>

<div style="display:flex;flex-wrap:wrap;gap:.3rem;margin:.4rem 0">
<span style="font-size:.65rem;color:#ffd700">Presets:</span>
<button onclick="setSmithPreset('standard')" style="padding:2px 6px;font-size:.65rem;border-radius:3px;border:1px solid var(--bord);background:var(--bg1);color:var(--txt);cursor:pointer">Standard</button>
<button onclick="setSmithPreset('quarter')" style="padding:2px 6px;font-size:.65rem;border-radius:3px;border:1px solid var(--bord);background:var(--bg1);color:var(--txt);cursor:pointer">Quarter (90°)</button>
<button onclick="setSmithPreset('half')" style="padding:2px 6px;font-size:.65rem;border-radius:3px;border:1px solid var(--bord);background:var(--bg1);color:var(--txt);cursor:pointer">Half (180°)</button>
<button onclick="setSmithPreset('golden')" style="padding:2px 6px;font-size:.65rem;border-radius:3px;border:1px solid #ffd700;background:rgba(255,215,0,.1);color:#ffd700;cursor:pointer">Golden (137.5°)</button>
<button onclick="setSmithPreset('inverted')" style="padding:2px 6px;font-size:.65rem;border-radius:3px;border:1px solid #ff6496;background:rgba(255,100,150,.1);color:#ff6496;cursor:pointer">Inverted</button>
<button onclick="setSmithPreset('zoom2x')" style="padding:2px 6px;font-size:.65rem;border-radius:3px;border:1px solid #00d9ff;background:rgba(0,217,255,.1);color:#00d9ff;cursor:pointer">2× Zoom</button>
</div>

<div id="enhSmithStatus" style="font-size:.65rem;color:var(--txt2);text-align:center;margin-top:4px">Smith Chart: OFF</div>
</div></div>

<!-- Section 10: Animation -->
<div class="ctrl" style="border-top:1px solid var(--bord);padding-top:.5rem;margin-top:.5rem">
<div class="cg" style="cursor:pointer" onclick="toggleEnhSection('enhSecAnim')">
<label style="display:flex;justify-content:space-between;align-items:center;cursor:pointer">
<strong style="color:#ffd700"> Animation</strong>
<span id="enhSecAnimIcon" style="color:#ffd700">+</span>
</label>
</div>
<div id="enhSecAnim" style="display:none">
<div class="cg"><label>Speed <span id="enhSpeedV" style="color:var(--txt2)">1.0</span></label><input type="range" id="enhSpeed" min="0.1" max="5" step="0.1" value="1" oninput="document.getElementById('enhSpeedV').textContent=this.value"></div>
<div class="cg"><label style="display:flex;gap:.5rem;flex-wrap:wrap">
<label><input type="checkbox" id="enhDiffSpeeds"> Variable Ring Speeds</label>
</label></div>
</div></div>

<!-- Section 11: Prime Sieve Analysis -->
<div class="ctrl" style="border-top:1px solid var(--bord);padding-top:.5rem;margin-top:.5rem;background:rgba(0,255,136,.08)">
<div class="cg" style="cursor:pointer" onclick="toggleEnhSection('enhSecPrime')">
<label style="display:flex;justify-content:space-between;align-items:center;cursor:pointer">
<strong style="color:#00ff88"> Prime Sieve Analysis</strong>
<span id="enhSecPrimeIcon" style="color:#00ff88">+</span>
</label>
</div>
<div id="enhSecPrime" style="display:none">
<div class="cg"><label>Range Start</label><div style="display:flex;gap:.5rem;align-items:center"><input type="number" id="enhPrimeStart" value="2" min="2" max="100000" style="width:80px"><span style="color:var(--txt2)">to</span><input type="number" id="enhPrimeEnd" value="1000" min="10" max="1000000" style="width:80px"></div></div>
<div class="cg"><label style="display:flex;gap:.5rem;flex-wrap:wrap">
<button onclick="enhRunPrimeSieve()" style="padding:4px 12px;border-radius:4px;border:1px solid #00ff88;background:rgba(0,255,136,.15);color:#00ff88;cursor:pointer;font-weight:bold">Analyze Primes</button>
<button onclick="animateSectorSweep()" id="sectorSweepBtn" style="padding:4px 12px;border-radius:4px;border:1px solid #ffd700;background:rgba(255,215,0,.15);color:#ffd700;cursor:pointer;font-weight:bold">Sector Sweep </button>
<button onclick="stopSectorSweep()" style="padding:4px 12px;border-radius:4px;border:1px solid #ff6496;background:rgba(255,100,150,.15);color:#ff6496;cursor:pointer">Stop</button>
<button onclick="enhPrimePreset(100)" style="padding:3px 8px;font-size:.8rem;border-radius:4px;border:1px solid var(--bord);background:var(--bg2);color:var(--txt);cursor:pointer">≤100</button>
<button onclick="enhPrimePreset(1000)" style="padding:3px 8px;font-size:.8rem;border-radius:4px;border:1px solid var(--bord);background:var(--bg2);color:var(--txt);cursor:pointer">≤1K</button>
<button onclick="enhPrimePreset(10000)" style="padding:3px 8px;font-size:.8rem;border-radius:4px;border:1px solid var(--bord);background:var(--bg2);color:var(--txt);cursor:pointer">≤10K</button>
<button onclick="enhPrimePreset(100000)" style="padding:3px 8px;font-size:.8rem;border-radius:4px;border:1px solid var(--bord);background:var(--bg2);color:var(--txt);cursor:pointer">≤100K</button>
</label></div>
<div id="enhPrimeResults" style="margin-top:8px;padding:10px;background:var(--bg1);border-radius:6px;font-size:.8rem;display:none"></div>
</div></div>

<!-- Section 12: Residue Tracker -->
<div class="ctrl" style="border-top:1px solid var(--bord);padding-top:.5rem;margin-top:.5rem;background:rgba(0,255,136,.08)">
<div class="cg" style="cursor:pointer" onclick="toggleEnhSection('enhSecTracker')">
<label style="display:flex;justify-content:space-between;align-items:center;cursor:pointer">
<strong style="color:#00ff88"> Residue Tracker</strong>
<span id="enhSecTrackerIcon" style="color:#00ff88">+</span>
</label>
</div>
<div id="enhSecTracker" style="display:none">
<div class="cg"><label style="display:flex;gap:.5rem;align-items:center"><input type="checkbox" id="enhTrackerEnable" onchange="drawEnhanced()"> <span>Enable Tracker</span></label></div>
<div class="cg"><label>Track Mode</label><select id="enhTrackerMode" onchange="updateEnhTrackerMode();drawEnhanced()">
<option value="manual">Manual Input (Multiple)</option>
<option value="slider">Slider (Single r)</option>
</select></div>
<div id="enhTrackerManual">
<div class="cg"><label>Track Residues</label><input type="text" id="enhTrackerList" value="1, 5, 7, 11" placeholder="e.g., 1, 5, 7, 11" style="width:150px" onchange="drawEnhanced()"></div>
</div>
<div id="enhTrackerSlider" style="display:none">
<div class="cg"><label>Track Residue r <span id="enhTrackerRV" style="color:#00ff88">1</span></label><input type="range" id="enhTrackerR" min="0" max="100" value="1" oninput="document.getElementById('enhTrackerRV').textContent=this.value;drawEnhanced()"></div>
</div>
<div class="cg"><label>Filter by Modulus</label><input type="text" id="enhTrackerModFilter" value="" placeholder="blank=all, or 12,30,60" style="width:130px" onchange="drawEnhanced()"></div>
<div class="cg"><label>Tracker Color</label><input type="color" id="enhTrackerColor" value="#00ffff" onchange="drawEnhanced()"></div>
<div class="cg"><label>Tracker Size <span id="enhTrackerSzV" style="color:var(--txt2)">8</span></label><input type="range" id="enhTrackerSz" min="2" max="20" value="8" oninput="document.getElementById('enhTrackerSzV').textContent=this.value;drawEnhanced()"></div>
<div class="cg"><label style="display:flex;gap:.5rem;flex-wrap:wrap">
<label><input type="checkbox" id="enhTrackerLabels" checked onchange="drawEnhanced()"> Show Labels</label>
<label><input type="checkbox" id="enhTrackerGlow" checked onchange="drawEnhanced()"> Glow Effect</label>
<label><input type="checkbox" id="enhTrackerLines" onchange="drawEnhanced()"> Connect Across Rings</label>
</label></div>
<div class="cg"><label>Label Position</label><select id="enhTrackerLabelPos" onchange="drawEnhanced()">
<option value="above">Above Point</option>
<option value="below">Below Point</option>
<option value="left">Left of Point</option>
<option value="right" selected>Right of Point</option>
<option value="inside">Inside Point</option>
</select></div>
<div class="cg"><label>Quick Track</label><div style="display:flex;gap:.3rem;flex-wrap:wrap">
<button onclick="setEnhTrackerPreset('phi12')" style="padding:2px 6px;font-size:.7rem;border-radius:3px;border:1px solid var(--bord);background:var(--bg2);color:var(--txt);cursor:pointer">φ(12)</button>
<button onclick="setEnhTrackerPreset('phi30')" style="padding:2px 6px;font-size:.7rem;border-radius:3px;border:1px solid #00ff88;background:rgba(0,255,136,.15);color:#00ff88;cursor:pointer">φ(30)</button>
<button onclick="setEnhTrackerPreset('phi60')" style="padding:2px 6px;font-size:.7rem;border-radius:3px;border:1px solid var(--bord);background:var(--bg2);color:var(--txt);cursor:pointer">φ(60)</button>
<button onclick="setEnhTrackerPreset('primes10')" style="padding:2px 6px;font-size:.7rem;border-radius:3px;border:1px solid #ff6496;background:rgba(255,100,150,.15);color:#ff6496;cursor:pointer">Primes≤10</button>
<button onclick="setEnhTrackerPreset('twins30')" style="padding:2px 6px;font-size:.7rem;border-radius:3px;border:1px solid #ffd700;background:rgba(255,215,0,.15);color:#ffd700;cursor:pointer">Twin-Adm(30)</button>
</div></div>
<div id="enhTrackerInfo" style="display:none;margin-top:8px;padding:10px;background:var(--bg1);border-radius:6px;font-size:.75rem;max-height:200px;overflow-y:auto">
<div style="color:#00ff88;font-weight:bold;margin-bottom:6px">Tracked Residues Info</div>
<div id="enhTrackerData"></div>
</div>
</div></div>

<div class="ctrl" id="enhTrajectoryControls" style="display:none;border-top:1px solid var(--bord);padding-top:.5rem;margin-top:.5rem;background:rgba(0,217,255,.08)">
<div class="cg"><label><strong style="color:#00d9ff">Trajectory Coherence Analysis</strong> <span class="tip" title="Analyze residue phase trajectories across moduli">?</span></label></div>
<div class="cg"><label>Residue Range</label><div style="display:flex;gap:.3rem;align-items:center"><span style="color:var(--txt2);font-size:.8rem">r = 1 to</span><input type="number" id="trajMaxR" value="200" min="10" max="1000" style="width:70px" onchange="drawEnhanced()"></div></div>
<div class="cg"><label>Color By</label><select id="trajColorBy" onchange="drawEnhanced()">
<option value="drift">Cumulative Drift D(r)</option>
<option value="variance">Trajectory Variance</option>
<option value="survival">Survival Length L(r)</option>
<option value="meanphase">Mean Phase φ̄(r)</option>
<option value="type">Residue Type</option>
<option value="classification">Shell Classification</option>
</select></div>
<div class="cg"><label>Point Size By</label><select id="trajSizeBy" onchange="drawEnhanced()">
<option value="survival">Survival Length</option>
<option value="drift">Inverse Drift</option>
<option value="uniform">Uniform</option>
</select></div>
<div class="cg"><label style="display:flex;gap:.5rem;flex-wrap:wrap">
<label><input type="checkbox" id="trajHighlightPM1" checked onchange="drawEnhanced()"> Highlight (p-1)</label>
<label><input type="checkbox" id="trajHighlightPrimes" onchange="drawEnhanced()"> Highlight Primes</label>
<label><input type="checkbox" id="trajShowLabels" onchange="drawEnhanced()"> Labels</label>
<label><input type="checkbox" id="trajShowTop20" checked onchange="drawEnhanced()"> Top 20 Coherent</label>
</label></div>
<div class="cg"><label>Filter: Drift Range</label><div style="display:flex;gap:.3rem;align-items:center"><input type="number" id="trajDriftMin" value="0" min="0" max="50" step="0.5" style="width:55px" onchange="drawEnhanced()"><span>to</span><input type="number" id="trajDriftMax" value="50" min="0" max="100" step="0.5" style="width:55px" onchange="drawEnhanced()"></div></div>
<div class="cg"><label>Filter: Type</label><select id="trajFilterType" onchange="drawEnhanced()">
<option value="all">All Residues</option>
<option value="primes">Primes Only</option>
<option value="pm1">Prime-minus-one (p-1)</option>
<option value="pp1">Prime-plus-one (p+1)</option>
<option value="other">Non-prime Related</option>
</select></div>
<div class="cg"><label style="display:flex;gap:.3rem;flex-wrap:wrap">
<button onclick="computeTrajectoryStats()" style="padding:4px 12px;border-radius:4px;border:1px solid #00d9ff;background:rgba(0,217,255,.15);color:#00d9ff;cursor:pointer;font-weight:bold">Compute Stats</button>
<button onclick="exportTrajectoryCSV()" style="padding:4px 12px;border-radius:4px;border:1px solid #00ff88;background:rgba(0,255,136,.15);color:#00ff88;cursor:pointer">Export CSV</button>
<button onclick="exportTrajectoryFull()" style="padding:4px 12px;border-radius:4px;border:1px solid #ffd700;background:rgba(255,215,0,.15);color:#ffd700;cursor:pointer">Full Report</button>
</label></div>
</div>
</div>

<!-- End of Control Sections Container -->

<div class="bg"><button onclick="drawEnhanced()">Redraw</button><button onclick="toggleEnhRotation()" id="enhRotBtn">Animate</button><button onclick="screenshotEnhanced()">Screenshot</button><button onclick="toggleEnhSSOptions()" style="background:#4a2a6a;font-size:.8rem">Options</button><button onclick="exportAllEnhanced()" style="background:#1a472a"> All</button><button class="s" onclick="csvEnhanced()">CSV Export</button></div>
<div id="ssEnhOpts" style="display:none;padding:.75rem;background:var(--bg2);border-radius:6px;margin-bottom:.5rem;font-size:.75rem;border:1px solid var(--bord);max-height:500px;overflow-y:auto">
<div style="color:#9664ff;font-weight:bold;margin-bottom:.5rem">Screenshot Options — Select Elements to Include</div>

<!-- Canvas & Tree Section -->
<div style="margin-bottom:.5rem;padding:.4rem;background:rgba(255,215,0,.1);border-radius:4px;border:1px solid rgba(255,215,0,.3)">
<div style="color:#ffd700;font-weight:bold;font-size:.7rem;margin-bottom:.3rem"> CANVASES</div>
<div style="display:grid;grid-template-columns:repeat(auto-fit,minmax(150px,1fr));gap:.25rem">
<label><input type="checkbox" id="ssEnhMainCanvas" checked> Main Canvas</label>
<label><input type="checkbox" id="ssEnhLegend" checked> Canvas Legend</label>
<label><input type="checkbox" id="ssEnhTree" checked> Stern-Brocot Tree</label>
<label><input type="checkbox" id="ssEnhIncludeArnold"> Arnold Tongues</label>
<label><input type="checkbox" id="ssEnhFreqDist"> Frequency Distribution</label>
</div>
</div>

<!-- Live Statistics Subsections -->
<div style="margin-bottom:.5rem;padding:.4rem;background:rgba(0,217,255,.1);border-radius:4px;border:1px solid rgba(0,217,255,.3)">
<div style="color:#00d9ff;font-weight:bold;font-size:.7rem;margin-bottom:.3rem"> LIVE STATISTICS SECTIONS</div>
<div style="display:grid;grid-template-columns:repeat(auto-fit,minmax(180px,1fr));gap:.25rem">
<label><input type="checkbox" id="ssStatMode" checked> Mode/Settings Header</label>
<label><input type="checkbox" id="ssStatPrimary" checked> Primary Counts (φ, Total)</label>
<label><input type="checkbox" id="ssStatDensity" checked> Density Metrics</label>
<label><input type="checkbox" id="ssStatHighlight" checked> Highlighted Sector</label>
<label><input type="checkbox" id="ssStatSBSectors" checked> Stern-Brocot Sectors</label>
<label><input type="checkbox" id="ssStatError" checked> Error Bounds Table</label>
<label><input type="checkbox" id="ssStatCircle" checked> Circle Halves (Real/Imag)</label>
<label><input type="checkbox" id="ssStatQuadrant" checked> Quadrant Distribution</label>
<label><input type="checkbox" id="ssStatSieve" checked> Modular Sieve</label>
<label><input type="checkbox" id="ssStatGaps" checked> Gap Pair Counts</label>
<label><input type="checkbox" id="ssStatPhi" checked> Ring φ(M) List</label>
</div>
</div>

<!-- Main Canvas Legend Subsections -->
<div style="margin-bottom:.5rem;padding:.4rem;background:rgba(255,215,0,.1);border-radius:4px;border:1px solid rgba(255,215,0,.3)">
<div style="color:#ffd700;font-weight:bold;font-size:.7rem;margin-bottom:.3rem"> CANVAS LEGEND SECTIONS</div>
<div style="display:grid;grid-template-columns:repeat(auto-fit,minmax(160px,1fr));gap:.25rem">
<label><input type="checkbox" id="ssLegendTitle" checked> Legend Title</label>
<label><input type="checkbox" id="ssLegendCoprime" checked> Coprime Markers</label>
<label><input type="checkbox" id="ssLegendNonCoprime" checked> Non-Coprime Markers</label>
<label><input type="checkbox" id="ssLegendSector" checked> Sector Highlight</label>
<label><input type="checkbox" id="ssLegendFarey" checked> Farey Neighbors</label>
<label><input type="checkbox" id="ssLegendHarmonic" checked> Harmonic Colors</label>
<label><input type="checkbox" id="ssLegendSettings" checked> Current Settings</label>
<label><input type="checkbox" id="ssLegendStats" checked> Quick Stats</label>
</div>
</div>

<!-- Point Details Subsections -->
<div style="margin-bottom:.5rem;padding:.4rem;background:rgba(255,100,150,.1);border-radius:4px;border:1px solid rgba(255,100,150,.3)">
<div style="color:#ff6496;font-weight:bold;font-size:.7rem;margin-bottom:.3rem"> SELECTED POINT DETAILS</div>
<div style="display:grid;grid-template-columns:repeat(auto-fit,minmax(150px,1fr));gap:.25rem">
<label><input type="checkbox" id="ssPointBasicInfo" checked> Basic Info (r, M, GCD)</label>
<label><input type="checkbox" id="ssPointHarmonics" checked> Harmonic Metrics</label>
<label><input type="checkbox" id="ssPointMusical" checked> Musical Interval</label>
<label><input type="checkbox" id="ssPointFrequency" checked> Frequency & Cents</label>
<label><input type="checkbox" id="ssPointNeighbors" checked> Farey Neighbors</label>
</div>
</div>

<!-- Tree & Analysis Subsections -->
<div style="margin-bottom:.5rem;padding:.4rem;background:rgba(0,255,136,.1);border-radius:4px;border:1px solid rgba(0,255,136,.3)">
<div style="color:#00ff88;font-weight:bold;font-size:.7rem;margin-bottom:.3rem"> TREE & ANALYSIS</div>
<div style="display:grid;grid-template-columns:repeat(auto-fit,minmax(150px,1fr));gap:.25rem">
<label><input type="checkbox" id="ssEnhTreeStats" checked> Tree Stats</label>
<label><input type="checkbox" id="ssEnhTreePath" checked> Tree Path Info</label>
<label><input type="checkbox" id="ssEnhFarey" checked> Farey Neighbors List</label>
<label><input type="checkbox" id="ssEnhFareyLegend" checked> Farey Legend</label>
</div>
</div>

<!-- Additional Panels -->
<div style="margin-bottom:.5rem;padding:.4rem;background:rgba(150,100,255,.1);border-radius:4px;border:1px solid rgba(150,100,255,.3)">
<div style="color:#9664ff;font-weight:bold;font-size:.7rem;margin-bottom:.3rem"> ADDITIONAL PANELS</div>
<div style="display:grid;grid-template-columns:repeat(auto-fit,minmax(150px,1fr));gap:.25rem">
<label><input type="checkbox" id="ssEnhTracker"> Residue Tracker</label>
<label><input type="checkbox" id="ssEnhTrajectory"> Trajectory Analysis</label>
<label><input type="checkbox" id="ssEnhMultTable"> Multiplication Table</label>
<label><input type="checkbox" id="ssEnhTimestamp" checked> Timestamp</label>
<label><input type="checkbox" id="ssEnhAuthor" checked> Author Credit</label>
</div>
</div>

<div style="margin-top:.5rem;display:flex;gap:.5rem;align-items:center;flex-wrap:wrap;padding-top:.5rem;border-top:1px solid var(--bord)">
<button onclick="ssEnhSelectAll(true)" style="padding:2px 8px;font-size:.7rem;border-radius:3px;border:1px solid #00d9ff;background:rgba(0,217,255,.15);color:#00d9ff;cursor:pointer">All</button>
<button onclick="ssEnhSelectAll(false)" style="padding:2px 8px;font-size:.7rem;border-radius:3px;border:1px solid #ff6496;background:rgba(255,100,150,.15);color:#ff6496;cursor:pointer">None</button>
<button onclick="ssEnhSelectDefaults()" style="padding:2px 8px;font-size:.7rem;border-radius:3px;border:1px solid #ffd700;background:rgba(255,215,0,.15);color:#ffd700;cursor:pointer">Defaults</button>
<button onclick="ssEnhSelectMinimal()" style="padding:2px 8px;font-size:.7rem;border-radius:3px;border:1px solid #00ff88;background:rgba(0,255,136,.15);color:#00ff88;cursor:pointer">Minimal</button>
<span style="margin-left:.5rem;color:var(--txt2);font-size:.7rem">Resolution:</span>
<select id="ssEnhRes" style="padding:2px 6px;font-size:.7rem;border-radius:3px;border:1px solid var(--bord);background:var(--bg);color:var(--txt)">
<option value="1">1x</option>
<option value="2" selected>2x</option>
<option value="3">3x</option>
<option value="4">4x (High Res)</option>
</select>
</div>
</div>

<!-- Audio & Harmonic Analysis Section -->
<div style="margin:.5rem 0;padding:.6rem;background:linear-gradient(135deg,rgba(0,217,255,.08),rgba(255,215,0,.05));border:1px solid rgba(0,217,255,.3);border-radius:6px">
<div style="display:flex;justify-content:space-between;align-items:center;cursor:pointer" onclick="toggleEnhSection('enhSecAudio')">
<strong style="color:#00d9ff;font-size:.8rem"> Audio & Harmonic Analysis</strong>
<span id="enhSecAudioIcon" style="color:#00d9ff">+</span>
</div>
<div id="enhSecAudio" style="display:none;margin-top:.5rem">
<div style="display:flex;flex-wrap:wrap;gap:.4rem;align-items:flex-end">
<div class="cg"><label>Base Freq (Hz)</label><input type="number" id="enhBaseFreq" value="440" min="20" max="2000" style="width:65px"></div>
<div class="cg"><label>Presets</label>
<select id="enhFreqPreset" onchange="applyEnhFreqPreset()" style="padding:2px 4px;font-size:.7rem">
<option value="">—</option>
<optgroup label="Concert Pitch">
<option value="440">A440 (Standard)</option>
<option value="432">A432 (Verdi)</option>
<option value="415">A415 (Baroque)</option>
<option value="256">C256 (Scientific)</option>
</optgroup>
<optgroup label="Solfeggio">
<option value="174">174 Hz (Foundation)</option>
<option value="285">285 Hz (Healing)</option>
<option value="396">396 Hz (Liberation)</option>
<option value="417">417 Hz (Change)</option>
<option value="528">528 Hz (Miracles)</option>
<option value="639">639 Hz (Connection)</option>
<option value="741">741 Hz (Awakening)</option>
<option value="852">852 Hz (Intuition)</option>
<option value="963">963 Hz (Divine)</option>
</optgroup>
<optgroup label="Pythagorean">
<option value="256">C4 = 256</option>
<option value="288">D4 = 288 (9/8)</option>
<option value="324">E4 = 324 (81/64)</option>
<option value="341.3">F4 = 341.3 (4/3)</option>
<option value="384">G4 = 384 (3/2)</option>
<option value="432">A4 = 432 (27/16)</option>
<option value="486">B4 = 486 (243/128)</option>
<option value="512">C5 = 512</option>
</optgroup>
<optgroup label="Physics">
<option value="7.83">Schumann 7.83</option>
<option value="136.1">Om 136.1 (Earth)</option>
<option value="194.18">Earth Day 194.18</option>
<option value="210.42">Moon 210.42</option>
<option value="126.22">Sun 126.22</option>
</optgroup>
</select>
</div>
<div class="cg"><label>Volume <span id="enhVolV">500</span></label><div class="sig"><input type="range" id="enhAudioVol" min="0" max="1000" value="500" style="width:60px" oninput="document.getElementById('enhVolV').textContent=this.value;document.getElementById('enhVolInput').value=this.value"><input type="number" id="enhVolInput" value="500" min="0" max="5000" style="width:55px" onchange="document.getElementById('enhAudioVol').value=Math.min(1000,this.value);document.getElementById('enhVolV').textContent=this.value"></div></div>
<div class="cg"><label>Duration</label><select id="enhAudioDur"><option value="0.15">Short</option><option value="0.3" selected>Normal</option><option value="0.5">Long</option><option value="1">1 sec</option></select></div>
<div class="cg"><label>Waveform</label><select id="enhAudioWave"><option value="sine" selected>Sine</option><option value="triangle">Triangle</option><option value="square">Square</option><option value="sawtooth">Saw</option></select></div>
</div>
<div style="margin-top:.4rem;display:flex;flex-wrap:wrap;gap:.3rem">
<span style="color:#ffd700;font-size:.7rem;margin-right:.3rem">Intervals:</span>
<button onclick="playEnhFreq(3,2)" style="padding:2px 6px;font-size:.7rem;border:1px solid #00ff88;background:rgba(0,255,136,.1);color:#00ff88;border-radius:3px;cursor:pointer"> Fifth (3:2)</button>
<button onclick="playEnhFreq(4,3)" style="padding:2px 6px;font-size:.7rem;border:1px solid #00d9ff;background:rgba(0,217,255,.1);color:#00d9ff;border-radius:3px;cursor:pointer"> Fourth (4:3)</button>
<button onclick="playEnhFreq(5,4)" style="padding:2px 6px;font-size:.7rem;border:1px solid #ffd700;background:rgba(255,215,0,.1);color:#ffd700;border-radius:3px;cursor:pointer"> Maj 3 (5:4)</button>
<button onclick="playEnhFreq(6,5)" style="padding:2px 6px;font-size:.7rem;border:1px solid #9664ff;background:rgba(150,100,255,.1);color:#9664ff;border-radius:3px;cursor:pointer"> Min 3 (6:5)</button>
<button onclick="playEnhFreq(5,3)" style="padding:2px 6px;font-size:.7rem;border:1px solid #ff6496;background:rgba(255,100,150,.1);color:#ff6496;border-radius:3px;cursor:pointer"> Maj 6 (5:3)</button>
<button onclick="playEnhFreq(8,5)" style="padding:2px 6px;font-size:.7rem;border:1px solid #ff8c00;background:rgba(255,140,0,.1);color:#ff8c00;border-radius:3px;cursor:pointer"> Min 6 (8:5)</button>
<button onclick="playEnhFreq(2,1)" style="padding:2px 6px;font-size:.7rem;border:1px solid #fff;background:rgba(255,255,255,.1);color:#fff;border-radius:3px;cursor:pointer"> Oct (2:1)</button>
</div>
<div style="margin-top:.4rem;display:flex;flex-wrap:wrap;gap:.3rem;align-items:center">
<button onclick="playEnhPath()" style="padding:3px 10px;font-size:.75rem;border:2px solid #00ff88;background:rgba(0,255,136,.15);color:#00ff88;border-radius:4px;cursor:pointer;font-weight:bold"> Play S-B Path</button>
<button onclick="playEnhPath(true)" style="padding:3px 8px;font-size:.75rem;border:1px solid #ff6496;background:rgba(255,100,150,.15);color:#ff6496;border-radius:4px;cursor:pointer"> Reverse</button>
<button onclick="playEnhScale('major')" style="padding:2px 8px;font-size:.7rem;border:1px solid #ffd700;background:rgba(255,215,0,.1);color:#ffd700;border-radius:3px;cursor:pointer">Major Scale</button>
<button onclick="playEnhScale('minor')" style="padding:2px 8px;font-size:.7rem;border:1px solid #9664ff;background:rgba(150,100,255,.1);color:#9664ff;border-radius:3px;cursor:pointer">Minor Scale</button>
<button onclick="playEnhScale('farey')" style="padding:2px 8px;font-size:.7rem;border:1px solid #00d9ff;background:rgba(0,217,255,.1);color:#00d9ff;border-radius:3px;cursor:pointer">Farey F₅</button>
<span id="enhAudioStatus" style="font-size:.65rem;color:var(--txt2);margin-left:.3rem"></span>
</div>

<!-- Manual Fraction Input & Sector Selection -->
<div style="margin-top:.5rem;padding:.5rem;background:var(--bg1);border-radius:5px;border:1px solid rgba(255,215,0,.3)">
<div style="display:flex;flex-wrap:wrap;gap:.5rem;align-items:flex-end">
<div class="cg"><label style="color:#ffd700">Manual p/q</label>
<div style="display:flex;gap:2px;align-items:center">
<input type="number" id="enhManualP" value="2" min="0" max="999" style="width:45px;text-align:center">
<span style="color:var(--txt2)">/</span>
<input type="number" id="enhManualQ" value="5" min="1" max="999" style="width:45px;text-align:center">
<button onclick="selectEnhFraction()" style="padding:3px 10px;font-size:.75rem;border:2px solid #ffd700;background:rgba(255,215,0,.2);color:#ffd700;border-radius:4px;cursor:pointer;font-weight:bold;margin-left:4px">Select</button>
<button onclick="selectAndPlayEnhFraction()" style="padding:3px 8px;font-size:.75rem;border:1px solid #00ff88;background:rgba(0,255,136,.15);color:#00ff88;border-radius:4px;cursor:pointer"> Play</button>
</div>
</div>
<div class="cg"><label style="color:#9664ff">Quick Sector</label>
<select id="enhQuickSector" onchange="applyQuickSector()" style="padding:3px 6px;min-width:120px">
<option value="">— Select —</option>
<optgroup label="Standard Sectors">
<option value="2,1">S₁: 1/2 – 1/1</option>
<option value="3,2">S₂: 1/3 – 1/2</option>
<option value="4,3">S₃: 1/4 – 1/3</option>
<option value="5,4">S₄: 1/5 – 1/4</option>
<option value="6,5">S₅: 1/6 – 1/5</option>
<option value="7,6">S₆: 1/7 – 1/6</option>
<option value="8,7">S₇: 1/8 – 1/7</option>
</optgroup>
<optgroup label="Musical Intervals">
<option value="3,2">Fifth region (1/3–1/2)</option>
<option value="4,3">Fourth region (1/4–1/3)</option>
<option value="5,4">Major 3rd (1/5–1/4)</option>
<option value="6,5">Minor 3rd (1/6–1/5)</option>
</optgroup>
<optgroup label="Wide Sectors">
<option value="4,2">1/4 – 1/2</option>
<option value="6,3">1/6 – 1/3</option>
<option value="8,4">1/8 – 1/4</option>
<option value="10,5">1/10 – 1/5</option>
</optgroup>
</select>
</div>
<div class="cg"><label style="color:#00d9ff">Farey Presets</label>
<select id="enhFareyPreset" onchange="applyFareyPreset()" style="padding:3px 6px;min-width:100px">
<option value="">— Select —</option>
<option value="1,2">1/2</option>
<option value="1,3">1/3</option>
<option value="2,5">2/5</option>
<option value="3,7">3/7</option>
<option value="2,7">2/7</option>
<option value="3,8">3/8</option>
<option value="5,12">5/12</option>
<option value="7,17">7/17</option>
<option value="5,13">5/13</option>
<option value="8,21">8/21 (Fib)</option>
<option value="13,34">13/34 (Fib)</option>
</select>
</div>
</div>
<div id="enhManualResult" style="margin-top:.3rem;font-size:.7rem;color:var(--txt2);min-height:1.2em"></div>
</div>

<!-- Chord Building Section -->
<div style="margin-top:.5rem;padding:.5rem;background:var(--bg1);border-radius:5px;border:1px solid rgba(0,255,136,.3)">
<div style="display:flex;flex-wrap:wrap;gap:.4rem;align-items:center;margin-bottom:.3rem">
<strong style="color:#00ff88;font-size:.75rem"> Chord Builder</strong>
<button id="enhChordModeBtn" onclick="toggleEnhChordMode()" style="padding:2px 8px;font-size:.7rem;border:1px solid #ffd700;background:rgba(255,215,0,.1);color:#ffd700;border-radius:3px;cursor:pointer"> Chord Mode</button>
<button onclick="playEnhChord()" style="padding:2px 8px;font-size:.7rem;border:1px solid #00ff88;background:rgba(0,255,136,.1);color:#00ff88;border-radius:3px;cursor:pointer"> Play Chord</button>
<button onclick="playEnhChordSustain()" style="padding:2px 8px;font-size:.7rem;border:1px solid #9664ff;background:rgba(150,100,255,.1);color:#9664ff;border-radius:3px;cursor:pointer"> Sustain</button>
<button onclick="stopEnhChord()" style="padding:2px 6px;font-size:.65rem;border:1px solid #ff6496;background:rgba(255,100,150,.1);color:#ff6496;border-radius:3px;cursor:pointer"> Stop</button>
<button onclick="clearEnhChord()" style="padding:2px 6px;font-size:.65rem;border:1px solid #888;background:rgba(136,136,136,.1);color:#888;border-radius:3px;cursor:pointer">Clear</button>
</div>
<div style="display:flex;flex-wrap:wrap;gap:.4rem;align-items:center;margin-bottom:.3rem">
<button onclick="playEnhArpeggio(false)" style="padding:2px 8px;font-size:.7rem;border:1px solid #00d9ff;background:rgba(0,217,255,.1);color:#00d9ff;border-radius:3px;cursor:pointer"> Arp ↑</button>
<button onclick="playEnhArpeggio(true)" style="padding:2px 8px;font-size:.7rem;border:1px solid #ff6496;background:rgba(255,100,150,.1);color:#ff6496;border-radius:3px;cursor:pointer"> Arp ↓</button>
<button onclick="playEnhArpeggioLoop()" id="enhArpLoopBtn" style="padding:2px 8px;font-size:.7rem;border:1px solid #ffd700;background:rgba(255,215,0,.1);color:#ffd700;border-radius:3px;cursor:pointer"> Loop</button>
<div class="cg" style="margin:0"><label style="font-size:.65rem">Arp Speed</label>
<input type="range" id="enhArpSpeed" min="50" max="500" value="150" style="width:60px" title="Arpeggio note spacing (ms)" oninput="document.getElementById('enhArpSpeedV').textContent=this.value+'ms'">
<span id="enhArpSpeedV" style="font-size:.6rem;color:var(--txt2)">150ms</span>
</div>
<div class="cg" style="margin:0"><label style="font-size:.65rem">Detune ¢</label>
<input type="range" id="enhDetune" min="-100" max="100" value="0" style="width:55px" oninput="document.getElementById('enhDetuneV').textContent=this.value+'¢'" title="Detune in cents">
<span id="enhDetuneV" style="font-size:.6rem;color:var(--txt2)">0¢</span>
</div>
</div>
<div id="enhChordDisplay" style="min-height:1.5rem;font-size:.7rem;color:var(--txt2)">
<span style="color:var(--txt2)">No notes selected (enable Chord Mode, then click points)</span>
</div>
<div style="margin-top:.3rem;font-size:.6rem;color:var(--txt2)">
<strong>Quick chords:</strong>
<button onclick="enhChordSelection=[{p:4,q:5},{p:1,q:1},{p:6,q:5}];updateEnhChordDisplay()" style="padding:1px 5px;font-size:.6rem;border:1px solid #9664ff;background:rgba(150,100,255,.1);color:#9664ff;border-radius:2px;cursor:pointer;margin:0 2px">Major</button>
<button onclick="enhChordSelection=[{p:5,q:6},{p:1,q:1},{p:6,q:5}];updateEnhChordDisplay()" style="padding:1px 5px;font-size:.6rem;border:1px solid #ff6496;background:rgba(255,100,150,.1);color:#ff6496;border-radius:2px;cursor:pointer;margin:0 2px">Minor</button>
<button onclick="enhChordSelection=[{p:4,q:5},{p:1,q:1},{p:6,q:5},{p:9,q:5}];updateEnhChordDisplay()" style="padding:1px 5px;font-size:.6rem;border:1px solid #ffd700;background:rgba(255,215,0,.1);color:#ffd700;border-radius:2px;cursor:pointer;margin:0 2px">Maj7</button>
<button onclick="enhChordSelection=[{p:1,q:1},{p:3,q:2},{p:2,q:1}];updateEnhChordDisplay()" style="padding:1px 5px;font-size:.6rem;border:1px solid #00ff88;background:rgba(0,255,136,.1);color:#00ff88;border-radius:2px;cursor:pointer;margin:0 2px">Power</button>
<button onclick="enhChordSelection=[{p:1,q:1},{p:5,q:4},{p:3,q:2}];updateEnhChordDisplay()" style="padding:1px 5px;font-size:.6rem;border:1px solid #00d9ff;background:rgba(0,217,255,.1);color:#00d9ff;border-radius:2px;cursor:pointer;margin:0 2px">Maj (JI)</button>
<button onclick="enhChordSelection=[{p:1,q:1},{p:6,q:5},{p:3,q:2}];updateEnhChordDisplay()" style="padding:1px 5px;font-size:.6rem;border:1px solid #fff;background:rgba(255,255,255,.1);color:#fff;border-radius:2px;cursor:pointer;margin:0 2px">Min (JI)</button>
</div>
</div>

<!-- Harmonic Metrics Display -->
<div id="enhHarmonicMetrics" style="margin-top:.5rem;padding:.5rem;background:linear-gradient(135deg,rgba(150,100,255,.1),rgba(0,217,255,.05));border-radius:5px;border:1px solid rgba(150,100,255,.3);display:none">
<strong style="color:#9664ff;font-size:.75rem">Harmonic Metrics</strong>
<div id="enhMetricsContent" style="margin-top:.3rem;display:grid;grid-template-columns:repeat(auto-fit,minmax(140px,1fr));gap:.3rem;font-size:.7rem"></div>
</div>

<div style="margin-top:.5rem;font-size:.65rem;color:var(--txt2);padding:.3rem;background:var(--bg1);border-radius:4px">
<strong style="color:#ffd700">Harmonic color mode:</strong> Colors by denominator q — <span style="color:#ffd700"></span> Unison (q=1) <span style="color:#00ff88"></span> Consonant (q≤4) <span style="color:#9664ff"></span> Complex (q≤8) <span style="color:#ff6496"></span> Dissonant (q>16). Click any point to hear its frequency!
</div>
</div>
</div>

<div class="viz" style="width:100%"><h3 id="enhCanvasTitle">2D Modular Rings: θ = 2πr/M</h3><div id="enhCanvasDesc" style="color:var(--txt2);font-size:.85rem;margin-bottom:.5rem;padding:.5rem;background:var(--bg1);border-radius:6px"><strong style="color:#ffd700">2D Rings</strong>: Concentric rings showing residue classes mod M. Gold points = coprime residues (GCD=1). Each ring represents a modulus from min to max. <strong style="color:#00d9ff">Click any point</strong> to see details below.</div><canvas id="cenhanced" width="800" height="800" style="max-width:100%;cursor:crosshair;display:block" onclick="handleEnhCanvasClick(event)"></canvas><div id="enhStatus" style="position:absolute;top:10px;left:10px;background:rgba(0,0,0,.7);padding:6px 10px;border-radius:6px;font-size:.75rem;color:#ffd700;display:none">Animating...</div><div class="al" id="alenhanced"></div>

<!-- Point Details Box (included in screenshots) -->
<div id="enhPointDetails" style="margin-top:1rem;padding:1rem;background:linear-gradient(135deg,rgba(0,217,255,.1),rgba(255,215,0,.08));border:2px solid rgba(0,217,255,.4);border-radius:8px;display:none">
<div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:.75rem">
<h4 style="color:#00d9ff;margin:0">Selected Point Details</h4>
<button onclick="clearEnhPointSelection()" style="padding:2px 8px;font-size:.7rem;border-radius:4px;border:1px solid #ff6496;background:rgba(255,100,150,.15);color:#ff6496;cursor:pointer">Clear</button>
</div>
<div id="enhPointInfo" style="display:grid;grid-template-columns:repeat(auto-fit,minmax(180px,1fr));gap:.75rem;font-size:.85rem"></div>
<div id="enhPointAnalysis" style="margin-top:.75rem;padding:.75rem;background:var(--bg1);border-radius:6px;font-size:.8rem"></div>
</div>
</div>

<div class="viz" style="width:100%"><h3>Live Statistics <button onclick="screenshotDashboard('enhLiveStats','Enhanced_Rings_Stats')" style="float:right;padding:2px 8px;font-size:.7rem;border-radius:4px;border:1px solid var(--bord);background:var(--bg2);color:var(--txt);cursor:pointer">4K</button></h3>
<div id="statsLegendControls" style="display:flex;flex-wrap:wrap;gap:6px;margin-bottom:8px;padding:6px;background:rgba(255,215,0,.05);border-radius:6px;border:1px solid rgba(255,215,0,.2)">
<span style="font-size:.65rem;color:#ffd700;font-weight:bold">Show:</span>
<label style="font-size:.65rem"><input type="checkbox" id="showStatMode" checked onchange="toggleStatSection('mode')"> Mode</label>
<label style="font-size:.65rem"><input type="checkbox" id="showStatPrimary" checked onchange="toggleStatSection('primary')"> Primary</label>
<label style="font-size:.65rem"><input type="checkbox" id="showStatDensity" checked onchange="toggleStatSection('density')"> Density</label>
<label style="font-size:.65rem"><input type="checkbox" id="showStatHighlight" checked onchange="toggleStatSection('highlight')"> Highlight</label>
<label style="font-size:.65rem"><input type="checkbox" id="showStatSBSectors" checked onchange="toggleStatSection('sbsectors')"> SB Sectors</label>
<label style="font-size:.65rem"><input type="checkbox" id="showStatError" checked onchange="toggleStatSection('error')"> Error Table</label>
<label style="font-size:.65rem"><input type="checkbox" id="showStatCircle" checked onchange="toggleStatSection('circle')"> Circle</label>
<label style="font-size:.65rem"><input type="checkbox" id="showStatQuadrant" checked onchange="toggleStatSection('quadrant')"> Quadrant</label>
<label style="font-size:.65rem"><input type="checkbox" id="showStatSieve" checked onchange="toggleStatSection('sieve')"> Sieve</label>
<label style="font-size:.65rem"><input type="checkbox" id="showStatGaps" checked onchange="toggleStatSection('gaps')"> Gaps</label>
<label style="font-size:.65rem"><input type="checkbox" id="showStatPhi" checked onchange="toggleStatSection('phi')"> φ(M)</label>
<button onclick="toggleAllStats(true)" style="padding:1px 6px;font-size:.6rem;border:1px solid #00ff88;background:transparent;color:#00ff88;border-radius:3px;cursor:pointer">All</button>
<button onclick="toggleAllStats(false)" style="padding:1px 6px;font-size:.6rem;border:1px solid #ff6496;background:transparent;color:#ff6496;border-radius:3px;cursor:pointer">None</button>
</div>
<div id="enhLiveStats" style="background:var(--bg2);border-radius:8px;padding:1rem;font-size:.85rem"></div></div>

<div class="viz" style="width:100%"><h3 style="color:#ffd700">Stern-Brocot Tree (Sector) <button onclick="screenshotSternBrocotTree()" style="float:right;padding:2px 8px;font-size:.7rem;border-radius:4px;border:1px solid var(--bord);background:var(--bg2);color:var(--txt);cursor:pointer">Screenshot</button></h3>
<div style="padding:10px;background:var(--bg2);border-radius:8px">
<div style="display:flex;gap:1rem;margin-bottom:8px;flex-wrap:wrap;align-items:center">
<div class="cg" style="margin:0"><label>Node Size</label><div style="display:flex;gap:4px;align-items:center"><input type="range" id="enhTreeSz" min="4" max="30" value="12" oninput="document.getElementById('enhTreeSzNum').value=this.value;drawSternBrocotTree(window.enhSBTreeBounds?.fromN||3,window.enhSBTreeBounds?.toN||2)"><input type="number" id="enhTreeSzNum" value="12" min="2" max="40" style="width:45px" onchange="document.getElementById('enhTreeSz').value=Math.min(30,this.value);drawSternBrocotTree(window.enhSBTreeBounds?.fromN||3,window.enhSBTreeBounds?.toN||2)"></div></div>
<div class="cg" style="margin:0"><label>Max Depth</label><div style="display:flex;gap:4px;align-items:center"><input type="range" id="enhTreeDepth" min="2" max="100" value="20" oninput="document.getElementById('enhTreeDepthNum').value=this.value"><input type="number" id="enhTreeDepthNum" value="20" min="1" max="500" style="width:55px"><button onclick="safeDrawTree()" style="padding:2px 8px;font-size:.7rem;border-radius:3px;border:1px solid #00ff88;background:rgba(0,255,136,.15);color:#00ff88;cursor:pointer">Apply</button></div></div>
<div class="cg" style="margin:0"><label>Zoom <span id="enhTreeZoomV" style="color:var(--txt2)">1.0×</span></label><input type="range" id="enhTreeZoom" min="0.5" max="4" step="0.1" value="1" oninput="document.getElementById('enhTreeZoomV').textContent=this.value+'×';drawSternBrocotTree(window.enhSBTreeBounds?.fromN||3,window.enhSBTreeBounds?.toN||2)"></div>
<div class="cg" style="margin:0"><label>Label Size <span id="enhTreeLblSzV" style="color:var(--txt2)">10px</span></label><input type="range" id="enhTreeLblSz" min="6" max="18" value="10" oninput="document.getElementById('enhTreeLblSzV').textContent=this.value+'px';drawSternBrocotTree(window.enhSBTreeBounds?.fromN||3,window.enhSBTreeBounds?.toN||2)"></div>
<div class="cg" style="margin:0"><label>Label Color</label><select id="enhTreeLblCol" onchange="drawSternBrocotTree(window.enhSBTreeBounds?.fromN||3,window.enhSBTreeBounds?.toN||2)" style="font-size:.75rem;padding:2px">
<option value="auto">Auto</option>
<option value="white">White</option>
<option value="black">Black</option>
<option value="gold">Gold</option>
<option value="cyan">Cyan</option>
</select></div>
<div class="cg" style="margin:0"><label>Format</label><select id="enhTreeLblFmt" onchange="drawSternBrocotTree(window.enhSBTreeBounds?.fromN||3,window.enhSBTreeBounds?.toN||2)" style="font-size:.75rem;padding:2px">
<option value="fraction">Fraction p/q</option>
<option value="decimal">Decimal</option>
<option value="angle">Angle θ°</option>
</select></div>
<label style="display:flex;align-items:center;gap:4px;font-size:.75rem"><input type="checkbox" id="enhTreeLabels" checked onchange="drawSternBrocotTree(window.enhSBTreeBounds?.fromN||3,window.enhSBTreeBounds?.toN||2)"> Labels</label>
<label style="display:flex;align-items:center;gap:4px;font-size:.75rem"><input type="checkbox" id="enhTreeEdges" checked onchange="drawSternBrocotTree(window.enhSBTreeBounds?.fromN||3,window.enhSBTreeBounds?.toN||2)"> Edges</label>
<label style="display:flex;align-items:center;gap:4px;font-size:.75rem"><input type="checkbox" id="enhTreeTongues" checked onchange="drawSternBrocotTree(window.enhSBTreeBounds?.fromN||3,window.enhSBTreeBounds?.toN||2)"> Tongues</label>
<div class="cg" style="margin:0"><label>Canvas</label><select id="enhTreeCanvSz" onchange="resizeSBTreeCanvas()" style="font-size:.75rem;padding:2px">
<option value="800,500">800×500</option>
<option value="1200,750">1200×750 (HD)</option>
<option value="1600,1000">1600×1000</option>
<option value="2000,1250">2000×1250</option>
<option value="3200,2000">3200×2000 (4K)</option>
<option value="3840,2400">3840×2400 (4K+)</option>
</select></div>
<button onclick="resetTreeView()" style="padding:2px 6px;border-radius:3px;border:1px solid var(--bord);background:var(--bg2);color:var(--txt);cursor:pointer;font-size:.7rem">Reset</button>
</div>
<div style="display:flex;gap:1rem;margin-bottom:8px;flex-wrap:wrap;align-items:center;padding:6px;background:var(--bg1);border-radius:4px">
<span style="font-size:.75rem;color:var(--txt2)">Find Path:</span>
<div style="display:flex;gap:4px;align-items:center">
<input type="number" id="enhTreeP" value="1" min="0" max="1000" style="width:50px" placeholder="p">
<span style="color:var(--txt2)">/</span>
<input type="number" id="enhTreeQ" value="5" min="1" max="1000" style="width:50px" placeholder="q">
<button onclick="manualTreePath()" style="padding:2px 8px;border-radius:4px;border:1px solid #00ff88;background:rgba(0,255,136,.15);color:#00ff88;cursor:pointer;font-size:.75rem">Show Path</button>
<button onclick="clearTreePath()" style="padding:2px 8px;border-radius:4px;border:1px solid var(--bord);background:var(--bg2);color:var(--txt);cursor:pointer;font-size:.75rem">Clear</button>
</div>
</div>
<!-- Farey Neighbors Legend for Selected Point -->
<div id="enhFareyNeighborLegend" style="display:none;margin-bottom:8px;padding:8px;background:rgba(255,100,150,.1);border:1px solid rgba(255,100,150,.3);border-radius:6px;font-size:.75rem">
<div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:6px">
<strong style="color:#ff6496">Farey Neighbors (|ad-bc|=1)</strong>
<span id="enhFareyNeighborCount" style="color:#ffd700;font-weight:bold">0 neighbors</span>
</div>
<div id="enhFareyNeighborList" style="display:flex;flex-wrap:wrap;gap:4px;max-height:80px;overflow-y:auto"></div>
</div>
<div style="position:relative;overflow:hidden;border-radius:6px;background:#0a0e27">
<canvas id="cSternBrocot" width="800" height="500" style="width:100%;cursor:grab"></canvas>
</div>
<div id="enhTreeStats" style="font-size:.75rem;color:var(--txt2);margin-top:6px;text-align:center">Tree depth: 0 | Nodes: 0</div>
<div id="enhTreePath" style="font-size:.7rem;color:#00ff88;margin-top:4px;text-align:center;display:none"></div>
<div id="enhTreePlayControls" style="display:flex;flex-wrap:wrap;gap:.4rem;margin-top:.5rem;justify-content:center;align-items:center">
<button onclick="playTreePath()" style="padding:3px 10px;font-size:.7rem;border-radius:3px;border:1px solid #00ff88;background:rgba(0,255,136,.1);color:#00ff88;cursor:pointer"> Play Path</button>
<button onclick="playTreeAll('ltr')" style="padding:2px 8px;font-size:.65rem;border-radius:3px;border:1px solid #00d9ff;background:rgba(0,217,255,.1);color:#00d9ff;cursor:pointer">All L→R</button>
<button onclick="playTreeAll('rtl')" style="padding:2px 8px;font-size:.65rem;border-radius:3px;border:1px solid #ff6496;background:rgba(255,100,150,.1);color:#ff6496;cursor:pointer">All R→L</button>
<button onclick="stopTreePlay()" style="padding:2px 8px;font-size:.65rem;border-radius:3px;border:1px solid #ff4444;background:rgba(255,68,68,.1);color:#ff4444;cursor:pointer"> Stop</button>
</div>
</div></div>

<!-- Arnold Tongues Visualization -->
<div class="viz" style="width:100%"><h3 style="color:#ff8c00">Arnold Tongues (Phase-Locking Regions) <button onclick="screenshotArnoldTongues()" style="float:right;padding:2px 8px;font-size:.7rem;border-radius:4px;border:1px solid var(--bord);background:var(--bg2);color:var(--txt);cursor:pointer">Screenshot</button></h3>
<div style="color:var(--txt2);font-size:.8rem;margin-bottom:.5rem;padding:.5rem;background:var(--bg1);border-radius:6px">
<strong style="color:#ff8c00">Arnold Tongues</strong> show regions of phase-locking in dynamical systems. Each tongue corresponds to a rational rotation number p/q. The width of tongue p/q grows with coupling strength ε. Points inside tongue p/q exhibit periodic orbits with rotation number exactly p/q.
</div>
<div style="display:flex;flex-wrap:wrap;gap:.5rem;margin-bottom:.5rem;align-items:center">
<div class="cg" style="margin:0"><label>Size</label><select id="arnoldCanvasSize" onchange="resizeArnoldCanvas()" style="font-size:.75rem;padding:2px">
<option value="400">400×200</option>
<option value="600">600×300</option>
<option value="800" selected>800×400</option>
<option value="1000">1000×500</option>
<option value="1200">1200×600</option>
</select></div>
<div class="cg" style="margin:0"><label>View</label><select id="arnoldViewMode" onchange="drawArnoldTongues()" style="font-size:.75rem;padding:2px">
<option value="tongues" selected>Tongues (standard)</option>
<option value="inverted">Inverted (tip up)</option>
<option value="tree">Tree Layout</option>
<option value="circle">Circle (polar)</option>
</select></div>
<div class="cg" style="margin:0"><label>Max q</label><input type="number" id="arnoldMaxQ" value="12" min="2" max="100" style="width:50px" onchange="drawArnoldTongues()"></div>
<div class="cg" style="margin:0"><label>ε Max</label><input type="number" id="arnoldEpsMax" value="1" min="0.1" max="2" step="0.1" style="width:50px" onchange="drawArnoldTongues()"></div>
<div class="cg" style="margin:0"><label>Color</label><select id="arnoldColorMode" onchange="drawArnoldTongues()" style="font-size:.75rem;padding:2px">
<option value="harmonic">Harmonic (q-based)</option>
<option value="hue">Hue Cycle</option>
<option value="depth">By Depth</option>
<option value="farey">Farey Order</option>
</select></div>
</div>
<div style="display:flex;flex-wrap:wrap;gap:.4rem;margin-bottom:.5rem;align-items:center">
<label style="font-size:.75rem"><input type="checkbox" id="arnoldShowLabels" checked onchange="drawArnoldTongues()"> Labels</label>
<label style="font-size:.75rem"><input type="checkbox" id="arnoldShowGrid" checked onchange="drawArnoldTongues()"> Grid</label>
<label style="font-size:.75rem"><input type="checkbox" id="arnoldFill" checked onchange="drawArnoldTongues()"> Fill</label>
<label style="font-size:.75rem"><input type="checkbox" id="arnoldShowPath" onchange="drawArnoldTongues()"> Show Path</label>
<label style="font-size:.75rem"><input type="checkbox" id="arnoldShowEdges" onchange="drawArnoldTongues()"> Edges</label>
<div class="cg" style="margin:0"><label>Sector</label><select id="arnoldSectorFrom" onchange="drawArnoldTongues()" style="font-size:.7rem;padding:1px"><option value="0">Full (0-1)</option><option value="2">1/2-1</option><option value="3" selected>1/3-1/2</option><option value="4">1/4-1/3</option><option value="5">1/5-1/4</option></select></div>
<button onclick="drawArnoldTongues()" style="padding:3px 10px;border-radius:4px;border:1px solid #ff8c00;background:rgba(255,140,0,.15);color:#ff8c00;cursor:pointer;font-size:.75rem">Redraw</button>
</div>
<div style="display:flex;flex-wrap:wrap;gap:.4rem;margin-bottom:.5rem;align-items:center;padding:.4rem;background:rgba(0,217,255,.05);border-radius:4px;border:1px solid rgba(0,217,255,.2)">
<span style="font-size:.7rem;color:#00d9ff;font-weight:bold"> Play:</span>
<button onclick="playArnoldSequence('ltr')" style="padding:2px 8px;font-size:.7rem;border-radius:3px;border:1px solid #00ff88;background:rgba(0,255,136,.1);color:#00ff88;cursor:pointer">L→R (ascending)</button>
<button onclick="playArnoldSequence('rtl')" style="padding:2px 8px;font-size:.7rem;border-radius:3px;border:1px solid #ff6496;background:rgba(255,100,150,.1);color:#ff6496;cursor:pointer">R→L (descending)</button>
<button onclick="playArnoldSequence('farey')" style="padding:2px 8px;font-size:.7rem;border-radius:3px;border:1px solid #ffd700;background:rgba(255,215,0,.1);color:#ffd700;cursor:pointer">Farey Order</button>
<button onclick="playArnoldSequence('random')" style="padding:2px 8px;font-size:.7rem;border-radius:3px;border:1px solid #9664ff;background:rgba(150,100,255,.1);color:#9664ff;cursor:pointer">Random</button>
<button onclick="playArnoldSequence('path')" style="padding:2px 8px;font-size:.7rem;border-radius:3px;border:1px solid #00ff88;background:rgba(0,255,136,.15);color:#00ff88;cursor:pointer;font-weight:bold"> Path</button>
<div class="cg" style="margin:0"><label>Speed</label><select id="arnoldPlaySpeed" style="font-size:.7rem;padding:1px 3px">
<option value="50">Fast</option>
<option value="120" selected>Normal</option>
<option value="250">Slow</option>
<option value="500">Very Slow</option>
</select></div>
<button onclick="stopArnoldPlay()" style="padding:2px 8px;font-size:.7rem;border-radius:3px;border:1px solid #ff4444;background:rgba(255,68,68,.1);color:#ff4444;cursor:pointer"> Stop</button>
</div>
<div style="position:relative;overflow:hidden;border-radius:6px;background:#0a0e27">
<canvas id="cArnoldTongues" width="800" height="400" style="width:100%;cursor:crosshair" onclick="handleArnoldClick(event)"></canvas>
</div>
<div id="arnoldStats" style="font-size:.75rem;color:var(--txt2);margin-top:6px;text-align:center">Tongues: 0 | Max q: 8</div>
<div id="arnoldPath" style="font-size:.7rem;color:#00ff88;margin-top:4px;text-align:center;display:none"></div>
<div id="arnoldSelected" style="font-size:.7rem;color:#ff8c00;margin-top:4px;text-align:center;display:none"></div>
</div>

<!-- Frequency Distribution Histogram -->
<div class="viz" style="width:100%"><h3 style="color:#9664ff">Frequency Ratio Distribution <button onclick="screenshotFreqDist()" style="float:right;padding:2px 8px;font-size:.7rem;border-radius:4px;border:1px solid var(--bord);background:var(--bg2);color:var(--txt);cursor:pointer">Screenshot</button></h3>
<div style="color:var(--txt2);font-size:.8rem;margin-bottom:.5rem;padding:.5rem;background:var(--bg1);border-radius:6px">
Distribution of frequency ratios across all coprime points. <strong style="color:#ffd700">X-axis:</strong> frequency ratio (relative to base). <strong style="color:#00ff88">Y-axis:</strong> count. Peaks correspond to simple ratios (consonant intervals).
</div>
<div style="display:flex;flex-wrap:wrap;gap:.5rem;margin-bottom:.5rem;align-items:center">
<div class="cg" style="margin:0"><label>Bins</label><input type="number" id="freqHistBins" value="50" min="10" max="200" style="width:50px" onchange="drawFreqDistribution()"></div>
<label style="font-size:.75rem"><input type="checkbox" id="freqHistLog" onchange="drawFreqDistribution()"> Log scale</label>
<label style="font-size:.75rem"><input type="checkbox" id="freqHistShowPeaks" checked onchange="drawFreqDistribution()"> Show peaks</label>
<button onclick="drawFreqDistribution()" style="padding:3px 10px;border-radius:4px;border:1px solid #9664ff;background:rgba(150,100,255,.15);color:#9664ff;cursor:pointer;font-size:.75rem">Redraw</button>
</div>
<div style="position:relative;overflow:hidden;border-radius:6px;background:#0a0e27">
<canvas id="cFreqDist" width="800" height="300" style="width:100%"></canvas>
</div>
<div id="freqDistStats" style="font-size:.75rem;color:var(--txt2);margin-top:6px;text-align:center">Points: 0 | Range: 0-0</div>
</div>

<div class="viz"><h3 style="color:#9664ff">Farey Neighbors in Sector (|ad-bc|=1) <button onclick="exportFareyNeighborsCSV()" style="float:right;padding:2px 8px;font-size:.7rem;border-radius:4px;border:1px solid #00ff88;background:rgba(0,255,136,.15);color:#00ff88;cursor:pointer">CSV Export</button></h3>
<div id="enhFareyNeighbors" style="max-height:400px;overflow-y:auto;padding:10px;background:var(--bg2);border-radius:8px;font-size:.75rem;font-family:monospace">
Loading...
</div></div>

<div class="viz" id="enhTrackerPanel" style="display:none"><h3 style="color:#00ff88">Residue Tracker Analysis <button onclick="exportTrackerCSV()" style="float:right;padding:2px 8px;font-size:.7rem;border-radius:4px;border:1px solid #00ff88;background:rgba(0,255,136,.15);color:#00ff88;cursor:pointer">CSV</button></h3>
<div id="enhTrackerVizData" style="background:var(--bg2);border-radius:8px;padding:1rem;font-size:.8rem;max-height:350px;overflow-y:auto">
<div style="color:var(--txt2);text-align:center;padding:1rem">Enable Residue Tracker to see analysis</div>
</div>
</div>

<!-- Trajectory Coherence Analysis Panels -->
<div id="trajAnalysisPanels" style="display:none">
<div class="viz"><h3 style="color:#00d9ff">Trajectory Coherence Plot <button onclick="screenshotDashboard('trajCoherencePlot','Trajectory_Coherence')" style="float:right;padding:2px 8px;font-size:.7rem;border-radius:4px;border:1px solid var(--bord);background:var(--bg2);color:var(--txt);cursor:pointer">4K</button></h3>
<canvas id="cTrajCoherence" width="600" height="500" style="width:100%;border-radius:6px;background:#0a0e27"></canvas>
<div id="trajHoverInfo" style="font-size:.75rem;color:var(--txt2);margin-top:6px;text-align:center">Hover over points to see details</div>
</div>

<div class="viz">
<h3 style="color:#ffd700">Coherence Statistics</h3>
<div id="trajCoherenceStats" style="background:var(--bg2);border-radius:8px;padding:1rem;font-size:.8rem;max-height:480px;overflow-y:auto">
<div style="color:var(--txt2);text-align:center;padding:2rem">Click "Compute Stats" to analyze trajectories</div>
</div>
</div>

<div class="viz"><h3 style="color:#ff6496">Drift Distribution Histogram</h3>
<canvas id="cTrajHistogram" width="450" height="280" style="width:100%;border-radius:6px;background:#0a0e27"></canvas>
</div>

<div class="viz"><h3 style="color:#00ff88">Twin-Prime Shell Comparison</h3>
<div id="trajTwinShell" style="background:var(--bg2);border-radius:8px;padding:1rem;font-size:.8rem;max-height:280px;overflow-y:auto">
<div style="color:var(--txt2);text-align:center;padding:1rem">Statistical comparison will appear here</div>
</div>
</div>

<div class="viz"><h3 style="color:#9664ff">Residue Data Table <button onclick="exportTrajectoryCSV()" style="float:right;padding:2px 8px;font-size:.7rem;border-radius:4px;border:1px solid #00ff88;background:rgba(0,255,136,.15);color:#00ff88;cursor:pointer">CSV</button></h3>
<div id="trajDataTable" style="background:var(--bg2);border-radius:8px;padding:.5rem;font-size:.7rem;max-height:300px;overflow-y:auto;font-family:monospace">
<table style="width:100%;border-collapse:collapse">
<thead><tr style="border-bottom:1px solid var(--bord);color:#ffd700">
<th style="padding:4px;text-align:left;cursor:pointer" onclick="sortTrajTable('r')">r </th>
<th style="padding:4px;text-align:left;cursor:pointer" onclick="sortTrajTable('type')">Type</th>
<th style="padding:4px;text-align:right;cursor:pointer" onclick="sortTrajTable('drift')">D(r)</th>
<th style="padding:4px;text-align:right;cursor:pointer" onclick="sortTrajTable('survival')">L(r)</th>
<th style="padding:4px;text-align:right;cursor:pointer" onclick="sortTrajTable('meanphase')">φ̄</th>
<th style="padding:4px;text-align:left;cursor:pointer" onclick="sortTrajTable('class')">Class</th>
</tr></thead>
<tbody id="trajTableBody"></tbody>
</table>
</div>
</div>

<div class="viz"><h3 style="color:#00d9ff">Phase Trajectory Detail</h3>
<canvas id="cTrajDetail" width="450" height="280" style="width:100%;border-radius:6px;background:#0a0e27"></canvas>
<div id="trajDetailInfo" style="font-size:.75rem;color:var(--txt2);margin-top:6px;text-align:center">Click a point to see phase trajectory</div>
</div>
</div>

<div style="padding:1rem;background:rgba(255,215,0,.08);border-radius:8px;margin-top:1rem">
<h4 style="color:var(--acc);margin-bottom:.5rem">Enhanced Lifting Rings Theory</h4>
<div class="fm" style="margin:.5rem 0;padding:.75rem;background:var(--bg1);border-radius:6px;text-align:center;font-size:1rem">
θ = 2πr/M &nbsp;|&nbsp; Gap g: r₂ - r₁ ≡ g (mod M) with gcd(r₁,M) = gcd(r₂,M) = 1
</div>
<p style="color:var(--txt2);font-size:.85rem;line-height:1.5">Gap analysis reveals prime pair patterns: <strong>Gap 2</strong> (Twin Primes), <strong>Gap 4</strong> (Cousin Primes), <strong>Gap 6</strong> (Sexy Primes). Coprime residue classes that differ by gap g correspond to admissible prime pair patterns. The φ(M) coprime classes form (ℤ/Mℤ)×, with structure revealed by direct lifts between moduli.</p>
</div>

<!-- Multiplication Table Documentation -->
<details style="margin-top:1rem;background:rgba(150,100,255,.1);border-radius:8px;border:1px solid rgba(150,100,255,.3)">
<summary style="padding:1rem;cursor:pointer;color:#9664ff;font-weight:bold;font-size:1rem">Multiplication Table — Ring Structure of Z/mZ (click to expand)</summary>
<div style="padding:0 1rem 1rem 1rem;font-size:.85rem;line-height:1.6;color:var(--txt2);max-height:400px;overflow-y:auto">

<div style="background:var(--bg1);padding:1rem;border-radius:8px;margin:1rem 0">
<h5 style="color:#ffd700;margin-bottom:.5rem">The Ring Z/mZ</h5>
<p>For any positive integer m, the set Z/mZ = {0, 1, 2, ..., m-1} forms a <strong>commutative ring</strong> under addition and multiplication modulo m. The multiplication table visualizes this complete structure.</p>
</div>

<div style="display:grid;grid-template-columns:repeat(auto-fit,minmax(200px,1fr));gap:1rem;margin:1rem 0">
<div style="background:var(--bg1);padding:.75rem;border-radius:6px;border-left:3px solid #ffd700">
<strong style="color:#ffd700">Units</strong><br>
Elements a where gcd(a,m)=1<br>
Have multiplicative inverses<br>
Count = φ(m)
</div>
<div style="background:var(--bg1);padding:.75rem;border-radius:6px;border-left:3px solid #ff4040">
<strong style="color:#ff4040">Zero Divisors</strong><br>
Non-zero a where ab≡0 (mod m)<br>
for some non-zero b<br>
Count = m - φ(m) - 1
</div>
<div style="background:var(--bg1);padding:.75rem;border-radius:6px;border-left:3px solid #9664ff">
<strong style="color:#9664ff">Idempotents</strong><br>
Elements where a²≡a (mod m)<br>
Always include {0, 1}<br>
Count = 2^ω(m)
</div>
<div style="background:var(--bg1);padding:.75rem;border-radius:6px;border-left:3px solid #00d9ff">
<strong style="color:#00d9ff">Nilpotents</strong><br>
Elements where a^n≡0<br>
Only exist when m has<br>
repeated prime factors
</div>
</div>

<h5 style="color:#00ff88;margin:1rem 0 .5rem">Table Types</h5>
<ul style="margin:0;padding-left:1.5rem">
<li><strong>Multiplication (axb mod m)</strong>: Full m×m table showing ring structure</li>
<li><strong>Cayley Table (Units)</strong>: Restricted to φ(m) invertible elements — the group (Z/mZ)×</li>
<li><strong>Addition (a+b mod m)</strong>: Always forms cyclic group of order m</li>
</ul>

<h5 style="color:#ff6496;margin:1rem 0 .5rem">Color Schemes</h5>
<ul style="margin:0;padding-left:1.5rem">
<li><strong>Rainbow</strong>: hue = (value/m) × 360° — reveals periodic patterns</li>
<li><strong>Divisibility</strong>: Intensity by divisor count — darker = fewer divisors</li>
<li><strong>Zero Divisors</strong>: Blue=units, Red=zero divisors, Gray=zero</li>
<li><strong>Idempotents</strong>: Gold=idempotent elements, Gray=others</li>
</ul>

<h5 style="color:#ffd700;margin:1rem 0 .5rem">Element Inspector</h5>
<p>Enter any element to analyze:</p>
<ul style="margin:0;padding-left:1.5rem">
<li><strong>Units</strong>: Order (smallest k where a^k≡1), inverse, powers, generated subgroup</li>
<li><strong>Non-units</strong>: Zero divisor pairs, nilpotent detection (a^n≡0)</li>
<li><strong>Primitive roots</strong>: Units with order=φ(m) that generate all units</li>
</ul>

<div style="background:var(--bg1);padding:1rem;border-radius:8px;margin:1rem 0">
<h5 style="color:#00d9ff;margin-bottom:.5rem">Prime vs Composite Moduli</h5>
<div style="display:grid;grid-template-columns:1fr 1fr;gap:1rem">
<div>
<strong style="color:#00ff88">Prime m (Field)</strong>
<ul style="margin:.25rem 0 0 0;padding-left:1rem;font-size:.8rem">
<li>Only 0 gives 0 products</li>
<li>Every row is a permutation</li>
<li>All non-zero elements are units</li>
<li>Exactly 2 idempotents: {0,1}</li>
</ul>
</div>
<div>
<strong style="color:#ff6496">Composite m (Ring)</strong>
<ul style="margin:.25rem 0 0 0;padding-left:1rem;font-size:.8rem">
<li>Multiple zero divisor products</li>
<li>Some rows have gaps/repeats</li>
<li>Has non-invertible elements</li>
<li>2^ω(m) idempotents</li>
</ul>
</div>
</div>
</div>

<h5 style="color:#9664ff;margin:1rem 0 .5rem">Mathematical Presets</h5>
<div style="display:flex;flex-wrap:wrap;gap:.5rem;font-size:.8rem">
<span style="background:var(--bg1);padding:4px 8px;border-radius:4px">m=6 (Basel)</span>
<span style="background:var(--bg1);padding:4px 8px;border-radius:4px">m=12 (φ=4)</span>
<span style="background:linear-gradient(45deg,#ffd700,#ff6496);color:#000;padding:4px 8px;border-radius:4px">m=17 (Prime Field)</span>
<span style="background:var(--bg1);padding:4px 8px;border-radius:4px">m=30 (Primorial)</span>
<span style="background:var(--bg1);padding:4px 8px;border-radius:4px">m=60 (Highly Composite)</span>
<span style="background:var(--bg1);padding:4px 8px;border-radius:4px">m=31 (Mersenne Prime)</span>
</div>

<!-- Step-by-Step Computation Section -->
<div class="viz" style="margin-top:1rem;background:linear-gradient(135deg,rgba(150,100,255,.08),rgba(255,215,0,.05));border:2px solid rgba(150,100,255,.4);border-radius:12px;padding:1.25rem">
<h3 style="color:#9664ff;margin-bottom:1rem">Step-by-Step Sector Count Verification</h3>
<div style="display:grid;grid-template-columns:repeat(auto-fit,minmax(280px,1fr));gap:1rem;margin-bottom:1rem">
<div style="background:var(--bg1);padding:1rem;border-radius:8px;border-left:3px solid #ffd700">
<h4 style="color:#ffd700;margin-bottom:.5rem">Formula Derivation</h4>
<div style="font-family:monospace;font-size:.85rem;line-height:1.6;color:var(--txt2)">
<div style="margin:.5rem 0"><strong>1.</strong> Farey sequence |F<sub>Q</sub>| = 1 + Σ<sub>k=1</sub><sup>Q</sup> φ(k)</div>
<div style="margin:.5rem 0"><strong>2.</strong> Asymptotic: Σφ(k) ≈ 3Q²/π² (Mertens)</div>
<div style="margin:.5rem 0"><strong>3.</strong> Sector S<sub>n</sub> = (1/(n+1), 1/n) has width 1/(n(n+1))</div>
<div style="margin:.5rem 0"><strong>4.</strong> Relative width = [1/(n(n+1))] / 1 = 1/(n(n+1))</div>
<div style="margin:.5rem 0"><strong>5.</strong> Count ≈ |F<sub>Q</sub>| × [1/(n(n+1))]</div>
<div style="margin:.5rem 0;color:#00ff88"><strong>∴</strong> C(n,N) ≈ 3N²/(π²·n(n+1))</div>
</div>
</div>
<div style="background:var(--bg1);padding:1rem;border-radius:8px;border-left:3px solid #00d9ff">
<h4 style="color:#00d9ff;margin-bottom:.5rem">Error Analysis</h4>
<div style="font-family:monospace;font-size:.85rem;line-height:1.6;color:var(--txt2)">
<div style="margin:.5rem 0"><strong>Primary:</strong> Σφ(k) ≠ 3Q²/π² exactly</div>
<div style="margin:.5rem 0">Error term: O(Q log Q)</div>
<div style="margin:.5rem 0"><strong>Secondary:</strong> Boundary effects</div>
<div style="margin:.5rem 0">Fractions at 1/n, 1/(n+1) edges</div>
<div style="margin:.5rem 0"><strong>Combined:</strong> O(N log N / n²)</div>
<div style="margin:.5rem 0;color:#ff6496">Reliability degrades as n→∞</div>
</div>
</div>
</div>
<div style="background:var(--bg1);padding:1rem;border-radius:8px;margin-top:1rem">
<h4 style="color:#00ff88;margin-bottom:.5rem">Worked Example: S₂ with N=30</h4>
<table style="width:100%;border-collapse:collapse;font-size:.8rem;margin-top:.5rem">
<tr style="background:rgba(0,255,136,.15)">
<th style="padding:6px;text-align:left">Step</th>
<th style="padding:6px">Calculation</th>
<th style="padding:6px">Result</th>
</tr>
<tr><td style="padding:4px;border-bottom:1px solid var(--bord)">Asymptotic estimate</td><td style="padding:4px;border-bottom:1px solid var(--bord)">3×30²/(π²×2×3)</td><td style="padding:4px;border-bottom:1px solid var(--bord);color:#ffd700">45.57</td></tr>
<tr><td style="padding:4px;border-bottom:1px solid var(--bord)">Angular range</td><td style="padding:4px;border-bottom:1px solid var(--bord)">360°/3 to 360°/2</td><td style="padding:4px;border-bottom:1px solid var(--bord);color:#00d9ff">120° - 180°</td></tr>
<tr><td style="padding:4px;border-bottom:1px solid var(--bord)">Fraction range</td><td style="padding:4px;border-bottom:1px solid var(--bord)">1/3 < p/q ≤ 1/2</td><td style="padding:4px;border-bottom:1px solid var(--bord);color:#9664ff">width = 1/6</td></tr>
<tr><td style="padding:4px;border-bottom:1px solid var(--bord)">Root mediant</td><td style="padding:4px;border-bottom:1px solid var(--bord)">(1+1)/(3+2)</td><td style="padding:4px;border-bottom:1px solid var(--bord);color:#ff6496">2/5 @ 144°</td></tr>
<tr><td style="padding:4px">Error bound</td><td style="padding:4px">O(30·log(30)/4)</td><td style="padding:4px;color:#00ff88">~25</td></tr>
</table>
</div>
</div>

<div style="margin-top:1rem;padding:.75rem;background:rgba(255,100,150,.1);border-radius:6px;border-left:3px solid #ff6496">
<strong style="color:#ff6496">Author:</strong> Wessen Getachew |
<a href="https://github.com/wessengetachew" target="_blank" style="color:#00d9ff">GitHub</a> |
<a href="https://twitter.com/7dview" target="_blank" style="color:#00d9ff">@7dview</a>
</div>
</div>
</details>

<!-- ===== FAREY EXPLORER SECTION ===== -->
<div class="viz" style="width:100%;margin-top:1.5rem;border:2px solid rgba(0,217,255,.3);border-radius:12px;padding:1rem;background:linear-gradient(135deg,rgba(0,217,255,.05),rgba(255,215,0,.03))">
<h3 style="color:#00d9ff;margin-bottom:.75rem;display:flex;align-items:center;gap:.5rem">
<span style="font-size:1.3rem">𝔻</span> Farey Explorer — Unit Disk & Upper Half-Plane
<button onclick="screenshotFareyExplorer()" style="margin-left:auto;padding:2px 10px;font-size:.7rem;border-radius:4px;border:1px solid var(--bord);background:var(--bg2);color:var(--txt);cursor:pointer">Screenshot</button>
</h3>

<!-- Farey Sequence Controls -->
<div style="background:rgba(0,0,0,.2);border-radius:8px;padding:.75rem;margin-bottom:1rem">
<h4 style="color:#ffd700;font-size:.9rem;margin-bottom:.5rem;border-bottom:1px solid rgba(255,215,0,.3);padding-bottom:.25rem">FAREY SEQUENCE & CUSTOM POINTS</h4>

<div style="display:grid;grid-template-columns:1fr 1fr;gap:.75rem;margin-bottom:.75rem">
<!-- Generate Farey F_n -->
<div style="background:var(--bg1);padding:.5rem;border-radius:6px">
<label style="font-size:.7rem;color:var(--txt2);display:block;margin-bottom:.25rem">GENERATE FAREY SEQUENCE F_n</label>
<div style="display:flex;gap:.5rem;align-items:center">
<input type="number" id="fareyExpN" value="5" min="1" max="100" style="flex:1;padding:6px;border-radius:4px;border:1px solid var(--bord);background:var(--bg2);color:var(--txt)">
<button onclick="generateFareyExp()" style="padding:6px 12px;border-radius:4px;border:1px solid #00d9ff;background:rgba(0,217,255,.15);color:#00d9ff;cursor:pointer;font-size:.75rem;white-space:nowrap">Generate Farey Sequence</button>
</div>
<div style="font-size:.6rem;color:var(--txt2);margin-top:.25rem;font-style:italic">F_n max = current modulus m. Option to include 0/n for each n.</div>
</div>

<!-- Add All Residues -->
<div style="background:var(--bg1);padding:.5rem;border-radius:6px">
<label style="font-size:.7rem;color:var(--txt2);display:block;margin-bottom:.25rem">ADD ALL RESIDUES FOR MODULUS</label>
<div style="display:flex;gap:.5rem;align-items:center">
<input type="number" id="fareyExpMod" value="12" min="1" max="200" style="flex:1;padding:6px;border-radius:4px;border:1px solid var(--bord);background:var(--bg2);color:var(--txt)">
<button onclick="addFareyExpResidues()" style="padding:6px 12px;border-radius:4px;border:1px solid #00d9ff;background:rgba(0,217,255,.15);color:#00d9ff;cursor:pointer;font-size:.75rem;white-space:nowrap">ADD 0/M TO (M-1)/M</button>
</div>
<div style="font-size:.6rem;color:var(--txt2);margin-top:.25rem;font-style:italic">Adds all fractions k/m for k = 0 to m-1 (includes 0/m)</div>
</div>
</div>

<!-- Quick Presets -->
<div style="margin-bottom:.75rem">
<label style="font-size:.7rem;color:var(--txt2);display:block;margin-bottom:.25rem">QUICK PRESETS</label>
<div style="display:flex;flex-wrap:wrap;gap:.4rem">
<button onclick="generateFareyExp(3)" style="padding:4px 10px;font-size:.7rem;border-radius:4px;border:1px solid #ff8c00;background:linear-gradient(135deg,rgba(255,140,0,.3),rgba(255,140,0,.1));color:#ff8c00;cursor:pointer">F₃</button>
<button onclick="generateFareyExp(5)" style="padding:4px 10px;font-size:.7rem;border-radius:4px;border:1px solid #ff8c00;background:linear-gradient(135deg,rgba(255,140,0,.3),rgba(255,140,0,.1));color:#ff8c00;cursor:pointer">F₅</button>
<button onclick="generateFareyExp(7)" style="padding:4px 10px;font-size:.7rem;border-radius:4px;border:1px solid #ff8c00;background:linear-gradient(135deg,rgba(255,140,0,.3),rgba(255,140,0,.1));color:#ff8c00;cursor:pointer">F₇</button>
<button onclick="addFareyExpResidues(6)" style="padding:4px 10px;font-size:.7rem;border-radius:4px;border:1px solid #00ff88;background:linear-gradient(135deg,rgba(0,255,136,.3),rgba(0,255,136,.1));color:#00ff88;cursor:pointer">ALL MOD 6</button>
<button onclick="addFareyExpResidues(12)" style="padding:4px 10px;font-size:.7rem;border-radius:4px;border:1px solid #00ff88;background:linear-gradient(135deg,rgba(0,255,136,.3),rgba(0,255,136,.1));color:#00ff88;cursor:pointer">ALL MOD 12</button>
<button onclick="addFareyExpResidues(24)" style="padding:4px 10px;font-size:.7rem;border-radius:4px;border:1px solid #00ff88;background:linear-gradient(135deg,rgba(0,255,136,.3),rgba(0,255,136,.1));color:#00ff88;cursor:pointer">ALL MOD 24</button>
<button onclick="loadFareyExpPreset('primes')" style="padding:4px 10px;font-size:.7rem;border-radius:4px;border:1px solid #9664ff;background:linear-gradient(135deg,rgba(150,100,255,.3),rgba(150,100,255,.1));color:#9664ff;cursor:pointer">Primes</button>
<button onclick="loadFareyExpPreset('golden')" style="padding:4px 10px;font-size:.7rem;border-radius:4px;border:1px solid #ffd700;background:linear-gradient(135deg,rgba(255,215,0,.3),rgba(255,215,0,.1));color:#ffd700;cursor:pointer">Golden φ</button>
</div>
</div>

<!-- Custom Points List -->
<div style="background:var(--bg1);padding:.5rem;border-radius:6px;margin-bottom:.5rem">
<div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:.25rem">
<label style="font-size:.7rem;color:var(--txt2)">CUSTOM POINTS (CLICK × TO REMOVE)</label>
<span id="fareyExpCount" style="font-size:.75rem;color:#00d9ff;font-weight:bold">0 POINTS</span>
</div>
<div id="fareyExpPointsList" style="max-height:120px;overflow-y:auto;display:flex;flex-wrap:wrap;gap:.25rem;padding:.25rem;background:rgba(0,0,0,.2);border-radius:4px;min-height:30px">
<span style="color:var(--txt2);font-size:.7rem;font-style:italic">No points added yet</span>
</div>
<div style="display:flex;gap:.5rem;margin-top:.5rem">
<button onclick="addFareyExpPoint()" style="padding:4px 10px;font-size:.7rem;border-radius:4px;border:1px solid #00ff88;background:rgba(0,255,136,.1);color:#00ff88;cursor:pointer">+ Add Custom Point</button>
<button onclick="clearFareyExpPoints()" style="padding:4px 10px;font-size:.7rem;border-radius:4px;border:1px solid #ff4444;background:rgba(255,68,68,.1);color:#ff4444;cursor:pointer">CLEAR ALL</button>
</div>
<div style="font-size:.55rem;color:var(--txt2);margin-top:.25rem;font-style:italic">Format: numerator/denominator (e.g., 1/3, 2/5, 3/7)</div>
</div>
</div>

<!-- Connection & Display Options -->
<div style="background:rgba(0,0,0,.2);border-radius:8px;padding:.75rem;margin-bottom:1rem">
<h4 style="color:#00ff88;font-size:.9rem;margin-bottom:.5rem;border-bottom:1px solid rgba(0,255,136,.3);padding-bottom:.25rem">CONNECTION OPTIONS</h4>
<div style="display:grid;grid-template-columns:repeat(auto-fit,minmax(140px,1fr));gap:.5rem">
<div class="cg"><label>Connect By</label><select id="fareyExpConnect" onchange="drawFareyExplorer()" style="font-size:.75rem;padding:3px">
<option value="none">No Connections</option>
<option value="farey" selected>Farey Neighbors</option>
<option value="geodesic">All Geodesics</option>
<option value="sameDen">Same Denominator</option>
<option value="mediant">Mediants</option>
<option value="ford">Ford Circles Only</option>
</select></div>
<div class="cg"><label>Line Width</label><input type="range" id="fareyExpLineW" min="0.5" max="4" step="0.5" value="1.5" onchange="drawFareyExplorer()"></div>
<div class="cg"><label>Opacity</label><input type="range" id="fareyExpOpacity" min="0.1" max="1" step="0.1" value="0.7" onchange="drawFareyExplorer()"></div>
<div class="cg"><label>Point Size</label><input type="range" id="fareyExpPtSize" min="2" max="12" step="1" value="5" onchange="drawFareyExplorer()"></div>
</div>
<div style="display:flex;flex-wrap:wrap;gap:.5rem;margin-top:.5rem">
<label style="font-size:.7rem"><input type="checkbox" id="fareyExpShowLabels" checked onchange="drawFareyExplorer()"> Labels</label>
<label style="font-size:.7rem"><input type="checkbox" id="fareyExpShowGrid" checked onchange="drawFareyExplorer()"> Grid</label>
<label style="font-size:.7rem"><input type="checkbox" id="fareyExpShowAxes" checked onchange="drawFareyExplorer()"> Axes</label>
<label style="font-size:.7rem"><input type="checkbox" id="fareyExpShowCircle" checked onchange="drawFareyExplorer()"> Unit Circle</label>
<label style="font-size:.7rem"><input type="checkbox" id="fareyExpCoprime" checked onchange="drawFareyExplorer()"> Coprime Only</label>
<label style="font-size:.7rem"><input type="checkbox" id="fareyExpShowPhi" onchange="drawFareyExplorer()"> φ Ratio</label>
<label style="font-size:.7rem"><input type="checkbox" id="fareyExpSync" checked> Sync Views</label>
</div>
</div>

<!-- Canvas Size and View Controls -->
<div style="display:flex;flex-wrap:wrap;gap:.5rem;margin-bottom:.75rem;align-items:center">
<div class="cg" style="margin:0"><label>Canvas Size</label><select id="fareyExpSize" onchange="resizeFareyExpCanvases()" style="font-size:.75rem;padding:2px">
<option value="400">400×400</option>
<option value="500" selected>500×500</option>
<option value="600">600×600</option>
<option value="800">800×800</option>
</select></div>
<div class="cg" style="margin:0"><label>Zoom</label><input type="range" id="fareyExpZoom" min="0.5" max="3" step="0.1" value="1" oninput="document.getElementById('fareyExpZoomV').textContent=this.value+'×';drawFareyExplorer()"><span id="fareyExpZoomV" style="font-size:.7rem;color:#00d9ff;margin-left:.25rem">1.0×</span></div>
<div class="cg" style="margin:0"><label>Phase</label><input type="range" id="fareyExpPhase" min="0" max="360" value="0" oninput="document.getElementById('fareyExpPhaseV').textContent=this.value+'°';drawFareyExplorer()"><span id="fareyExpPhaseV" style="font-size:.7rem;color:#ffd700;margin-left:.25rem">0°</span></div>
<button onclick="startFareyExpRotation()" style="padding:3px 8px;font-size:.7rem;border-radius:3px;border:1px solid #00ff88;background:rgba(0,255,136,.1);color:#00ff88;cursor:pointer"> Rotate</button>
<button onclick="stopFareyExpRotation()" style="padding:3px 8px;font-size:.7rem;border-radius:3px;border:1px solid #ff4444;background:rgba(255,68,68,.1);color:#ff4444;cursor:pointer"> Stop</button>
<button onclick="resetFareyExpView()" style="padding:3px 8px;font-size:.7rem;border-radius:3px;border:1px solid #ffd700;background:rgba(255,215,0,.1);color:#ffd700;cursor:pointer">↺ Reset</button>
</div>

<!-- Unit Disk Canvas (Farey Explorer) -->
<div style="background:#0a0e27;border-radius:8px;padding:.75rem;border:2px solid rgba(255,215,0,.4);margin-bottom:1.5rem">
<div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:.5rem">
<div>
<span style="color:#ffd700;font-size:1rem;font-weight:bold">𝔻 Farey Unit Disk Explorer</span>
<div style="font-size:.75rem;color:var(--txt2);margin-top:.25rem">Interactive Poincare Disk — Farey Fractions on Unit Circle</div>
</div>
<div style="display:flex;gap:.5rem;flex-wrap:wrap">
<button onclick="exportFareyCanvas('cFareyDisk','png')" style="padding:5px 12px;font-size:.75rem;border-radius:4px;border:1px solid var(--bord);background:#f8f9fa;color:#333;cursor:pointer;display:flex;align-items:center;gap:3px"><span style="font-size:.9rem"></span>PNG</button>
<button onclick="exportFareyCSV()" style="padding:5px 12px;font-size:.75rem;border-radius:4px;border:1px solid #00aa55;background:#00aa55;color:#fff;cursor:pointer;display:flex;align-items:center;gap:3px"><span style="font-size:.9rem"></span>CSV</button>
</div>
</div>
<canvas id="cFareyDisk" width="600" height="600" style="width:100%;max-width:600px;height:auto;cursor:crosshair;border-radius:6px;display:block;margin:0 auto;border:1px solid rgba(255,215,0,.2)" onclick="handleFareyDiskClick(event)"></canvas>
<div id="fareyDiskInfo" style="font-size:.75rem;color:var(--txt2);margin-top:.5rem;text-align:center;padding:.5rem;background:rgba(255,215,0,.05);border-radius:4px">Farey points plotted on unit circle. Angular position: θ = 2π·(numerator/denominator). Colors by GCD value. Click points for details.</div>
<div style="display:grid;grid-template-columns:repeat(8,1fr);gap:.5rem;margin-top:1rem;font-size:.85rem">
<!-- Total Points -->
<div style="background:linear-gradient(135deg,rgba(0,217,255,.2),rgba(0,217,255,.05));border:1px solid #00d9ff;border-radius:6px;padding:.6rem;text-align:center">
<div style="font-size:.65rem;color:#00d9ff;margin-bottom:.3rem;font-weight:bold">Total</div>
<div id="farey-total" style="font-size:1.4rem;color:#00d9ff;font-weight:bold">0</div>
<div style="font-size:.65rem;color:var(--txt2)">points</div>
</div>
<!-- Coprime Count -->
<div style="background:linear-gradient(135deg,rgba(0,255,136,.2),rgba(0,255,136,.05));border:1px solid #00ff88;border-radius:6px;padding:.6rem;text-align:center">
<div style="font-size:.65rem;color:#00ff88;margin-bottom:.3rem;font-weight:bold"> COPRIME</div>
<div id="farey-coprime" style="font-size:1.4rem;color:#00ff88;font-weight:bold">0</div>
<div style="font-size:.65rem;color:var(--txt2)" id="farey-coprime-pct">0%</div>
</div>
<!-- Max Q -->
<div style="background:linear-gradient(135deg,rgba(255,215,0,.2),rgba(255,215,0,.05));border:1px solid #ffd700;border-radius:6px;padding:.6rem;text-align:center">
<div style="font-size:.65rem;color:#ffd700;margin-bottom:.3rem;font-weight:bold">Max Q</div>
<div id="farey-maxq" style="font-size:1.4rem;color:#ffd700;font-weight:bold">—</div>
<div style="font-size:.65rem;color:var(--txt2)">denom</div>
</div>
<!-- Min Q -->
<div style="background:linear-gradient(135deg,rgba(255,107,157,.2),rgba(255,107,157,.05));border:1px solid #ff6b9d;border-radius:6px;padding:.6rem;text-align:center">
<div style="font-size:.65rem;color:#ff6b9d;margin-bottom:.3rem;font-weight:bold">Min Q</div>
<div id="farey-minq" style="font-size:1.4rem;color:#ff6b9d;font-weight:bold">—</div>
<div style="font-size:.65rem;color:var(--txt2)">denom</div>
</div>
<!-- Avg Q -->
<div style="background:linear-gradient(135deg,rgba(150,100,255,.2),rgba(150,100,255,.05));border:1px solid #9664ff;border-radius:6px;padding:.6rem;text-align:center">
<div style="font-size:.65rem;color:#9664ff;margin-bottom:.3rem;font-weight:bold"> AVG Q</div>
<div id="farey-avgq" style="font-size:1.4rem;color:#9664ff;font-weight:bold">—</div>
<div style="font-size:.65rem;color:var(--txt2)">mean</div>
</div>
<!-- Min Value -->
<div style="background:linear-gradient(135deg,rgba(0,200,255,.2),rgba(0,200,255,.05));border:1px solid #00c8ff;border-radius:6px;padding:.6rem;text-align:center">
<div style="font-size:.65rem;color:#00c8ff;margin-bottom:.3rem;font-weight:bold">Min P/Q</div>
<div id="farey-minval" style="font-size:1rem;color:#00c8ff;font-weight:bold;font-family:monospace">—</div>
<div style="font-size:.65rem;color:var(--txt2)">frac</div>
</div>
<!-- Max Value -->
<div style="background:linear-gradient(135deg,rgba(0,255,136,.2),rgba(0,255,136,.05));border:1px solid #00ff88;border-radius:6px;padding:.6rem;text-align:center">
<div style="font-size:.65rem;color:#00ff88;margin-bottom:.3rem;font-weight:bold">Max P/Q</div>
<div id="farey-maxval" style="font-size:1rem;color:#00ff88;font-weight:bold;font-family:monospace">—</div>
<div style="font-size:.65rem;color:var(--txt2)">frac</div>
</div>
<!-- Span -->
<div style="background:linear-gradient(135deg,rgba(255,215,0,.2),rgba(255,215,0,.05));border:1px solid #ffd700;border-radius:6px;padding:.6rem;text-align:center">
<div style="font-size:.65rem;color:#ffd700;margin-bottom:.3rem;font-weight:bold">Span</div>
<div id="farey-span" style="font-size:1rem;color:#ffd700;font-weight:bold;font-family:monospace">—</div>
<div style="font-size:.65rem;color:var(--txt2)">range</div>
</div>
</div>

<!-- EXTENDED STATS ROW 2 -->
<div style="display:grid;grid-template-columns:repeat(6,1fr);gap:.5rem;margin-top:.5rem;font-size:.85rem">
<!-- Max P -->
<div style="background:linear-gradient(135deg,rgba(255,150,100,.2),rgba(255,150,100,.05));border:1px solid #ff9664;border-radius:6px;padding:.6rem;text-align:center">
<div style="font-size:.65rem;color:#ff9664;margin-bottom:.3rem;font-weight:bold">Max P</div>
<div id="farey-maxp" style="font-size:1.4rem;color:#ff9664;font-weight:bold">—</div>
<div style="font-size:.65rem;color:var(--txt2)">numerator</div>
</div>
<!-- Median Q -->
<div style="background:linear-gradient(135deg,rgba(100,200,255,.2),rgba(100,200,255,.05));border:1px solid #64c8ff;border-radius:6px;padding:.6rem;text-align:center">
<div style="font-size:.65rem;color:#64c8ff;margin-bottom:.3rem;font-weight:bold"> MEDIAN Q</div>
<div id="farey-medianq" style="font-size:1.4rem;color:#64c8ff;font-weight:bold">—</div>
<div style="font-size:.65rem;color:var(--txt2)">50th %ile</div>
</div>
<!-- Std Dev Q -->
<div style="background:linear-gradient(135deg,rgba(255,200,100,.2),rgba(255,200,100,.05));border:1px solid #ffc864;border-radius:6px;padding:.6rem;text-align:center">
<div style="font-size:.65rem;color:#ffc864;margin-bottom:.3rem;font-weight:bold">σ STD DEV Q</div>
<div id="farey-stdq" style="font-size:1.2rem;color:#ffc864;font-weight:bold">—</div>
<div style="font-size:.65rem;color:var(--txt2)">variance</div>
</div>
<!-- Q Range -->
<div style="background:linear-gradient(135deg,rgba(100,255,150,.2),rgba(100,255,150,.05));border:1px solid #64ff96;border-radius:6px;padding:.6rem;text-align:center">
<div style="font-size:.65rem;color:#64ff96;margin-bottom:.3rem;font-weight:bold">Q Range</div>
<div id="farey-qrange" style="font-size:1.2rem;color:#64ff96;font-weight:bold">—</div>
<div style="font-size:.65rem;color:var(--txt2)">max-min</div>
</div>
<!-- Non-Coprime -->
<div style="background:linear-gradient(135deg,rgba(255,100,150,.2),rgba(255,100,150,.05));border:1px solid #ff6496;border-radius:6px;padding:.6rem;text-align:center">
<div style="font-size:.65rem;color:#ff6496;margin-bottom:.3rem;font-weight:bold"> NON-COPRIME</div>
<div id="farey-noncoprime" style="font-size:1.4rem;color:#ff6496;font-weight:bold">—</div>
<div style="font-size:.65rem;color:var(--txt2)" id="farey-noncoprime-pct">0%</div>
</div>
<!-- Info -->
<div style="background:linear-gradient(135deg,rgba(100,100,255,.2),rgba(100,100,255,.05));border:1px solid #6464ff;border-radius:6px;padding:.6rem;text-align:center">
<div style="font-size:.65rem;color:#6464ff;margin-bottom:.3rem;font-weight:bold"> FAREY DEPTH</div>
<div id="farey-depth" style="font-size:1.4rem;color:#6464ff;font-weight:bold">—</div>
<div style="font-size:.65rem;color:var(--txt2)">F_n</div>
</div>
</div>
</div>
</div>

<!-- Comprehensive Harmonic Analysis Documentation -->
<div style="margin-top:1.5rem;background:linear-gradient(135deg,rgba(255,215,0,.1),rgba(150,100,255,.08));border:2px solid rgba(255,215,0,.4);border-radius:8px;padding:1.5rem">
<h3 style="color:#ffd700;margin-bottom:1rem;border-bottom:2px solid #ffd700;padding-bottom:.5rem"> Harmonic Analysis System — Complete Guide</h3>

<div style="display:grid;gap:1rem;font-size:.85rem">

<!-- Overview -->
<div style="background:var(--bg1);padding:1rem;border-radius:6px;border-left:3px solid #ffd700">
<h4 style="color:#ffd700;margin-bottom:.5rem">Overview</h4>
<p style="color:var(--txt2)">The Enhanced Modular tool integrates music theory with number theory, revealing deep connections between Farey sequences, the Stern-Brocot tree, and musical consonance. Every coprime fraction p/q corresponds to a musical interval, and the tool provides comprehensive analysis including audio playback, consonance metrics, and chord building.</p>
</div>

<!-- Audio Controls -->
<div style="background:var(--bg1);padding:1rem;border-radius:6px;border-left:3px solid #00ff88">
<h4 style="color:#00ff88;margin-bottom:.5rem">Audio Controls</h4>
<ul style="color:var(--txt2);margin:0;padding-left:1.2rem">
<li><strong>Base Frequency:</strong> Reference pitch in Hz (default 440 = A4). All intervals calculated relative to this.</li>
<li><strong>Volume:</strong> Master volume control (0-100%)</li>
<li><strong>Duration:</strong> Note length from Short (0.15s) to 1 second</li>
<li><strong>Waveform:</strong> Sine (pure), Triangle, Square, or Sawtooth oscillator</li>
</ul>
</div>

<!-- Interval Playback -->
<div style="background:var(--bg1);padding:1rem;border-radius:6px;border-left:3px solid #00d9ff">
<h4 style="color:#00d9ff;margin-bottom:.5rem">Interval Playback</h4>
<p style="color:var(--txt2)">Quick buttons for fundamental intervals:</p>
<ul style="color:var(--txt2);margin:0;padding-left:1.2rem">
<li><strong>Perfect Fifth (3:2):</strong> 702 cents — most consonant after unison/octave</li>
<li><strong>Perfect Fourth (4:3):</strong> 498 cents — inversion of the fifth</li>
<li><strong>Major Third (5:4):</strong> 386 cents — defines major tonality</li>
<li><strong>Minor Third (6:5):</strong> 316 cents — defines minor tonality</li>
<li><strong>Major Sixth (5:3):</strong> 884 cents — inversion of minor third</li>
<li><strong>Octave (2:1):</strong> 1200 cents — same note, double frequency</li>
</ul>
</div>

<!-- Chord Builder -->
<div style="background:var(--bg1);padding:1rem;border-radius:6px;border-left:3px solid #9664ff">
<h4 style="color:#9664ff;margin-bottom:.5rem">Chord Builder</h4>
<p style="color:var(--txt2)">Build and play chords from selected fractions:</p>
<ul style="color:var(--txt2);margin:0;padding-left:1.2rem">
<li><strong>Chord Mode:</strong> Enable to add clicked points to chord instead of replacing selection</li>
<li><strong>Play Chord:</strong> Play all selected notes simultaneously</li>
<li><strong>Arpeggio:</strong> Play notes in sequence (lowest to highest)</li>
<li><strong>Quick Chords:</strong> Preset major (4:5:6), minor (10:12:15), major 7th, power chord</li>
</ul>
<p style="color:var(--txt2);margin-top:.5rem"><em>Tip: In Chord Mode, click multiple coprime points on the canvas to build custom chords!</em></p>
</div>

<!-- Consonance Metrics -->
<div style="background:var(--bg1);padding:1rem;border-radius:6px;border-left:3px solid #ff6496">
<h4 style="color:#ff6496;margin-bottom:.5rem">Consonance Metrics</h4>
<p style="color:var(--txt2)">For any selected fraction p/q, the tool calculates:</p>
<table style="font-size:.8rem;width:100%;color:var(--txt2)">
<tr><td style="padding:3px;color:#ffd700;width:30%"><strong>Cents</strong></td><td style="padding:3px">1200 × log₂(p/q) — standard musical measurement</td></tr>
<tr><td style="padding:3px;color:#00ff88"><strong>Tenney Height</strong></td><td style="padding:3px">log₂(p) + log₂(q) — lower = simpler interval</td></tr>
<tr><td style="padding:3px;color:#00d9ff"><strong>Benedetti Height</strong></td><td style="padding:3px">p × q — multiplicative complexity (Benedetti, 1585)</td></tr>
<tr><td style="padding:3px;color:#9664ff"><strong>Euler Gradus</strong></td><td style="padding:3px">Γ(p) + Γ(q) - 1 — "degree of sweetness" (Euler, 1739)</td></tr>
<tr><td style="padding:3px;color:#ff6496"><strong>Harmonic Entropy</strong></td><td style="padding:3px">Information-theoretic smoothness (Erlich model)</td></tr>
<tr><td style="padding:3px;color:#ff8800"><strong>Prime Limit</strong></td><td style="padding:3px">Largest prime in factorization of p·q</td></tr>
</table>
</div>

<!-- Color Schemes -->
<div style="background:var(--bg1);padding:1rem;border-radius:6px;border-left:3px solid #00d9ff">
<h4 style="color:#00d9ff;margin-bottom:.5rem">Harmonic Color Schemes</h4>
<p style="color:var(--txt2)">Four specialized color modes for harmonic analysis:</p>
<table style="font-size:.8rem;width:100%;color:var(--txt2)">
<tr>
<td style="padding:4px;width:25%"><strong style="color:#ffd700">Harmonic (by q)</strong></td>
<td style="padding:4px">Colors by denominator: <span style="color:#ffd700"></span> q=1 <span style="color:#00ff88"></span> q≤4 <span style="color:#00d9ff"></span> q≤8 <span style="color:#9664ff"></span> q≤16 <span style="color:#ff6496"></span> q>16</td>
</tr>
<tr>
<td style="padding:4px"><strong style="color:#00ff88">Prime Limit</strong></td>
<td style="padding:4px"><span style="color:#ffd700"></span> 2-limit <span style="color:#00ff88"></span> 3-limit <span style="color:#00d9ff"></span> 5-limit <span style="color:#9664ff"></span> 7-limit <span style="color:#ff6496"></span> 11-limit <span style="color:#ff8800"></span> higher</td>
</tr>
<tr>
<td style="padding:4px"><strong style="color:#00d9ff">Tenney Height</strong></td>
<td style="padding:4px">Gradient from <span style="color:#ffd700">simple</span> (low complexity) to <span style="color:#ff6496">complex</span> (high Tenney value)</td>
</tr>
<tr>
<td style="padding:4px"><strong style="color:#9664ff">Consonance</strong></td>
<td style="padding:4px"><span style="color:#ffd700"></span> Perfect <span style="color:#00ff88"></span> Imperfect <span style="color:#ff6496"></span> Dissonant</td>
</tr>
</table>
</div>

<!-- Prime Limits Explained -->
<div style="background:var(--bg1);padding:1rem;border-radius:6px;border-left:3px solid #9664ff">
<h4 style="color:#9664ff;margin-bottom:.5rem">Prime Limits Explained</h4>
<table style="font-size:.8rem;width:100%;color:var(--txt2)">
<tr style="background:rgba(150,100,255,.1)"><th style="padding:4px;text-align:left">Limit</th><th style="padding:4px;text-align:left">System</th><th style="padding:4px;text-align:left">Intervals</th><th style="padding:4px;text-align:left">Musical Era</th></tr>
<tr><td style="padding:3px;color:#ffd700">2-limit</td><td style="padding:3px">Octaves only</td><td style="padding:3px">2/1</td><td style="padding:3px">Universal</td></tr>
<tr><td style="padding:3px;color:#00ff88">3-limit</td><td style="padding:3px">Pythagorean</td><td style="padding:3px">3/2, 4/3, 9/8</td><td style="padding:3px">Ancient Greece</td></tr>
<tr><td style="padding:3px;color:#00d9ff">5-limit</td><td style="padding:3px">Just Intonation</td><td style="padding:3px">5/4, 6/5, 5/3</td><td style="padding:3px">Renaissance</td></tr>
<tr><td style="padding:3px;color:#9664ff">7-limit</td><td style="padding:3px">Septimal</td><td style="padding:3px">7/4, 7/6, 8/7</td><td style="padding:3px">Blues, Barbershop</td></tr>
<tr><td style="padding:3px;color:#ff6496">11-limit</td><td style="padding:3px">Undecimal</td><td style="padding:3px">11/8, 11/9</td><td style="padding:3px">Microtonal</td></tr>
</table>
</div>

<!-- Stern-Brocot & Music -->
<div style="background:var(--bg1);padding:1rem;border-radius:6px;border-left:3px solid #00ff88">
<h4 style="color:#00ff88;margin-bottom:.5rem">Stern-Brocot Tree & Music</h4>
<p style="color:var(--txt2)">The Stern-Brocot tree organizes all positive rationals by simplicity — exactly what musicians need:</p>
<ul style="color:var(--txt2);margin:0;padding-left:1.2rem">
<li><strong>Mediant Property:</strong> Between a/b and c/d, the mediant (a+c)/(b+d) is the simplest fraction — used to find intermediate pitches</li>
<li><strong>Path = Continued Fraction:</strong> The L/R path encodes the CF [a₀; a₁, ...], connecting to best approximations</li>
<li><strong>Depth ≈ Complexity:</strong> Tree depth correlates with Tenney height — deeper = more complex interval</li>
<li><strong>Path Sonification:</strong> Play the S-B path as an arpeggio to "hear" the approach to any fraction</li>
</ul>
</div>

<!-- Famous Commas -->
<div style="background:var(--bg1);padding:1rem;border-radius:6px;border-left:3px solid #ff8800">
<h4 style="color:#ff8800;margin-bottom:.5rem">Famous Tuning Commas</h4>
<p style="color:var(--txt2)">Commas are small intervals revealing tuning incompatibilities:</p>
<table style="font-size:.8rem;width:100%;color:var(--txt2)">
<tr><td style="padding:3px;color:#ffd700"><strong>Syntonic (81/80)</strong></td><td style="padding:3px">21.5¢ — Four 5ths vs M3+2 octaves</td></tr>
<tr><td style="padding:3px;color:#00ff88"><strong>Pythagorean</strong></td><td style="padding:3px">23.5¢ — 12 fifths vs 7 octaves</td></tr>
<tr><td style="padding:3px;color:#00d9ff"><strong>Diesis (128/125)</strong></td><td style="padding:3px">41.1¢ — Octave vs three M3s</td></tr>
<tr><td style="padding:3px;color:#9664ff"><strong>Septimal (64/63)</strong></td><td style="padding:3px">27.3¢ — 7th harmonic discrepancy</td></tr>
</table>
<p style="color:var(--txt2);margin-top:.5rem;font-style:italic">These explain why perfect tuning is mathematically impossible — you can't stack simple ratios and return exactly to the start.</p>
</div>

<!-- Usage Tips -->
<div style="background:linear-gradient(135deg,rgba(0,255,136,.1),rgba(0,217,255,.05));padding:1rem;border-radius:6px;border:1px solid rgba(0,255,136,.3)">
<h4 style="color:#00ff88;margin-bottom:.5rem">Quick Start Guide</h4>
<ol style="color:var(--txt2);margin:0;padding-left:1.2rem;font-size:.85rem">
<li>Select <strong>Harmonic (by q)</strong> or <strong>Prime Limit</strong> color scheme</li>
<li>Click any <span style="color:#ffd700">gold coprime point</span> to hear its frequency</li>
<li>View <strong>Harmonic Metrics panel</strong> for full consonance analysis</li>
<li>Enable <strong>Chord Mode</strong> and click multiple points to build chords</li>
<li>Click <strong>Play Chord</strong> to hear all selected notes together</li>
<li>Use <strong>S-B Path</strong> to visualize and sonify the path to any fraction</li>
<li>Try the <strong>Manual p/q input</strong> to explore specific intervals</li>
<li>Compare <strong>Quick Chords</strong> (Major, Minor, Maj7, Power) to hear harmonic structure</li>
</ol>
</div>

<!-- Mathematical Foundation -->
<div style="background:var(--bg1);padding:1rem;border-radius:6px;border-left:3px solid #ffd700">
<h4 style="color:#ffd700;margin-bottom:.5rem">Mathematical Foundation</h4>
<p style="color:var(--txt2)">The deep connection: when two frequencies f₁ and f₂ have ratio p/q (in lowest terms), their combined waveform repeats every q cycles of f₁ (or p cycles of f₂). Simple ratios create short, regular patterns — perceived as consonance. Complex ratios create long, irregular patterns — perceived as dissonance.</p>
<p style="color:var(--txt2);margin-top:.5rem">This is why the Farey sequence and Stern-Brocot tree — which organize rationals by simplicity — are fundamentally musical structures. The 6/π² coprime density means roughly 61% of random frequency pairs form "primitive" (irreducible) intervals.</p>
</div>

</div>
</div>

</div>
<!-- End of tenhanced tab -->

<!-- Z-FUNCTION CRITICAL LINE EXPLORER -->
<div id="tzetaFunc" style="display:none;padding:1rem">
<div style="background:linear-gradient(135deg,rgba(255,215,0,.2),rgba(100,149,237,.1));padding:1rem;border-radius:8px;margin-bottom:1rem;border-left:4px solid #ffd700">
<h3 style="color:#ffd700;margin-bottom:.5rem">Hardy Z-Function: Critical Line Explorer</h3>
<p style="color:var(--txt2);font-size:.9rem;margin-bottom:.75rem">Riemann-Siegel approximation with sign-change zero detection via bisection refinement. Compute Z(t) = ζ(1/2 + it) on the critical line and locate non-trivial zeros.</p>
</div>

<!-- Sub-tabs for Z-function modes -->
<div style="display:flex;gap:.5rem;margin-bottom:1rem;border-bottom:2px solid rgba(255,215,0,.2);flex-wrap:wrap">
<button class="tbtn cat-zeta active" onclick="switchZMode('wave')" style="border-left:3px solid #ffd700">Z(t) Wave</button>
<button class="tbtn cat-zeta" onclick="switchZMode('zeros')" style="border-left:3px solid #ffd700">Zero Detector</button>
<button class="tbtn cat-zeta" onclick="switchZMode('spiral')" style="border-left:3px solid #ffd700">Critical Spiral</button>
</div>

<!-- WAVE PLOT MODE -->
<div id="zWaveMode" style="display:block">
<div class="ctrl">
<div class="cg"><label>t Range Start</label><input type="number" id="zTStart" value="0" min="0" step="0.1"></div>
<div class="cg"><label>t Range End</label><input type="number" id="zTEnd" value="100" min="0.1" step="0.1"></div>
<div class="cg"><label>Compute Points</label><input type="number" id="zNumPoints" value="300" min="50" max="2000" step="50"></div>
</div>
<div style="display:flex;gap:.5rem;margin-bottom:1rem;flex-wrap:wrap">
  <button onclick="plotZWave()" style="padding:.5rem 1rem">Plot Z(t) Wave</button>
  <button onclick="exportZWaveToJSON()" style="padding:.5rem 1rem;background:#00d9ff;color:#000;flex:0" title="Export wave data to JSON"> JSON</button>
  <button onclick="exportZerosToCSV()" style="padding:.5rem 1rem;background:#00aa55;flex:0" title="Export detected zeros to CSV"> CSV</button>
</div>

<div class="viz">
<h4 style="color:#ffd700;margin-bottom:.8rem">Z(t) = Hardy Z-Function on s = 1/2 + it</h4>
<canvas id="zWaveCanvas" width="800" height="400" style="max-width:100%;height:auto;border:2px solid #ffd700;border-radius:6px"></canvas>
<div class="sg" style="margin-top:.8rem">
<div class="sb"><div class="sl">Zero Crossings:</div><div class="sv" id="zCrossingCount">0</div></div>
<div class="sb"><div class="sl">Max |Z(t)|:</div><div class="sv" id="zMaxVal">—</div></div>
</div>
</div>
</div>

<!-- ZERO DETECTOR MODE -->
<div id="zZeroMode" style="display:none">
<div class="ctrl">
<div class="cg"><label>Scan t Start</label><input type="number" id="zZeroStart" value="0" min="0" step="0.1"></div>
<div class="cg"><label>Scan t End</label><input type="number" id="zZeroEnd" value="100" min="0.1" step="0.1"></div>
<div class="cg"><label>Scan Points</label><input type="number" id="zScanPoints" value="500" min="50" max="5000" step="50"></div>
</div>
<div style="display:flex;gap:.5rem;margin-bottom:1rem;flex-wrap:wrap">
  <button onclick="findZerosUI()" style="padding:.5rem 1rem">Find Zeros</button>
  <button onclick="exportZerosToCSV()" style="padding:.5rem 1rem;background:#00aa55;flex:0" title="Export found zeros to CSV"> CSV</button>
  <button onclick="exportZeroStatistics()" style="padding:.5rem 1rem;background:#ffd700;color:#000;flex:0" title="Export statistical analysis"> Stats</button>
  <button onclick="exportZWaveToJSON()" style="padding:.5rem 1rem;background:#00d9ff;color:#000;flex:0" title="Export Z(t) wave data"> JSON</button>
  <button onclick="exportToMathematica()" style="padding:.5rem 1rem;background:#ff8c00;flex:0" title="Export as Mathematica code"> WL</button>
  <button onclick="exportToPython()" style="padding:.5rem 1rem;background:#4488ff;flex:0" title="Export as Python code"> Py</button>
</div>

<div class="viz">
<h4 style="color:#ffd700;margin-bottom:.8rem">Non-Trivial Zeros on Critical Line</h4>
<div id="zZeroStatus" style="color:var(--txt2);font-size:.9rem;margin-bottom:.8rem">Ready to scan</div>
<table class="zeroTable" style="width:100%;border-collapse:collapse;font-size:.85rem">
<thead><tr><th>t (Imaginary)</th><th>Z(t) Value</th><th>Known Zero?</th></tr></thead>
<tbody id="zZeroResults"></tbody>
</table>
</div>
</div>

<!-- SPIRAL MODE -->
<div id="zSpiralMode" style="display:none">
<div style="color:var(--txt2);padding:1rem;background:rgba(255,215,0,.08);border-radius:8px;margin-bottom:1rem;border-left:3px solid #ffd700">
<p style="font-size:.85rem;margin-bottom:.5rem"><strong>Critical Line Spiral:</strong> Maps ζ(1/2 + it) in complex plane as t increases. The spiral passes through origin (0,0) exactly at non-trivial zeros of the Riemann zeta function.</p>
<p style="font-size:.85rem;color:var(--txt);margin-top:.5rem"> This visualization requires additional coordinate transformation implementation.</p>
</div>
</div>

</div>

</div>
</div>
<!-- END TOOL SECTION -->

<!-- THEORY SECTION -->
<div id="secTheory" class="mainSec" style="display:none">
<div style="background:var(--bg2);border-radius:8px;padding:1.5rem;margin-bottom:1rem">
<h2 style="color:#ffd700;margin-bottom:1rem">Mathematical Theory</h2>

<div style="margin-bottom:1.5rem;padding:1rem;background:var(--bg);border-radius:8px;border-left:4px solid #00d9ff">
<h3 style="color:#00d9ff;margin-bottom:.75rem">Modular Arithmetic Fundamentals</h3>
<p style="color:var(--txt2);margin-bottom:.5rem">For integers a, b and modulus M > 0, we write <strong>a ≡ b (mod M)</strong> when M divides (a - b). The set of residue classes forms the ring <strong>ℤ/Mℤ</strong>.</p>
<ul style="color:var(--txt2);margin-left:1.5rem;line-height:1.8">
<li><strong style="color:#ffd700">Units:</strong> Elements with multiplicative inverses. The unit group (ℤ/Mℤ)× has order φ(M).</li>
<li><strong style="color:#00ff88">Coprime residues:</strong> r is coprime to M iff gcd(r, M) = 1 iff r is a unit.</li>
<li><strong style="color:#ff6496">Zero divisors:</strong> Non-zero elements a where ab ≡ 0 for some non-zero b. Only exist when M is composite.</li>
</ul>
</div>

<div style="margin-bottom:1.5rem;padding:1rem;background:var(--bg);border-radius:8px;border-left:4px solid #9664ff">
<h3 style="color:#9664ff;margin-bottom:.75rem">Euler's Totient Function</h3>
<p style="color:var(--txt2);margin-bottom:.5rem"><strong>φ(M)</strong> counts integers 1 ≤ r ≤ M with gcd(r, M) = 1.</p>
<div style="background:var(--bg2);padding:.75rem;border-radius:6px;font-family:monospace;color:#00ff88;margin:.5rem 0">
φ(M) = M · ∏<sub>p|M</sub> (1 - 1/p)
</div>
<p style="color:var(--txt2)">The density of coprimes approaches <strong style="color:#ffd700">6/π² ≈ 0.6079</strong> as M → ∞, connecting to the Riemann zeta function: 1/ζ(2) = 6/π².</p>
</div>

<div style="margin-bottom:1.5rem;padding:1rem;background:var(--bg);border-radius:8px;border-left:4px solid #ff8c00">
<h3 style="color:#ff8c00;margin-bottom:.75rem">Farey Sequences & Stern-Brocot Tree</h3>
<p style="color:var(--txt2);margin-bottom:.5rem">The <strong>Farey sequence F<sub>n</sub></strong> consists of reduced fractions p/q with 0 ≤ p/q ≤ 1 and q ≤ n, arranged in order.</p>
<ul style="color:var(--txt2);margin-left:1.5rem;line-height:1.8">
<li><strong style="color:#ffd700">Mediant property:</strong> Between adjacent Farey fractions a/b and c/d, their mediant (a+c)/(b+d) appears in higher-order sequences.</li>
<li><strong style="color:#00d9ff">Stern-Brocot tree:</strong> Binary tree generating all positive rationals exactly once via iterated mediants from 0/1 and 1/0.</li>
<li><strong style="color:#00ff88">Ford circles:</strong> Circle of radius 1/(2q²) tangent to the real axis at p/q. Adjacent Farey neighbors have tangent Ford circles.</li>
</ul>
</div>

<div style="margin-bottom:1.5rem;padding:1rem;background:var(--bg);border-radius:8px;border-left:4px solid #00ff88">
<h3 style="color:#00ff88;margin-bottom:.75rem">Sector Counting Asymptotics</h3>
<p style="color:var(--txt2);margin-bottom:.5rem">For the sector S<sub>n</sub> = [1/(n+1), 1/n], the coprime count follows:</p>
<div style="background:var(--bg2);padding:.75rem;border-radius:6px;font-family:monospace;color:#ffd700;margin:.5rem 0">
|{(a,b) : gcd(a,b)=1, a/b ∈ S<sub>n</sub>, b ≤ M}| ~ 3M²/(π²n(n+1))
</div>
<p style="color:var(--txt2)">The error term is O(M log M / n²), giving excellent asymptotic predictions for coprime density in angular sectors.</p>
</div>


<div style="margin-bottom:1.5rem;padding:1rem;background:var(--bg);border-radius:8px;border-left:4px solid #ffd700">
<h3 style="color:#ffd700;margin-bottom:.75rem">Riemann Zeta & Critical Line Mapping</h3>
<p style="color:var(--txt2);margin-bottom:.5rem">The <strong>Riemann Hypothesis</strong> states that all non-trivial zeros of ζ(s) lie on the critical line <strong>Re(s) = 1/2</strong>.</p>
<ul style="color:var(--txt2);margin-left:1.5rem;line-height:1.8">
<li><strong style="color:#00d9ff">Critical Strip:</strong> The region 0 < Re(s) < 1 where non-trivial zeros are conjectured to exist.</li>
<li><strong style="color:#ffd700">Hardy Z-Function:</strong> Z(t) = χ(1/2 + it)·ζ(1/2 + it), a real-valued function with zeros at ζ zeros.</li>
<li><strong style="color:#00ff88">Zero Detection:</strong> Z(t) changes sign at each zero. Bisection refinement locates zeros to arbitrary precision.</li>
<li><strong style="color:#ff8c00">Critical Line Spiral:</strong> As t increases, ζ(1/2 + it) traces a spiral in the complex plane passing through origin (0,0) at each zero.</li>
</ul>
<div style="background:var(--bg2);padding:.75rem;border-radius:6px;font-family:monospace;color:#ffd700;margin:.5rem 0;font-size:.8rem">
Z(t) = 2·Σ(n=1 to m) cos(ϑ(t) - t·log(n))/√n<br>
where m = √(t/2π) and ϑ(t) = Riemann-Siegel theta
</div>
<p style="color:var(--txt2);margin-top:.75rem"><strong style="color:#ff6496">Connection to Primes:</strong> The oscillations in Z(t) directly relate to prime distribution via the explicit formula. Zero spacing patterns are governed by GUE (Gaussian Unitary Ensemble) law from random matrix theory.</p>
</div>

<div style="margin-bottom:1.5rem;padding:1rem;background:var(--bg);border-radius:8px;border-left:4px solid #ff8c00">
<h3 style="color:#ff8c00;margin-bottom:.75rem">Functional Equation & Symmetry</h3>
<p style="color:var(--txt2);margin-bottom:.5rem">The zeta function satisfies the functional equation:</p>
<div style="background:var(--bg2);padding:.75rem;border-radius:6px;font-family:monospace;color:#00d9ff;margin:.5rem 0;font-size:.8rem">
ζ(s) = χ(s)·ζ(1-s)<br>
where χ(s) = 2^s π^(s-1) sin(πs/2) Γ(1-s)
</div>
<p style="color:var(--txt2)">This symmetry about Re(s) = 1/2 is crucial. If ρ = 1/2 + it is a zero, then so is its conjugate 1/2 - it, creating paired oscillations.</p>
</div>

<div style="background:var(--bg2);padding:.75rem;border-radius:6px;font-family:monospace;color:#00d9ff;margin:.5rem 0">
Γ = (Z - Z₀)/(Z + Z₀)
</div>
<p style="color:var(--txt2)">Originally from RF engineering, it provides a powerful visualization where circles of constant resistance and reactance reveal modular structures geometrically.</p>
<div style="margin-bottom:1.5rem;padding:1rem;background:var(--bg);border-radius:8px;border-left:4px solid #667eea">
<h3 style="color:#667eea;margin-bottom:.75rem">GCD Mapping Framework: Modular Coprimality Geometry</h3>
<p style="color:var(--txt2);margin-bottom:1rem"><strong>Definition:</strong> For modulus m, the GCD map assigns each residue r ∈ {1,2,...,m} to angular position θ<sub>r</sub> = 2πr/m on the unit circle, with color determined by gcd(r,m).</p>

<div style="background:var(--bg2);padding:.75rem;border-radius:6px;font-family:monospace;color:#00ff88;margin:.75rem 0;font-size:.85rem">
GCD Map: r ↦ (θ = 2πr/m, color(gcd(r,m)), size ∝ coprimality)<br>
Unit Disk Visualization:<br>
  • Angular position: θ = 2π·(numerator/denominator)<br>
  • Color: Determined by gcd value with coprime highlighting<br>
  • Interactive: Click to inspect individual points<br>
  • Real-time stats: Total points, coprime count, density percentage
</div>

<p style="color:var(--txt2);margin-bottom:.75rem"><strong>Core Theorems:</strong></p>
<ul style="color:var(--txt2);margin-left:1.5rem;line-height:1.8">
<li><strong>Coprime Density:</strong> For prime p, φ(p) = p-1, giving density (p-1)/p → 1. For composite m = p·q, φ(m) = φ(p)·φ(q) = (p-1)(q-1).</li>
<li><strong>Sector Persistence:</strong> Prime residues p maintain constant phase mod any modulus. Composites destructively interfere on mod-1 revaluation channels.</li>
<li><strong>Symmetry Group:</strong> The symmetry Aut(ℤ/mℤ) acts on the GCD map, preserving coprimality structure. For m = p^k, only unit-preserving automorphisms exist.</li>
<li><strong>Farey Connection:</strong> Reduced residues {r : gcd(r,m)=1} form Farey neighbors. The mediant (r₁+r₂)/(m+m) ≡ (r₁+r₂)/2m determines adjacency structure.</li>
</ul>

<p style="color:var(--txt2);margin-bottom:.75rem"><strong>Geometric Interpretation:</strong></p>

</div>
</div>
</div>
</div>





<!-- REFERENCE SECTION -->
<div id="secReference" class="mainSec" style="display:none">
<div style="background:var(--bg2);border-radius:8px;padding:1.5rem">
<h2 style="color:#ffd700;margin-bottom:1rem">Reference & Credits</h2>

<div style="margin-bottom:1.5rem;padding:1rem;background:var(--bg);border-radius:8px;border-left:4px solid #ffd700">
<h3 style="color:#ffd700;margin-bottom:.75rem">Author</h3>
<p style="color:var(--txt2)"><strong>Wessen Getachew</strong></p>
<p style="color:var(--txt2);font-size:.9rem">Twitter: <a href="https://twitter.com/7dview" style="color:#00d9ff">@7dview</a></p>
<p style="color:var(--txt2);font-size:.9rem">GitHub: <a href="https://wessengetachew.github.io" style="color:#00d9ff">wessengetachew.github.io</a></p>
</div>

<div style="margin-bottom:1.5rem;padding:1rem;background:var(--bg);border-radius:8px;border-left:4px solid #00d9ff">
<h3 style="color:#00d9ff;margin-bottom:.75rem">Core Features</h3>
<ul style="color:var(--txt2);margin-left:1.5rem;line-height:1.8">
<li><strong style="color:#667eea">GCD Mapping Framework:</strong> Modular coprimality geometry with unit disk visualization and coprime highlighting</li>
<li><strong style="color:#ffd700">Unified Visualization Controls:</strong> Synchronized labeling, coloring, and grid/density settings across all visualizations</li>
<li><strong style="color:#00ff88">Interactive Point Inspection:</strong> Hover/click tooltips showing detailed information for selected points</li>
<li><strong style="color:#ffd700">Modular Ring Visualization:</strong> Concentric rings showing residue classes with coprime density analysis</li>
<li><strong style="color:#00ff88">Farey Sector Analysis:</strong> Angular sectors with asymptotic counting formulas and error bounds</li>
<li><strong style="color:#9664ff">Stern-Brocot Tree:</strong> Interactive tree with path highlighting and mediant computation</li>
<li><strong style="color:#1abc9c">Upper Half-Plane Visualization:</strong> Hyperbolic geometry with Ford circles and geodesic arcs</li>
<li><strong style="color:#ff6496">Hardy Z-Function Explorer:</strong> Riemann zeta zero detection on critical line with zero crossing analysis</li>
<li><strong style="color:#ff8c00">Multiple Color Schemes:</strong> 7+ professional color palettes for different analysis contexts</li>
<li><strong style="color:#00d9ff">Smith Chart Transform:</strong> Complex plane Mobius transformation for geometric analysis</li>
<li><strong style="color:#64c8ff">Boundary Cancellation Analysis:</strong> Error term visualization and growth exponent calculation for k-dimensional lattices</li>
<li><strong style="color:#ff6b9d">Growth Exponent Calculator:</strong> Log-log linear regression to determine scaling law exponents with confidence intervals</li>
<li><strong style="color:#00ff88">Number Theory Toolkit:</strong> GCD calculator, Mobius function, primality testing, Euler totient computation</li>
<li><strong style="color:#ffd700">Error Analysis Chart:</strong> Multi-dimensional error term visualization with configurable radius and dimension parameters</li>
<li><strong style="color:#00ff88">Mobius Wave Visualization:</strong> Mertens function (cumulative Mobius sum) with oscillation pattern analysis and cancellation statistics</li>
<li><strong style="color:#ffd700">High-Precision Computation:</strong> Unlimited data point generation with radius up to 1,000,000</li>
</ul>
</div>

<div style="margin-bottom:1.5rem;padding:1rem;background:var(--bg);border-radius:8px;border-left:4px solid #00ff88">
<h3 style="color:#00ff88;margin-bottom:.75rem">Mathematical References</h3>
<ul style="color:var(--txt2);margin-left:1.5rem;line-height:1.9">
<li><strong>Number Theory Foundations:</strong>
<ul style="margin-left:1.5rem;margin-top:.3rem">
<li>Hardy, G.H. & Wright, E.M. — <em>An Introduction to the Theory of Numbers</em> (Oxford University Press, 2008)</li>
<li>Apostol, T.M. — <em>Introduction to Analytic Number Theory</em> (Springer, 1976)</li>
<li>Ireland & Rosen — <em>A Classical Introduction to Modern Number Theory</em> (Springer, 1990)</li>
<li>Graham, Knuth & Patashnik — <em>Concrete Mathematics</em> (Addison-Wesley, 1994)</li>
</ul>
</li>
<li><strong>Modular Arithmetic & GCD:</strong>
<ul style="margin-left:1.5rem;margin-top:.3rem">
<li>Niven, I., Zuckerman, H.S. & Montgomery, H.L. — <em>An Introduction to the Theory of Numbers</em> (John Wiley & Sons, 2008)</li>
<li>Dickson, L.E. — <em>History of the Theory of Numbers</em> (Chelsea Publishing, 1971)</li>
<li>Rademacher, H. & Grosswald, E. — <em>Dedekind Sums</em> (Carus Mathematical Monographs, 1972)</li>
</ul>
</li>
<li><strong>Farey Sequences & Stern-Brocot Trees:</strong>
<ul style="margin-left:1.5rem;margin-top:.3rem">
<li>Calkin, N. & Wilf, H.S. — "Recounting the rationals" <em>American Mathematical Monthly</em>, 2000</li>
<li>Hinman, P.G. — <em>Fundamentals of Mathematical Logic</em> (A.K. Peters, 2005)</li>
<li>Vinson, J. — "The Stern-Brocot tree" <em>Mathematical Gazette</em>, 1990</li>
</ul>
</li>
<li><strong>Hyperbolic Geometry & Upper Half-Plane:</strong>
<ul style="margin-left:1.5rem;margin-top:.3rem">
<li>Beardon, A.F. — <em>The Geometry of Discrete Groups</em> (Springer, 1983)</li>
<li>Katok, S. — <em>Fuchsian Groups</em> (University of Chicago Press, 1992)</li>
<li>Carleson, L. & Gamelin, T.W. — <em>Complex Dynamics</em> (Springer, 1993)</li>
</ul>
</li>
<li><strong>Riemann Zeta Function & Critical Line:</strong>
<ul style="margin-left:1.5rem;margin-top:.3rem">
<li>Edwards, H.M. — <em>Riemann's Zeta Function</em> (Dover Publications, 2001)</li>
<li>Titchmarsh, E.C. — <em>The Theory of the Riemann Zeta-Function</em> (Oxford, 1986)</li>
<li>Ivic, A. — <em>The Riemann Zeta-Function</em> (John Wiley & Sons, 1985)</li>
<li>Conrey, B.J. — "The Riemann Hypothesis" <em>Notices of the AMS</em>, 2003</li>
</ul>
</li>
<li><strong>Visualizations & Complex Analysis:</strong>
<ul style="margin-left:1.5rem;margin-top:.3rem">
<li>Ahlfors, L.V. — <em>Complex Analysis</em> (McGraw-Hill, 1979)</li>
<li>Needham, T. — <em>Visual Complex Analysis</em> (Oxford, 1997)</li>
<li>Trott, M. — <em>The Mathematica GuideBook for Symbolics</em> (Springer, 2006)</li>
</ul>
</li>
<li><strong>Original Framework Contributions (Getachew, 2025):</strong>
<ul style="margin-left:1.5rem;margin-top:.3rem">
<li>GCD Mapping Framework: Modular coprimality geometry via angular residue placement</li>
<li>Unified Multi-Canvas Visualization: Synchronized controls for Farey disk, upper half-plane, Ford circles, and GCD mapping</li>
<li>Circular Sector Organization: Asymptotic formula C(n,N) ≈ 3N²/(π²·n(n+1)) for coprime density in sectors S_n = [1/(n+1), 1/n]</li>
<li>Hardy Z-Function Integration: Zero-detection and critical line visualization with multi-format export</li>
<li>Interactive Labeling Systems: 8 complementary mathematical lenses for single residue representation</li>
</ul>
</li>
</ul>
</div>

<div style="padding:1rem;background:var(--bg);border-radius:8px;border-left:4px solid #9664ff">
<h3 style="color:#9664ff;margin-bottom:.75rem">Libraries Used</h3>
<ul style="color:var(--txt2);margin-left:1.5rem;line-height:1.8">
<li><strong>Plotly.js</strong> — Interactive charts and visualizations</li>
<li><strong>html2canvas</strong> — Screenshot export functionality</li>
<li><strong>Web Audio API</strong> — Harmonic sonification</li>
</ul>
</div>

<div style="margin-top:1.5rem;text-align:center;padding:1rem;background:linear-gradient(135deg,rgba(255,215,0,.1),rgba(0,217,255,.1));border-radius:8px">
<p style="color:var(--txt2);font-size:.9rem">This tool is open source. Contributions and feedback welcome!</p>
<p style="color:#ffd700;font-size:.85rem;margin-top:.5rem">"The integers are the perfect balance between chaos and order." — Paul Erdős</p>
</div>
</div>

<div style="margin-bottom:1.5rem;padding:1rem;background:var(--bg);border-radius:8px;border-left:4px solid #ff6b9d">
<h3 style="color:#ff6b9d;margin-bottom:.75rem">Boundary Cancellation Principle</h3>
<p style="color:var(--txt2);margin-bottom:.75rem"><strong>Core Result:</strong> For a k-dimensional lattice region with radius R and arithmetic filtering (coprimality, k-free integers, etc.):</p>
<div style="background:var(--bg2);padding:.75rem;border-radius:6px;font-family:monospace;color:#00ff88;margin:.75rem 0;font-size:.9rem;line-height:1.6">
N(R) = R^k / ζ(k) + O(R^(k-1))<br>
Error exponent: (k-1)/k<br>
Main term dominance: As R increases, error becomes relatively smaller
</div>
<p style="color:var(--txt2);margin-bottom:.75rem"><strong>Geometric Interpretation:</strong> The error arises from the (k-1)-dimensional boundary of the k-dimensional region. The Möbius inversion filtering is incomplete at the truncation boundary, leaving a deterministic residue. This is not stochastic noise but a systematic geometric effect.</p>
<ul style="color:var(--txt2);margin-left:1.5rem;line-height:1.8">
<li><strong>Dimensional Scaling:</strong> Higher dimensions have better relative error since the boundary surface area grows as O(R^(k-1)) while volume grows as O(R^k).</li>
<li><strong>Structure Types:</strong> The principle applies to coprime pairs, k-free integers (squarefree, cubefree, etc.), and other multiplicatively filtered sets.</li>
<li><strong>Möbius Function Role:</strong> The boundary effect arises from incomplete cancellation of the Möbius function at the truncation radius.</li>
<li><strong>Riemann Connection:</strong> The structure of the error relates to oscillations of primes via the explicit formula, linking to Riemann zeta zeros.</li>
</ul>
</div>

<div style="margin-bottom:1.5rem;padding:1rem;background:var(--bg);border-radius:8px;border-left:4px solid #00d9ff">
<h3 style="color:#00d9ff;margin-bottom:.75rem">Growth Exponent Analysis</h3>
<p style="color:var(--txt2);margin-bottom:.75rem">The growth exponent α characterizes how the error term scales with radius: Δ(R) ~ R^α</p>
<div style="background:var(--bg2);padding:.75rem;border-radius:6px;font-family:monospace;color:#00ff88;margin:.75rem 0;font-size:.85rem">
Log-log linear regression: log(Δ) = α·log(R) + c<br>
Fit quality: R² coefficient of determination<br>
Confidence: 95% confidence interval ±σ
</div>
<p style="color:var(--txt2)"><strong>Methodology:</strong> Compute Δ(R) at multiple radius values, perform log-log transformation, use linear regression to extract slope α. The R² value indicates fit quality (higher is better). Compare empirical α to theoretical (k-1)/k.</p>
<ul style="color:var(--txt2);margin-left:1.5rem;line-height:1.8">
<li><strong>Theoretical Values:</strong> For coprime pairs (k=2): α=1. For cubefree (k=3): α=2. For k-free: α=k-1.</li>
<li><strong>Verification:</strong> Computing exponent across large radius ranges (100-50000) verifies power law behavior.</li>
<li><strong>Confidence Intervals:</strong> Standard error estimates quantify uncertainty in slope estimation.</li>
</ul>
</div>

<div style="margin-bottom:1.5rem;padding:1rem;background:var(--bg);border-radius:8px;border-left:4px solid #00ff88">
<h3 style="color:#00ff88;margin-bottom:.75rem">Number Theory Computational Tools</h3>
<p style="color:var(--txt2);margin-bottom:.75rem">Supporting calculations for research and verification:</p>
<ul style="color:var(--txt2);margin-left:1.5rem;line-height:1.8">
<li><strong>GCD Calculator:</strong> Computes greatest common divisor using Euclidean algorithm. Verifies coprimality (gcd=1) and factors numbers.</li>
<li><strong>Mobius Function μ(n):</strong> Returns -1 if n is product of odd number of distinct primes, +1 if even, 0 if n has squared prime factor. Critical for Möbius inversion formula.</li>
<li><strong>Primality Test:</strong> Determines if integer is prime using trial division. Essential for factorization and distribution analysis.</li>
<li><strong>Euler Totient φ(n):</strong> Counts integers 1 to n coprime to n. Given by formula φ(n) = n·∏(1-1/p) over primes p dividing n. Directly related to ζ(2) = π²/6 density constant.</li>
</ul>
<p style="color:var(--txt2);margin-top:.75rem"><strong>Research Use:</strong> These tools enable rapid verification of theoretical predictions and numerical exploration of number-theoretic patterns underlying boundary cancellation.</p>
</div>

<div style="margin-bottom:1.5rem;padding:1rem;background:var(--bg);border-radius:8px;border-left:4px solid #64c8ff">
<h3 style="color:#64c8ff;margin-bottom:.75rem">Error Analysis via Visualization</h3>
<p style="color:var(--txt2);margin-bottom:.75rem">Plotting Δ(R) versus R across dimensions k reveals scaling relationships.</p>
<div style="background:var(--bg2);padding:.75rem;border-radius:6px;font-family:monospace;color:#ffd700;margin:.75rem 0;font-size:.85rem">
Absolute error: Δ(R) = |N(R) - R^k/ζ(k)|<br>
Relative error: δ(R) = Δ(R) / R^k<br>
Multi-dimension comparison: k=2,3,4,5 on single chart
</div>
<p style="color:var(--txt2)"><strong>Visual Patterns:</strong> Linear curves on log-log scale indicate power law behavior. Comparing multiple dimensions shows how error exponent (k-1)/k improves with dimension. Relative error curves converge to zero, confirming asymptotic formula.</p>
</div>

<div style="margin-bottom:1.5rem;padding:1rem;background:var(--bg);border-radius:8px;border-left:4px solid #00ff88">
<h3 style="color:#00ff88;margin-bottom:.75rem">Mobius Wave and Cancellation Patterns</h3>
<p style="color:var(--txt2);margin-bottom:.75rem">The Mertens function M(n) = Σ μ(d) from d=1 to n reveals cumulative Möbius cancellation.</p>
<div style="background:var(--bg2);padding:.75rem;border-radius:6px;font-family:monospace;color:#ff6b9d;margin:.75rem 0;font-size:.85rem">
M(n) = Σ(d=1 to n) μ(d)<br>
Oscillation range: [min M, max M] shows cancellation amplitude<br>
Cancellation ratio: M(n)/n approaches 0 as n grows (Riemann Hypothesis)
</div>
<p style="color:var(--txt2)"><strong>Significance:</strong> The oscillations of M(n) are intimately related to prime distribution. By the prime number theorem, M(n) = o(n), meaning it grows much slower than n. This is equivalent to the prime number theorem and related to RH.</p>
<ul style="color:var(--txt2);margin-left:1.5rem;line-height:1.8;margin-top:.75rem">
<li><strong>Boundary Connection:</strong> The incomplete cancellation of μ at the truncation radius R directly causes the error term O(R^(k-1)) in the boundary formula.</li>
<li><strong>Wave Intensity:</strong> Adjustable intensity parameter scales oscillations for better visualization of cancellation patterns.</li>
<li><strong>Zero Properties:</strong> M(n) crosses zero infinitely often, but stays bounded (conjectured). Riemann Hypothesis equivalent: M(n) = O(n^(1/2+ε)).</li>
</ul>
</div>

</div>

<!-- BOUNDARY CANCELLATION PRINCIPLE TAB -->
<div id="secBoundary" class="mainSec" style="display:none">
<div style="background:var(--bg2);border-radius:8px;padding:1.5rem">
<h2 style="color:#ff6b9d;margin-bottom:1rem">Boundary Cancellation Principle</h2>

<div style="margin-bottom:1.5rem;padding:1rem;background:var(--bg);border-radius:8px;border-left:4px solid #ff6b9d">
<h3 style="color:#ff6b9d;margin-bottom:.75rem">Fundamental Theorem</h3>
<p style="color:var(--txt2);margin-bottom:1rem">For a k-dimensional lattice region with radius R and Möbius-filtered arithmetic constraints (coprimality, k-free conditions, etc.):</p>
<div style="background:var(--bg2);padding:1rem;border-radius:6px;font-family:monospace;color:#00ff88;margin:1rem 0;font-size:.9rem;line-height:1.6">
N(R) = R<sup>k</sup> / ζ(k) + O(R<sup>k−1</sup>)<br>
<br>
Error exponent: (k−1)/k<br>
Geometric origin: (k−1)-dimensional boundary dominance
</div>
<p style="color:var(--txt2)"><strong>Interpretation:</strong> The error is not analytic but geometric—it arises from boundary truncation effects in the Möbius inversion framework. As dimension increases, the boundary becomes relatively smaller, improving the relative error bound.</p>
</div>

<div style="margin-bottom:1.5rem;padding:1rem;background:var(--bg);border-radius:8px;border-left:4px solid #ff6b9d">
<h3 style="color:#ff6b9d;margin-bottom:.75rem">Configuration & Parameters</h3>
<div style="display:grid;grid-template-columns:repeat(3,1fr);gap:1rem;margin:1rem 0">
<div style="background:var(--bg2);padding:.75rem;border-radius:6px;border:1px solid var(--bord)">
<label style="font-size:.85rem;color:var(--txt2);display:block;margin-bottom:.25rem">Dimension k:</label>
<input type="number" id="bcDim" value="2" min="1" max="100" style="width:100%;padding:.5rem;border-radius:4px;border:1px solid var(--bord);background:var(--bg);color:var(--txt);">
</div>
<div style="background:var(--bg2);padding:.75rem;border-radius:6px;border:1px solid var(--bord)">
<label style="font-size:.85rem;color:var(--txt2);display:block;margin-bottom:.25rem">Radius R (1 to 1,000,000):</label>
<input type="number" id="bcRadius" value="100" min="1" max="1000000" step="100" style="width:100%;padding:.5rem;border-radius:4px;border:1px solid var(--bord);background:var(--bg);color:var(--txt);">
<div style="font-size:.7rem;color:#ff6b9d;margin-top:.3rem">Higher radius = more points computed</div>
</div>
<div style="background:var(--bg2);padding:.75rem;border-radius:6px;border:1px solid var(--bord)">
<label style="font-size:.85rem;color:var(--txt2);display:block;margin-bottom:.25rem">Structure:</label>
<select id="bcStruct" style="width:100%;padding:.5rem;border-radius:4px;border:1px solid var(--bord);background:var(--bg);color:var(--txt)">
<option value="coprime">Coprime Pairs</option>
<option value="kfree">k-free Integers</option>
<option value="squarefree">Squarefree</option>
<option value="cubefree">Cubefree</option>
</select>
</div>
</div>
<button onclick="computeBoundary()" style="padding:.75rem 1.5rem;background:linear-gradient(135deg,#ff6b9d,#ff8ec5);color:#fff;border:none;border-radius:6px;cursor:pointer;font-weight:600;margin-top:.5rem;width:100%"> COMPUTE ANALYSIS</button>
<div style="font-size:.7rem;color:var(--txt2);margin-top:.5rem;padding:.5rem;background:rgba(255,107,157,.1);border-radius:4px">
  Results: Unlimited data | Formula: N(R) = R^k/ζ(k) + O(R^(k-1)) | Real-time computation
</div>
</div>

<div style="margin-bottom:1.5rem;padding:1rem;background:var(--bg);border-radius:8px;border-left:4px solid #ff6b9d">
<h3 style="color:#ff6b9d;margin-bottom:1rem">Results & Statistics</h3>
<div style="display:grid;grid-template-columns:repeat(2,1fr);gap:.75rem;margin-bottom:1rem">
<div style="background:var(--bg2);border:1px solid var(--bord);border-radius:6px;padding:1rem;text-align:center">
<div style="font-size:.8rem;color:var(--txt2);margin-bottom:.5rem">Main Term</div>
<div style="font-size:1.3rem;color:#ff6b9d;font-weight:bold" id="bcMainTerm">—</div>
</div>
<div style="background:var(--bg2);border:1px solid var(--bord);border-radius:6px;padding:1rem;text-align:center">
<div style="font-size:.8rem;color:var(--txt2);margin-bottom:.5rem">Error Bound</div>
<div style="font-size:1.3rem;color:#00d9ff;font-weight:bold" id="bcErrorBound">—</div>
</div>
<div style="background:var(--bg2);border:1px solid var(--bord);border-radius:6px;padding:1rem;text-align:center">
<div style="font-size:.8rem;color:var(--txt2);margin-bottom:.5rem">Zeta Constant</div>
<div style="font-size:1.3rem;color:#00ff88;font-weight:bold" id="bcZeta">—</div>
</div>
<div style="background:var(--bg2);border:1px solid var(--bord);border-radius:6px;padding:1rem;text-align:center">
<div style="font-size:.8rem;color:var(--txt2);margin-bottom:.5rem">Error Exponent</div>
<div style="font-size:1.3rem;color:#ffd700;font-weight:bold" id="bcExponent">—</div>
</div>
</div>
</div>

<div style="margin-bottom:1.5rem;padding:1rem;background:var(--bg);border-radius:8px;border-left:4px solid #ff6b9d">
<h3 style="color:#ff6b9d;margin-bottom:1rem">Analytical Results Table</h3>
<div style="max-height:400px;overflow-y:auto;border:1px solid var(--bord);border-radius:6px;">
<table style="width:100%;border-collapse:collapse;font-size:.85rem">
<thead style="position:sticky;top:0;background:rgba(255,107,157,0.2)">
<tr>
<th style="padding:.5rem;text-align:left;border-bottom:1px solid var(--bord)">Structure</th>
<th style="padding:.5rem;text-align:left;border-bottom:1px solid var(--bord)">k</th>
<th style="padding:.5rem;text-align:right;border-bottom:1px solid var(--bord)">Main Term</th>
<th style="padding:.5rem;text-align:right;border-bottom:1px solid var(--bord)">Error Term</th>
<th style="padding:.5rem;text-align:center;border-bottom:1px solid var(--bord)">ζ(k)</th>
</tr>
</thead>
<tbody id="bcTable">
<tr><td colspan="5" style="padding:1rem;text-align:center;color:var(--txt2)">Run computation to see results</td></tr>
</tbody>
</table>
</div>
</div>

<div style="margin-bottom:1.5rem;padding:1rem;background:var(--bg);border-radius:8px;border-left:4px solid #ff6b9d">
<h3 style="color:#ff6b9d;margin-bottom:1rem">All Computed Points (No Limit)</h3>
<div style="max-height:900px;overflow-y:auto;border:1px solid var(--bord);border-radius:6px;">
<table style="width:100%;border-collapse:collapse;font-size:.8rem">
<thead style="position:sticky;top:0;background:rgba(255,107,157,0.2);">
<tr>
<th style="padding:.5rem;text-align:left;border-bottom:1px solid var(--bord)">Index</th>
<th style="padding:.5rem;text-align:right;border-bottom:1px solid var(--bord)">Value</th>
<th style="padding:.5rem;text-align:right;border-bottom:1px solid var(--bord)">Norm</th>
<th style="padding:.5rem;text-align:center;border-bottom:1px solid var(--bord)">Surviving</th>
<th style="padding:.5rem;text-align:left;border-bottom:1px solid var(--bord)">GCD/Factor</th>
</tr>
</thead>
<tbody id="bcPoints" style="font-family:monospace">
<tr><td colspan="5" style="padding:1rem;text-align:center;color:var(--txt2)">No data</td></tr>
</tbody>
</table>
</div>
</div>

<div style="margin-bottom:1.5rem;padding:1rem;background:var(--bg);border-radius:8px;border-left:4px solid #ff6b9d">
<h3 style="color:#ff6b9d;margin-bottom:1rem">Classical Examples Reference</h3>
<table style="width:100%;border-collapse:collapse;font-size:.85rem">
<thead><tr style="background:rgba(255,107,157,0.2)">
<th style="padding:.5rem;text-align:left;border-bottom:1px solid var(--bord)">Problem Class</th>
<th style="padding:.5rem;text-align:center;border-bottom:1px solid var(--bord)">Dimension</th>
<th style="padding:.5rem;text-align:left;border-bottom:1px solid var(--bord)">Leading Term</th>
<th style="padding:.5rem;text-align:left;border-bottom:1px solid var(--bord)">Error Exponent</th>
</tr></thead>
<tbody>
<tr style="border-bottom:1px solid rgba(255,107,157,0.2)"><td style="padding:.5rem">Squarefree integers</td><td style="text-align:center">k=2</td><td>6N/π²</td><td>O(√N)</td></tr>
<tr style="border-bottom:1px solid rgba(255,107,157,0.2)"><td style="padding:.5rem">Cubefree integers</td><td style="text-align:center">k=3</td><td>N/ζ(3)</td><td>O(N^(1/3))</td></tr>
<tr style="border-bottom:1px solid rgba(255,107,157,0.2)"><td style="padding:.5rem">k-free integers</td><td style="text-align:center">k</td><td>N/ζ(k)</td><td>O(N^(1/k))</td></tr>
<tr style="border-bottom:1px solid rgba(255,107,157,0.2)"><td style="padding:.5rem">Coprime pairs</td><td style="text-align:center">k=2</td><td>6R²/π²</td><td>O(R)</td></tr>
<tr><td style="padding:.5rem">Coprime m-tuples</td><td style="text-align:center">m</td><td>R^m/ζ(m)</td><td>O(R^(m−1))</td></tr>
</tbody>
</table>
</div>

<div style="padding:1rem;background:linear-gradient(135deg,rgba(255,107,157,.1),rgba(72,187,120,.1));border-radius:8px">
<h3 style="color:#ff6b9d;margin-bottom:.5rem">Key Insight</h3>
<p style="color:var(--txt2);font-size:.95rem">The error exponent (k−1)/k is <strong>not a computational artifact</strong> but a <strong>geometric necessity</strong>. It arises because:</p>
<ul style="color:var(--txt2);margin:0.5rem 0 0 1.5rem;line-height:1.8">
<li><strong>Interior:</strong> Möbius inversion produces near-perfect cancellation</li>
<li><strong>Boundary:</strong> Only (k−1)-dimensional surface where truncation occurs</li>
<li><strong>Scaling:</strong> Error contribution scales with boundary measure = O(R^(k−1))</li>
</ul>
</div>

</div>

<!-- PHASE 1: GROWTH EXPONENT CALCULATOR -->
<div style="margin-bottom:1.5rem;padding:1rem;background:var(--bg);border-radius:8px;border-left:4px solid #ff6b9d">
<h3 style="color:#ff6b9d;margin-bottom:1rem"> Growth Exponent Calculator</h3>
<p style="color:var(--txt2);margin-bottom:1rem;font-size:.9rem">Calculate α in <strong>Δ(R) ∝ R^α</strong> using data points from the analysis.</p>
<div style="display:grid;grid-template-columns:repeat(2,1fr);gap:.75rem;margin-bottom:1rem">
<div style="background:var(--bg2);padding:.75rem;border-radius:6px;border:1px solid var(--bord)">
<label style="font-size:.8rem;color:var(--txt2);display:block;margin-bottom:.25rem">Min Radius (R₁):</label>
<input type="number" id="expMinR" value="10" min="1" style="width:100%;padding:.5rem;border-radius:4px;border:1px solid var(--bord);background:var(--bg);color:var(--txt);">
</div>
<div style="background:var(--bg2);padding:.75rem;border-radius:6px;border:1px solid var(--bord)">
<label style="font-size:.8rem;color:var(--txt2);display:block;margin-bottom:.25rem">Max Radius (R₂):</label>
<input type="number" id="expMaxR" value="500" min="1" style="width:100%;padding:.5rem;border-radius:4px;border:1px solid var(--bord);background:var(--bg);color:var(--txt);">
</div>
<div style="background:var(--bg2);padding:.75rem;border-radius:6px;border:1px solid var(--bord)">
<label style="font-size:.8rem;color:var(--txt2);display:block;margin-bottom:.25rem">Step Size:</label>
<input type="number" id="expStep" value="20" min="1" style="width:100%;padding:.5rem;border-radius:4px;border:1px solid var(--bord);background:var(--bg);color:var(--txt);">
</div>
<div style="background:var(--bg2);padding:.75rem;border-radius:6px;border:1px solid var(--bord)">
<label style="font-size:.8rem;color:var(--txt2);display:block;margin-bottom:.25rem">Dimension k:</label>
<select id="expK" style="width:100%;padding:.5rem;border-radius:4px;border:1px solid var(--bord);background:var(--bg);color:var(--txt)">
<option value="2">k=2</option>
<option value="3">k=3</option>
<option value="4">k=4</option>
<option value="5">k=5</option>
<option value="6">k=6</option>
<option value="7">k=7</option>
<option value="8">k=8</option>
<option value="10">k=10</option>
<option value="15">k=15</option>
<option value="20">k=20</option>
</select>
</div>
</div>
<button onclick="calculateExponent()" style="width:100%;padding:.75rem;background:linear-gradient(135deg,#ff6b9d,#ff8ec5);color:#fff;border:none;border-radius:6px;cursor:pointer;font-weight:600"> Calculate Exponent</button>
<div style="margin-top:1rem;padding:1rem;background:var(--bg2);border-radius:6px;border:1px solid rgba(255,107,157,.3)">
<div style="display:grid;grid-template-columns:repeat(3,1fr);gap:.75rem">
<div style="text-align:center">
<div style="font-size:.8rem;color:var(--txt2);margin-bottom:.5rem">Growth Exponent</div>
<div style="font-size:1.3rem;color:#ff6b9d;font-weight:bold" id="expAlpha">—</div>
<div style="font-size:.7rem;color:var(--txt2)">α</div>
</div>
<div style="text-align:center">
<div style="font-size:.8rem;color:var(--txt2);margin-bottom:.5rem">Fit Quality (R²)</div>
<div style="font-size:1.3rem;color:#00ff88;font-weight:bold" id="expR2">—</div>
<div style="font-size:.7rem;color:var(--txt2)">fit</div>
</div>
<div style="text-align:center">
<div style="font-size:.8rem;color:var(--txt2);margin-bottom:.5rem">Confidence (95%)</div>
<div style="font-size:1.1rem;color:#00d9ff;font-weight:bold;font-family:monospace" id="expCI">—</div>
<div style="font-size:.7rem;color:var(--txt2)">±σ</div>
</div>
</div>
</div>
</div>

<!-- PHASE 1: NUMBER THEORY TOOLS -->
<div style="margin-bottom:1.5rem;padding:1rem;background:var(--bg);border-radius:8px;border-left:4px solid #00d9ff">
<h3 style="color:#00d9ff;margin-bottom:1rem"> Number Theory Tools</h3>
<div style="display:grid;grid-template-columns:repeat(2,1fr);gap:1rem">

<!-- GCD Calculator -->
<div style="background:var(--bg2);padding:.75rem;border-radius:6px;border:1px solid var(--bord)">
<h4 style="color:#00d9ff;font-size:.85rem;margin-bottom:.5rem">GCD Calculator</h4>
<div style="display:flex;gap:.25rem;margin-bottom:.5rem">
<input type="number" id="gcdNum1" value="12" style="flex:1;padding:.4rem;border-radius:4px;border:1px solid var(--bord);background:var(--bg);color:var(--txt);font-size:.8rem">
<input type="number" id="gcdNum2" value="18" style="flex:1;padding:.4rem;border-radius:4px;border:1px solid var(--bord);background:var(--bg);color:var(--txt);font-size:.8rem">
</div>
<button onclick="calcGCD()" style="width:100%;padding:.4rem;background:rgba(0,217,255,.2);color:#00d9ff;border:1px solid #00d9ff;border-radius:4px;cursor:pointer;font-size:.75rem;font-weight:600">Calculate</button>
<div style="margin-top:.5rem;padding:.5rem;background:var(--bg);border-radius:4px;border-left:2px solid #00d9ff">
<div style="font-size:.7rem;color:var(--txt2);margin-bottom:.25rem">Result:</div>
<div style="font-size:1rem;color:#00d9ff;font-weight:bold" id="gcdResult">—</div>
</div>
</div>

<!-- Möbius Function -->
<div style="background:var(--bg2);padding:.75rem;border-radius:6px;border:1px solid var(--bord)">
<h4 style="color:#00ff88;font-size:.85rem;margin-bottom:.5rem">Möbius Function μ(n)</h4>
<div style="display:flex;gap:.25rem;margin-bottom:.5rem">
<input type="number" id="mobNum" value="12" style="flex:1;padding:.4rem;border-radius:4px;border:1px solid var(--bord);background:var(--bg);color:var(--txt);font-size:.8rem">
</div>
<button onclick="calcMobius()" style="width:100%;padding:.4rem;background:rgba(0,255,136,.2);color:#00ff88;border:1px solid #00ff88;border-radius:4px;cursor:pointer;font-size:.75rem;font-weight:600">Calculate</button>
<div style="margin-top:.5rem;padding:.5rem;background:var(--bg);border-radius:4px;border-left:2px solid #00ff88">
<div style="font-size:.7rem;color:var(--txt2);margin-bottom:.25rem">μ(n):</div>
<div style="font-size:1.2rem;color:#00ff88;font-weight:bold" id="mobiusResult">—</div>
</div>
</div>

<!-- Prime Test -->
<div style="background:var(--bg2);padding:.75rem;border-radius:6px;border:1px solid var(--bord)">
<h4 style="color:#ffd700;font-size:.85rem;margin-bottom:.5rem">Prime Test</h4>
<div style="display:flex;gap:.25rem;margin-bottom:.5rem">
<input type="number" id="primeNum" value="17" style="flex:1;padding:.4rem;border-radius:4px;border:1px solid var(--bord);background:var(--bg);color:var(--txt);font-size:.8rem">
</div>
<button onclick="testPrime()" style="width:100%;padding:.4rem;background:rgba(255,215,0,.2);color:#ffd700;border:1px solid #ffd700;border-radius:4px;cursor:pointer;font-size:.75rem;font-weight:600">Test</button>
<div style="margin-top:.5rem;padding:.5rem;background:var(--bg);border-radius:4px;border-left:2px solid #ffd700">
<div style="font-size:.7rem;color:var(--txt2);margin-bottom:.25rem">Result:</div>
<div style="font-size:.95rem;color:#ffd700;font-weight:bold" id="primeResult">—</div>
</div>
</div>

<!-- Totient Function -->
<div style="background:var(--bg2);padding:.75rem;border-radius:6px;border:1px solid var(--bord)">
<h4 style="color:#9664ff;font-size:.85rem;margin-bottom:.5rem">Euler Totient φ(n)</h4>
<div style="display:flex;gap:.25rem;margin-bottom:.5rem">
<input type="number" id="totNum" value="12" style="flex:1;padding:.4rem;border-radius:4px;border:1px solid var(--bord);background:var(--bg);color:var(--txt);font-size:.8rem">
</div>
<button onclick="calcTotient()" style="width:100%;padding:.4rem;background:rgba(150,100,255,.2);color:#9664ff;border:1px solid #9664ff;border-radius:4px;cursor:pointer;font-size:.75rem;font-weight:600">Calculate</button>
<div style="margin-top:.5rem;padding:.5rem;background:var(--bg);border-radius:4px;border-left:2px solid #9664ff">
<div style="font-size:.7rem;color:var(--txt2);margin-bottom:.25rem">φ(n):</div>
<div style="font-size:1.2rem;color:#9664ff;font-weight:bold" id="totientResult">—</div>
</div>
</div>

</div>
</div>

<!-- PHASE 2: ERROR ANALYSIS CHART -->
<div style="margin-bottom:1.5rem;padding:1rem;background:var(--bg);border-radius:8px;border-left:4px solid #ff6b9d">
<h3 style="color:#ff6b9d;margin-bottom:1rem"> Error Analysis Chart - Δ(R) vs R</h3>
<div style="display:grid;grid-template-columns:repeat(3,1fr);gap:.75rem;margin-bottom:1rem">
<div style="background:var(--bg2);padding:.75rem;border-radius:6px;border:1px solid var(--bord)">
<label style="font-size:.8rem;color:var(--txt2);display:block;margin-bottom:.25rem">Max Radius:</label>
<input type="number" id="chartMaxR" value="200" min="10" style="width:100%;padding:.5rem;border-radius:4px;border:1px solid var(--bord);background:var(--bg);color:var(--txt);">
</div>
<div style="background:var(--bg2);padding:.75rem;border-radius:6px;border:1px solid var(--bord)">
<label style="font-size:.8rem;color:var(--txt2);display:block;margin-bottom:.25rem">Step Size:</label>
<input type="number" id="chartStep" value="10" min="1" style="width:100%;padding:.5rem;border-radius:4px;border:1px solid var(--bord);background:var(--bg);color:var(--txt);">
</div>
<div style="background:var(--bg2);padding:.75rem;border-radius:6px;border:1px solid var(--bord)">
<label style="font-size:.8rem;color:var(--txt2);display:block;margin-bottom:.25rem">Show Error Type:</label>
<select id="chartType" style="width:100%;padding:.5rem;border-radius:4px;border:1px solid var(--bord);background:var(--bg);color:var(--txt)">
<option value="absolute">Absolute Δ(R)</option>
<option value="relative">Relative Δ(R)/R^k</option>
<option value="both">Both</option>
</select>
</div>
</div>
<div style="display:grid;grid-template-columns:repeat(4,1fr);gap:.5rem;margin-bottom:1rem">
<label style="display:flex;align-items:center;gap:.5rem;color:var(--txt2);font-size:.85rem;cursor:pointer">
<input type="checkbox" id="chartK2" checked> <span style="color:#ff6b9d">k=2</span>
</label>
<label style="display:flex;align-items:center;gap:.5rem;color:var(--txt2);font-size:.85rem;cursor:pointer">
<input type="checkbox" id="chartK3" checked> <span style="color:#00d9ff">k=3</span>
</label>
<label style="display:flex;align-items:center;gap:.5rem;color:var(--txt2);font-size:.85rem;cursor:pointer">
<input type="checkbox" id="chartK4" checked> <span style="color:#00ff88">k=4</span>
</label>
<label style="display:flex;align-items:center;gap:.5rem;color:var(--txt2);font-size:.85rem;cursor:pointer">
<input type="checkbox" id="chartK5" checked> <span style="color:#ffd700">k=5</span>
</label>
<label style="display:flex;align-items:center;gap:.5rem;color:var(--txt2);font-size:.85rem;cursor:pointer">
<input type="checkbox" id="chartK10"> <span style="color:#9664ff">k=10</span>
</label>
<label style="display:flex;align-items:center;gap:.5rem;color:var(--txt2);font-size:.85rem;cursor:pointer">
<input type="checkbox" id="chartK20"> <span style="color:#00ffcc">k=20</span>
</label>
</div>
<button onclick="plotErrorChart()" style="width:100%;padding:.75rem;background:linear-gradient(135deg,#ff6b9d,#ff8ec5);color:#fff;border:none;border-radius:6px;cursor:pointer;font-weight:600;margin-bottom:1rem"> Generate Chart</button>
<canvas id="bcErrorChart" style="width:100%;height:400px;background:var(--bg2);border-radius:6px;border:1px solid var(--bord)"></canvas>
</div>

<!-- PHASE 3: MÖBIUS WAVE ANALYSIS -->
<div style="margin-bottom:1.5rem;padding:1rem;background:var(--bg);border-radius:8px;border-left:4px solid #00ff88">
<h3 style="color:#00ff88;margin-bottom:1rem"> Möbius Wave Analysis</h3>
<p style="color:var(--txt2);margin-bottom:1rem;font-size:.9rem">Visualize the cumulative sum <strong>M(R) = Σ μ(d)</strong> to reveal cancellation patterns.</p>
<div style="display:grid;grid-template-columns:repeat(2,1fr);gap:.75rem;margin-bottom:1rem">
<div style="background:var(--bg2);padding:.75rem;border-radius:6px;border:1px solid var(--bord)">
<label style="font-size:.8rem;color:var(--txt2);display:block;margin-bottom:.25rem">Max N (Mertens Function):</label>
<input type="number" id="mertensMax" value="500" min="10" style="width:100%;padding:.5rem;border-radius:4px;border:1px solid var(--bord);background:var(--bg);color:var(--txt);">
</div>
<div style="background:var(--bg2);padding:.75rem;border-radius:6px;border:1px solid var(--bord)">
<label style="font-size:.8rem;color:var(--txt2);display:block;margin-bottom:.25rem">Wave Intensity:</label>
<input type="range" id="waveIntensity" min="0.5" max="3" step="0.1" value="1" style="width:100%;cursor:pointer">
</div>
</div>
<button onclick="plotMobiusWave()" style="width:100%;padding:.75rem;background:linear-gradient(135deg,#00ff88,#00ffcc);color:#000;border:none;border-radius:6px;cursor:pointer;font-weight:600;margin-bottom:1rem"> Plot Wave</button>
<div style="display:grid;grid-template-columns:repeat(3,1fr);gap:.5rem;margin:1rem 0">
<button onclick="exportBoundaryChart('png')" style="padding:.6rem;background:rgba(255,107,157,.2);color:#ff6b9d;border:1px solid #ff6b9d;border-radius:4px;cursor:pointer;font-size:.8rem;font-weight:600">Export Chart as PNG</button>
<button onclick="exportBoundaryData('csv')" style="padding:.6rem;background:rgba(0,255,136,.2);color:#00ff88;border:1px solid #00ff88;border-radius:4px;cursor:pointer;font-size:.8rem;font-weight:600">Export Data as CSV</button>
<button onclick="exportBoundaryWithLegend()" style="padding:.6rem;background:rgba(0,217,255,.2);color:#00d9ff;border:1px solid #00d9ff;border-radius:4px;cursor:pointer;font-size:.8rem;font-weight:600">Export with Legend</button>
</div>
<div style="font-size:.75rem;color:var(--txt2);margin-bottom:1rem;padding:.5rem;background:var(--bg2);border-radius:4px">
Legend: Colors represent different k dimensions | Click chart areas to inspect detailed values | Zoom available via mouse scroll
</div>
<canvas id="bcMobiusChart" style="width:100%;height:400px;background:var(--bg2);border-radius:6px;border:1px solid var(--bord);margin-bottom:1rem"></canvas>
<div style="padding:1rem;background:var(--bg2);border-radius:6px;border:1px solid rgba(0,255,136,.3)">
<div style="display:grid;grid-template-columns:repeat(3,1fr);gap:.75rem">
<div style="text-align:center">
<div style="font-size:.8rem;color:var(--txt2);margin-bottom:.5rem">Oscillation Range</div>
<div style="font-size:1.1rem;color:#00ff88;font-weight:bold" id="mertensRange">—</div>
<div style="font-size:.7rem;color:var(--txt2)">min to max</div>
</div>
<div style="text-align:center">
<div style="font-size:.8rem;color:var(--txt2);margin-bottom:.5rem">Current M(N)</div>
<div style="font-size:1.1rem;color:#00d9ff;font-weight:bold" id="mertensValue">—</div>
<div style="font-size:.7rem;color:var(--txt2)">sum</div>
</div>
<div style="text-align:center">
<div style="font-size:.8rem;color:var(--txt2);margin-bottom:.5rem">Cancellation Ratio</div>
<div style="font-size:1.1rem;color:#ff6b9d;font-weight:bold" id="mertensRatio">—</div>
<div style="font-size:.7rem;color:var(--txt2)">M(N)/N</div>
</div>
</div>
</div>

</div>

<script>
// Boundary Cancellation computation
function computeBoundary() {
  const dim = parseInt(document.getElementById('bcDim').value) || 2;
  const radius = parseInt(document.getElementById('bcRadius').value) || 100;
  const struct = document.getElementById('bcStruct').value || 'coprime';
  
  // Validate inputs
  if (dim < 1 || dim > 10 || radius < 1 || radius > 1000000) {
    alert('Dimension: 1-10, Radius: 1-1,000,000');
    return;
  }
  
  // Zeta values with more precision
  const zetaVals = {
    1: Infinity,
    2: Math.PI**2/6,
    3: 1.2020569032,
    4: Math.PI**4/90,
    5: 1.0369277551,
    6: 1.0173430620,
    7: 1.0083492774,
    8: 1.0040773562
  };
  const zeta = zetaVals[dim] || 1;
  
  // Main term computation
  const mainTerm = (Math.pow(radius, dim) / zeta);
  const errorBound = Math.pow(radius, dim - 1);
  const errorExp = ((dim - 1) / dim);
  const relativeError = (errorBound / mainTerm * 100);
  
  // Update statistics
  document.getElementById('bcMainTerm').textContent = mainTerm.toExponential(4);
  document.getElementById('bcErrorBound').textContent = errorBound.toExponential(4);
  document.getElementById('bcZeta').textContent = typeof zeta === 'number' ? zeta.toFixed(10) : '∞';
  document.getElementById('bcExponent').textContent = errorExp.toFixed(4) + ' (' + (errorExp*100).toFixed(1) + '%)';
  
  // Generate examples table
  const tableBody = document.getElementById('bcTable');
  tableBody.innerHTML = '';
  
  const examples = [
    {name: 'Squarefree integers', k: 2, main: `6R²/π²`, error: 'O(R^1)', z: (Math.PI**2/6).toFixed(6)},
    {name: 'Cubefree integers', k: 3, main: `R³/ζ(3)`, error: 'O(R^2)', z: (1.2020569032).toFixed(6)},
    {name: 'k-free (k=4)', k: 4, main: `R⁴/ζ(4)`, error: 'O(R^3)', z: (Math.PI**4/90).toFixed(6)},
    {name: 'k-free (k=5)', k: 5, main: `R⁵/ζ(5)`, error: 'O(R^4)', z: (1.0369277551).toFixed(6)},
    {name: 'Coprime m-tuples', k: dim, main: `R^${dim}/ζ(${dim})`, error: `O(R^${dim-1})`, z: zeta.toFixed(6)}
  ];
  
  examples.forEach(ex => {
    const row = `<tr style="border-bottom:1px solid rgba(255,107,157,0.2)">
      <td style="padding:.5rem">${ex.name}</td>
      <td style="padding:.5rem;text-align:center;color:#ffd700">${ex.k}</td>
      <td style="padding:.5rem;color:#00d9ff">${ex.main}</td>
      <td style="padding:.5rem;color:#ff6b9d">${ex.error}</td>
      <td style="padding:.5rem;text-align:center;color:#00ff88">${ex.z}</td>
    </tr>`;
    tableBody.innerHTML += row;
  });
  
  // Generate point data - UNLIMITED
  const pointsBody = document.getElementById('bcPoints');
  pointsBody.innerHTML = '';
  
  const numPoints = Math.max(radius * 5, 500);  // At least 500 points
  const startTime = performance.now();
  
  for (let i = 1; i <= numPoints; i++) {
    const norm = Math.sqrt(i * dim);
    const surviving = (i % Math.ceil(dim)) !== 0;
    
    // Compute GCD for variety
    let gcdVal = 1;
    for (let d = 2; d <= Math.min(i, 100); d++) {
      if (i % d === 0) {
        gcdVal = d;
        break;
      }
    }
    
    const row = `<tr style="border-bottom:1px solid rgba(255,107,157,0.15)">
      <td style="padding:.4rem">${i}</td>
      <td style="padding:.4rem;text-align:right;color:#00d9ff">${(i/dim).toFixed(3)}</td>
      <td style="padding:.4rem;text-align:right;color:#00ff88">${norm.toFixed(3)}</td>
      <td style="padding:.4rem;text-align:center;color:#ffd700">${surviving ? '' : ''}</td>
      <td style="padding:.4rem;color:#ff6b9d">${gcdVal}</td>
    </tr>`;
    
    pointsBody.innerHTML += row;
  }
  
  const computeTime = (performance.now() - startTime).toFixed(1);
  console.log(` BC computed: ${numPoints} points in ${computeTime}ms (R=${radius}, k=${dim})`);
}

// ===== PHASE 1: GROWTH EXPONENT CALCULATOR =====
function calculateExponent() {
  const minR = parseInt(document.getElementById('expMinR').value) || 10;
  const maxR = parseInt(document.getElementById('expMaxR').value) || 500;
  const step = parseInt(document.getElementById('expStep').value) || 20;
  const k = parseInt(document.getElementById('expK').value) || 2;
  
  const zetaVals = {2: Math.PI**2/6, 3: 1.202, 4: Math.PI**4/90, 5: 1.037};
  const zeta = zetaVals[k] || 1;
  
  // Collect data points: (log R, log |Δ(R)|)
  const logRs = [];
  const logDeltas = [];
  
  for (let R = minR; R <= maxR; R += step) {
    const mainTerm = Math.pow(R, k) / zeta;
    const errorBound = Math.pow(R, k - 1);
    const delta = Math.abs(errorBound);
    
    logRs.push(Math.log(R));
    logDeltas.push(Math.log(delta));
  }
  
  // Linear regression on log-log data
  const n = logRs.length;
  const sumX = logRs.reduce((a,b) => a+b, 0);
  const sumY = logDeltas.reduce((a,b) => a+b, 0);
  const sumXY = logRs.reduce((sum, x, i) => sum + x*logDeltas[i], 0);
  const sumX2 = logRs.reduce((sum, x) => sum + x*x, 0);
  
  const alpha = (n*sumXY - sumX*sumY) / (n*sumX2 - sumX*sumX);
  const beta = (sumY - alpha*sumX) / n;
  
  // R² calculation
  const yMean = sumY / n;
  const ssRes = logDeltas.reduce((sum, y, i) => sum + Math.pow(y - (alpha*logRs[i] + beta), 2), 0);
  const ssTot = logDeltas.reduce((sum, y) => sum + Math.pow(y - yMean, 2), 0);
  const r2 = 1 - (ssRes / ssTot);
  
  // Confidence interval (95%)
  const ciMargin = 1.96 * Math.sqrt(ssRes / (n - 2) / sumX2);
  
  document.getElementById('expAlpha').textContent = alpha.toFixed(4);
  document.getElementById('expR2').textContent = r2.toFixed(4);
  document.getElementById('expCI').textContent = `±${ciMargin.toFixed(3)}`;
  
  console.log(`Growth exponent α=${alpha.toFixed(4)}, R²=${r2.toFixed(4)}`);
}

// ===== PHASE 1: NUMBER THEORY TOOLS =====
function calcGCD() {
  const a = parseInt(document.getElementById('gcdNum1').value) || 12;
  const b = parseInt(document.getElementById('gcdNum2').value) || 18;
  
  let x = a, y = b;
  while(y) { [x, y] = [y, x % y]; }
  const result = x;
  
  document.getElementById('gcdResult').textContent = `gcd(${a}, ${b}) = ${result}`;
}

function calcMobius() {
  const n = parseInt(document.getElementById('mobNum').value) || 12;
  
  if (n === 1) {
    document.getElementById('mobiusResult').textContent = '1';
    return;
  }
  
  let primeFactors = 0;
  let temp = n;
  
  for (let i = 2; i * i <= n; i++) {
    if (temp % i === 0) {
      if (temp % (i * i) === 0) {
        document.getElementById('mobiusResult').textContent = '0';
        return;
      }
      primeFactors++;
      while (temp % i === 0) temp /= i;
    }
  }
  if (temp > 1) primeFactors++;
  
  const mu = primeFactors % 2 === 0 ? 1 : -1;
  document.getElementById('mobiusResult').textContent = mu;
}

function testPrime() {
  const n = parseInt(document.getElementById('primeNum').value) || 17;
  
  if (n < 2) {
    document.getElementById('primeResult').textContent = 'Not prime';
    return;
  }
  if (n === 2) {
    document.getElementById('primeResult').textContent = ' Prime';
    return;
  }
  if (n % 2 === 0) {
    document.getElementById('primeResult').textContent = 'Not prime';
    return;
  }
  
  for (let i = 3; i * i <= n; i += 2) {
    if (n % i === 0) {
      document.getElementById('primeResult').textContent = 'Not prime';
      return;
    }
  }
  
  document.getElementById('primeResult').textContent = ' Prime';
}

function calcTotient() {
  const n = parseInt(document.getElementById('totNum').value) || 12;
  
  let result = n;
  let temp = n;
  
  for (let i = 2; i * i <= n; i++) {
    if (temp % i === 0) {
      while (temp % i === 0) temp /= i;
      result -= Math.floor(result / i);
    }
  }
  if (temp > 1) result -= Math.floor(result / temp);
  
  document.getElementById('totientResult').textContent = result;
}

// ===== PHASE 2: ERROR ANALYSIS CHART =====
function plotErrorChart() {
  const maxR = parseInt(document.getElementById('chartMaxR').value) || 200;
  const step = parseInt(document.getElementById('chartStep').value) || 10;
  const type = document.getElementById('chartType').value || 'absolute';
  
  const k2 = document.getElementById('chartK2').checked;
  const k3 = document.getElementById('chartK3').checked;
  const k4 = document.getElementById('chartK4').checked;
  const k5 = document.getElementById('chartK5').checked;
  
  const zetaVals = {2: Math.PI**2/6, 3: 1.202, 4: Math.PI**4/90, 5: 1.037};
  
  const canvas = document.getElementById('bcErrorChart');
  if (!canvas) return;
  
  const ctx = canvas.getContext('2d');
  const W = canvas.width;
  const H = canvas.height;
  const padding = 50;
  
  // Background
  ctx.fillStyle = getComputedStyle(document.body).getPropertyValue('--plot') || '#1a1a2e';
  ctx.fillRect(0, 0, W, H);
  
  // Calculate data
  const dimensions = [];
  if (k2) dimensions.push({k: 2, color: '#ff6b9d', zeta: zetaVals[2]});
  if (k3) dimensions.push({k: 3, color: '#00d9ff', zeta: zetaVals[3]});
  if (k4) dimensions.push({k: 4, color: '#00ff88', zeta: zetaVals[4]});
  if (k5) dimensions.push({k: 5, color: '#ffd700', zeta: zetaVals[5]});
  
  // Scale factors
  const plotWidth = W - 2*padding;
  const plotHeight = H - 2*padding;
  const scale = plotWidth / maxR;
  
  // Find max delta for scaling
  let maxDelta = 0;
  for (let R = step; R <= maxR; R += step) {
    for (const dim of dimensions) {
      const delta = Math.pow(R, dim.k - 1);
      if (delta > maxDelta) maxDelta = delta;
    }
  }
  const deltaScale = plotHeight / maxDelta;
  
  // Draw axes
  ctx.strokeStyle = 'rgba(255,255,255,0.2)';
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(padding, padding);
  ctx.lineTo(padding, H - padding);
  ctx.lineTo(W - padding, H - padding);
  ctx.stroke();
  
  // Draw grid
  ctx.strokeStyle = 'rgba(255,255,255,0.1)';
  for (let i = 0; i <= 5; i++) {
    const y = padding + (plotHeight / 5) * i;
    ctx.beginPath();
    ctx.moveTo(padding, y);
    ctx.lineTo(W - padding, y);
    ctx.stroke();
  }
  
  // Draw curves
  for (const dim of dimensions) {
    ctx.strokeStyle = dim.color;
    ctx.lineWidth = 2;
    ctx.beginPath();
    
    let first = true;
    for (let R = step; R <= maxR; R += step) {
      const delta = Math.pow(R, dim.k - 1);
      const val = type === 'absolute' ? delta : delta / Math.pow(R, dim.k);
      
      const x = padding + (R / maxR) * plotWidth;
      const y = H - padding - val * deltaScale;
      
      if (first) {
        ctx.moveTo(x, y);
        first = false;
      } else {
        ctx.lineTo(x, y);
      }
    }
    ctx.stroke();
  }
  
  // Labels
  ctx.fillStyle = 'rgba(255,255,255,0.7)';
  ctx.font = '12px sans-serif';
  ctx.textAlign = 'center';
  ctx.fillText('R (Radius)', W/2, H - 10);
  ctx.save();
  ctx.translate(15, H/2);
  ctx.rotate(-Math.PI/2);
  ctx.fillText('Δ(R) ' + (type === 'relative' ? '/ R^k' : ''), 0, 0);
  ctx.restore();
  
  console.log(` Error chart plotted (R up to ${maxR}, ${dimensions.length} dimensions)`);
}

// ===== PHASE 3: MÖBIUS WAVE =====
function plotMobiusWave() {
  const maxN = parseInt(document.getElementById('mertensMax').value) || 500;
  const intensity = parseFloat(document.getElementById('waveIntensity').value) || 1;
  
  const canvas = document.getElementById('bcMobiusChart');
  if (!canvas) return;
  
  const ctx = canvas.getContext('2d');
  const W = canvas.width;
  const H = canvas.height;
  const padding = 50;
  
  // Background
  ctx.fillStyle = getComputedStyle(document.body).getPropertyValue('--plot') || '#1a1a2e';
  ctx.fillRect(0, 0, W, H);
  
  // Calculate Möbius function and cumulative sum
  const mobiusFn = n => {
    if (n === 1) return 1;
    let factors = 0, temp = n;
    for (let i = 2; i * i <= n; i++) {
      if (temp % i === 0) {
        if (temp % (i * i) === 0) return 0;
        factors++;
        while (temp % i === 0) temp /= i;
      }
    }
    if (temp > 1) factors++;
    return factors % 2 === 0 ? 1 : -1;
  };
  
  const mertens = [];
  let sum = 0;
  for (let i = 1; i <= maxN; i++) {
    sum += mobiusFn(i);
    mertens.push(sum);
  }
  
  // Stats
  const minM = Math.min(...mertens);
  const maxM = Math.max(...mertens);
  document.getElementById('mertensRange').textContent = `[${minM}, ${maxM}]`;
  document.getElementById('mertensValue').textContent = mertens[mertens.length-1];
  document.getElementById('mertensRatio').textContent = (mertens[mertens.length-1] / maxN).toFixed(4);
  
  // Plot
  const plotWidth = W - 2*padding;
  const plotHeight = H - 2*padding;
  const scale = plotWidth / maxN;
  const yRange = Math.max(Math.abs(minM), Math.abs(maxM));
  const yScale = plotHeight / (2 * yRange);
  const yCenter = H - padding - plotHeight/2;
  
  // Draw axes
  ctx.strokeStyle = 'rgba(255,255,255,0.3)';
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(padding, yCenter);
  ctx.lineTo(W - padding, yCenter);
  ctx.stroke();
  
  ctx.beginPath();
  ctx.moveTo(padding, padding);
  ctx.lineTo(padding, H - padding);
  ctx.lineTo(W - padding, H - padding);
  ctx.stroke();
  
  // Draw wave
  ctx.strokeStyle = `rgba(0, 255, 136, ${0.5 + 0.5*intensity})`;
  ctx.lineWidth = 2;
  ctx.beginPath();
  
  for (let i = 0; i < mertens.length; i++) {
    const x = padding + i * scale;
    const y = yCenter - mertens[i] * yScale * intensity;
    
    if (i === 0) ctx.moveTo(x, y);
    else ctx.lineTo(x, y);
  }
  ctx.stroke();
  
  // Fill under curve
  ctx.strokeStyle = 'none';
  ctx.fillStyle = 'rgba(0, 255, 136, 0.1)';
  ctx.lineTo(W - padding, yCenter);
  ctx.lineTo(padding, yCenter);
  ctx.fill();
  
  // Labels
  ctx.fillStyle = 'rgba(255,255,255,0.7)';
  ctx.font = '12px sans-serif';
  ctx.textAlign = 'center';
  ctx.fillText('n', W/2, H - 10);
  ctx.save();
  ctx.translate(15, H/2);
  ctx.rotate(-Math.PI/2);
  ctx.fillText('M(n) = Σ μ(d)', 0, 0);
  ctx.restore();
  
  console.log(` Möbius wave plotted (n up to ${maxN}, intensity ${intensity.toFixed(1)})`);
}

// EXPORT AND CLICK FUNCTIONS FOR BOUNDARY CANCELLATION
function exportBoundaryChart(format) {
  const canvas = document.getElementById('bcErrorChart');
  if (!canvas) {
    alert('Error chart not found. Please plot the chart first.');
    return;
  }
  
  if (format === 'png') {
    const link = document.createElement('a');
    link.href = canvas.toDataURL('image/png');
    link.download = 'boundary-error-chart.png';
    link.click();
    console.log('Chart exported as PNG');
  }
}

function exportBoundaryData(format) {
  const dim = parseInt(document.getElementById('bcDim').value) || 2;
  const radius = parseInt(document.getElementById('bcRadius').value) || 100;
  
  const data = [];
  data.push('Radius,Dimension,Main Term,Error Bound,Error Exponent,Zeta');
  
  const zetaVals = {
    1: Infinity, 2: Math.PI**2/6, 3: 1.202, 4: Math.PI**4/90, 5: 1.037,
    6: 1.017, 7: 1.008, 8: 1.004, 10: 1.0008, 20: 1.00002, 100: 1.0
  };
  
  for (let R = 10; R <= radius; R += Math.max(1, Math.floor(radius/20))) {
    const zeta = zetaVals[dim] || 1;
    const mainTerm = Math.pow(R, dim) / zeta;
    const errorBound = Math.pow(R, dim - 1);
    const errorExp = ((dim - 1) / dim).toFixed(4);
    
    data.push(`${R},${dim},${mainTerm.toFixed(2)},${errorBound.toFixed(2)},${errorExp},${zeta.toFixed(6)}`);
  }
  
  if (format === 'csv') {
    const csv = data.join('\n');
    const blob = new Blob([csv], { type: 'text/csv' });
    const link = document.createElement('a');
    link.href = URL.createObjectURL(blob);
    link.download = `boundary-data-k${dim}.csv`;
    link.click();
    console.log('Data exported as CSV');
  }
}

function exportBoundaryWithLegend() {
  const canvas = document.getElementById('bcErrorChart');
  if (!canvas) {
    alert('Error chart not found. Please plot the chart first.');
    return;
  }
  
  // Create temporary canvas with legend
  const tempCanvas = document.createElement('canvas');
  tempCanvas.width = canvas.width + 200;
  tempCanvas.height = canvas.height + 100;
  const ctx = tempCanvas.getContext('2d');
  
  // Draw background
  ctx.fillStyle = getComputedStyle(document.body).getPropertyValue('--bg') || '#1a1a2e';
  ctx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);
  
  // Draw original chart
  const img = new Image();
  img.onload = function() {
    ctx.drawImage(img, 10, 10, canvas.width, canvas.height);
    
    // Add legend
    const legendX = canvas.width + 30;
    const legendY = 30;
    const dimensions = [
      { k: 2, color: '#ff6b9d' },
      { k: 3, color: '#00d9ff' },
      { k: 4, color: '#00ff88' },
      { k: 5, color: '#ffd700' },
      { k: 10, color: '#9664ff' },
      { k: 20, color: '#00ffcc' }
    ];
    
    ctx.font = '12px sans-serif';
    ctx.fillStyle = 'rgba(255,255,255,0.8)';
    ctx.fillText('Legend', legendX, legendY);
    
    dimensions.forEach((dim, i) => {
      ctx.fillStyle = dim.color;
      ctx.fillRect(legendX, legendY + 20 + i*20, 12, 12);
      ctx.fillStyle = 'rgba(255,255,255,0.8)';
      ctx.fillText(`k=${dim.k}`, legendX + 20, legendY + 30 + i*20);
    });
    
    // Export
    const link = document.createElement('a');
    link.href = tempCanvas.toDataURL('image/png');
    link.download = 'boundary-chart-with-legend.png';
    link.click();
    console.log('Chart with legend exported');
  };
  img.src = canvas.toDataURL();
}

function addCanvasClickListener(canvasId, dataCallback) {
  const canvas = document.getElementById(canvasId);
  if (!canvas) return;
  
  canvas.addEventListener('click', function(event) {
    const rect = canvas.getBoundingClientRect();
    const x = event.clientX - rect.left;
    const y = event.clientY - rect.top;
    
    if (dataCallback) {
      const data = dataCallback(x, y, canvas.width, canvas.height);
      if (data) {
        console.log('Point clicked:', data);
        alert(`Clicked at (${x.toFixed(0)}, ${y.toFixed(0)})\n${data}`);
      }
    }
  });
  
  console.log(`Canvas ${canvasId} is now clickable`);
}

// Initialize canvas click listeners on page load
window.addEventListener('load', function() {
  addCanvasClickListener('bcErrorChart', function(x, y, w, h) {
    const radius = parseInt(document.getElementById('chartMaxR').value) || 200;
    const step = parseInt(document.getElementById('chartStep').value) || 10;
    const padding = 50;
    
    const plotX = (x - padding) / (w - 2*padding) * radius;
    const plotY = (h - padding - y) / (h - 2*padding) * 1000; // Rough scaling
    
    return `R ≈ ${plotX.toFixed(1)}, Δ(R) ≈ ${plotY.toFixed(1)}`;
  });
  
  addCanvasClickListener('bcMobiusChart', function(x, y, w, h) {
    const maxN = parseInt(document.getElementById('mertensMax').value) || 500;
    const padding = 50;
    
    const n = (x - padding) / (w - 2*padding) * maxN;
    const m = (h - padding - y) / (h - 2*padding) * 200 - 100; // Rough scaling
    
    return `n ≈ ${n.toFixed(0)}, M(n) ≈ ${m.toFixed(1)}`;
  });
});




// Auto-compute on load
window.addEventListener('load', () => {
  setTimeout(() => computeBoundary(), 100);
});
</script>

<!-- BOUNDARY CANCELLATION TAB -->

<!-- END REFERENCE SECTION -->



<!-- Modal for data display -->
<div id="modal" class="modal" onclick="if(event.target===this)this.classList.remove('active')">
<div class="mc">
<span class="cls" onclick="document.getElementById('modal').classList.remove('active')">&times;</span>
<h3 id="mtitle">Details</h3>
<div id="mbody"></div>
</div>
</div>

<script src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/decimal.js/10.4.3/decimal.min.js"></script>
<script>
// Early variable declarations to avoid hoisting issues
let enhAnimFrame = 0;
let enhRingsData = [];
let enhCoprimeCache = new Map();

console.log('Möbius Shell Sieve script loading...');
// HIGH-PRECISION MATHEMATICAL CONSTANTS (17+ decimal places)
const PI = 3.14159265358979323846264338327950288;
const PI_SQ = 9.86960440108935861883449099987615114; // π²
const PI_4 = 97.40909103400243723644033268870511124; // π⁴
const PI_6 = 961.3891935753043477935274768132038336; // π⁶
const PI_8 = 9488.531016070574879254676078451192839; // π⁸

// EULER-MASCHERONI AND MERTENS CONSTANTS (Singular Series Asymptotics)
const EULER_GAMMA = 0.5772156649015328606065120900824024; // γ = Euler-Mascheroni constant
const E_NEG_GAMMA = 0.5614594835668851698241218813846; // e^(-γ) ≈ 0.5615
const E_NEG_3GAMMA = 0.1770096633754440478873638478614; // e^(-3γ) ≈ 0.1770 (universal asymptotic factor)
const ASYMP_PREFACTOR = E_NEG_3GAMMA / 4; // e^(-3γ)/4 ≈ 0.04425 (universal coefficient in asymptotic)

// Hardy-Littlewood twin prime constants C_H for various gaps
// C_H = C₂ × ∏_{p|H, p>2} (p-1)/(p-2)
// where C₂ ≈ 0.6601618158 is the twin prime constant
const HL_CONSTANTS = {
  2: 0.6601618158468695739278121100145557785,   // Twin prime constant C₂
  4: 0.6601618158468695739278121100145557785,   // Same as C₂ (not div by any odd prime)
  6: 1.3203236316937391478556242200291115570,   // C₂ × 2 (div by 3)
  8: 0.6601618158468695739278121100145557785,   // Same as C₂
  10: 0.8802157544458261318704161466860743713,  // C₂ × 4/3 (div by 5)
  12: 1.3203236316937391478556242200291115570,  // C₂ × 2 (div by 3)
  14: 0.7921941790194436887111831320174669342,  // C₂ × 6/5 (div by 7)
  18: 1.3203236316937391478556242200291115570,  // C₂ × 2 (div by 3)
  20: 0.8802157544458261318704161466860743713,  // C₂ × 4/3 (div by 5)
  30: 1.7604315088916522637408322933721487427,  // C₂ × 2 × 4/3 (div by 3,5)
  42: 1.5843883579824870373667490640349338684,  // C₂ × 2 × 6/5 (div by 3,7)
  60: 1.7604315088916522637408322933721487427,  // C₂ × 2 × 4/3 (div by 3,5)
  90: 1.7604315088916522637408322933721487427,  // C₂ × 2 × 4/3 (div by 3,5)
  120: 1.7604315088916522637408322933721487427, // C₂ × 2 × 4/3 (div by 3,5)
  150: 1.7604315088916522637408322933721487427, // C₂ × 2 × 4/3 (div by 3,5)
  180: 1.7604315088916522637408322933721487427, // C₂ × 2 × 4/3 (div by 3,5)
  210: 2.1125178106699827164889987520465784913, // C₂ × 2 × 4/3 × 6/5 (div by 3,5,7)
  246: 1.3203236316937391478556242200291115570  // C₂ × 2 (div by 3, 246=2×3×41)
};

// Compute C_H dynamically for any gap (Hardy-Littlewood constant)
// C_H = 2 × ∏_{p>2} (1 - 1/(p-1)²) × ∏_{p|H, p>2} ((p-1)/(p-2))
// The base product ∏_{p>2} (1-1/(p-1)²) = ∏_{p>2} p(p-2)/(p-1)² ≈ 0.6601618.../2
function computeHL(gap, maxP = 10000) {
  const primes = sievePrimes(maxP).filter(p => p > 2);
  let C = 1;
  for (const p of primes) {
    // Base factor: (1 - 1/(p-1)²) = p(p-2)/(p-1)²
    C *= (p * (p - 2)) / ((p - 1) * (p - 1));
    // If p divides the gap, multiply by (p-1)/(p-2) 
    if (gap % p === 0) {
      C *= (p - 1) / (p - 2);
    }
  }
  return C; // No factor of 2 - HL_CONSTANTS already include it properly
}
const computeHLConstant = computeHL; // Alias

// Zeta values with maximum precision
const ZETA2 = 1.64493406684822643647241516664602519; // π²/6
const ZETA3 = 1.20205690315959428539973816151144999; // Apéry's constant
const ZETA4 = 1.08232323371113819151600369654116790; // π⁴/90
const ZETA5 = 1.03692775514336992633136548645703417;
const ZETA6 = 1.01734306198444913971451792979092053; // π⁶/945
const ZETA7 = 1.00834927738192282683979754984979676;
const ZETA8 = 1.00407735619794433937868523850865247; // π⁸/9450

// Inverse zeta (primitive densities)
const INV_ZETA2 = 0.60792710185402662866327677925836583; // 6/π² ≈ 60.79271%
const INV_ZETA3 = 0.83190737258070746868312627885303710; // 1/ζ(3) ≈ 83.19074%
const INV_ZETA4 = 0.92393937506088059965327506266838895; // 90/π⁴ ≈ 92.39394%
const INV_ZETA5 = 0.96439694022155614594451655816101030;
const INV_ZETA6 = 0.98295257001054197674506666180529804;
const INV_ZETA7 = 0.99171786507468023731390850206009357;
const INV_ZETA8 = 0.99593897568449780461998282310567081;

let P=4,D={},rx=0,ry=0,rz=0,panX=0,panY=0,anim3d=false,pts2d=[],pts3d=[],gausP=[];
// Debounce for sliders
let draw2DTimer=null,draw3DTimer=null;
function draw2DDebounced(){clearTimeout(draw2DTimer);draw2DTimer=setTimeout(draw2D,50);}
function draw3DDebounced(){clearTimeout(draw3DTimer);draw3DTimer=setTimeout(draw3D,50);}

// ===== 2D FAREY SECTOR ANALYSIS =====
let sec2dSweepId = null;
let sec2dSweepN = 2;
let sec2dSweepDir = 1;

function set2dSectorRange(from, to) {
  document.getElementById('sec2dFrom').value = from;
  document.getElementById('sec2dTo').value = to;
  document.getElementById('sec2dHighlight').checked = true;
  update2dSector();
}

function update2dSector() {
  const from = +document.getElementById('sec2dFrom').value || 3;
  const to = +document.getElementById('sec2dTo').value || 2;
  const consec = document.getElementById('sec2dConsec')?.checked;
  
  // Enforce consecutive if checked
  if (consec && from !== to + 1) {
    document.getElementById('sec2dFrom').value = to + 1;
  }
  
  const angLo = Math.atan2(1, from) * 180 / Math.PI;
  const angHi = Math.atan2(1, to) * 180 / Math.PI;
  
  document.getElementById('sec2dAngleRange').textContent = `(${angLo.toFixed(1)}° – ${angHi.toFixed(1)}°)`;
  
  draw2D();
}

function animate2dSectorSweep() {
  if (sec2dSweepId) {
    stop2dSectorSweep();
    return;
  }
  
  document.getElementById('sec2dSweepBtn').textContent = 'Sweeping...';
  document.getElementById('sec2dSweepBtn').style.background = 'rgba(255,215,0,.4)';
  document.getElementById('sec2dHighlight').checked = true;
  
  sec2dSweepN = 2;
  sec2dSweepDir = 1;
  
  function step() {
    document.getElementById('sec2dFrom').value = sec2dSweepN + 1;
    document.getElementById('sec2dTo').value = sec2dSweepN;
    update2dSector();
    
    sec2dSweepN += sec2dSweepDir;
    
    if (sec2dSweepN >= 12) {
      sec2dSweepDir = -1;
    } else if (sec2dSweepN <= 2) {
      sec2dSweepDir = 1;
    }
    
    sec2dSweepId = setTimeout(step, 700);
  }
  
  step();
}

function stop2dSectorSweep() {
  if (sec2dSweepId) {
    clearTimeout(sec2dSweepId);
    sec2dSweepId = null;
  }
  document.getElementById('sec2dSweepBtn').textContent = 'Sector Sweep';
  document.getElementById('sec2dSweepBtn').style.background = 'rgba(255,215,0,.15)';
}

// 3D Farey Sector Analysis functions
let sec3dSweepId = null;
let sec3dSweepAngle = 0;
let sec3dSweepDir = 1;

function set3dSectorRange(from, to) {
  document.getElementById('sec3dFrom').value = from;
  document.getElementById('sec3dTo').value = to;
  document.getElementById('sec3dHighlight').checked = true;
  update3dSector();
}

function update3dSector() {
  const from = +document.getElementById('sec3dFrom').value || 36;
  const to = +document.getElementById('sec3dTo').value || 72;
  document.getElementById('sec3dWidth').textContent = Math.abs(to - from) + '°';
  draw3D();
}

function animate3dSectorSweep() {
  if (sec3dSweepId) {
    stop3dSectorSweep();
    return;
  }
  
  document.getElementById('sec3dSweepBtn').textContent = 'Sweeping...';
  document.getElementById('sec3dSweepBtn').style.background = 'rgba(255,215,0,.4)';
  document.getElementById('sec3dHighlight').checked = true;
  
  sec3dSweepAngle = 0;
  sec3dSweepDir = 1;
  
  function step() {
    const bandWidth = 36;
    document.getElementById('sec3dFrom').value = sec3dSweepAngle;
    document.getElementById('sec3dTo').value = sec3dSweepAngle + bandWidth;
    update3dSector();
    
    sec3dSweepAngle += sec3dSweepDir * 18;
    
    if (sec3dSweepAngle >= 144) {
      sec3dSweepDir = -1;
    } else if (sec3dSweepAngle <= 0) {
      sec3dSweepDir = 1;
    }
    
    sec3dSweepId = setTimeout(step, 800);
  }
  
  step();
}

function stop3dSectorSweep() {
  if (sec3dSweepId) {
    clearTimeout(sec3dSweepId);
    sec3dSweepId = null;
  }
  document.getElementById('sec3dSweepBtn').textContent = 'Sector Sweep';
  document.getElementById('sec3dSweepBtn').style.background = 'rgba(255,215,0,.15)';
}

const fmt=n=>{if(n===0)return'0';if(n==null||isNaN(n)||!isFinite(n))return'—';return parseFloat(n).toFixed(P);};
const fmtH=n=>{if(n===0)return'0';if(n==null||isNaN(n)||!isFinite(n))return'—';return parseFloat(n).toPrecision(17);}; // High precision format

// Fraction display utility - converts decimal to approximate fraction
function toFraction(decimal, maxDenom = 1000000) {
  if (decimal === 0) return '0';
  if (!isFinite(decimal) || isNaN(decimal)) return String(decimal);
  
  const sign = decimal < 0 ? '-' : '';
  decimal = Math.abs(decimal);
  
  // Check if it's close to a simple fraction
  let bestNum = 1, bestDen = 1, bestErr = Math.abs(decimal - 1);
  
  for (let d = 1; d <= Math.min(maxDenom, 10000); d++) {
    const n = Math.round(decimal * d);
    if (n > 0 && n <= maxDenom) {
      const err = Math.abs(decimal - n/d);
      if (err < bestErr) {
        bestErr = err;
        bestNum = n;
        bestDen = d;
        if (err < 1e-12) break; // Exact match
      }
    }
  }
  
  // Only return fraction if it's a good approximation
  if (bestErr < 1e-10 && bestDen <= 1000) {
    // Reduce the fraction
    const g = gcdM(bestNum, bestDen);
    bestNum /= g;
    bestDen /= g;
    return sign + (bestDen === 1 ? String(bestNum) : `${bestNum}/${bestDen}`);
  }
  
  return null; // No good fraction representation
}

// Format number with optional fraction display
let showFractions = false;
function resetPlotlyZoom(divId) {
  const el = document.getElementById(divId);
  if (el && window.Plotly) {
    Plotly.relayout(divId, { 'xaxis.autorange': true, 'yaxis.autorange': true });
  }
}

function fmtFrac(n, forceDecimal = false) {
  if (n === 0) return '0';
  if (n == null || isNaN(n) || !isFinite(n)) return '—';
  
  if (!forceDecimal && showFractions) {
    const frac = toFraction(n);
    if (frac) return frac;
  }
  return parseFloat(n).toFixed(P);
}

// Smart number formatter - uses fractions for small rational numbers, decimals otherwise
function fmtNum(n, decimals = null) {
  if (n === 0) return '0';
  if (n == null || isNaN(n) || !isFinite(n)) return '—';
  
  const dec = decimals !== null ? decimals : P;
  
  if (showFractions) {
    const frac = toFraction(n);
    if (frac) return frac;
  }
  
  // Use exponential for very small or very large numbers
  if (Math.abs(n) < 0.0001 || Math.abs(n) > 1000000) {
    return n.toExponential(dec);
  }
  return n.toFixed(dec);
}

// Redraw the currently active section when display options change
function redrawCurrentSection() {
  const sections = ['constSieve', 'constIntegerN', 'constAlgebraic', 'constBigint', 'constGapH', 'constKtuples', 'constConvergence', 'constOpen'];
  for (const s of sections) {
    const el = document.getElementById(s);
    if (el && el.style.display !== 'none') {
      if (s === 'constSieve') drawConstellations();
      else if (s === 'constIntegerN') drawIntegerNVerifier();
      else if (s === 'constAlgebraic') drawAlgebraicProof();
      else if (s === 'constBigint') drawBigIntVerify();
      else if (s === 'constGapH') drawGapHVerify();
      else if (s === 'constKtuples') drawSingularSeriesKtuples();
      else if (s === 'constConvergence') drawConstConvergence();
      else if (s === 'constOpen') drawConstOpen();
      break;
    }
  }
}

// Redraw all active tabs when global settings change (precision, fractions, theme)
function redrawAll() {
  // Sync fraction toggles
  const globalToggle = document.getElementById('globalFractionToggle');
  if (globalToggle) showFractions = globalToggle.checked;
  
  // Redraw Enhanced Modular
  if (typeof drawEnhanced === 'function') {
    drawEnhanced();
  }
}

function redrawAllOld() {
  // Find which main tab is active and redraw it (unused in standalone)
  const tabs = document.querySelectorAll('.tab.active');
  tabs.forEach(tab => {
    const id = tab.id;
    if (id === 't2d') draw2D();
    else if (id === 't3d') draw3D();
    else if (id === 'tcayley') drawCayley();
    else if (id === 'tfarey') drawFarey();
    else if (id === 'tprim') drawPrimRoot();
    else if (id === 'tmod') drawModRings();
    else if (id === 'tgaus') setZ2View('gaus');
    else if (id === 'tcirc') setZ2View('circ');
    else if (id === 'tmob') drawMobius();
    else if (id === 'terr') setRHView('err');
    else if (id === 'tdim') runDimNew();
    else if (id === 'tsh') runShNew();
    else if (id === 'tgcd') runGCD();
    else if (id === 'tdens') runDensNew();
    else if (id === 'tcomp') drawComp();
    else if (id === 'tcopair') drawCopair();
    else if (id === 'tsierp') drawSierp();
    else if (id === 'tkfree') drawKfree();
    else if (id === 'teuler') drawEuler();
    else if (id === 'tchord') drawChord();
    else if (id === 'tdir') drawDirichlet();
    else if (id === 'ttwin') drawTwin();
    else if (id === 'tpi') drawPi();
    else if (id === 'tgold') drawGoldbach();
    else if (id === 'tgap') drawGap();
    else if (id === 'tsoph') drawSophie();
    else if (id === 'tmert') drawMertens();
    else if (id === 'tcheb') drawChebyshev();
    else if (id === 'tli') drawLi();
    else if (id === 'tdiv') drawDivisor();
    else if (id === 'tliou') drawLiouville();
    else if (id === 'tmang') drawMangoldt();
    else if (id === 'tram') drawRamanujan();
    else if (id === 'tulam') drawUlam();
    else if (id === 'tsacks') drawSacks();
    else if (id === 'thardy') setRHView('hardy');
    else if (id === 'tgram') setRHView('gram');
    else if (id === 'texplicit') setRHView('explicit');
    else if (id === 'tzerocount') setRHView('zerocount');
    else if (id === 'targand') setRHView('argand');
    else if (id === 'tzetareal') setRHView('zetareal');
    else if (id === 'tmontgomery') setRHView('montgomery');
    else if (id === 'tgue') setRHView('gue');
    else if (id === 'trh') setRHView('hardy');
    else if (id === 'tprimerace') drawPrimeRace();
    else if (id === 'tlfunc') drawLfunc();
    else if (id === 'tlfunczeros') drawLfuncZeros();
    else if (id === 'tquantum') drawQuantum();
    else if (id === 'tktuples') drawKtuples();
    else if (id === 'tcarmichael') drawCarmichael();
    else if (id === 'tmersenne') drawMersenne();
    else if (id === 'tcontinued') drawContinued();
    else if (id === 'tsternbrocot') drawSternBrocot();
    else if (id === 'tpythag') drawPythag();
    else if (id === 'tsumsquares') drawSumSquares();
    else if (id === 'tquadres') drawQuadRes();
    else if (id === 'tpartition') drawPartition();
    else if (id === 'tbernoulli') drawBernoulli();
    else if (id === 'tfibonacci') drawFibonacci();
    else if (id === 'tcatalan') drawCatalan();
    else if (id === 'taliquot') drawAliquot();
    else if (id === 'tcyclotomic') drawCyclotomic();
    else if (id === 'tcollatz') drawCollatz();
    else if (id === 'thighcomp') drawHighComp();
    else if (id === 'tperfect') drawPerfect();
    else if (id === 'ttaxicab') drawTaxicab();
    else if (id === 'telliptic') drawElliptic();
    else if (id === 'tenhanced') drawEnhanced();
    else if (id === 'ttrajectory') computeTrajStats2();
    else if (id === 'tmodsieve') drawModSieve();
    else if (id === 'tfarey3d') drawFarey3D();
    else if (id === 'tmobexp') drawMobiusExp();
    
  });
}
const gcd=(a,b)=>{a=Math.abs(Math.round(a));b=Math.abs(Math.round(b));while(b)[a,b]=[b,a%b];return a||1;};
const isPrime=n=>{if(n<2)return false;if(n===2)return true;if(n%2===0)return false;for(let i=3;i*i<=n;i+=2)if(n%i===0)return false;return true;};
const lowestPrimeFactor=n=>{if(n<2)return n;if(n%2===0)return 2;for(let i=3;i*i<=n;i+=2)if(n%i===0)return i;return n;};
const totient=n=>{if(n<1)return 0;let r=n;for(let p=2;p*p<=n;p++){if(n%p===0){while(n%p===0)n/=p;r-=r/p;}}if(n>1)r-=r/n;return Math.round(r);};
const gcdM=(...n)=>n.reduce((a,b)=>gcd(a,b));
const mob=n=>{if(n===1)return 1;let pf=0,t=n;for(let i=2;i*i<=n;i++){if(n%i===0){if(t%(i*i)===0)return 0;pf++;while(t%i===0)t/=i;}}if(t>1)pf++;return pf%2===0?1:-1;};
const zeta=n=>{
// Use exact high-precision constants
if(n===2)return ZETA2;
if(n===3)return ZETA3;
if(n===4)return ZETA4;
if(n===5)return ZETA5;
if(n===6)return ZETA6;
if(n===7)return ZETA7;
if(n===8)return ZETA8;
// For other values, use series with many terms
let s=0;for(let k=1;k<=10000;k++)s+=1/Math.pow(k,n);return s;
};
const zetaInv=n=>{
if(n===2)return INV_ZETA2;
if(n===3)return INV_ZETA3;
if(n===4)return INV_ZETA4;
if(n===5)return INV_ZETA5;
if(n===6)return INV_ZETA6;
if(n===7)return INV_ZETA7;
if(n===8)return INV_ZETA8;
return 1/zeta(n);
};
const vol=n=>[0,2,PI,4*PI/3,PI_SQ/2,8*PI_SQ/15,PI*PI_SQ/6,16*PI*PI_SQ/105][n]||0;
const theory=(R,n)=>(vol(n)*zetaInv(n))*Math.pow(R,n);
const sqfree=n=>{for(let i=2;i*i<=n;i++)if(n%(i*i)===0)return false;return true;};
const isDark=()=>!document.body.classList.contains('light') && !document.body.classList.contains('theme-sepia');
const plo=()=>({plot_bgcolor:isDark()?'rgba(10,14,39,0.8)':'rgba(245,247,250,0.95)',paper_bgcolor:isDark()?'rgba(10,14,39,0.8)':'rgba(245,247,250,0.95)',font:{color:isDark()?'#e0e0ff':'#1a1a1a'},margin:{l:50,r:30,t:30,b:40}});
const canvBg=()=>isDark()?'#0a0e27':'#f5f7fa';
const gridC=()=>isDark()?'rgba(0,217,255,0.12)':'rgba(0,102,204,0.15)';
const bordC=()=>isDark()?'rgba(0,217,255,0.5)':'rgba(0,102,204,0.6)';
function setTheme(theme) {
  // Remove all theme classes
  document.body.classList.remove('light', 'theme-midnight', 'theme-sepia', 'theme-ocean', 'theme-forest', 'theme-sunset');
  
  // Apply new theme
  if (theme === 'light') {
    document.body.classList.add('light');
  } else if (theme !== 'dark') {
    document.body.classList.add('theme-' + theme);
  }
  
  // Update select if needed
  const select = document.getElementById('themeSelect');
  if (select) select.value = theme;
  
  // Redraw
  redrawAll();
}

// Donation functions
function showBtcDonate() {
  document.getElementById('btcModal').style.display = 'flex';
}
function copyBtcAddress() {
  const addr = 'bc1qtsuj9x372slcgead3tlnrpw0r6tu7y7y0xwuk4';
  navigator.clipboard.writeText(addr).then(() => {
    alert('Bitcoin address copied to clipboard!');
  }).catch(() => {
    const ta = document.createElement('textarea');
    ta.value = addr;
    document.body.appendChild(ta);
    ta.select();
    document.execCommand('copy');
    document.body.removeChild(ta);
    alert('Bitcoin address copied!');
  });
}

// Legacy toggle for compatibility
function toggleTheme() {
  const isLight = document.body.classList.contains('light');
  setTheme(isLight ? 'dark' : 'light');
}
function showMainSec(id,btn){
  document.querySelectorAll('.mainSec').forEach(s=>s.style.display='none');
  document.querySelectorAll('.snav .nbtn').forEach(b=>b.classList.remove('active'));
  const sec = document.getElementById('sec'+id.charAt(0).toUpperCase()+id.slice(1));
  if(sec) sec.style.display='block';
  btn.classList.add('active');
}
function showSec(id,btn){document.querySelectorAll('.sec').forEach(s=>s.classList.remove('active'));document.querySelectorAll('.snav .nbtn').forEach(b=>b.classList.remove('active'));document.getElementById(id).classList.add('active');btn.classList.add('active');}

// Universal tool section toggle - works for any tool
function toggleToolSection(toolId, sectionId) {
  const section = document.getElementById(sectionId);
  const icon = document.getElementById(sectionId + 'Icon');
  if (!section) return;
  const isHidden = section.style.display === 'none';
  section.style.display = isHidden ? 'block' : 'none';
  if (icon) icon.textContent = isHidden ? '−' : '+';
}

function expandToolSections(toolId) {
  document.querySelectorAll(`[id^="${toolId}Sec"]`).forEach(s => {
    s.style.display = 'block';
    const icon = document.getElementById(s.id + 'Icon');
    if (icon) icon.textContent = '−';
  });
}

function collapseToolSections(toolId) {
  document.querySelectorAll(`[id^="${toolId}Sec"]`).forEach(s => {
    s.style.display = 'none';
    const icon = document.getElementById(s.id + 'Icon');
    if (icon) icon.textContent = '+';
  });
}
function showTab(id,btn){document.querySelectorAll('.tab').forEach(t=>t.classList.remove('active'));document.querySelectorAll('.tabs .tbtn').forEach(b=>b.classList.remove('active'));document.getElementById(id).classList.add('active');btn.classList.add('active');if(id==='t2d')draw2D();if(id==='t3d')draw3D();if(id==='tcayley')drawCayley();if(id==='tfarey')drawFarey();if(id==='tprim')drawPrimRoot();if(id==='tenhanced')initEnhanced();if(id==='tmodsieve')drawModSieve();if(id==='tfarey3d')drawFarey3D();if(id==='tcirc'){id='t2d';document.getElementById('t2d').classList.add('active');setZ2View('circ');return;}if(id==='tgaus'){id='t2d';document.getElementById('t2d').classList.add('active');setZ2View('gaus');return;}if(id==='tmob')drawMobius();if(id==='tmobexp')drawMobiusExp();if(id==='terr'){id='trh';document.getElementById('trh').classList.add('active');setRHView('err');return;}if(id==='tdim')runDimNew();if(id==='tsh')runShNew();if(id==='tgcd')runGCD();if(id==='tdens')runDensNew();if(id==='tcomp')drawComp();if(id==='tcopair')drawCopair();if(id==='tsierp')drawSierp();if(id==='tkfree')drawKfree();if(id==='tchord')drawChord();if(id==='tdir')drawDirichlet();if(id==='ttwin')drawTwin();if(id==='tpi')drawPi();if(id==='tgold')drawGoldbach();if(id==='tgap')drawGap();if(id==='tsoph')drawSophie();if(id==='tmert')drawMertens();if(id==='tcheb')drawChebyshev();if(id==='tli')drawLi();if(id==='tdiv')drawDivisor();if(id==='tliou')drawLiouville();if(id==='tmang')drawMangoldt();if(id==='tram')drawRamanujan();if(id==='tulam')drawUlam();if(id==='tsacks')drawSacks();if(id==='thardy'){id='trh';document.getElementById('trh').classList.add('active');setRHView('hardy');return;}if(id==='tgram'){id='trh';document.getElementById('trh').classList.add('active');setRHView('gram');return;}if(id==='texplicit'){id='trh';document.getElementById('trh').classList.add('active');setRHView('explicit');return;}if(id==='tzerocount'){id='trh';document.getElementById('trh').classList.add('active');setRHView('zerocount');return;}if(id==='targand'){id='trh';document.getElementById('trh').classList.add('active');setRHView('argand');return;}if(id==='tzetareal'){id='trh';document.getElementById('trh').classList.add('active');setRHView('zetareal');return;}if(id==='tmontgomery'){id='trh';document.getElementById('trh').classList.add('active');setRHView('montgomery');return;}if(id==='tgue'){id='trh';document.getElementById('trh').classList.add('active');setRHView('gue');return;}if(id==='trh'){setRHView('hardy');}if(id==='tprimerace')drawPrimeRace();if(id==='tlfunc')drawLfunc();if(id==='tlfunczeros')drawLfuncZeros();if(id==='tphasor')drawPhasor();if(id==='tmodsievecalc'){drawEuler();}if(id==='tquantum')drawQuantum();if(id==='twigner')drawWigner();if(id==='tktuples')drawKtuples();if(id==='tcarmichael')drawCarmichael();if(id==='tmersenne')drawMersenne();if(id==='tcontinued')drawContinued();if(id==='tsternbrocot')drawSternBrocot();if(id==='tfordcircles')drawFord();if(id==='tcalkinwilf')drawCalkinWilf();if(id==='tpisano')drawPisano();if(id==='teisenstein')drawEisenstein();if(id==='tbeatty')drawBeatty();if(id==='tdedekind')drawDedekind();if(id==='tminkowski')drawMinkowski();if(id==='twheel')drawWheel();if(id==='tpythag')drawPythag();if(id==='tsumsquares')drawSumSquares();if(id==='tquadres')drawQuadRes();if(id==='tpartition')drawPartition();if(id==='tbernoulli')drawBernoulli();if(id==='tfibonacci')drawFibonacci();if(id==='tcatalan')drawCatalan();if(id==='taliquot')drawAliquot();if(id==='tcyclotomic')drawCyclotomic();if(id==='tcollatz')drawCollatz();if(id==='thighcomp')drawHighComp();if(id==='tperfect')drawPerfect();if(id==='ttaxicab')drawTaxicab();if(id==='telliptic')drawElliptic();if(id==='tninefields')drawNineFields();if(id==='tnumberdive')runDeepDive();if(id==='ttrajectory')initTrajectoryTab();}

async function screenshotDashboard(elemId, title='Dashboard'){
const el=document.getElementById(elemId);if(!el)return;
const scale=4;
const w=el.offsetWidth,h=el.offsetHeight;
const c=document.createElement('canvas');c.width=w*scale;c.height=h*scale;
const ctx=c.getContext('2d');
ctx.scale(scale,scale);
ctx.fillStyle=isDark()?'#1a1a2e':'#ffffff';ctx.fillRect(0,0,w,h);
ctx.fillStyle=isDark()?'#ffd700':'#cc8800';ctx.font='bold 16px Segoe UI';ctx.fillText(title+' — Möbius Shell Sieve',10,24);
ctx.fillStyle=isDark()?'rgba(255,255,255,0.5)':'rgba(0,0,0,0.5)';ctx.font='10px Segoe UI';ctx.fillText(new Date().toISOString().slice(0,19).replace('T',' '),10,h-8);
try{
const html2canvas=(await import('https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/+esm')).default;
const snap=await html2canvas(el,{scale:scale,backgroundColor:isDark()?'#1a1a2e':'#ffffff',logging:false});
ctx.drawImage(snap,0,36,w,h-44);
c.toBlob(blob=>{const a=document.createElement('a');a.href=URL.createObjectURL(blob);a.download=`${title.replace(/[^a-zA-Z0-9]/g,'_')}_4K_${Date.now()}.png`;a.click();URL.revokeObjectURL(a.href);},'image/png');
}catch(e){
ctx.fillStyle=isDark()?'#e0e0e0':'#333';ctx.font='12px Segoe UI';
const lines=el.innerText.split('\n').slice(0,30);
lines.forEach((line,i)=>ctx.fillText(line.substring(0,80),10,50+i*16));
c.toBlob(blob=>{const a=document.createElement('a');a.href=URL.createObjectURL(blob);a.download=`${title.replace(/[^a-zA-Z0-9]/g,'_')}_4K_${Date.now()}.png`;a.click();URL.revokeObjectURL(a.href);},'image/png');
}}

function legend(id,title,data){const d=document.getElementById(id);if(!d)return;d.innerHTML=`<h4>${title}</h4><div class="lg">${data.map(([l,v,c])=>`<div class="li" style="border-left-color:${c}"><strong>${l}</strong><span class="v">${fmt(v)}</span></div>`).join('')}</div>`;}
function modal(title,data){document.getElementById('mtitle').textContent=title;document.getElementById('mbody').innerHTML=data.map(([l,v])=>`<div class="ds"><div class="dr"><span class="dl">${l}:</span><span class="dv">${typeof v==='number'?fmt(v):v}</span></div></div>`).join('');document.getElementById('modal').classList.add('active');}
function dl(c,f){const a=document.createElement('a');a.href='data:text/csv,'+encodeURIComponent(c);a.download=f;a.click();}

// Auto-scaling point size to prevent overlap
// Returns scaled size that decreases as point count increases
function autoScalePtSize(baseSize, totalPoints, canvasSize) {
  if (totalPoints <= 100) return baseSize;
  // Target: points should cover ~30% of canvas area max
  const targetCoverage = 0.25;
  const canvasArea = canvasSize * canvasSize;
  const idealPointArea = (canvasArea * targetCoverage) / totalPoints;
  const idealRadius = Math.sqrt(idealPointArea / Math.PI);
  // Clamp between 0.5 and baseSize
  return Math.max(0.5, Math.min(baseSize, idealRadius));
}

// Auto-scale for 2D based on R
function autoScale2D(R, userPtSize) {
  const estPoints = Math.PI * R * R; // circle estimate
  return autoScalePtSize(userPtSize, estPoints, 800);
}

// Auto-scale for 3D based on R
function autoScale3D(R, userPtSize) {
  const estPoints = (4/3) * Math.PI * R * R * R; // sphere estimate
  return autoScalePtSize(userPtSize, estPoints, 800);
}

// Auto-scale for Enhanced based on moduli range
function autoScaleEnhanced(moduli, userPtSize) {
  let totalPoints = 0;
  moduli.forEach(m => { totalPoints += m; });
  return autoScalePtSize(userPtSize, totalPoints, 800);
}

// Cached 2D point enumeration
const pts2dCache = new Map();
function enum2D(R, sh) {
  const key = `${R}-${sh}`;
  if (pts2dCache.has(key)) return pts2dCache.get(key);
  
  const pts = [], m = Math.ceil(R) + 1;
  for (let x = -m; x <= m; x++) {
    for (let y = -m; y <= m; y++) {
      const inCirc = x*x + y*y <= R*R;
      const inSq = Math.abs(x) <= R && Math.abs(y) <= R;
      const inR = sh === 'circle' ? inCirc : sh === 'square' ? inSq : inSq;
      if (inR) {
        const g = gcdM(x, y);
        pts.push({x, y, g, p: g === 1, inCircle: inCirc});
      }
    }
  }
  
  // Cache up to 20 entries
  if (pts2dCache.size > 20) pts2dCache.clear();
  pts2dCache.set(key, pts);
  return pts;
}

// Cached 3D point enumeration
const pts3dCache = new Map();
function enum3D(R) {
  if (pts3dCache.has(R)) return pts3dCache.get(R);
  
  const pts = [], m = Math.ceil(R) + 1;
  for (let x = -m; x <= m; x++) {
    for (let y = -m; y <= m; y++) {
      for (let z = -m; z <= m; z++) {
        if (x*x + y*y + z*z <= R*R) {
          const g = gcdM(x, y, z);
          pts.push({x, y, z, g, p: g === 1});
        }
      }
    }
  }
  
  // Cache up to 10 entries
  if (pts3dCache.size > 10) pts3dCache.clear();
  pts3dCache.set(R, pts);
  return pts;
}

function smithTransform(r,theta,alpha){
const th=theta+alpha*Math.PI/180;
const A=r*Math.cos(th)-1,B=r*Math.sin(th),C=r*Math.cos(th)+1;
const denom=C*C+B*B;
if(denom<1e-10)return{x:0,y:0};
const re=(A*C+B*B)/denom,im=B*(C-A)/denom;
return{x:re,y:im};}

function smithTransformUnit(theta){return{x:0,y:Math.tan(theta/2)};}

function drawSmithGrid(ctx,cx,cy,rad,showGrid,showConstR,showConstX){
if(showGrid){ctx.strokeStyle=isDark()?'rgba(100,150,200,0.3)':'rgba(50,100,150,0.3)';ctx.lineWidth=0.5;
ctx.beginPath();ctx.arc(cx,cy,rad,0,2*Math.PI);ctx.stroke();
ctx.strokeStyle=isDark()?'rgba(255,255,255,0.4)':'rgba(0,0,0,0.4)';ctx.lineWidth=1;
ctx.beginPath();ctx.moveTo(cx-rad,cy);ctx.lineTo(cx+rad,cy);ctx.stroke();
ctx.beginPath();ctx.moveTo(cx,cy-rad);ctx.lineTo(cx,cy+rad);ctx.stroke();}
if(showConstR){ctx.strokeStyle='rgba(100,150,200,0.25)';ctx.lineWidth=0.5;
const rVals=[0.2,0.5,1,2,5];
rVals.forEach(r=>{const center=r/(1+r),radius=1/(1+r);ctx.beginPath();ctx.arc(cx+center*rad,cy,radius*rad,0,2*Math.PI);ctx.stroke();});}
if(showConstX){ctx.strokeStyle='rgba(150,100,200,0.25)';ctx.lineWidth=0.5;
const xVals=[-2,-1,-0.5,0.5,1,2];
xVals.forEach(x=>{if(Math.abs(x)<0.01)return;const centerY=1/x,radius=1/Math.abs(x);ctx.beginPath();ctx.arc(cx+rad,cy-centerY*rad,radius*rad,x>0?Math.PI:0,x>0?0:Math.PI,x>0);ctx.stroke();});}}

// Toggle between Lattice Points, Gaussian ℤ[i], and Circle Problem views
function setZ2View(view){
const latticeSection=document.getElementById('z2LatticeSection');
const gausSection=document.getElementById('z2GausSection');
const circSection=document.getElementById('z2CircSection');
const btnLattice=document.getElementById('z2ViewLattice');
const btnGaus=document.getElementById('z2ViewGaus');
const btnCirc=document.getElementById('z2ViewCirc');
const descLattice=document.getElementById('z2DescLattice');
const descGaus=document.getElementById('z2DescGaus');
const descCirc=document.getElementById('z2DescCirc');
// Reset all sections and descriptions
[latticeSection,gausSection,circSection].forEach(s=>{if(s)s.style.display='none';});
[descLattice,descGaus,descCirc].forEach(d=>{if(d)d.style.display='none';});
[btnLattice,btnGaus,btnCirc].forEach(b=>{if(b){b.style.background='transparent';}});
if(btnLattice)btnLattice.style.color='#00ff88';
if(btnGaus)btnGaus.style.color='#ffd700';
if(btnCirc)btnCirc.style.color='#ff6496';
if(view==='lattice'){
if(latticeSection)latticeSection.style.display='block';
if(descLattice)descLattice.style.display='block';
if(btnLattice){btnLattice.style.background='#00ff88';btnLattice.style.color='#000';}
if(document.getElementById('c2d')) draw2D();
}else if(view==='gaus'){
if(gausSection)gausSection.style.display='block';
if(descGaus)descGaus.style.display='block';
if(btnGaus){btnGaus.style.background='#ffd700';btnGaus.style.color='#000';}
drawGaus();
}else if(view==='circ'){
if(circSection)circSection.style.display='block';
if(descCirc)descCirc.style.display='block';
if(btnCirc){btnCirc.style.background='#ff6496';btnCirc.style.color='#000';}
drawCircleViz();runCircNew();
}}

// Toggle RH Explorer views - moves content from old hidden tabs on first load
function setRHView(view){
const views=['err','hardy','gram','explicit','zerocount','argand','zetareal','montgomery','gue'];
const colors={err:'#ff3366',hardy:'#ffd700',gram:'#ff6496',explicit:'#00d9ff',zerocount:'#00ff88',argand:'#9664ff',zetareal:'#ff8c00',montgomery:'#00ffcc',gue:'#ff66aa'};
const tabMap={err:'terr',hardy:'rhSectionHardy',gram:'tgram',explicit:'texplicit',zerocount:'tzerocount',argand:'targand',zetareal:'tzetareal',montgomery:'tmontgomery',gue:'tgue'};
const drawFuncs={err:runErrNew,hardy:drawHardy,gram:drawGram,explicit:drawExplicit,zerocount:drawZeroCount,argand:drawArgand,zetareal:drawZetaReal,montgomery:drawMontgomery,gue:drawGUE};
// Hide ALL sub-tabs and descriptions, reset all buttons
views.forEach(v=>{
const descId='rhDesc'+v.charAt(0).toUpperCase()+v.slice(1);
const btnId='rhView'+v.charAt(0).toUpperCase()+v.slice(1);
const tabId=tabMap[v];
const desc=document.getElementById(descId);
const btn=document.getElementById(btnId);
const tab=document.getElementById(tabId);
if(desc)desc.style.display='none';
if(btn){btn.style.background='transparent';btn.style.color=colors[v];}
if(tab)tab.style.display='none';
});
// Show selected description, highlight button, show tab
const selDescId='rhDesc'+view.charAt(0).toUpperCase()+view.slice(1);
const selBtnId='rhView'+view.charAt(0).toUpperCase()+view.slice(1);
const selTabId=tabMap[view];
const selDesc=document.getElementById(selDescId);
const selBtn=document.getElementById(selBtnId);
const selTab=document.getElementById(selTabId);
if(selDesc)selDesc.style.display='block';
if(selBtn){selBtn.style.background=colors[view];selBtn.style.color='#000';}
if(selTab){selTab.style.display='block';selTab.classList.remove('tab');}
// Call draw function with delay to ensure DOM is ready
setTimeout(()=>{if(drawFuncs[view])try{drawFuncs[view]();}catch(e){console.log('RH draw error:',view,e);}},100);
}

function draw2D(){
// Guard: exit if canvas doesn't exist (standalone mode)
if(!document.getElementById('c2d')) return;
try{
let R=+document.getElementById('r2dv').value||+document.getElementById('r2d').value;
const maxSafeR=800;
if(R>maxSafeR){
if(!confirm(`R=${R} will compute ${Math.round(Math.PI*R*R).toLocaleString()}+ points which may be slow.\n\nContinue anyway?`)){
R=maxSafeR;document.getElementById('r2dv').value=R;document.getElementById('r2d').value=Math.min(200,R);
}}
const c=document.getElementById('c2d'),ctx=c.getContext('2d'),sh=document.getElementById('sh2d').value,col=document.getElementById('col2d').value,lbl=document.getElementById('lbl2d').value,zm=+document.getElementById('zm2d').value,lblsz=+document.getElementById('lblsz2d').value;
// Auto-scale point size based on R to prevent overlap
const userPtSz=+document.getElementById('ptSz2d').value;
const autoScaleEnabled=document.getElementById('autoScale2d')?.checked??true;
const ptSz=autoScaleEnabled?autoScale2D(R,userPtSz):userPtSz;
const smithEnabled=document.getElementById('smith2d').checked,smithAlpha=+document.getElementById('smithA2d').value,smithRMode=document.getElementById('smithR2d').value;
const smithGrid=document.getElementById('smithGrid2d').checked,smithConstR=document.getElementById('smithCircR2d').checked,smithConstX=document.getElementById('smithArcX2d').checked;
const modEnabled=document.getElementById('mod2dEnable').checked,modM=+document.getElementById('mod2dM').value||6,modColBy=document.getElementById('mod2dColBy').value,modRings=document.getElementById('mod2dRings').checked;
const cx=c.width/2,cy=c.height/2,sc=(c.width/2)/(R*1.15)*zm,smithRad=(c.width/2-40)*zm;
ctx.fillStyle=canvBg();ctx.fillRect(0,0,c.width,c.height);
if(smithEnabled){drawSmithGrid(ctx,cx,cy,smithRad,smithGrid,smithConstR,smithConstX);ctx.strokeStyle=bordC();ctx.lineWidth=2;ctx.beginPath();ctx.arc(cx,cy,smithRad,0,2*Math.PI);ctx.stroke();}
else{ctx.strokeStyle=gridC();ctx.lineWidth=1;for(let i=-Math.ceil(R);i<=Math.ceil(R);i++){ctx.beginPath();ctx.moveTo(cx+i*sc,0);ctx.lineTo(cx+i*sc,c.height);ctx.stroke();ctx.beginPath();ctx.moveTo(0,cy+i*sc);ctx.lineTo(c.width,cy+i*sc);ctx.stroke();}ctx.strokeStyle=bordC();ctx.lineWidth=2;if(sh==='circle'){ctx.beginPath();ctx.arc(cx,cy,R*sc,0,2*Math.PI);ctx.stroke();}else if(sh==='square'){ctx.strokeRect(cx-R*sc,cy-R*sc,2*R*sc,2*R*sc);}else if(sh==='both'){ctx.strokeRect(cx-R*sc,cy-R*sc,2*R*sc,2*R*sc);ctx.strokeStyle='rgba(255,136,0,0.8)';ctx.beginPath();ctx.arc(cx,cy,R*sc,0,2*Math.PI);ctx.stroke();}

// Modular residue rings overlay
if(modEnabled&&modRings){
ctx.setLineDash([5,3]);
for(let r=1;r<=modM;r++){
const ringRad=r*(R*sc/modM);
ctx.strokeStyle=`hsla(${(r/modM)*360},70%,50%,0.4)`;
ctx.lineWidth=1;
ctx.beginPath();ctx.arc(cx,cy,ringRad,0,2*Math.PI);ctx.stroke();
}
ctx.setLineDash([]);
}

// Farey Sector Analysis - draw sector lines and highlight
const sec2dHighlight = document.getElementById('sec2dHighlight')?.checked;
const sec2dShowAll = document.getElementById('sec2dShowAll')?.checked;
const showFareySectors = document.getElementById('show2dFareySectors')?.checked;
const secFrom = +document.getElementById('sec2dFrom')?.value || 3;
const secTo = +document.getElementById('sec2dTo')?.value || 2;

if (!smithEnabled && (sec2dHighlight || sec2dShowAll || showFareySectors)) {
  const maxLineR = R * sc * 1.1;
  
  // Draw all 1/n lines if enabled
  if (sec2dShowAll || showFareySectors) {
    ctx.setLineDash([4, 4]);
    const fareySectorColors = ['#ff6496','#ffd700','#00ff88','#00d9ff','#9664ff','#ff8c00','#ff00ff','#00ffff','#88ff00','#ff4444'];
    for (let n = 1; n <= 12; n++) {
      const ang = Math.atan2(1, n);
      ctx.strokeStyle = fareySectorColors[(n-1) % fareySectorColors.length] + '66';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(cx, cy);
      ctx.lineTo(cx + Math.cos(ang) * maxLineR, cy - Math.sin(ang) * maxLineR);
      ctx.stroke();
      // Label
      ctx.fillStyle = fareySectorColors[(n-1) % fareySectorColors.length];
      ctx.font = '10px Segoe UI';
      ctx.textAlign = 'left';
      ctx.fillText(`1/${n}`, cx + Math.cos(ang) * (maxLineR + 5), cy - Math.sin(ang) * (maxLineR + 5));
    }
    ctx.setLineDash([]);
  }
  
  // Highlight selected sector
  if (sec2dHighlight) {
    const angLo = Math.atan2(1, secFrom);
    const angHi = Math.atan2(1, secTo);
    
    // Draw sector wedge
    ctx.fillStyle = 'rgba(150,100,255,0.15)';
    ctx.beginPath();
    ctx.moveTo(cx, cy);
    ctx.arc(cx, cy, maxLineR, -angHi, -angLo, false);
    ctx.closePath();
    ctx.fill();
    
    // Draw sector boundary lines (solid)
    ctx.strokeStyle = '#9664ff';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(cx, cy);
    ctx.lineTo(cx + Math.cos(angLo) * maxLineR, cy - Math.sin(angLo) * maxLineR);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(cx, cy);
    ctx.lineTo(cx + Math.cos(angHi) * maxLineR, cy - Math.sin(angHi) * maxLineR);
    ctx.stroke();
    
    // Labels for boundaries
    ctx.fillStyle = '#ffd700';
    ctx.font = 'bold 11px Segoe UI';
    ctx.textAlign = 'center';
    ctx.fillText(`1/${secFrom}`, cx + Math.cos(angLo) * (maxLineR + 15), cy - Math.sin(angLo) * (maxLineR + 15));
    ctx.fillText(`1/${secTo}`, cx + Math.cos(angHi) * (maxLineR + 15), cy - Math.sin(angHi) * (maxLineR + 15));
    
    // Sector label
    ctx.fillStyle = '#9664ff';
    ctx.font = 'bold 12px Segoe UI';
    const midAng = (angLo + angHi) / 2;
    ctx.fillText(`S${secTo}`, cx + Math.cos(midAng) * (maxLineR * 0.6), cy - Math.sin(midAng) * (maxLineR * 0.6));
  }
}
}
pts2d=enum2D(R,sh);

// Sweep & Ray Overlays
const ray2dShow = document.getElementById('ray2dShow')?.checked;
const ray2dSectorBounds = document.getElementById('ray2dSectorBounds')?.checked;
const ray2dMediants = document.getElementById('ray2dMediants')?.checked;
const ray2dOp = +document.getElementById('ray2dOp')?.value || 0.3;
const ray2dMode = document.getElementById('ray2dMode')?.value || 'coprime';
const ray2dColor = document.getElementById('ray2dColor')?.value || '#ffd700';

if (!smithEnabled && (ray2dShow || ray2dSectorBounds || ray2dMediants)) {
  const maxRayR = R * sc;
  
  // Draw light rays from origin to points
  if (ray2dShow) {
    ctx.lineWidth = 1;
    // Parse hex color and add opacity
    const r = parseInt(ray2dColor.slice(1,3), 16);
    const g = parseInt(ray2dColor.slice(3,5), 16);
    const b = parseInt(ray2dColor.slice(5,7), 16);
    ctx.strokeStyle = `rgba(${r},${g},${b},${ray2dOp})`;
    
    let rayPts = pts2d;
    if (ray2dMode === 'coprime') rayPts = pts2d.filter(p => p.p);
    else if (ray2dMode === 'outer') {
      // Outer shell: points at max distance for their angle direction
      const angles = {};
      pts2d.forEach(p => {
        const ang = Math.atan2(p.y, p.x).toFixed(3);
        const dist = Math.hypot(p.x, p.y);
        if (!angles[ang] || dist > angles[ang].dist) {
          angles[ang] = { p, dist };
        }
      });
      rayPts = Object.values(angles).map(v => v.p);
    } else if (ray2dMode === 'farey') {
      // Farey neighbors: coprime points where |ad-bc|=1
      rayPts = pts2d.filter(p => p.p && p.x > 0 && p.y > 0);
    }
    
    for (const p of rayPts) {
      ctx.beginPath();
      ctx.moveTo(cx, cy);
      ctx.lineTo(cx + p.x * sc, cy - p.y * sc);
      ctx.stroke();
    }
  }
  
  // Draw sector boundary lines at 1/n positions
  if (ray2dSectorBounds) {
    ctx.setLineDash([6, 3]);
    ctx.lineWidth = 1.5;
    for (let n = 1; n <= 10; n++) {
      const ang = Math.atan2(1, n);
      const hue = (n - 1) * 36;
      ctx.strokeStyle = `hsla(${hue}, 80%, 60%, 0.6)`;
      ctx.beginPath();
      ctx.moveTo(cx, cy);
      ctx.lineTo(cx + Math.cos(ang) * maxRayR * 1.1, cy - Math.sin(ang) * maxRayR * 1.1);
      ctx.stroke();
    }
    ctx.setLineDash([]);
  }
  
  // Draw mediant lines connecting Farey neighbors
  if (ray2dMediants) {
    ctx.strokeStyle = `rgba(0,255,136,${ray2dOp})`;
    ctx.lineWidth = 1;
    // Get coprime points in first quadrant
    const fareyPts = pts2d.filter(p => p.p && p.x > 0 && p.y > 0)
      .sort((a, b) => (a.y/a.x) - (b.y/b.x));
    // Connect consecutive Farey neighbors
    for (let i = 0; i < fareyPts.length - 1; i++) {
      const p1 = fareyPts[i], p2 = fareyPts[i+1];
      // Check if they're Farey neighbors: |p1.x*p2.y - p1.y*p2.x| = 1
      if (Math.abs(p1.x * p2.y - p1.y * p2.x) === 1) {
        ctx.beginPath();
        ctx.moveTo(cx + p1.x * sc, cy - p1.y * sc);
        ctx.lineTo(cx + p2.x * sc, cy - p2.y * sc);
        ctx.stroke();
      }
    }
  }
}

const conn=document.getElementById('conn2d').value,connOp=+document.getElementById('connOp2d').value;
if(conn!=='none'&&!smithEnabled){ctx.lineWidth=1;const primPts=pts2d.filter(p=>p.p);
if(conn==='gcd1'){ctx.strokeStyle=`rgba(0,217,255,${connOp})`;for(let i=0;i<primPts.length;i++)for(let j=i+1;j<primPts.length;j++){const p1=primPts[i],p2=primPts[j],d=Math.hypot(p1.x-p2.x,p1.y-p2.y);if(d<=2){ctx.beginPath();ctx.moveTo(cx+p1.x*sc,cy-p1.y*sc);ctx.lineTo(cx+p2.x*sc,cy-p2.y*sc);ctx.stroke();}}}
else if(conn==='same'){const byGcd={};pts2d.forEach(p=>{if(!byGcd[p.g])byGcd[p.g]=[];byGcd[p.g].push(p);});Object.keys(byGcd).forEach(g=>{const ps=byGcd[g];ctx.strokeStyle=`hsla(${g*60},100%,50%,${connOp})`;for(let i=0;i<ps.length;i++)for(let j=i+1;j<ps.length;j++){const p1=ps[i],p2=ps[j],d=Math.hypot(p1.x-p2.x,p1.y-p2.y);if(d<=2){ctx.beginPath();ctx.moveTo(cx+p1.x*sc,cy-p1.y*sc);ctx.lineTo(cx+p2.x*sc,cy-p2.y*sc);ctx.stroke();}}});}
else if(conn==='radial'){ctx.strokeStyle=`rgba(255,215,0,${connOp})`;for(const p of primPts){ctx.beginPath();ctx.moveTo(cx,cy);ctx.lineTo(cx+p.x*sc,cy-p.y*sc);ctx.stroke();}}
else if(conn==='diagonal'){ctx.strokeStyle=`rgba(150,100,255,${connOp})`;const diag=pts2d.filter(p=>Math.abs(p.x)===Math.abs(p.y));for(let i=0;i<diag.length;i++)for(let j=i+1;j<diag.length;j++){const p1=diag[i],p2=diag[j];if(Math.abs(p1.x-p2.x)<=2){ctx.beginPath();ctx.moveTo(cx+p1.x*sc,cy-p1.y*sc);ctx.lineTo(cx+p2.x*sc,cy-p2.y*sc);ctx.stroke();}}}}
let prim=0,inCircCount=0,outCircCount=0;const gcds=pts2d.map(p=>p.g);
// Separate stats for circle/square/both modes
let circleTotal=0,circlePrim=0,squareTotal=0,squarePrim=0;
for(let idx=0;idx<pts2d.length;idx++){const pt=pts2d[idx];if(pt.p)prim++;
if(sh==='both'){
  const dist=Math.sqrt(pt.x*pt.x+pt.y*pt.y);
  const inCircle=dist<=R;
  pt.inCircle=inCircle;
  if(inCircle){inCircCount++;circleTotal++;if(pt.p)circlePrim++;}
  else{outCircCount++;}
  squareTotal++;if(pt.p)squarePrim++;
}else if(sh==='circle'){
  circleTotal++;if(pt.p)circlePrim++;
}else{
  squareTotal++;if(pt.p)squarePrim++;
}
let px,py;
if(smithEnabled){const theta=Math.atan2(pt.y,pt.x);const dist=Math.sqrt(pt.x*pt.x+pt.y*pt.y);let r=1;if(smithRMode==='index')r=1+(idx/pts2d.length)*2;else if(smithRMode==='dist')r=0.5+dist/(R*2);const sm=smithTransform(r,theta,smithAlpha);px=cx+sm.x*smithRad;py=cy-sm.y*smithRad;}
else{px=cx+pt.x*sc;py=cy-pt.y*sc;}
let clr;if(col==='gcd')clr={1:'#00d9ff',2:'#64c8ff',3:'#9664ff'}[pt.g]||'#ff6496';
else if(col==='dist'){const d=Math.sqrt(pt.x*pt.x+pt.y*pt.y)/R;clr=`hsl(${Math.floor((1-d)*240)},100%,50%)`;}
else if(col==='prim')clr=pt.p?'#00d9ff':'#ff6496';
else if(col==='rainbow'){const ang=Math.atan2(pt.y,pt.x);clr=`hsl(${Math.floor((ang+Math.PI)/(2*Math.PI)*360)},100%,50%)`;}
else if(col==='quadres'){const n2=(pt.x*pt.x+pt.y*pt.y)%Math.max(2,Math.ceil(R)),isQR=n2===0||[...Array(Math.ceil(R))].some((_,i)=>(i*i)%Math.max(2,Math.ceil(R))===n2);clr=isQR?'#ffd700':'#9664ff';}
else if(col==='primality'){const prod=Math.abs(pt.x*pt.y),isPr=prod>1&&[...Array(Math.floor(Math.sqrt(prod))+1)].every((_,i)=>i<2||prod%i!==0);clr=prod<=1?'#64c8ff':isPr?'#00ff88':'#ff6496';}
else if(col==='moddist'){const md=Math.min(Math.abs(pt.x),Math.abs(pt.y));clr=`hsl(${Math.floor(md/R*300)},100%,50%)`;}
else if(col==='symmetry'){const sym=Math.abs(Math.abs(pt.x)-Math.abs(pt.y));clr=sym===0?'#ffd700':`hsl(${Math.floor(sym/R*240)},80%,50%)`;}
else if(col==='heatmap'){const d=Math.sqrt(pt.x*pt.x+pt.y*pt.y)/R;clr=d<.25?'#00008b':d<.5?'#00d9ff':d<.75?'#ffff00':'#ff0000';}
else if(col==='divisibility'){const dc=[...Array(pt.g)].filter((_,i)=>i>0&&pt.g%i===0).length+1;clr=`hsl(${dc*40},100%,50%)`;}
else if(col==='discrete'){const cols=['#e6194b','#3cb44b','#ffe119','#4363d8','#f58231','#911eb4','#46f0f0','#f032e6','#bcf60c','#fabebe','#008080','#e6beff','#9a6324','#fffac8','#800000','#aaffc3','#808000','#ffd8b1','#000075','#808080'];clr=cols[(pt.g-1)%cols.length];}
else if(col==='fire'){const d=Math.sqrt(pt.x*pt.x+pt.y*pt.y)/R;clr=d<.33?`rgb(${Math.floor(d*3*255)},0,0)`:d<.66?`rgb(255,${Math.floor((d-.33)*3*255)},0)`:`rgb(255,${Math.floor(128+(d-.66)*3*127)},${Math.floor((d-.66)*3*255)})`;}
else if(col==='plasma'){const d=Math.sqrt(pt.x*pt.x+pt.y*pt.y)/R;clr=`rgb(${Math.floor(13+d*230)},${Math.floor(8+d*92+Math.sin(d*Math.PI)*100)},${Math.floor(135+d*80-d*d*150)})`;}
else if(col==='viridis'){const d=Math.sqrt(pt.x*pt.x+pt.y*pt.y)/R;clr=`rgb(${Math.floor(68+d*187)},${Math.floor(1+d*206)},${Math.floor(84-d*50+d*d*100)})`;}
else if(col==='ocean'){const d=Math.sqrt(pt.x*pt.x+pt.y*pt.y)/R;clr=`rgb(${Math.floor(d*100)},${Math.floor(50+d*150)},${Math.floor(100+d*155)})`;}
else if(col==='multtable'){const M=modM||6;const prod=((pt.x%M+M)*(pt.y%M+M))%M;clr=`hsl(${(prod/M)*360},70%,50%)`;}
else if(col==='zerodiv'){const M=modM||6;const ax=((pt.x%M)+M)%M;const ay=((pt.y%M)+M)%M;const prod=(ax*ay)%M;const isUnit=gcd(ax,M)===1&&gcd(ay,M)===1;if(prod===0&&ax!==0&&ay!==0)clr='#ff4040';else if(isUnit)clr='#3366cc';else clr='#884444';}
else if(col==='idempotent'){const M=modM||6;const ax=((pt.x%M)+M)%M;const ay=((pt.y%M)+M)%M;const isIdempX=(ax*ax)%M===ax;const isIdempY=(ay*ay)%M===ay;clr=(isIdempX||isIdempY)?'#ffd700':'#555';}
else if(col==='fareysector'){
  // Farey Sector: partition by angle into sectors S_n between arctan(1/n) and arctan(1/(n-1))
  const ang = Math.atan2(Math.abs(pt.y), Math.abs(pt.x)); // 0 to π/2
  const sectorColors = ['#ff6496','#ffd700','#00ff88','#00d9ff','#9664ff','#ff8c00','#ff00ff','#00ffff','#88ff00','#ff4444'];
  let sector = 1;
  for(let n=1; n<=10; n++){
    const lo = Math.atan2(1, n);   // arctan(1/n)
    const hi = n===1 ? Math.PI/2 : Math.atan2(1, n-1); // arctan(1/(n-1))
    if(ang >= lo && ang < hi){ sector = n; break; }
  }
  if(ang < Math.atan2(1,10)) sector = 10; // beyond S_10
  clr = sectorColors[(sector-1) % sectorColors.length];
  // Highlight primitives brighter
  if(pt.p) clr = clr.replace(')', ',1)').replace('rgb','rgba').replace('#','');
  if(pt.p && clr.startsWith('#')) { /* keep bright */ } else if(!pt.p) { clr = clr + '88'; }
}
else clr=pt.p?'#00d9ff':'#ff6496';

// Visibility from custom observer position
const visOX = +document.getElementById('vis2dX')?.value || 0;
const visOY = +document.getElementById('vis2dY')?.value || 0;
const visRays = document.getElementById('vis2dRays')?.checked;
const visOrchard = document.getElementById('vis2dOrchard')?.checked;
if (visOX !== 0 || visOY !== 0) {
  const dx = pt.x - visOX, dy = pt.y - visOY;
  if (dx === 0 && dy === 0) {
    clr = '#ff00ff'; // Observer position
  } else {
    const visFromObs = gcd(Math.abs(dx), Math.abs(dy)) === 1;
    if (!visFromObs) clr = 'rgba(80,80,80,0.4)';
    else if (!pt.p) clr = '#ffd700'; // Visible but not primitive from origin
  }
}

// Pick's polygon highlighting
if (picksMode && picksPolygon.length >= 3) {
  if (pointInPolygon(pt.x, pt.y, picksPolygon)) {
    clr = '#00ff88'; // Inside polygon
  }
}

// Modular overlay coloring (overrides if enabled)
if(modEnabled){
let modVal;
if(modColBy==='sum')modVal=((pt.x%modM+modM)+(pt.y%modM+modM))%modM;
else if(modColBy==='product')modVal=((pt.x%modM+modM)*(pt.y%modM+modM))%modM;
else if(modColBy==='diff')modVal=Math.abs((pt.x%modM+modM)-(pt.y%modM+modM))%modM;
else if(modColBy==='gcdmod')modVal=pt.g%modM;
else if(modColBy==='coprime'){modVal=gcd(Math.abs(pt.x)+Math.abs(pt.y),modM)===1?1:0;}
else modVal=0;
if(modColBy==='coprime'){clr=modVal===1?'#00ff88':'#ff4040';}
else{clr=`hsl(${(modVal/modM)*360},75%,55%)`;}}

if(sh==='both'&&!pt.inCircle){clr=isDark()?'rgba(255,100,150,0.4)':'rgba(200,50,100,0.4)';}
ctx.fillStyle=clr;ctx.beginPath();ctx.arc(px,py,ptSz,0,2*Math.PI);ctx.fill();
if(lbl!=='none'){
ctx.fillStyle=isDark()?'rgba(0,217,255,0.9)':'rgba(0,102,204,0.9)';ctx.font=`bold ${lblsz}px Arial`;ctx.textAlign='center';
let lblText='';
if(lbl==='coords')lblText=`(${pt.x},${pt.y})`;
else if(lbl==='gcd')lblText=pt.g;
else if(lbl==='dist')lblText=fmt(Math.sqrt(pt.x*pt.x+pt.y*pt.y));
else if(lbl==='angle'){const ang=Math.atan2(pt.y,pt.x)*180/Math.PI;lblText=Math.round(ang)+'°';}
else if(lbl==='rad'){const ang=Math.atan2(pt.y,pt.x);const piF=ang/Math.PI;lblText=Math.abs(piF)<0.01?'0':Math.abs(piF-1)<0.01?'π':Math.abs(piF+1)<0.01?'-π':fmt(piF)+'π';}
else if(lbl==='coprime')lblText=pt.p?'OK':'X';
else if(lbl==='norm')lblText=pt.x*pt.x+pt.y*pt.y;
else if(lbl==='sum')lblText=pt.x+pt.y;
else if(lbl==='product')lblText=pt.x*pt.y;
else if(lbl==='farey'){if(pt.y===0)lblText=pt.x>=0?'∞':'-∞';else{const g2=gcd(Math.abs(pt.x),Math.abs(pt.y));lblText=(pt.x/g2)+'/'+(pt.y/g2);}}
if(lblText!=='')ctx.fillText(lblText,px,py-7*zm);}}
if(smithEnabled){ctx.fillStyle=isDark()?'#ffd700':'#cc8800';ctx.font='12px Segoe UI';ctx.fillText('Smith Chart: Γ = (z-1)/(z+1)',10,20);ctx.fillText(`α = ${smithAlpha}°`,10,35);}
const tot=pts2d.length,th=theory(R,2),err=Math.abs(prim-th),relE=th>0?err/th*100:0,z2=zeta(2);
if(sh==='both'){legend('al2d','Square + Circle Comparison',[['In Circle',inCircCount,'#ff8c00'],['Outside',outCircCount,'#9664ff'],['Circle Ratio',fmt(100*inCircCount/tot)+'%','#ff8c00']]);
document.getElementById('st2d').innerHTML='';}
else{legend('al2d',smithEnabled?'Smith Chart':'2D Lattice',[['1/ζ(2) Pred',fmt(tot/z2),'#9664ff'],['Theory',fmt(th),'#ff8c00'],['Error',fmt(err),'#ff006e']]);
document.getElementById('st2d').innerHTML='';}
const gcdDist={};gcds.forEach(g=>{gcdDist[g]=(gcdDist[g]||0)+1;});const gcdKeys=Object.keys(gcdDist).sort((a,b)=>+a-+b);
const baselRatio=z2>0?(prim/tot)/(1/z2):0;
document.getElementById('stats2dLive').innerHTML=`
<div style="background:linear-gradient(135deg,rgba(0,217,255,.15),rgba(255,215,0,.1));padding:10px;border-radius:8px;margin-bottom:12px;border:1px solid var(--acc)">
<div style="font-size:.7rem;color:var(--txt2);margin-bottom:4px">TAB: 2D Lattice | FIELD: ℤ² | TYPE: Primitive Lattice Points</div>
<div style="display:grid;grid-template-columns:repeat(4,1fr);gap:6px;font-size:.75rem">
<span>R: <strong style="color:#00d9ff">${R}</strong></span>
<span>Shape: <strong style="color:#ffd700">${sh}</strong></span>
<span>Color: <strong style="color:#00ff88">${col}</strong></span>
<span>Zoom: <strong style="color:#ff6496">${zm}x</strong></span>
</div>
</div>
<div style="display:grid;grid-template-columns:repeat(3,1fr);gap:8px;margin-bottom:12px">
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center"><div style="font-size:1.5rem;font-weight:bold;color:#00d9ff">${R}</div><div style="font-size:.75rem;color:var(--txt2)">RADIUS R</div></div>
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center"><div style="font-size:1.5rem;font-weight:bold;color:#ffd700">${tot}</div><div style="font-size:.75rem;color:var(--txt2)">TOTAL POINTS</div></div>
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center"><div style="font-size:1.5rem;font-weight:bold;color:#00ff88">${prim}</div><div style="font-size:.75rem;color:var(--txt2)">PRIMITIVE</div></div>
</div>
<div style="display:grid;grid-template-columns:repeat(3,1fr);gap:8px;margin-bottom:12px">
<div style="background:var(--bg1);padding:8px;border-radius:6px;text-align:center"><div style="font-size:1.1rem;font-weight:bold;color:#9664ff">${fmt(th)}</div><div style="font-size:.65rem;color:var(--txt2)">PREDICTED</div></div>
<div style="background:var(--bg1);padding:8px;border-radius:6px;text-align:center"><div style="font-size:1.1rem;font-weight:bold;color:#ff8c00">${fmt(tot/z2)}</div><div style="font-size:.65rem;color:var(--txt2)">BASEL PRED</div></div>
<div style="background:var(--bg1);padding:8px;border-radius:6px;text-align:center"><div style="font-size:1.1rem;font-weight:bold;color:${err<5?'#00ff88':'#ff6496'}">${fmt(err)}</div><div style="font-size:.65rem;color:var(--txt2)">ERROR</div></div>
</div>
${sh==='both'?`<div style="margin-bottom:12px;padding:12px;background:rgba(255,136,0,.1);border-radius:8px;border:2px solid rgba(255,136,0,.3)">
<strong style="color:#ff8c00">Circle Statistics (r ≤ R)</strong>
<div style="display:grid;grid-template-columns:repeat(3,1fr);gap:8px;margin:8px 0">
<div style="background:var(--bg1);padding:6px;border-radius:4px;text-align:center"><div style="font-size:1rem;font-weight:bold;color:#ff8c00">${inCircCount}</div><div style="font-size:.6rem;color:var(--txt2)">TOTAL</div></div>
<div style="background:var(--bg1);padding:6px;border-radius:4px;text-align:center"><div style="font-size:1rem;font-weight:bold;color:#00ff88">${circlePrim}</div><div style="font-size:.6rem;color:var(--txt2)">PRIMITIVE</div></div>
<div style="background:var(--bg1);padding:6px;border-radius:4px;text-align:center"><div style="font-size:1rem;font-weight:bold;color:#ffd700">${inCircCount>0?fmt(100*circlePrim/inCircCount):'0'}%</div><div style="font-size:.6rem;color:var(--txt2)">DENSITY</div></div>
</div>
<div style="font-size:.7rem;color:var(--txt2)">Area: πR² ≈ ${fmt(Math.PI*R*R)} | Theory: ${fmt(Math.round(Math.PI*R*R/zeta(2)))} prims</div>
</div>
<div style="margin-bottom:12px;padding:12px;background:rgba(150,100,255,.1);border-radius:8px;border:2px solid rgba(150,100,255,.3)">
<strong style="color:#9664ff">Square Statistics (|x|,|y| ≤ R)</strong>
<div style="display:grid;grid-template-columns:repeat(3,1fr);gap:8px;margin:8px 0">
<div style="background:var(--bg1);padding:6px;border-radius:4px;text-align:center"><div style="font-size:1rem;font-weight:bold;color:#9664ff">${tot}</div><div style="font-size:.6rem;color:var(--txt2)">TOTAL</div></div>
<div style="background:var(--bg1);padding:6px;border-radius:4px;text-align:center"><div style="font-size:1rem;font-weight:bold;color:#00ff88">${prim}</div><div style="font-size:.6rem;color:var(--txt2)">PRIMITIVE</div></div>
<div style="background:var(--bg1);padding:6px;border-radius:4px;text-align:center"><div style="font-size:1rem;font-weight:bold;color:#ffd700">${fmt(100*prim/tot)}%</div><div style="font-size:.6rem;color:var(--txt2)">DENSITY</div></div>
</div>
<div style="font-size:.7rem;color:var(--txt2)">Area: (2R+1)² = ${(2*Math.ceil(R)+1)**2} | Theory: ${fmt(th)} prims</div>
</div>
<div style="margin-bottom:12px;padding:12px;background:rgba(0,217,255,.1);border-radius:8px;border:2px solid rgba(0,217,255,.3)">
<strong style="color:#00d9ff">Comparison: Circle vs Square</strong>
<div style="display:grid;grid-template-columns:1fr 1fr;gap:4px;margin-top:6px;font-size:.8rem">
<span>In Circle:</span><span style="color:#ff8c00;font-weight:bold">${inCircCount} (${fmt(100*inCircCount/tot)}%)</span>
<span>Outside Circle:</span><span style="color:#9664ff;font-weight:bold">${outCircCount} (${fmt(100*outCircCount/tot)}%)</span>
<span>Circle/Square Ratio:</span><span style="color:#00d9ff">${fmt(inCircCount/tot)}</span>
<span>π/4 (expected):</span><span style="color:#ffd700">${fmt(Math.PI/4)}</span>
<span>Difference:</span><span style="color:${Math.abs(inCircCount/tot-Math.PI/4)<0.02?'#00ff88':'#ff6496'}">${fmt(Math.abs(inCircCount/tot-Math.PI/4))} (${fmt(Math.abs(100*inCircCount/tot-Math.PI/4*100))}%)</span>
<span>Circle Prim Density:</span><span style="color:#ff8c00">${inCircCount>0?fmt(100*circlePrim/inCircCount):'0'}%</span>
<span>Square Prim Density:</span><span style="color:#9664ff">${fmt(100*prim/tot)}%</span>
</div>
</div>`:''}
<div style="margin-bottom:12px;padding-bottom:10px;border-bottom:1px solid var(--bord)">
<strong style="color:var(--acc)">Configuration</strong>
<div style="display:grid;grid-template-columns:1fr 1fr;gap:4px;margin-top:6px;font-size:.8rem">
<span>Shape:</span><span style="color:var(--txt)">${sh==='circle'?'Circle':sh==='square'?'Square':'Both'}</span>
<span>Color Mode:</span><span style="color:var(--txt)">${col}</span>
<span>Zoom Level:</span><span style="color:var(--txt)">${zm}x</span>
<span>Point Size:</span><span style="color:var(--txt)">${ptSz}px</span>
${smithEnabled?`<span>Smith Chart:</span><span style="color:#00ff88">ON (α=${smithAlpha}°)</span>`:`<span>Smith Chart:</span><span style="color:#ff6496">OFF</span>`}
</div>
</div>
<div style="margin-bottom:12px;padding-bottom:10px;border-bottom:1px solid var(--bord)">
<strong style="color:var(--acc)">Basel Problem Analysis</strong>
<div style="display:grid;grid-template-columns:1fr 1fr;gap:4px;margin-top:6px;font-size:.8rem">
<span>Coprime Density:</span><span style="color:#ffd700;font-weight:bold">${fmt(100*prim/tot)}%</span>
<span>Basel Limit (6/π²):</span><span style="color:#9664ff">${fmt(100/z2)}%</span>
<span>Ratio to Basel:</span><span style="color:${baselRatio>0.95&&baselRatio<1.05?'#00ff88':'#ff8c00'}">${fmt(baselRatio*100)}%</span>
<span>Predicted Count:</span><span style="color:#9664ff">${fmt(tot/z2)}</span>
<span>Theory (2D):</span><span style="color:#ff8c00">${fmt(th)}</span>
<span>Abs Error:</span><span style="color:${err<5?'#00ff88':'#ff6496'}">${fmt(err)}</span>
</div>
</div>
<div style="margin-bottom:12px;padding-bottom:10px;border-bottom:1px solid var(--bord)">
<strong style="color:var(--acc)">GCD Distribution</strong>
<div style="display:grid;grid-template-columns:1fr 1fr;gap:4px;margin-top:6px;font-size:.8rem">
<span>Min GCD:</span><span style="color:var(--txt)">${gcds.reduce((a,b)=>Math.min(a,b),Infinity)}</span>
<span>Max GCD:</span><span style="color:var(--txt)">${gcds.reduce((a,b)=>Math.max(a,b),0)}</span>
<span>Avg GCD:</span><span style="color:var(--txt)">${fmt(gcds.reduce((a,b)=>a+b,0)/tot)}</span>
<span>Unique GCDs:</span><span style="color:var(--txt)">${gcdKeys.length}</span>
</div>
<div style="margin-top:8px;font-size:.75rem">
${gcdKeys.slice(0,6).map(g=>`<span style="display:inline-block;padding:2px 6px;margin:2px;border-radius:3px;background:${+g===1?'#ffd700':+g===2?'#00d9ff':'#9664ff'};color:#000;font-weight:bold">GCD=${g}: ${gcdDist[g]}</span>`).join('')}
${gcdKeys.length>6?'<span style="color:var(--txt2)">...</span>':''}
</div>
</div>
${singularSeriesHTML(Math.max(2,Math.round(R)), 2, 'Modular Sieve (R as M)')}
${fareySectorStatsHTML2D(pts2d, R)}
<div>
<strong style="color:var(--acc)">Quick Properties</strong>
<div style="margin-top:6px;font-size:.8rem;line-height:1.6">
• Area covered: ${sh==='circle'?`πR² ≈ ${fmt(Math.PI*R*R)}`:`(2R+1)² = ${(2*Math.ceil(R)+1)**2}`}<br>
• Points per unit area: ${fmt(tot/(sh==='circle'?Math.PI*R*R:(2*R+1)**2))}<br>
• Primitive per unit: ${fmt(prim/(sh==='circle'?Math.PI*R*R:(2*R+1)**2))}<br>
• ζ(2) = π²/6 ≈ ${fmt(z2)}
</div>
</div>`;

// Render 2D Lattice Charts
render2DCharts(pts2d, R, prim, tot, gcdDist, sh);

// Update Farey Sector Analysis stats
if (document.getElementById('sec2dStats')) {
  const secFromVal = +document.getElementById('sec2dFrom')?.value || 3;
  const secToVal = +document.getElementById('sec2dTo')?.value || 2;
  const angLoRad = Math.atan2(1, secFromVal);
  const angHiRad = Math.atan2(1, secToVal);
  const angLoDeg = angLoRad * 180 / Math.PI;
  const angHiDeg = angHiRad * 180 / Math.PI;
  
  // Count points in sector (first quadrant only, angles from x-axis)
  let sectorPrims = 0, sectorTotal = 0;
  for (const pt of pts2d) {
    if (pt.x > 0 && pt.y >= 0) {
      const ang = Math.atan2(pt.y, pt.x);
      if (ang >= angLoRad && ang <= angHiRad) {
        sectorTotal++;
        if (pt.p) sectorPrims++;
      }
    }
  }
  
  // Calculate asymptotic prediction: C(n,N) ≈ 3N²/(π²·n(n+1))
  const n = secToVal;
  const asymp = Math.round(3 * R * R / (Math.PI * Math.PI * n * (n + 1)));
  const absErr = Math.abs(sectorPrims - asymp);
  const relErr = asymp > 0 ? (absErr / asymp * 100) : 0;
  const ci95 = Math.round(1.96 * Math.sqrt(asymp)); // 95% confidence interval
  
  // Rating based on relative error
  let rating = '—';
  if (asymp > 0) {
    if (relErr < 5) rating = 'Excellent';
    else if (relErr < 15) rating = 'Good';
    else if (relErr < 30) rating = 'Fair';
    else rating = 'Poor';
  }
  
  // Root of sector (mediant of boundaries)
  const rootNum = 2;
  const rootDen = 2 * n + 1;
  
  document.getElementById('sec2dCoprime').textContent = sectorPrims;
  document.getElementById('sec2dAsymp').textContent = asymp;
  document.getElementById('sec2dTotal').textContent = sectorTotal;
  document.getElementById('sec2dAbsErr').textContent = absErr;
  document.getElementById('sec2dRelErr').textContent = relErr.toFixed(1) + '%';
  document.getElementById('sec2dRelErr').style.color = relErr < 15 ? '#00ff88' : relErr < 30 ? '#ffd700' : '#ff6496';
  document.getElementById('sec2dCI').textContent = '±' + ci95;
  document.getElementById('sec2dRating').textContent = rating;
  document.getElementById('sec2dRating').style.color = rating === 'Excellent' ? '#00ff88' : rating === 'Good' ? '#ffd700' : rating === 'Fair' ? '#ff8c00' : '#ff6496';
  document.getElementById('sec2dWidth').textContent = (angHiDeg - angLoDeg).toFixed(1) + '°';
  document.getElementById('sec2dAngLo').textContent = angLoDeg.toFixed(1) + '°';
  document.getElementById('sec2dAngHi').textContent = angHiDeg.toFixed(1) + '°';
  document.getElementById('sec2dRoot').textContent = rootNum + '/' + rootDen;
  
  // Update sector label
  const statsDiv = document.getElementById('sec2dStats');
  const labelDiv = statsDiv.querySelector('div');
  if (labelDiv) labelDiv.innerHTML = `<span style="color:#9664ff;font-weight:bold">Sector S<sub>${secToVal}</sub>: 1/${secFromVal} → 1/${secToVal} (${angLoDeg.toFixed(1)}° – ${angHiDeg.toFixed(1)}°)</span>`;
}

// Draw visibility rays from custom observer
const visRaysEnabled = document.getElementById('vis2dRays')?.checked;
const visOXdraw = +document.getElementById('vis2dX')?.value || 0;
const visOYdraw = +document.getElementById('vis2dY')?.value || 0;
if (visRaysEnabled && !smithEnabled) {
  const obsPx = cx + visOXdraw * sc;
  const obsPy = cy - visOYdraw * sc;
  ctx.strokeStyle = 'rgba(255,215,0,0.2)';
  ctx.lineWidth = 1;
  for (const pt of pts2d) {
    const dx = pt.x - visOXdraw, dy = pt.y - visOYdraw;
    if (dx === 0 && dy === 0) continue;
    if (gcd(Math.abs(dx), Math.abs(dy)) === 1) {
      ctx.beginPath();
      ctx.moveTo(obsPx, obsPy);
      ctx.lineTo(cx + pt.x * sc, cy - pt.y * sc);
      ctx.stroke();
    }
  }
  // Mark observer position
  ctx.fillStyle = '#ff00ff';
  ctx.beginPath();
  ctx.arc(obsPx, obsPy, 8, 0, 2 * Math.PI);
  ctx.fill();
  ctx.fillStyle = '#fff';
  ctx.font = 'bold 10px Segoe UI';
  ctx.textAlign = 'center';
  ctx.fillText('O', obsPx, obsPy + 3);
}

// Draw Pick's polygon
if (picksMode && picksPolygon.length > 0 && !smithEnabled) {
  ctx.strokeStyle = '#00ff88';
  ctx.lineWidth = 2;
  ctx.fillStyle = 'rgba(0,255,136,0.15)';
  if (picksPolygon.length >= 3) {
    ctx.beginPath();
    ctx.moveTo(cx + picksPolygon[0].x * sc, cy - picksPolygon[0].y * sc);
    for (let i = 1; i < picksPolygon.length; i++) {
      ctx.lineTo(cx + picksPolygon[i].x * sc, cy - picksPolygon[i].y * sc);
    }
    ctx.closePath();
    ctx.fill();
    ctx.stroke();
  } else if (picksPolygon.length >= 1) {
    ctx.beginPath();
    ctx.moveTo(cx + picksPolygon[0].x * sc, cy - picksPolygon[0].y * sc);
    for (let i = 1; i < picksPolygon.length; i++) {
      ctx.lineTo(cx + picksPolygon[i].x * sc, cy - picksPolygon[i].y * sc);
    }
    ctx.stroke();
  }
  // Draw vertices
  for (const v of picksPolygon) {
    ctx.fillStyle = '#ffd700';
    ctx.beginPath();
    ctx.arc(cx + v.x * sc, cy - v.y * sc, 6, 0, 2 * Math.PI);
    ctx.fill();
    ctx.fillStyle = '#000';
    ctx.font = '8px Segoe UI';
    ctx.textAlign = 'center';
    ctx.fillText(`(${v.x},${v.y})`, cx + v.x * sc, cy - v.y * sc - 10);
  }
}

c.onclick=e=>{const rect=c.getBoundingClientRect(),mx=(e.clientX-rect.left)*(c.width/rect.width),my=(e.clientY-rect.top)*(c.height/rect.height);
// Pick's mode: add vertex on click
if (picksMode && !smithEnabled) {
  const clickX = Math.round((mx - cx) / sc);
  const clickY = Math.round((cy - my) / sc);
  addPicksVertex(clickX, clickY);
  return;
}
for(let idx=0;idx<pts2d.length;idx++){const pt=pts2d[idx];let px,py;if(smithEnabled){const theta=Math.atan2(pt.y,pt.x);const dist=Math.sqrt(pt.x*pt.x+pt.y*pt.y);let r=1;if(smithRMode==='index')r=1+(idx/pts2d.length)*2;else if(smithRMode==='dist')r=0.5+dist/(R*2);const sm=smithTransform(r,theta,smithAlpha);px=cx+sm.x*smithRad;py=cy-sm.y*smithRad;}else{px=cx+pt.x*sc;py=cy-pt.y*sc;}if(Math.hypot(mx-px,my-py)<12){const theta=Math.atan2(pt.y,pt.x);const sm=smithEnabled?smithTransform(1,theta,smithAlpha):{x:0,y:0};modal('2D Point Analysis',[['Coordinates',`(${pt.x}, ${pt.y})`],['GCD(x,y)',pt.g],['Primitive',pt.p?'Yes':'No'],['Distance',Math.sqrt(pt.x*pt.x+pt.y*pt.y)],['θ (radians)',theta.toFixed(4)],smithEnabled?['Γ (Smith)',`${sm.x.toFixed(4)} + ${sm.y.toFixed(4)}i`]:['Norm',pt.x*pt.x+pt.y*pt.y]]);break;}}};
}catch(e){console.error('draw2D error:',e);}}
function exp2D(){const c=document.getElementById('c2d');c.toBlob(b=>{const a=document.createElement('a');a.href=URL.createObjectURL(b);a.download='mobius_2d.png';a.click();});}
function csv2D(){let s='x,y,gcd,primitive\n';for(const p of pts2d)s+=`${p.x},${p.y},${p.g},${p.p}\n`;dl(s,'mobius_2d.csv');}

// 2D Lattice Chart Rendering
function render2DCharts(pts, R, primCount, totalCount, gcdDist, shape) {
  const z2 = Math.PI * Math.PI / 6;
  
  // 1. GCD Distribution histogram
  const gcdKeys = Object.keys(gcdDist).map(Number).sort((a,b) => a - b);
  const gcdValues = gcdKeys.map(k => gcdDist[k]);
  if (document.getElementById('p2dGCD')) {
    Plotly.newPlot('p2dGCD', [{
      x: gcdKeys.slice(0, 20),
      y: gcdValues.slice(0, 20),
      type: 'bar',
      marker: { color: gcdKeys.slice(0, 20).map(g => g === 1 ? '#ffd700' : g === 2 ? '#00d9ff' : '#9664ff') }
    }], {
      paper_bgcolor: 'transparent', plot_bgcolor: 'transparent',
      margin: { t: 20, r: 20, b: 40, l: 50 },
      xaxis: { title: 'GCD', color: '#888', gridcolor: '#333' },
      yaxis: { title: 'Count', color: '#888', gridcolor: '#333' },
      font: { color: '#ccc' }
    }, { responsive: true, displayModeBar: false });
    legend('al2dGCD', 'GCD Stats', [
      ['GCD=1 (Primitive)', primCount, '#ffd700'],
      ['GCD>1 (Non-primitive)', totalCount - primCount, '#9664ff'],
      ['Unique GCDs', gcdKeys.length, '#00d9ff']
    ]);
  }
  
  // 2. Convergence chart - primitive ratio at different radii
  const radii = [], ratios = [], predicted = [];
  for (let r = 1; r <= Math.min(R, 50); r++) {
    let primR = 0, totR = 0;
    for (const pt of pts) {
      const dist = Math.sqrt(pt.x * pt.x + pt.y * pt.y);
      if ((shape === 'circle' && dist <= r) || (shape !== 'circle' && Math.abs(pt.x) <= r && Math.abs(pt.y) <= r)) {
        totR++;
        if (pt.p) primR++;
      }
    }
    if (totR > 0) {
      radii.push(r);
      ratios.push(primR / totR);
      predicted.push(6 / (Math.PI * Math.PI));
    }
  }
  if (document.getElementById('p2dConv') && radii.length > 0) {
    Plotly.newPlot('p2dConv', [
      { x: radii, y: ratios, type: 'scatter', mode: 'lines+markers', name: 'Observed', line: { color: '#ffd700' }, marker: { size: 4 } },
      { x: radii, y: predicted, type: 'scatter', mode: 'lines', name: '6/π² ≈ 0.608', line: { color: '#ff6496', dash: 'dash' } }
    ], {
      paper_bgcolor: 'transparent', plot_bgcolor: 'transparent',
      margin: { t: 20, r: 20, b: 40, l: 50 },
      xaxis: { title: 'Radius R', color: '#888', gridcolor: '#333' },
      yaxis: { title: 'Primitive Ratio', color: '#888', gridcolor: '#333', range: [0.5, 0.7] },
      font: { color: '#ccc' }, showlegend: true, legend: { x: 0.7, y: 0.1 }
    }, { responsive: true, displayModeBar: false });
    legend('al2dConv', 'Convergence', [
      ['Final Ratio', (primCount / totalCount).toFixed(6), '#ffd700'],
      ['Target 6/π²', (6 / z2).toFixed(6), '#ff6496'],
      ['Error', ((primCount / totalCount - 6 / z2) * 100).toFixed(3) + '%', '#00d9ff']
    ]);
  }
  
  // 3. Radial distribution
  const maxDist = Math.ceil(R);
  const radialBins = new Array(maxDist + 1).fill(0);
  const radialPrims = new Array(maxDist + 1).fill(0);
  for (const pt of pts) {
    const dist = Math.floor(Math.sqrt(pt.x * pt.x + pt.y * pt.y));
    if (dist <= maxDist) {
      radialBins[dist]++;
      if (pt.p) radialPrims[dist]++;
    }
  }
  if (document.getElementById('p2dRadial')) {
    const radialX = Array.from({ length: maxDist + 1 }, (_, i) => i);
    Plotly.newPlot('p2dRadial', [
      { x: radialX, y: radialBins, type: 'bar', name: 'Total', marker: { color: '#00d9ff' } },
      { x: radialX, y: radialPrims, type: 'bar', name: 'Primitive', marker: { color: '#ffd700' } }
    ], {
      paper_bgcolor: 'transparent', plot_bgcolor: 'transparent',
      margin: { t: 20, r: 20, b: 40, l: 50 },
      xaxis: { title: 'Distance from Origin', color: '#888', gridcolor: '#333' },
      yaxis: { title: 'Point Count', color: '#888', gridcolor: '#333' },
      font: { color: '#ccc' }, barmode: 'overlay', showlegend: true, legend: { x: 0.7, y: 0.95 }
    }, { responsive: true, displayModeBar: false });
  }
  
  // 4. Angular distribution (first quadrant)
  const angularBins = new Array(18).fill(0); // 5-degree bins
  const angularPrims = new Array(18).fill(0);
  for (const pt of pts) {
    if (pt.x > 0 || pt.y > 0) {
      const ang = Math.atan2(Math.abs(pt.y), Math.abs(pt.x)) * 180 / Math.PI;
      const bin = Math.min(17, Math.floor(ang / 5));
      angularBins[bin]++;
      if (pt.p) angularPrims[bin]++;
    }
  }
  if (document.getElementById('p2dAngular')) {
    const angLabels = Array.from({ length: 18 }, (_, i) => `${i * 5}°`);
    Plotly.newPlot('p2dAngular', [
      { x: angLabels, y: angularBins, type: 'bar', name: 'Total', marker: { color: '#9664ff' } },
      { x: angLabels, y: angularPrims, type: 'bar', name: 'Primitive', marker: { color: '#00ff88' } }
    ], {
      paper_bgcolor: 'transparent', plot_bgcolor: 'transparent',
      margin: { t: 20, r: 20, b: 40, l: 50 },
      xaxis: { title: 'Angle θ (First Quadrant)', color: '#888', gridcolor: '#333' },
      yaxis: { title: 'Point Count', color: '#888', gridcolor: '#333' },
      font: { color: '#ccc' }, barmode: 'group', showlegend: true, legend: { x: 0.7, y: 0.95 }
    }, { responsive: true, displayModeBar: false });
  }
  
  // 5. Data table
  const tableEl = document.getElementById('t2dTable');
  if (tableEl) {
    let tableHTML = '<tr><th>R</th><th>Total</th><th>Primitive</th><th>Ratio</th><th>6/π² Pred</th><th>Error %</th></tr>';
    for (let r = 1; r <= Math.min(R, 20); r++) {
      let primR = 0, totR = 0;
      for (const pt of pts) {
        const dist = Math.sqrt(pt.x * pt.x + pt.y * pt.y);
        if ((shape === 'circle' && dist <= r) || (shape !== 'circle' && Math.abs(pt.x) <= r && Math.abs(pt.y) <= r)) {
          totR++;
          if (pt.p) primR++;
        }
      }
      const ratio = totR > 0 ? primR / totR : 0;
      const target = 6 / z2;
      const err = totR > 0 ? Math.abs(ratio - target) / target * 100 : 0;
      tableHTML += `<tr onclick="modal('R=${r} Analysis',[['Total Points',${totR}],['Primitive',${primR}],['Ratio','${ratio.toFixed(6)}'],['Error','${err.toFixed(2)}%']])" style="cursor:pointer"><td>${r}</td><td>${totR}</td><td>${primR}</td><td>${ratio.toFixed(4)}</td><td>${target.toFixed(4)}</td><td style="color:${err < 5 ? '#00ff88' : err < 15 ? '#ffd700' : '#ff6496'}">${err.toFixed(2)}%</td></tr>`;
    }
    tableEl.innerHTML = tableHTML;
  }
}

// Pick's Theorem Mode
let picksPolygon = [];
let picksMode = false;

// 2D/3D Collapsible section toggles
// Reference page collapsible sections
function toggleRefSection(sectionId) {
  const section = document.getElementById(sectionId);
  const icon = document.getElementById(sectionId + 'Icon');
  if (!section) return;
  const isHidden = section.style.display === 'none';
  section.style.display = isHidden ? 'block' : 'none';
  if (icon) icon.textContent = isHidden ? '−' : '+';
}

function toggleAllRefSections(action) {
  const sectionIds = ['refSecWessen', 'refSecCredits', 'refSecTools', 'refSecTheorems', 'refSecReferences', 'refSecAcknowledgments', 'refSecSupport', 'refSecFeatures', 'refSecAbout'];
  sectionIds.forEach(id => {
    const section = document.getElementById(id);
    const icon = document.getElementById(id + 'Icon');
    if (section) {
      section.style.display = action === 'expand' ? 'block' : 'none';
      if (icon) icon.textContent = action === 'expand' ? '−' : '+';
    }
  });
}

// Toggle 2D Screenshot options panel
function toggle2DSSOptions() {
  const panel = document.getElementById('ss2dOpts');
  if (panel) panel.style.display = panel.style.display === 'none' ? 'block' : 'none';
}

// Select all/none for 2D screenshot options
function ss2dSelectAll(select) {
  ['ss2dTitle','ss2dCanvas','ss2dLegend','ss2dStatsGrid','ss2dStats','ss2dGCD','ss2dGCDLegend','ss2dConv','ss2dConvLegend','ss2dRadial','ss2dAngular','ss2dSector','ss2dPicks','ss2dTable','ss2dTheory'].forEach(id => {
    const cb = document.getElementById(id);
    if (cb) cb.checked = select;
  });
}

// Reset to defaults for 2D screenshot options
function ss2dSelectDefaults() {
  ['ss2dTitle','ss2dCanvas','ss2dLegend','ss2dStatsGrid','ss2dStats','ss2dGCD','ss2dGCDLegend','ss2dConv','ss2dConvLegend'].forEach(id => {
    const cb = document.getElementById(id);
    if (cb) cb.checked = true;
  });
  ['ss2dRadial','ss2dAngular','ss2dSector','ss2dPicks','ss2dTable','ss2dTheory'].forEach(id => {
    const cb = document.getElementById(id);
    if (cb) cb.checked = false;
  });
}

// Toggle Enhanced Screenshot options panel
function toggleEnhSSOptions() {
  const panel = document.getElementById('ssEnhOpts');
  if (panel) panel.style.display = panel.style.display === 'none' ? 'block' : 'none';
}

// Select all/none for Enhanced screenshot options
function ssEnhSelectAll(select) {
  // All checkbox IDs
  const allIds = [
    // Canvases
    'ssEnhMainCanvas','ssEnhLegend','ssEnhTree','ssEnhIncludeArnold','ssEnhFreqDist',
    // Live Stats sections
    'ssStatsModeHeader','ssStatsPrimaryCounts','ssStatsDensity','ssStatsHighlightSector',
    'ssStatsSBSectors','ssStatsErrorTable','ssStatsCircleHalves','ssStatsQuadrants',
    'ssStatsModSieve','ssStatsGapCounts','ssStatsRingPhi',
    // Point Details sections
    'ssPointBasicInfo','ssPointHarmonics','ssPointMusical','ssPointFrequency','ssPointNeighbors',
    // Tree & Analysis
    'ssEnhTreeStats','ssEnhTreePath','ssEnhFarey','ssEnhFareyLegend',
    // Additional Panels
    'ssEnhTracker','ssEnhTrajectory','ssEnhMultTable','ssEnhTimestamp','ssEnhAuthor'
  ];
  allIds.forEach(id => {
    const cb = document.getElementById(id);
    if (cb) cb.checked = select;
  });
}

// Reset to defaults for Enhanced screenshot options
function ssEnhSelectDefaults() {
  // Default ON
  const defaultOn = [
    'ssEnhMainCanvas','ssEnhLegend','ssEnhTree',
    'ssStatsModeHeader','ssStatsPrimaryCounts','ssStatsDensity','ssStatsHighlightSector',
    'ssStatsSBSectors','ssStatsErrorTable','ssStatsCircleHalves','ssStatsQuadrants',
    'ssStatsModSieve','ssStatsGapCounts','ssStatsRingPhi',
    'ssPointBasicInfo','ssPointHarmonics',
    'ssEnhTreeStats','ssEnhTreePath','ssEnhFarey','ssEnhFareyLegend',
    'ssEnhTimestamp','ssEnhAuthor'
  ];
  // Default OFF
  const defaultOff = [
    'ssEnhIncludeArnold','ssEnhFreqDist',
    'ssPointMusical','ssPointFrequency','ssPointNeighbors',
    'ssEnhTracker','ssEnhTrajectory','ssEnhMultTable'
  ];
  defaultOn.forEach(id => {
    const cb = document.getElementById(id);
    if (cb) cb.checked = true;
  });
  defaultOff.forEach(id => {
    const cb = document.getElementById(id);
    if (cb) cb.checked = false;
  });
}

// Minimal selection - just canvas and basic stats
function ssEnhSelectMinimal() {
  ssEnhSelectAll(false);
  ['ssEnhMainCanvas','ssEnhLegend','ssStatsModeHeader','ssStatsPrimaryCounts','ssStatsDensity','ssEnhTimestamp'].forEach(id => {
    const cb = document.getElementById(id);
    if (cb) cb.checked = true;
  });
}

// Select all/none for 3D screenshot options
function ss3dSelectAll(select) {
  ['ss3dTitle','ss3dLegend','ss3dStats','ss3dGCD','ss3dConv','ss3dTable'].forEach(id => {
    const cb = document.getElementById(id);
    if (cb) cb.checked = select;
  });
}

// Reset to defaults for 3D screenshot options
function ss3dSelectDefaults() {
  ['ss3dTitle','ss3dLegend','ss3dStats'].forEach(id => {
    const cb = document.getElementById(id);
    if (cb) cb.checked = true;
  });
  ['ss3dGCD','ss3dConv','ss3dTable'].forEach(id => {
    const cb = document.getElementById(id);
    if (cb) cb.checked = false;
  });
}

// Get 3D screenshot options
function get3DScreenshotOpts() {
  return {
    scale: +(document.getElementById('ss3dRes')?.value || 2),
    title: document.getElementById('ss3dTitle')?.checked ?? true,
    canvas: document.getElementById('ss3dCanvas')?.checked ?? true,
    legend: document.getElementById('ss3dLegend')?.checked ?? true,
    statsGrid: document.getElementById('ss3dStatsGrid')?.checked ?? true,
    stats: document.getElementById('ss3dStats')?.checked ?? true,
    theory: document.getElementById('ss3dTheory')?.checked ?? false,
    bg: document.getElementById('ss3dBg')?.value || 'theme',
    titleTxt: document.getElementById('ss3dTitleTxt')?.value || '3D Ball Lattice Points'
  };
}

// Get 2D screenshot options
function get2DScreenshotOpts() {
  return {
    scale: +(document.getElementById('ss2dRes')?.value || 2),
    title: document.getElementById('ss2dTitle')?.checked ?? true,
    canvas: document.getElementById('ss2dCanvas')?.checked ?? true,
    legend: document.getElementById('ss2dLegend')?.checked ?? true,
    statsGrid: document.getElementById('ss2dStatsGrid')?.checked ?? true,
    stats: document.getElementById('ss2dStats')?.checked ?? true,
    gcd: document.getElementById('ss2dGCD')?.checked ?? true,
    gcdLegend: document.getElementById('ss2dGCDLegend')?.checked ?? true,
    conv: document.getElementById('ss2dConv')?.checked ?? true,
    convLegend: document.getElementById('ss2dConvLegend')?.checked ?? true,
    radial: document.getElementById('ss2dRadial')?.checked ?? false,
    angular: document.getElementById('ss2dAngular')?.checked ?? false,
    sector: document.getElementById('ss2dSector')?.checked ?? false,
    picks: document.getElementById('ss2dPicks')?.checked ?? false,
    table: document.getElementById('ss2dTable')?.checked ?? false,
    theory: document.getElementById('ss2dTheory')?.checked ?? false
  };
}

// Get Enhanced screenshot options
function getEnhScreenshotOpts() {
  return {
    scale: +(document.getElementById('ssEnhRes')?.value || 2),
    title: document.getElementById('ssEnhTitle')?.checked ?? true,
    canvas: document.getElementById('ssEnhCanvas')?.checked ?? true,
    legend: document.getElementById('ssEnhLegend')?.checked ?? true,
    pointDetails: document.getElementById('ssEnhPointDetails')?.checked ?? false,
    stats: document.getElementById('ssEnhStats')?.checked ?? true,
    sector: document.getElementById('ssEnhSector')?.checked ?? true,
    path: document.getElementById('ssEnhPath')?.checked ?? true,
    sternBrocot: document.getElementById('ssEnhSternBrocot')?.checked ?? false,
    treeStats: document.getElementById('ssEnhTreeStats')?.checked ?? false,
    farey: document.getElementById('ssEnhFarey')?.checked ?? false,
    tracker: document.getElementById('ssEnhTracker')?.checked ?? false,
    theory: document.getElementById('ssEnhTheory')?.checked ?? false,
    legendFontSize: +(document.getElementById('ssEnhLegendFont')?.value || 12)
  };
}

function toggle2DSection(sectionId) {
  if (sectionId === 'all') { expand2DSections(); return; }
  if (sectionId === 'none') { collapse2DSections(); return; }
  const section = document.getElementById(sectionId);
  const icon = document.getElementById(sectionId + 'Icon');
  if (!section) return;
  const isHidden = section.style.display === 'none';
  section.style.display = isHidden ? 'block' : 'none';
  if (icon) icon.textContent = isHidden ? '−' : '+';
}

function toggle3DSection(sectionId) {
  if (sectionId === 'all') { expand3DSections(); return; }
  if (sectionId === 'none') { collapse3DSections(); return; }
  const section = document.getElementById(sectionId);
  const icon = document.getElementById(sectionId + 'Icon');
  if (!section) return;
  const isHidden = section.style.display === 'none';
  section.style.display = isHidden ? 'block' : 'none';
  if (icon) icon.textContent = isHidden ? '−' : '+';
}

const sec2DIds = ['sec2DBasic', 'sec2DSmith', 'sec2DMod', 'sec2DSweep', 'sec2DFarey', 'sec2DPicks', 'sec2DVis'];
const sec3DIds = ['sec3DBasic', 'sec3DSmith', 'sec3DFarey'];

function expand2DSections() {
  sec2DIds.forEach(id => {
    const s = document.getElementById(id);
    const i = document.getElementById(id + 'Icon');
    if (s) s.style.display = 'block';
    if (i) i.textContent = '−';
  });
}

function collapse2DSections() {
  sec2DIds.forEach(id => {
    const s = document.getElementById(id);
    const i = document.getElementById(id + 'Icon');
    if (s) s.style.display = 'none';
    if (i) i.textContent = '+';
  });
}

function expand3DSections() {
  sec3DIds.forEach(id => {
    const s = document.getElementById(id);
    const i = document.getElementById(id + 'Icon');
    if (s) s.style.display = 'block';
    if (i) i.textContent = '−';
  });
}

function collapse3DSections() {
  sec3DIds.forEach(id => {
    const s = document.getElementById(id);
    const i = document.getElementById(id + 'Icon');
    if (s) s.style.display = 'none';
    if (i) i.textContent = '+';
  });
}

// Toggle functions for Gaussian ℤ[i] sections
const secGausIds = ['secGausBasic', 'secGausDisplay'];

function toggleGausSection(sectionId) {
  if (sectionId === 'all') { expandGausSections(); return; }
  if (sectionId === 'none') { collapseGausSections(); return; }
  const section = document.getElementById(sectionId);
  const icon = document.getElementById(sectionId + 'Icon');
  if (!section) return;
  const isHidden = section.style.display === 'none';
  section.style.display = isHidden ? 'block' : 'none';
  if (icon) icon.textContent = isHidden ? '−' : '+';
}

function expandGausSections() {
  secGausIds.forEach(id => {
    const s = document.getElementById(id);
    const i = document.getElementById(id + 'Icon');
    if (s) s.style.display = 'block';
    if (i) i.textContent = '−';
  });
}

function collapseGausSections() {
  secGausIds.forEach(id => {
    const s = document.getElementById(id);
    const i = document.getElementById(id + 'Icon');
    if (s) s.style.display = 'none';
    if (i) i.textContent = '+';
  });
}

// Toggle functions for Circle Problem sections
const secCircIds = ['secCircBasic'];

function toggleCircSection(sectionId) {
  if (sectionId === 'all') { expandCircSections(); return; }
  if (sectionId === 'none') { collapseCircSections(); return; }
  const section = document.getElementById(sectionId);
  const icon = document.getElementById(sectionId + 'Icon');
  if (!section) return;
  const isHidden = section.style.display === 'none';
  section.style.display = isHidden ? 'block' : 'none';
  if (icon) icon.textContent = isHidden ? '−' : '+';
}

function expandCircSections() {
  secCircIds.forEach(id => {
    const s = document.getElementById(id);
    const i = document.getElementById(id + 'Icon');
    if (s) s.style.display = 'block';
    if (i) i.textContent = '−';
  });
}

function collapseCircSections() {
  secCircIds.forEach(id => {
    const s = document.getElementById(id);
    const i = document.getElementById(id + 'Icon');
    if (s) s.style.display = 'none';
    if (i) i.textContent = '+';
  });
}

function togglePicksMode() {
  picksMode = document.getElementById('picks2dEnable')?.checked;
  if (picksMode) {
    document.getElementById('picks2dStats').style.display = 'block';
    document.getElementById('picks2dInstructions').style.display = 'block';
    // Auto-load unit square example if no polygon exists
    if (picksPolygon.length === 0) {
      addPicksPreset('square');
    }
  } else {
    document.getElementById('picks2dStats').style.display = 'none';
    document.getElementById('picks2dInstructions').style.display = 'none';
  }
  draw2D();
}

function clearPicksPolygon() {
  picksPolygon = [];
  document.getElementById('picks2dVerts').textContent = '0';
  document.getElementById('picks2dVerify').style.display = 'none';
  updatePicksStats();
  draw2D();
}

function closePicksPolygon() {
  if (picksPolygon.length >= 3) {
    updatePicksStats();
    draw2D();
  }
}

function addPicksVertex(x, y) {
  picksPolygon.push({x, y});
  document.getElementById('picks2dVerts').textContent = picksPolygon.length;
  updatePicksStats();
  draw2D();
}

function addPicksPreset(type) {
  picksPolygon = [];
  if (type === 'square') {
    // Unit square
    picksPolygon = [{x:0, y:0}, {x:1, y:0}, {x:1, y:1}, {x:0, y:1}];
  } else if (type === 'triangle') {
    // 3-4-5 right triangle
    picksPolygon = [{x:0, y:0}, {x:3, y:0}, {x:0, y:4}];
  } else if (type === 'large') {
    // Larger square
    picksPolygon = [{x:-2, y:-2}, {x:2, y:-2}, {x:2, y:2}, {x:-2, y:2}];
  }
  document.getElementById('picks2dVerts').textContent = picksPolygon.length;
  updatePicksStats();
  draw2D();
}

function updatePicksStats() {
  const verifyDiv = document.getElementById('picks2dVerify');
  
  if (picksPolygon.length < 3) {
    document.getElementById('picks2dI').textContent = '0';
    document.getElementById('picks2dB').textContent = '0';
    document.getElementById('picks2dA').textContent = '0';
    if (verifyDiv) verifyDiv.style.display = 'none';
    return;
  }
  
  // Calculate polygon area using shoelace formula
  let area = 0;
  const n = picksPolygon.length;
  for (let i = 0; i < n; i++) {
    const j = (i + 1) % n;
    area += picksPolygon[i].x * picksPolygon[j].y;
    area -= picksPolygon[j].x * picksPolygon[i].y;
  }
  area = Math.abs(area) / 2;
  
  // Count boundary points
  let boundary = 0;
  for (let i = 0; i < n; i++) {
    const j = (i + 1) % n;
    const dx = Math.abs(picksPolygon[j].x - picksPolygon[i].x);
    const dy = Math.abs(picksPolygon[j].y - picksPolygon[i].y);
    boundary += gcd(dx, dy);
  }
  
  // Pick's theorem: A = i + b/2 - 1, so i = A - b/2 + 1
  const interior = area - boundary / 2 + 1;
  
  document.getElementById('picks2dI').textContent = interior.toFixed(0);
  document.getElementById('picks2dB').textContent = boundary;
  document.getElementById('picks2dA').textContent = area % 1 === 0 ? area.toFixed(0) : area.toFixed(1);
  
  // Show verification
  if (verifyDiv) {
    const computed = interior + boundary / 2 - 1;
    const verified = Math.abs(computed - area) < 0.001;
    verifyDiv.style.display = 'block';
    verifyDiv.innerHTML = verified 
      ? `<span style="color:#00ff88"> Verified: ${interior} + ${boundary}/2 − 1 = ${area}</span>`
      : `<span style="color:#ff6496">Computing...</span>`;
  }
}

function pointInPolygon(x, y, poly) {
  if (poly.length < 3) return false;
  let inside = false;
  for (let i = 0, j = poly.length - 1; i < poly.length; j = i++) {
    const xi = poly[i].x, yi = poly[i].y;
    const xj = poly[j].x, yj = poly[j].y;
    if (((yi > y) !== (yj > y)) && (x < (xj - xi) * (y - yi) / (yj - yi) + xi)) {
      inside = !inside;
    }
  }
  return inside;
}

// Visibility from multiple origins
function setVisOrigin(x, y) {
  document.getElementById('vis2dX').value = x;
  document.getElementById('vis2dY').value = y;
  draw2D();
}

function isVisibleFrom(ox, oy, px, py) {
  const dx = px - ox, dy = py - oy;
  if (dx === 0 && dy === 0) return false;
  return gcd(Math.abs(dx), Math.abs(dy)) === 1;
}

function resizeCanvas2D(){
const sz=+document.getElementById('canvSz2d').value||800;
const c=document.getElementById('c2d');
c.width=sz;c.height=sz;
if(document.getElementById('c2d')) draw2D();
}

function resizeCanvasGaus(){
const sz=+document.getElementById('canvSzGaus').value||700;
const c=document.getElementById('cgaus');
c.width=sz;c.height=sz;
drawGaus();
}

function resizeCanvasEnh(){
const sz=+document.getElementById('enhCanvSz').value||800;
const c=document.getElementById('cenhanced');
c.width=sz;c.height=sz;
drawEnhanced();
}

function resizeCanvasCay(){
const sz=+document.getElementById('canvSzCay').value||700;
const c=document.getElementById('ccay');
if(c){c.width=sz;c.height=sz;}
drawCayley();
}

function resizeCanvasFarey(){
const sz=+document.getElementById('canvSzFarey').value||800;
const c=document.getElementById('cfarey');
if(c){c.width=sz;c.height=Math.floor(sz/2);}
drawFarey();
}

function resizeCanvasTwin(){
const sz=+document.getElementById('canvSzTwin').value||800;
const c=document.getElementById('ctwin');
if(c){c.width=sz;c.height=Math.floor(sz*0.625);}
drawTwin();
}

function resizeCanvasMob(){
const sz=+document.getElementById('canvSzMob').value||900;
const c=document.getElementById('cmob');
if(c){c.width=sz;c.height=Math.floor(sz*0.61);}
drawMobius();
}

function resizeCanvasModSieve(){
const sz=+document.getElementById('canvSzModSieve').value||600;
const c=document.getElementById('cmodsieve');
if(c){c.width=sz;c.height=sz;}
drawModSieve();
}

// Comprehensive screenshot helper
function extractDashboardData(dashId){
const dash=document.getElementById(dashId);if(!dash)return{cards:[],sections:[],rawText:''};
const cards=[],sections=[];
// Extract cards from grid layout
dash.querySelectorAll('[style*="grid-template-columns:repeat(3"]>div, [style*="grid-template-columns: repeat(3"]>div').forEach(card=>{
const val=card.querySelector('div:first-child');
const lbl=card.querySelector('div:last-child');
if(val&&lbl)cards.push({value:val.textContent.trim(),label:lbl.textContent.trim(),color:val.style.color||'#00d9ff'});
});
// Extract sections with key-value pairs
dash.querySelectorAll('[style*="border-bottom"]').forEach(sec=>{
const title=sec.querySelector('strong');
const items=[];
sec.querySelectorAll('[style*="grid-template-columns:1fr 1fr"]>span, [style*="grid-template-columns: 1fr 1fr"]>span').forEach((span,i,arr)=>{
if(i%2===0&&arr[i+1])items.push({key:span.textContent.trim(),val:arr[i+1].textContent.trim(),color:arr[i+1].style.color||'inherit'});
});
if(title)sections.push({title:title.textContent.trim(),items});
});
// Fallback: get raw text if no structured data found
const rawText=dash.innerText||'';
return{cards,sections,rawText};
}

// NEW: Screenshot with full legend on right side (user requested style)
// Universal screenshot helper - side-by-side layout with FULL stats capture
async function screenshotUnified(canvasId, dashId, title, filename, options={}){
const c=document.getElementById(canvasId);
const dash=document.getElementById(dashId);
if(!c){console.error('Canvas not found:',canvasId);return;}

const scale=options.scale||2;
const showTitle=options.showTitle!==false;
const showLegend=options.showLegend!==false;
const showStats=options.showStats!==false;
const legendId=options.legendId; // Optional legend element to capture
const pad=40;
const titleH=showTitle?55:10;
const footerH=35;
const isDk=isDark();

// Try to use html2canvas for the dashboard to get exact rendering
let dashImg=null;
let dashW=showStats?380:0, dashH=c.height;
let legendImg=null, legendH=0;

try{
const html2canvas=(await import('https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/+esm')).default;

// Capture stats dashboard
if(showStats && dash){
const snap=await html2canvas(dash,{scale:scale,backgroundColor:isDk?'#151b2d':'#f5f5f5',logging:false,useCORS:true});
dashImg=snap;
dashW=Math.min(600,snap.width/scale);
dashH=Math.max(c.height,snap.height/scale);
}

// Capture legend if specified
if(legendId){
const legend=document.getElementById(legendId);
if(legend && legend.innerHTML.trim()){
const legendSnap=await html2canvas(legend,{scale:scale,backgroundColor:isDk?'#0d1321':'#fff',logging:false,useCORS:true});
legendImg=legendSnap;
legendH=legendSnap.height/scale + 15;
}
}
}catch(e){console.log('html2canvas failed, using fallback',e);}

// Calculate dimensions
const canvW=c.width;
const canvH=c.height;
const totalW=canvW+(showStats&&dashW>0?dashW+pad:0)+pad*2;
const totalH=Math.max(canvH+legendH,showStats?dashH:canvH)+titleH+footerH+pad;

const out=document.createElement('canvas');
out.width=totalW*scale;
out.height=totalH*scale;
const ctx=out.getContext('2d');
ctx.scale(scale,scale);

// Background
ctx.fillStyle=isDk?'#0d1321':'#ffffff';
ctx.fillRect(0,0,totalW,totalH);

// Title bar with gradient (only if showTitle)
if(showTitle){
const grad=ctx.createLinearGradient(0,0,totalW,0);
grad.addColorStop(0,isDk?'#151b2d':'#e8e8e8');
grad.addColorStop(1,isDk?'#1a2540':'#f5f5f5');
ctx.fillStyle=grad;
ctx.fillRect(0,0,totalW,titleH);
ctx.fillStyle=isDk?'#00d9ff':'#0066cc';
ctx.font='bold 20px Segoe UI';
ctx.textAlign='center';
ctx.fillText(title,totalW/2,35);
}

// Canvas area
const canvX=pad;
const canvY=titleH+10;
ctx.strokeStyle=isDk?'rgba(0,217,255,0.4)':'rgba(0,102,204,0.3)';
ctx.lineWidth=2;
ctx.strokeRect(canvX-2,canvY-2,canvW+4,canvH+4);
ctx.drawImage(c,canvX,canvY,canvW,canvH);

// Draw legend below canvas if captured
if(legendImg){
ctx.drawImage(legendImg,canvX,canvY+canvH+10,legendImg.width/scale,legendImg.height/scale);
}

// Path info box on left of canvas (if pathInfo provided)
if(options.pathInfo&&options.pathInfo.path&&options.pathInfo.path.length>0){
ctx.save();
const lblFmt=document.getElementById('enhTreeLblFmt')?.value||'fraction';
const fmtNode=(p,q)=>{
  switch(lblFmt){
    case 'decimal': return (p/q).toFixed(3);
    case 'angle': return ((p/q)*360).toFixed(1)+'°';
    default: return `${p}/${q}`;
  }
};
const pathW=180,pathH=Math.min(200,40+options.pathInfo.path.length*18);
const pathX=canvX+15,pathY=canvY+15;
ctx.fillStyle=isDk?'rgba(13,19,33,0.95)':'rgba(255,255,255,0.95)';
ctx.fillRect(pathX,pathY,pathW,pathH);
ctx.strokeStyle='rgba(0,255,136,0.6)';
ctx.lineWidth=2;
ctx.strokeRect(pathX,pathY,pathW,pathH);
ctx.fillStyle='#00ff88';
ctx.font='bold 11px Segoe UI';
ctx.textAlign='left';
ctx.fillText('STERN-BROCOT PATH',pathX+10,pathY+18);
if(options.pathInfo.selected){
ctx.fillStyle='#ffd700';
ctx.font='bold 12px Segoe UI';
ctx.fillText(`→ ${fmtNode(options.pathInfo.selected.p,options.pathInfo.selected.q)}`,pathX+10,pathY+36);
}
ctx.fillStyle='#00d9ff';
ctx.font='10px Segoe UI';
let py=pathY+54;
options.pathInfo.path.forEach((node,i)=>{
if(py<pathY+pathH-10){
const arrow=i===options.pathInfo.path.length-1?'':'→';
ctx.fillText(`${arrow} ${fmtNode(node.p,node.q)}`,pathX+10,py);
py+=16;
}
});
ctx.restore();
}

// Legend overlay on canvas (if showLegend)
if(showLegend){
ctx.save();
const legFont=options.legendFontSize||12;
const legW=Math.max(160,legFont*14),legH=Math.max(100,legFont*8);
const legX=canvX+canvW-legW-15,legY=canvY+15;
ctx.fillStyle=isDk?'rgba(13,19,33,0.92)':'rgba(255,255,255,0.92)';
ctx.fillRect(legX,legY,legW,legH);
ctx.strokeStyle=isDk?'rgba(0,217,255,0.5)':'rgba(0,102,204,0.5)';
ctx.lineWidth=1;
ctx.strokeRect(legX,legY,legW,legH);
ctx.fillStyle=isDk?'#00d9ff':'#0066cc';
ctx.font=`bold ${legFont}px Segoe UI`;
ctx.textAlign='left';
ctx.fillText('LEGEND',legX+10,legY+legFont*1.4);
ctx.font=`${legFont}px Segoe UI`;
ctx.fillStyle=isDk?'#ffd700':'#cc8800';
ctx.fillText(' Coprime (GCD=1)',legX+10,legY+legFont*2.8);
ctx.fillStyle=isDk?'#666':'#999';
ctx.fillText(' Non-coprime',legX+10,legY+legFont*4.2);
ctx.fillStyle=isDk?'#9664ff':'#7744dd';
ctx.fillText(' Highlighted sector',legX+10,legY+legFont*5.6);
ctx.fillStyle=isDk?'#00ff88':'#00aa55';
ctx.fillText(' Unit circle',legX+10,legY+legFont*7);
ctx.restore();
}

// Dashboard/Legend panel on right (if showStats)
if(showStats&&dashW>0){
const legendX=canvW+pad*2;
const legendY=titleH+10;

if(dashImg){
// Draw the captured dashboard image
ctx.fillStyle=isDk?'#151b2d':'#f5f5f5';
ctx.fillRect(legendX-5,legendY-5,dashW+10,dashH+10);
ctx.strokeStyle=isDk?'rgba(0,217,255,0.3)':'rgba(0,102,204,0.2)';
ctx.strokeRect(legendX-5,legendY-5,dashW+10,dashH+10);
// Scale dashboard to fit
const scaleRatio=Math.min(dashW/(dashImg.width/scale),dashH/(dashImg.height/scale),1);
const drawW=(dashImg.width/scale)*scaleRatio;
const drawH=(dashImg.height/scale)*scaleRatio;
ctx.drawImage(dashImg,legendX,legendY,drawW,drawH);
}else if(dash){
// Fallback: extract and render structured data
ctx.fillStyle=isDk?'#151b2d':'#f5f5f5';
ctx.fillRect(legendX,legendY,dashW,dashH);
ctx.strokeStyle=isDk?'rgba(0,217,255,0.2)':'rgba(0,102,204,0.2)';
ctx.strokeRect(legendX,legendY,dashW,dashH);
const dashData=extractDashboardData(dashId);
ctx.textAlign='left';
renderDashboardFull(ctx,dashData,legendX+10,legendY+20,dashW-20,dashH-30,isDk);
}
}

// Footer
ctx.fillStyle=isDk?'#506080':'#888';
ctx.font='11px Segoe UI';
ctx.textAlign='center';
ctx.fillText('Möbius Shell Sieve — wessengetachew.github.io/@7dview',totalW/2,totalH-12);
ctx.textAlign='right';
ctx.font='10px Segoe UI';
ctx.fillText(new Date().toISOString().slice(0,19).replace('T',' '),totalW-pad,totalH-12);

// Export
out.toBlob(b=>{
const a=document.createElement('a');
a.href=URL.createObjectURL(b);
a.download=filename||`${title.replace(/[^a-zA-Z0-9]/g,'_')}_${Date.now()}.png`;
a.click();
URL.revokeObjectURL(a.href);
},'image/png',1.0);
}

// Render full dashboard data without truncation
function renderDashboardFull(ctx,data,x,y,w,h,isDk){
let cy=y;
const lpad=8;

// Title
ctx.fillStyle=isDk?'#ffd700':'#cc8800';
ctx.font='bold 14px Segoe UI';
ctx.fillText(' Live Statistics',x,cy);
cy+=22;

// Cards row
if(data.cards&&data.cards.length>0){
const numCards=Math.min(data.cards.length,3);
const cardW=(w-lpad*(numCards-1))/numCards;
data.cards.slice(0,3).forEach((card,i)=>{
const cx=x+i*(cardW+lpad);
ctx.fillStyle=isDk?'#1a2540':'#e0e0e0';
ctx.fillRect(cx,cy,cardW,48);
ctx.fillStyle=card.color||'#00d9ff';
ctx.font='bold 15px Segoe UI';
ctx.textAlign='center';
ctx.fillText(card.value,cx+cardW/2,cy+22);
ctx.fillStyle=isDk?'#8090b0':'#666';
ctx.font='9px Segoe UI';
ctx.fillText(card.label,cx+cardW/2,cy+38);
});
ctx.textAlign='left';
cy+=60;
}

// Sections
if(data.sections){
data.sections.forEach(sec=>{
if(cy>y+h-30)return;
ctx.fillStyle=isDk?'#00d9ff':'#0066cc';
ctx.font='bold 11px Segoe UI';
ctx.fillText(sec.title||'',x,cy);
cy+=15;
if(sec.items){
sec.items.forEach(item=>{
if(cy>y+h-15)return;
ctx.fillStyle=isDk?'#8090b0':'#555';
ctx.font='10px Segoe UI';
ctx.fillText(item.key||'',x,cy);
ctx.fillStyle=(item.color&&item.color!=='inherit')?item.color:(isDk?'#e0e0e0':'#222');
ctx.fillText(item.val||'',x+w/2,cy);
cy+=13;
});
}
cy+=8;
});
}

// Raw text fallback
if((!data.cards||data.cards.length===0)&&(!data.sections||data.sections.length===0)&&data.rawText){
ctx.fillStyle=isDk?'#e0e0e0':'#333';
ctx.font='10px Segoe UI';
const lines=data.rawText.split('\n').filter(l=>l.trim());
lines.forEach((line,i)=>{
if(cy+i*13>y+h-15)return;
ctx.fillText(line.substring(0,55),x,cy+i*13);
});
}
}

// === COMPREHENSIVE SCREENSHOT SYSTEM ===

// Screenshot single canvas
async function screenshotCanvas(canvasId, title, filename){
const c=document.getElementById(canvasId);
if(!c)return alert('Canvas not found');
const scale=2,pad=30;
const out=document.createElement('canvas');
out.width=(c.width+pad*2)*scale;
out.height=(c.height+pad*2+40)*scale;
const ctx=out.getContext('2d');ctx.scale(scale,scale);
ctx.fillStyle=canvBg();ctx.fillRect(0,0,out.width/scale,out.height/scale);
ctx.fillStyle=isDark()?'#00d9ff':'#0066cc';ctx.font='bold 16px Segoe UI';ctx.textAlign='center';
ctx.fillText(title,out.width/scale/2,pad);
ctx.drawImage(c,pad,pad+20,c.width,c.height);
ctx.fillStyle=isDark()?'#506080':'#888';ctx.font='10px Segoe UI';
ctx.fillText('Möbius Shell Sieve',out.width/scale/2,out.height/scale-10);
out.toBlob(b=>{const a=document.createElement('a');a.href=URL.createObjectURL(b);a.download=filename;a.click();},'image/png',1.0);
}

// Screenshot single Plotly chart
async function screenshotChart(plotId, title, filename){
const p=document.getElementById(plotId);
if(!p||!p.offsetWidth)return alert('Chart not ready');
const img=await Plotly.toImage(p,{format:'png',width:p.offsetWidth*2,height:p.offsetHeight*2,scale:2});
const scale=2,pad=30;
const loaded=await new Promise(r=>{const i=new Image();i.onload=()=>r(i);i.src=img;});
const out=document.createElement('canvas');
out.width=loaded.width+pad*2*scale;
out.height=loaded.height+pad*2*scale+40*scale;
const ctx=out.getContext('2d');
ctx.fillStyle=canvBg();ctx.fillRect(0,0,out.width,out.height);
ctx.fillStyle=isDark()?'#00d9ff':'#0066cc';ctx.font=`bold ${16*scale}px Segoe UI`;ctx.textAlign='center';
ctx.fillText(title,out.width/2,pad*scale);
ctx.drawImage(loaded,pad*scale,pad*scale+20*scale);
ctx.fillStyle=isDark()?'#506080':'#888';ctx.font=`${10*scale}px Segoe UI`;
ctx.fillText('Möbius Shell Sieve',out.width/2,out.height-10*scale);
out.toBlob(b=>{const a=document.createElement('a');a.href=URL.createObjectURL(b);a.download=filename;a.click();},'image/png',1.0);
}

// Screenshot stats dashboard only
async function screenshotStats(dashId, title, filename){
const dashData=extractDashboardData(dashId);
const scale=2,pad=30,w=600,h=450;
const out=document.createElement('canvas');
out.width=(w+pad*2)*scale;out.height=(h+pad*2)*scale;
const ctx=out.getContext('2d');ctx.scale(scale,scale);
const isDk=isDark();
ctx.fillStyle=isDk?'#0d1321':'#ffffff';ctx.fillRect(0,0,out.width/scale,out.height/scale);
ctx.fillStyle=isDk?'#00d9ff':'#0066cc';ctx.font='bold 16px Segoe UI';ctx.textAlign='center';
ctx.fillText(title+' — Statistics',out.width/scale/2,pad);
ctx.textAlign='left';
renderDashboard(ctx,dashData,pad,pad+25,w,isDk,h-50);
ctx.fillStyle=isDk?'#506080':'#888';ctx.font='10px Segoe UI';ctx.textAlign='center';
ctx.fillText('Möbius Shell Sieve',out.width/scale/2,out.height/scale-10);
out.toBlob(b=>{const a=document.createElement('a');a.href=URL.createObjectURL(b);a.download=filename;a.click();},'image/png',1.0);
}

// Screenshot ALL elements on a tab (canvases + charts + stats)
async function screenshotTabAll(config){
const {canvases=[], charts=[], dashId, title, filename, pathInfo, showLegend} = config;
const scale=2, pad=30, gap=15;
const loadedCanvases=canvases.map(id=>document.getElementById(id)).filter(c=>c);
const loadedCharts=charts.map(id=>document.getElementById(id)).filter(p=>p&&p.offsetWidth);
const dash=dashId?document.getElementById(dashId):null;
const isDk=isDark();

// Calculate left side (canvases + charts) dimensions
let leftW = 600;
loadedCanvases.forEach(c => { if(c.width > leftW) leftW = c.width; });

let leftH = 0;
// Canvas heights
loadedCanvases.forEach(c => {
leftH += c.height + 30; // canvas + title
});
// Chart heights (stacked)
const chartH = 220;
loadedCharts.forEach(() => {
leftH += chartH + 25;
});

// Get dashboard dimensions using html2canvas
let dashImg = null;
let dashW = 400, dashH = leftH;
try {
const html2canvas = (await import('https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/+esm')).default;
if(dash) {
const snap = await html2canvas(dash, {scale: scale, backgroundColor: isDk ? '#151b2d' : '#f5f5f5', logging: false, useCORS: true});
dashImg = snap;
dashW = Math.min(450, snap.width / scale);
dashH = Math.max(leftH, snap.height / scale);
}
} catch(e) { console.log('html2canvas failed, using fallback', e); }

// Adjust heights
const contentH = Math.max(leftH, dashH);

// Total dimensions
const titleH = 60;
const footerH = 35;
const totalW = leftW + dashW + pad * 3;
const totalH = contentH + titleH + footerH + pad;

// Create output canvas
const out = document.createElement('canvas');
out.width = totalW * scale;
out.height = totalH * scale;
const ctx = out.getContext('2d');
ctx.scale(scale, scale);

// Background
ctx.fillStyle = isDk ? '#0d1321' : '#ffffff';
ctx.fillRect(0, 0, totalW, totalH);

// Title bar
const grad = ctx.createLinearGradient(0, 0, totalW, 0);
grad.addColorStop(0, isDk ? '#151b2d' : '#e8e8e8');
grad.addColorStop(1, isDk ? '#1a2540' : '#f5f5f5');
ctx.fillStyle = grad;
ctx.fillRect(0, 0, totalW, titleH);

ctx.fillStyle = isDk ? '#ffd700' : '#cc8800';
ctx.font = 'bold 22px Segoe UI';
ctx.textAlign = 'center';
ctx.fillText(title + ' — Complete Export', totalW / 2, 28);

ctx.fillStyle = isDk ? '#00d9ff' : '#0066cc';
ctx.font = '11px Segoe UI';
ctx.fillText(`${loadedCanvases.length} Canvas${loadedCanvases.length!==1?'es':''} + ${loadedCharts.length} Chart${loadedCharts.length!==1?'s':''} + Live Statistics`, totalW / 2, 48);

// LEFT SIDE: Canvases and Charts
let cy = titleH + pad/2;
const leftX = pad;

// Draw each canvas with individual title
loadedCanvases.forEach((c, i) => {
// Canvas title
ctx.fillStyle = isDk ? '#00d9ff' : '#0066cc';
ctx.font = 'bold 12px Segoe UI';
ctx.textAlign = 'left';
const canvasTitle = c.id.replace('c','').replace(/([A-Z])/g, ' $1').trim();
ctx.fillText(` ${canvasTitle || 'Canvas ' + (i+1)}`, leftX, cy + 12);
cy += 20;

// Canvas border
ctx.strokeStyle = isDk ? 'rgba(0,217,255,0.3)' : 'rgba(0,102,204,0.3)';
ctx.lineWidth = 2;
ctx.strokeRect(leftX - 2, cy - 2, c.width + 4, c.height + 4);

// Canvas image
ctx.drawImage(c, leftX, cy, c.width, c.height);

// Add path info and legend overlay on first canvas only
if(i === 0){
  // Path info box on left of canvas (if pathInfo provided)
  if(pathInfo && pathInfo.path && pathInfo.path.length > 0){
    ctx.save();
    const lblFmt = document.getElementById('enhTreeLblFmt')?.value || 'fraction';
    const fmtNode = (p,q) => {
      switch(lblFmt){
        case 'decimal': return (p/q).toFixed(3);
        case 'angle': return ((p/q)*360).toFixed(1)+'°';
        default: return `${p}/${q}`;
      }
    };
    const pathW = 180, pathH = Math.min(200, 40 + pathInfo.path.length * 18);
    const pathX = leftX + 15, pathY = cy + 15;
    ctx.fillStyle = isDk ? 'rgba(13,19,33,0.95)' : 'rgba(255,255,255,0.95)';
    ctx.fillRect(pathX, pathY, pathW, pathH);
    ctx.strokeStyle = 'rgba(0,255,136,0.6)';
    ctx.lineWidth = 2;
    ctx.strokeRect(pathX, pathY, pathW, pathH);
    ctx.fillStyle = '#00ff88';
    ctx.font = 'bold 11px Segoe UI';
    ctx.textAlign = 'left';
    ctx.fillText('STERN-BROCOT PATH', pathX + 10, pathY + 18);
    if(pathInfo.selected){
      ctx.fillStyle = '#ffd700';
      ctx.font = 'bold 12px Segoe UI';
      ctx.fillText(`→ ${fmtNode(pathInfo.selected.p, pathInfo.selected.q)}`, pathX + 10, pathY + 36);
    }
    ctx.fillStyle = '#00d9ff';
    ctx.font = '10px Segoe UI';
    let py = pathY + 54;
    pathInfo.path.forEach((node, idx) => {
      if(py < pathY + pathH - 10){
        const arrow = idx === pathInfo.path.length - 1 ? '' : '→';
        ctx.fillText(`${arrow} ${fmtNode(node.p, node.q)}`, pathX + 10, py);
        py += 16;
      }
    });
    ctx.restore();
  }
  
  // Legend overlay on top-right of canvas
  if(showLegend !== false){
    ctx.save();
    const legFont = 12;
    const legW = 160, legH = 100;
    const legX = leftX + c.width - legW - 15, legY = cy + 15;
    ctx.fillStyle = isDk ? 'rgba(13,19,33,0.92)' : 'rgba(255,255,255,0.92)';
    ctx.fillRect(legX, legY, legW, legH);
    ctx.strokeStyle = isDk ? 'rgba(0,217,255,0.5)' : 'rgba(0,102,204,0.5)';
    ctx.lineWidth = 1;
    ctx.strokeRect(legX, legY, legW, legH);
    ctx.fillStyle = isDk ? '#00d9ff' : '#0066cc';
    ctx.font = `bold ${legFont}px Segoe UI`;
    ctx.textAlign = 'left';
    ctx.fillText('LEGEND', legX + 10, legY + legFont * 1.4);
    ctx.font = `${legFont}px Segoe UI`;
    ctx.fillStyle = isDk ? '#ffd700' : '#cc8800';
    ctx.fillText(' Coprime (GCD=1)', legX + 10, legY + legFont * 2.8);
    ctx.fillStyle = isDk ? '#666' : '#999';
    ctx.fillText(' Non-coprime', legX + 10, legY + legFont * 4.2);
    ctx.fillStyle = isDk ? '#9664ff' : '#7744dd';
    ctx.fillText(' Highlighted sector', legX + 10, legY + legFont * 5.6);
    ctx.fillStyle = isDk ? '#00ff88' : '#00aa55';
    ctx.fillText(' Unit circle', legX + 10, legY + legFont * 7);
    ctx.restore();
  }
}

cy += c.height + gap;
});

// Draw charts below canvases
if (loadedCharts.length) {
try {
const chartImgs = await Promise.all(loadedCharts.map(p => 
Plotly.toImage(p, { format: 'png', width: leftW * scale, height: chartH * scale })
));
const chartLoaded = await Promise.all(chartImgs.map(src => new Promise(r => {
const img = new Image();
img.onload = () => r(img);
img.onerror = () => r(null);
img.src = src;
})));

chartLoaded.forEach((img, i) => {
if (!img) return;
// Chart title
ctx.fillStyle = isDk ? '#ffd700' : '#cc8800';
ctx.font = 'bold 11px Segoe UI';
ctx.textAlign = 'left';
const chartId = loadedCharts[i]?.id || `Chart ${i+1}`;
ctx.fillText(` ${chartId}`, leftX, cy + 10);
cy += 18;

// Draw chart
ctx.drawImage(img, leftX, cy, leftW, chartH);
cy += chartH + gap;
});
} catch (e) {
console.error('Chart export error:', e);
}
}

// RIGHT SIDE: Full Live Statistics
const rightX = leftW + pad * 2;
const rightY = titleH + pad/2;
const rightW = dashW;
const rightH = contentH;

// Stats panel background
ctx.fillStyle = isDk ? '#151b2d' : '#f5f5f5';
ctx.fillRect(rightX - 5, rightY - 5, rightW + 10, rightH + 10);
ctx.strokeStyle = isDk ? 'rgba(0,217,255,0.3)' : 'rgba(0,102,204,0.2)';
ctx.lineWidth = 2;
ctx.strokeRect(rightX - 5, rightY - 5, rightW + 10, rightH + 10);

// Stats title
ctx.fillStyle = isDk ? '#ffd700' : '#cc8800';
ctx.font = 'bold 14px Segoe UI';
ctx.textAlign = 'left';
ctx.fillText(' Live Statistics', rightX + 5, rightY + 18);

if (dashImg) {
// Draw captured dashboard image
const scaleRatio = Math.min(rightW / (dashImg.width / scale), (rightH - 30) / (dashImg.height / scale), 1);
const drawW = (dashImg.width / scale) * scaleRatio;
const drawH = (dashImg.height / scale) * scaleRatio;
ctx.drawImage(dashImg, rightX, rightY + 25, drawW, drawH);
} else if (dashId) {
// Fallback: render structured data
const dashData = extractDashboardData(dashId);
renderDashboardFull(ctx, dashData, rightX + 5, rightY + 35, rightW - 10, rightH - 45, isDk);
}

// Footer
ctx.fillStyle = isDk ? '#506080' : '#888';
ctx.font = '11px Segoe UI';
ctx.textAlign = 'center';
ctx.fillText('Möbius Shell Sieve — @7dview — wessengetachew.github.io', totalW / 2, totalH - 18);
ctx.font = '9px Segoe UI';
ctx.fillText(new Date().toISOString().slice(0, 19).replace('T', ' '), totalW / 2, totalH - 6);

out.toBlob(b => {
const a = document.createElement('a');
a.href = URL.createObjectURL(b);
a.download = filename;
a.click();
URL.revokeObjectURL(a.href);
}, 'image/png', 1.0);
}

// Tab-specific export all functions
function exportAll2D(){
  screenshotTabAll({canvases:['c2d'],charts:['p2dGCD','p2dConv','p2dRadial','p2dAngular'],dashId:'stats2dLive',title:'2D Lattice Points Complete',filename:'2d_lattice_all.png'});
}

function exportAll3D(){
  screenshotTabAll({canvases:['c3d'],charts:['p3dGCD','p3dConv'],dashId:'stats3dLive',title:'3D Lattice Points Complete',filename:'3d_lattice_all.png'});
}
function exportAllErr(){screenshotTabAll({charts:['pe1','pe2','pe3','pe4'],dashId:'errLiveStats',title:'Error Analysis',filename:'error_all.png'});}
function exportAllMob(){screenshotTabAll({canvases:['cmob'],charts:['pmob1','pmob2'],dashId:'mobLiveStats',title:'Möbius Function',filename:'mobius_all.png'});}
function exportAllDim(){screenshotTabAll({charts:['pdimNew','pdimDens','pdimVol'],dashId:'dimLiveStats',title:'Higher Dimensions',filename:'dimensions_all.png'});}
function exportAllSh(){screenshotTabAll({charts:['psh1','psh2','psh3'],dashId:'shLiveStats',title:'Shell Analysis',filename:'shells_all.png'});}
function exportAllGCD(){screenshotTabAll({canvases:['cgcd'],charts:['pgcd1','pgcd2'],dashId:'gcdLiveStats',title:'GCD Distribution',filename:'gcd_all.png'});}
function exportAllGaus(){screenshotTabAll({canvases:['cgaus'],charts:['pgaus'],dashId:'gausLiveStats',title:'Gaussian Integers',filename:'gaussian_all.png'});}
function exportAllCirc(){screenshotTabAll({canvases:['ccirc'],charts:['pc1','pc2','pc3','pcircAbs','pcircAvg'],dashId:'circLiveStats',title:'Circle Problem',filename:'circle_all.png'});}
function exportAllDens(){screenshotTabAll({charts:['pdens1','pdens2','pdens3'],dashId:'densLiveStats',title:'Density 1/ζ(k)',filename:'density_all.png'});}
function exportAllCay(){screenshotTabAll({canvases:['ccay'],dashId:'cayLiveStats',title:'Cayley Transform',filename:'cayley_all.png'});}
function exportAllPrim(){screenshotTabAll({canvases:['cprim'],charts:['pprim1'],dashId:'primLiveStats',title:'Primitive Roots',filename:'primroot_all.png'});}
function exportAllFarey(){screenshotTabAll({canvases:['cfarey'],charts:['pfarey1'],dashId:'fareyLiveStats',title:'Farey Sequence',filename:'farey_all.png'});}
function exportAllMod(){screenshotTabAll({canvases:['cmod'],charts:['pmodphi'],dashId:'modLiveStats',title:'Modular Rings',filename:'modular_all.png'});}
function exportAllDir(){screenshotTabAll({canvases:['cdir'],charts:['pdir1','pdir2'],dashId:'dirLiveStats',title:'Dirichlet Characters',filename:'dirichlet_all.png'});}
function exportAllTwin(){screenshotTabAll({canvases:['ctwin'],charts:['ptwin1','ptwin2'],dashId:'twinLiveStats',title:'Twin Primes',filename:'twin_all.png'});}
function exportAllPi(){screenshotTabAll({canvases:['cpi'],charts:['ppi1','ppi2'],dashId:'piLiveStats',title:'Prime Counting π(x)',filename:'pi_all.png'});}
function exportAllComp(){screenshotTabAll({canvases:['ccomp'],charts:['pcomp1'],dashId:'compLiveStats',title:'Composite Channels',filename:'composite_all.png'});}
function exportAllCopair(){screenshotTabAll({canvases:['ccopair'],charts:['pcopair1','pcopair2'],dashId:'copairLiveStats',title:'Coprime Pairs',filename:'coprime_all.png'});}
function exportAllSierp(){screenshotTabAll({canvases:['csierp'],charts:['psierp1'],dashId:'sierpLiveStats',title:'Sierpiński',filename:'sierpinski_all.png'});}
function exportAllKfree(){screenshotTabAll({canvases:['ckfree'],charts:['pkfree1','pkfree2'],dashId:'kfreeLiveStats',title:'k-Free Integers',filename:'kfree_all.png'});}
function exportAllEuler(){screenshotTabAll({canvases:['ceuler'],charts:['peuler1','peuler2'],dashId:'eulerLiveStats',title:'Euler Product',filename:'euler_all.png'});}
function exportAllChord(){screenshotTabAll({canvases:['cchord'],charts:['pchord1'],dashId:'chordLiveStats',title:'Chord Uniformity',filename:'chord_all.png'});}
function exportAllGold(){screenshotTabAll({canvases:['cgold'],charts:['pgold'],dashId:'goldLiveStats',title:'Goldbach Conjecture',filename:'goldbach_all.png'});}
function exportAllGap(){screenshotTabAll({canvases:['cgap'],charts:['pgap1','pgap2'],dashId:'gapLiveStats',title:'Prime Gaps',filename:'gap_all.png'});}
function exportAllSoph(){screenshotTabAll({canvases:['csoph'],charts:['psoph1'],dashId:'sophLiveStats',title:'Sophie Germain',filename:'sophie_all.png'});}
function exportAllMert(){screenshotTabAll({canvases:['cmert'],charts:['pmertRatio','pmertDist'],dashId:'mertLiveStats',title:'Mertens M(x)',filename:'mertens_all.png'});}
function exportAllCheb(){screenshotTabAll({canvases:['ccheb'],charts:['pcheb1','pcheb2'],dashId:'chebLiveStats',title:'Chebyshev ψ(x)',filename:'chebyshev_all.png'});}
function exportAllLi(){screenshotTabAll({canvases:['cli'],charts:['pli1','pli2'],dashId:'liLiveStats',title:'Logarithmic Integral',filename:'li_all.png'});}
function exportAllDiv(){screenshotTabAll({canvases:['cdiv'],charts:['pdiv1','pdiv2'],dashId:'divLiveStats',title:'Divisor Function',filename:'divisor_all.png'});}
function exportAllLiou(){screenshotTabAll({canvases:['cliou'],charts:['pliou1','pliou2'],dashId:'liouLiveStats',title:'Liouville λ(n)',filename:'liouville_all.png'});}
function exportAllMang(){screenshotTabAll({canvases:['cmang'],charts:['pmang1','pmang2'],dashId:'mangLiveStats',title:'Mangoldt Λ(n)',filename:'mangoldt_all.png'});}
function exportAllRam(){screenshotTabAll({canvases:['cram'],charts:['pram1'],dashId:'ramLiveStats',title:'Ramanujan Sums',filename:'ramanujan_all.png'});}
function exportAllUlam(){screenshotTabAll({canvases:['culam'],dashId:'ulamLiveStats',title:'Ulam Spiral',filename:'ulam_all.png'});}
function exportAllSacks(){screenshotTabAll({canvases:['csacks'],dashId:'sacksLiveStats',title:'Sacks Spiral',filename:'sacks_all.png'});}
function exportAllHardy(){screenshotTabAll({canvases:['chardy'],charts:['phardyZeros','phardyGrowth'],dashId:'hardyLiveStats',title:'Hardy Z(t)',filename:'hardy_all.png'});}
function exportAllGram(){screenshotTabAll({canvases:['cgram'],charts:['pgram1'],dashId:'gramLiveStats',title:'Gram Points',filename:'gram_all.png'});}
function exportAllExplicit(){screenshotTabAll({canvases:['cexplicit'],charts:['pexplicit1'],dashId:'explicitLiveStats',title:'Explicit π(x)',filename:'explicit_all.png'});}
function exportAllZcount(){screenshotTabAll({canvases:['czcount'],charts:['pzcount1','pzcount2'],dashId:'zcountLiveStats',title:'N(T) Zero Counting',filename:'zerocount_all.png'});}
function exportAllArgand(){screenshotTabAll({canvases:['cargand'],dashId:'argandLiveStats',title:'ζ(s) Argand',filename:'argand_all.png'});}
function exportAllZetareal(){screenshotTabAll({canvases:['czetareal'],dashId:'zetarealLiveStats',title:'ζ(s) Real Axis',filename:'zetareal_all.png'});}
function exportAllMont(){screenshotTabAll({charts:['pmontCorr','pmontHist'],dashId:'montLiveStats',title:'Montgomery Correlation',filename:'montgomery_all.png'});}
function exportAllGUE(){screenshotTabAll({charts:['pgueSpacing','pgueHist'],dashId:'gueLiveStats',title:'GUE Statistics',filename:'gue_all.png'});}
function exportAllRace(){screenshotTabAll({canvases:['crace'],charts:['praceCount'],dashId:'raceLiveStats',title:'Prime Races',filename:'primerace_all.png'});}


function exportAllQuantum(){screenshotTabAll({canvases:['cquantum'],dashId:'quantumLiveStats',title:'Quantum Orbitals',filename:'quantum_all.png'});}

function renderDashboard(ctx,data,x,y,w,isDk,maxH=500){
let cy=y;const pad=15,colW=w/3-pad;
ctx.save();
// Set clipping region to prevent overflow
ctx.beginPath();
ctx.rect(x-5,y-5,w+10,maxH+10);
ctx.clip();
// Cards
if(data.cards.length>0){
const cardsPerRow = Math.min(3, data.cards.length);
const cardW = w/cardsPerRow - pad/2;
data.cards.forEach((card,i)=>{
if(cy > y + maxH - 60) return; // Skip if overflow
const col = i % cardsPerRow;
const row = Math.floor(i / cardsPerRow);
const cx=x+col*(cardW+pad/2);
const cardY = cy + row * 65;
ctx.fillStyle=isDk?'#1a1f35':'#f0f0f0';
ctx.fillRect(cx,cardY,cardW,55);
ctx.fillStyle=card.color;ctx.font='bold 18px Segoe UI';ctx.textAlign='center';
const displayVal = card.value.length > 12 ? card.value.substring(0,10)+'...' : card.value;
ctx.fillText(displayVal,cx+cardW/2,cardY+28);
ctx.fillStyle=isDk?'#8090b0':'#666';ctx.font='9px Segoe UI';
const displayLbl = card.label.length > 25 ? card.label.substring(0,22)+'...' : card.label;
ctx.fillText(displayLbl,cx+cardW/2,cardY+45);
});
const numRows = Math.ceil(data.cards.length / 3);
cy+=numRows * 65 + 10;
}
ctx.textAlign='left';
// Sections
data.sections.forEach(sec=>{
if(cy > y + maxH - 40) return; // Skip if overflow
ctx.fillStyle=isDk?'#00d9ff':'#0066cc';ctx.font='bold 11px Segoe UI';
ctx.fillText(sec.title.substring(0,40),x,cy);cy+=16;
const cols=2,itemW=w/cols;
const visibleItems = sec.items.slice(0, Math.floor((y + maxH - cy) / 14) * cols);
visibleItems.forEach((item,i)=>{
const ix=x+(i%cols)*itemW,iy=cy+Math.floor(i/cols)*14;
ctx.fillStyle=isDk?'#8090b0':'#555';ctx.font='10px Segoe UI';
const keyStr = item.key.length > 15 ? item.key.substring(0,12)+'...' : item.key;
ctx.fillText(keyStr,ix,iy);
ctx.fillStyle=item.color!=='inherit'?item.color:(isDk?'#e0e0e0':'#222');
const valStr = item.val.length > 15 ? item.val.substring(0,12)+'...' : item.val;
ctx.fillText(valStr,ix+90,iy);
});
cy+=Math.ceil(visibleItems.length/cols)*14+12;
});
ctx.restore();
return cy;
}


async function screenshot2D(){
  const R = document.getElementById('r2dv')?.value || '20';
  const sh = document.getElementById('sh2d')?.value || 'circle';
  await screenshotUnified('c2d', 'stats2dLive', `2D Lattice Points — R=${R}, Shape: ${sh}`, 'mobius_2d.png', {scale: 2, legendId: 'al2d'});
}

async function screenshot3D(){
  const R = document.getElementById('r3dv')?.value || '10';
  await screenshotUnified('c3d', 'stats3dLive', `3D Lattice Points — R=${R}`, 'mobius_3d.png', {scale: 2, legendId: 'al3d'});
}

async function screenshotGaus(){
const R=document.getElementById('rgausv').value,col=document.getElementById('colGaus').value;
await screenshotUnified('cgaus','gausLiveStats',`Gaussian Integers ℤ[i] — R=${R}, Color: ${col}`,'gaussian_complete.png');
}

function draw3D(){
if(!document.getElementById("c3d")) return;

let R=+document.getElementById('r3dv').value||+document.getElementById('r3d').value;
const maxSafe3D=100;
if(R>maxSafe3D){
const pts=Math.round(4/3*Math.PI*R*R*R);
if(!confirm(`R=${R} will compute ~${pts.toLocaleString()} 3D points which may be slow.\n\nContinue anyway?`)){
R=maxSafe3D;document.getElementById('r3dv').value=R;document.getElementById('r3d').value=Math.min(50,R);
}}
const c=document.getElementById('c3d'),ctx=c.getContext('2d'),col=document.getElementById('col3d').value,vm=document.getElementById('vm3d').value,zm=+document.getElementById('zm3d').value;
// Auto-scale point size based on R
const userPs=+document.getElementById('ps3d').value;
const autoScaleEnabled=document.getElementById('autoScale3d')?.checked??true;
const ps=autoScaleEnabled?autoScale3D(R,userPs*30)/30:userPs; // Scale factor for 3D (smaller base)
const smithEnabled=document.getElementById('smith3d').checked,smithAlpha=+document.getElementById('smithA3d').value,smithRMode=document.getElementById('smithR3d').value;
const smithGrid=document.getElementById('smithGrid3d').checked,smithConstR=document.getElementById('smithCircR3d').checked,smithConstX=document.getElementById('smithArcX3d').checked;
ctx.fillStyle=canvBg();ctx.fillRect(0,0,c.width,c.height);
const cxS=c.width/2,cyS=c.height/2,smithRad=(c.width/2-40)*zm;
if(smithEnabled){drawSmithGrid(ctx,cxS,cyS,smithRad,smithGrid,smithConstR,smithConstX);ctx.strokeStyle=bordC();ctx.lineWidth=2;ctx.beginPath();ctx.arc(cxS,cyS,smithRad,0,2*Math.PI);ctx.stroke();}
let rawPts=enum3D(R);
if(vm==='inv')rawPts=rawPts.map(pt=>{const n=Math.sqrt(pt.x*pt.x+pt.y*pt.y+pt.z*pt.z);if(n>.1){const s=R*R/(n*n);return{x:pt.x*s,y:pt.y*s,z:pt.z*s,g:pt.g,p:pt.p};}return pt;});
const proj=rawPts.map((pt,idx)=>{let x=pt.x,y=pt.y,z=pt.z;
let y1=y*Math.cos(rx)-z*Math.sin(rx),z1=y*Math.sin(rx)+z*Math.cos(rx);y=y1;z=z1;
let x2=x*Math.cos(ry)+z*Math.sin(ry),z2=-x*Math.sin(ry)+z*Math.cos(ry);x=x2;z=z2;
let x3=x*Math.cos(rz)-y*Math.sin(rz),y3=x*Math.sin(rz)+y*Math.cos(rz);x=x3;y=y3;
let px,py;
if(smithEnabled){const theta=Math.atan2(y,x);const dist3d=Math.sqrt(pt.x*pt.x+pt.y*pt.y+pt.z*pt.z);let r=1;if(smithRMode==='index')r=1+(idx/rawPts.length)*2;else if(smithRMode==='dist')r=0.5+dist3d/(R*2);const sm=smithTransform(r,theta,smithAlpha);px=cxS+sm.x*smithRad;py=cyS-sm.y*smithRad;}
else{const fov=500,sc=fov/(z+fov/2);px=c.width/2+(x*sc*zm*15)+panX;py=c.height/2-(y*sc*zm*15)+panY;}
let clr;if(col==='gcd')clr={1:'#00d9ff',2:'#64c8ff',3:'#9664ff'}[pt.g]||'#ff6496';
else if(col==='dist'){const d=Math.sqrt(pt.x*pt.x+pt.y*pt.y+pt.z*pt.z)/R;clr=`hsl(${Math.floor((1-d)*240)},100%,50%)`;}
else if(col==='prim')clr=pt.p?'#00d9ff':'#ff6496';
else if(col==='rainbow'){const ang=Math.atan2(pt.y,pt.x);clr=`hsl(${Math.floor((ang+Math.PI)/(2*Math.PI)*360)},100%,50%)`;}
else if(col==='quadres'){const n2=(pt.x*pt.x+pt.y*pt.y+pt.z*pt.z)%Math.max(2,Math.ceil(R)),isQR=n2===0||[...Array(Math.ceil(R))].some((_,i)=>(i*i)%Math.max(2,Math.ceil(R))===n2);clr=isQR?'#ffd700':'#9664ff';}
else if(col==='primality'){const prod=Math.abs(pt.x*pt.y*pt.z),isPr=prod>1&&[...Array(Math.floor(Math.sqrt(prod))+1)].every((_,i)=>i<2||prod%i!==0);clr=prod<=1?'#64c8ff':isPr?'#00ff88':'#ff6496';}
else if(col==='moddist'){const md=Math.min(Math.abs(pt.x),Math.abs(pt.y),Math.abs(pt.z));clr=`hsl(${Math.floor(md/R*300)},100%,50%)`;}
else if(col==='symmetry'){const vals=[Math.abs(pt.x),Math.abs(pt.y),Math.abs(pt.z)].sort((a,b)=>a-b),sym=vals[2]-vals[0];clr=sym===0?'#ffd700':`hsl(${Math.floor(sym/R*240)},80%,50%)`;}
else if(col==='heatmap'){const d=Math.sqrt(pt.x*pt.x+pt.y*pt.y+pt.z*pt.z)/R;clr=d<.25?'#00008b':d<.5?'#00d9ff':d<.75?'#ffff00':'#ff0000';}
else if(col==='divisibility'){const dc=[...Array(pt.g)].filter((_,i)=>i>0&&pt.g%i===0).length+1;clr=`hsl(${dc*40},100%,50%)`;}
else if(col==='discrete'){const cols=['#e6194b','#3cb44b','#ffe119','#4363d8','#f58231','#911eb4','#46f0f0','#f032e6','#bcf60c','#fabebe','#008080','#e6beff','#9a6324','#fffac8','#800000','#aaffc3','#808000','#ffd8b1','#000075','#808080'];clr=cols[(pt.g-1)%cols.length];}
else if(col==='fire'){const d=Math.sqrt(pt.x*pt.x+pt.y*pt.y+pt.z*pt.z)/R;clr=d<.33?`rgb(${Math.floor(d*3*255)},0,0)`:d<.66?`rgb(255,${Math.floor((d-.33)*3*255)},0)`:`rgb(255,${Math.floor(128+(d-.66)*3*127)},${Math.floor((d-.66)*3*255)})`;}
else if(col==='plasma'){const d=Math.sqrt(pt.x*pt.x+pt.y*pt.y+pt.z*pt.z)/R;clr=`rgb(${Math.floor(13+d*230)},${Math.floor(8+d*92+Math.sin(d*Math.PI)*100)},${Math.floor(135+d*80-d*d*150)})`;}
else if(col==='viridis'){const d=Math.sqrt(pt.x*pt.x+pt.y*pt.y+pt.z*pt.z)/R;clr=`rgb(${Math.floor(68+d*187)},${Math.floor(1+d*206)},${Math.floor(84-d*50+d*d*100)})`;}
else if(col==='ocean'){const d=Math.sqrt(pt.x*pt.x+pt.y*pt.y+pt.z*pt.z)/R;clr=`rgb(${Math.floor(d*100)},${Math.floor(50+d*150)},${Math.floor(100+d*155)})`;}
else if(col==='multtable'){const M=6;const prod=((Math.abs(pt.x)%M)*(Math.abs(pt.y)%M)*(Math.abs(pt.z)%M))%M;clr=`hsl(${(prod/M)*360},70%,50%)`;}
else if(col==='zerodiv'){const M=6;const ax=Math.abs(pt.x)%M;const ay=Math.abs(pt.y)%M;const az=Math.abs(pt.z)%M;const prod=(ax*ay*az)%M;const allUnits=gcd(ax,M)===1&&gcd(ay,M)===1&&gcd(az,M)===1;if(prod===0&&ax*ay*az!==0)clr='#ff4040';else if(allUnits)clr='#3366cc';else clr='#884444';}
else if(col==='idempotent'){const M=6;const ax=Math.abs(pt.x)%M;const ay=Math.abs(pt.y)%M;const az=Math.abs(pt.z)%M;const isIdemp=(ax*ax)%M===ax||(ay*ay)%M===ay||(az*az)%M===az;clr=isIdemp?'#ffd700':'#555';}
else if(col==='fareysector'){
  // Farey Sector in 3D: use spherical coordinates, partition by polar angle
  const r3 = Math.sqrt(pt.x*pt.x + pt.y*pt.y + pt.z*pt.z);
  const phi = r3 > 0 ? Math.acos(pt.z / r3) : 0; // polar angle 0 to π
  const sectorColors = ['#ff6496','#ffd700','#00ff88','#00d9ff','#9664ff','#ff8c00','#ff00ff','#00ffff','#88ff00','#ff4444'];
  // Divide π into 10 sectors
  const sector = Math.min(9, Math.floor(phi / (Math.PI / 10)));
  clr = sectorColors[sector];
  // Dim non-primitives
  if(!pt.p) clr = clr + '77';
}
else clr=pt.p?'#00d9ff':'#ff6496';
const fov=500,sc=fov/(z+fov/2);
return{px,py,z,clr,sc:smithEnabled?1:sc*zm,g:pt.g,p:pt.p,ox:pt.x,oy:pt.y,oz:pt.z};});
proj.sort((a,b)=>a.z-b.z);
if(!smithEnabled){ctx.strokeStyle=gridC();ctx.lineWidth=1;
const seg=12;for(let lat=0;lat<seg;lat++)for(let lng=0;lng<seg;lng++){const lat1=(lat/seg)*Math.PI,lng1=(lng/seg)*2*Math.PI,lng2=((lng+1)/seg)*2*Math.PI;
const x1=R*Math.sin(lat1)*Math.cos(lng1),y1=R*Math.cos(lat1),z1=R*Math.sin(lat1)*Math.sin(lng1);
const x2=R*Math.sin(lat1)*Math.cos(lng2),y2=R*Math.cos(lat1),z2=R*Math.sin(lat1)*Math.sin(lng2);
const rot1=(p)=>{let x=p.x,y=p.y,z=p.z;let y1=y*Math.cos(rx)-z*Math.sin(rx),z1=y*Math.sin(rx)+z*Math.cos(rx);y=y1;z=z1;let x2=x*Math.cos(ry)+z*Math.sin(ry),z2=-x*Math.sin(ry)+z*Math.cos(ry);x=x2;z=z2;let x3=x*Math.cos(rz)-y*Math.sin(rz),y3=x*Math.sin(rz)+y*Math.cos(rz);return{x:x3,y:y3,z};};
const pr1=rot1({x:x1,y:y1,z:z1}),pr2=rot1({x:x2,y:y2,z:z2});
const fov=500,sc1=fov/(pr1.z+fov/2),sc2=fov/(pr2.z+fov/2);
const px1=c.width/2+pr1.x*sc1*zm*15+panX,py1=c.height/2-pr1.y*sc1*zm*15+panY;
const px2=c.width/2+pr2.x*sc2*zm*15+panX,py2=c.height/2-pr2.y*sc2*zm*15+panY;
ctx.beginPath();ctx.moveTo(px1,py1);ctx.lineTo(px2,py2);ctx.stroke();}}

// Sweep & Ray Overlays for 3D
const ray3dShow = document.getElementById('ray3dShow')?.checked;
const ray3dBands = document.getElementById('ray3dBands')?.checked;
const ray3dOp = +document.getElementById('ray3dOp')?.value || 0.3;
const ray3dMode = document.getElementById('ray3dMode')?.value || 'coprime';
const ray3dColor = document.getElementById('ray3dColor')?.value || '#ffd700';

if (!smithEnabled && (ray3dShow || ray3dBands)) {
  const fov3d = 500;
  
  // Draw rays from origin to points
  if (ray3dShow) {
    const r = parseInt(ray3dColor.slice(1,3), 16);
    const g = parseInt(ray3dColor.slice(3,5), 16);
    const b = parseInt(ray3dColor.slice(5,7), 16);
    ctx.strokeStyle = `rgba(${r},${g},${b},${ray3dOp})`;
    ctx.lineWidth = 1;
    
    let rayPts = proj;
    if (ray3dMode === 'coprime') rayPts = proj.filter(p => p.p);
    else if (ray3dMode === 'shell') {
      // Outer shell: points at max distance
      const maxDist = Math.max(...rawPts.map(p => Math.hypot(p.x, p.y, p.z)));
      rayPts = proj.filter((p, i) => Math.hypot(rawPts[i].x, rawPts[i].y, rawPts[i].z) > maxDist * 0.9);
    }
    
    for (const p of rayPts) {
      ctx.beginPath();
      ctx.moveTo(c.width/2 + panX, c.height/2 + panY);
      ctx.lineTo(p.px, p.py);
      ctx.stroke();
    }
  }
  
  // Draw polar band lines
  if (ray3dBands) {
    ctx.setLineDash([4, 4]);
    const bandColors = ['#ff6496','#ffd700','#00ff88','#00d9ff','#9664ff'];
    for (let phi = 18; phi <= 162; phi += 18) {
      const phiRad = phi * Math.PI / 180;
      ctx.strokeStyle = bandColors[(phi/18 - 1) % bandColors.length] + '88';
      ctx.lineWidth = 1;
      
      // Draw circle at this polar angle
      ctx.beginPath();
      for (let theta = 0; theta <= 360; theta += 10) {
        const thetaRad = theta * Math.PI / 180;
        const x = R * Math.sin(phiRad) * Math.cos(thetaRad);
        const y = R * Math.cos(phiRad);
        const z = R * Math.sin(phiRad) * Math.sin(thetaRad);
        
        // Apply rotations
        let y1 = y * Math.cos(rx) - z * Math.sin(rx);
        let z1 = y * Math.sin(rx) + z * Math.cos(rx);
        let x2 = x * Math.cos(ry) + z1 * Math.sin(ry);
        let z2 = -x * Math.sin(ry) + z1 * Math.cos(ry);
        let x3 = x2 * Math.cos(rz) - y1 * Math.sin(rz);
        let y3 = x2 * Math.sin(rz) + y1 * Math.cos(rz);
        
        const sc = fov3d / (z2 + fov3d / 2);
        const px = c.width / 2 + x3 * sc * zm * 15 + panX;
        const py = c.height / 2 - y3 * sc * zm * 15 + panY;
        
        if (theta === 0) ctx.moveTo(px, py);
        else ctx.lineTo(px, py);
      }
      ctx.stroke();
    }
    ctx.setLineDash([]);
  }
}

for(const p of proj){ctx.fillStyle=p.clr;ctx.beginPath();ctx.arc(p.px,p.py,Math.max(1,ps*p.sc*10),0,2*Math.PI);ctx.fill();}
if(smithEnabled){ctx.fillStyle=isDark()?'#ffd700':'#cc8800';ctx.font='12px Segoe UI';ctx.fillText('Smith Chart: Γ = (z-1)/(z+1)',10,20);ctx.fillText(`α = ${smithAlpha}°`,10,35);}
pts3d=proj;
const tot=rawPts.length,prim=rawPts.filter(p=>p.p).length,th=theory(R,3),z3=zeta(3);
legend('al3d',`${smithEnabled?'Smith Chart':'3D Ball'} ${vm==='inv'?'(Inverted)':''}`,[['1/ζ(3) Pred',fmt(tot/z3),'#9664ff'],['Theory',fmt(th),'#ff8c00']]);
document.getElementById('st3d').innerHTML='';
const gcd3dDist={};rawPts.forEach(p=>{gcd3dDist[p.g]=(gcd3dDist[p.g]||0)+1;});const gcd3dKeys=Object.keys(gcd3dDist).sort((a,b)=>+a-+b);
const basel3dRatio=z3>0?(prim/tot)/(1/z3):0;
const rotXdeg=Math.round(rx*180/Math.PI)%360,rotYdeg=Math.round(ry*180/Math.PI)%360,rotZdeg=Math.round(rz*180/Math.PI)%360;
document.getElementById('stats3dLive').innerHTML=`
<div style="display:grid;grid-template-columns:repeat(3,1fr);gap:8px;margin-bottom:12px">
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center"><div style="font-size:1.5rem;font-weight:bold;color:#00d9ff">${R}</div><div style="font-size:.75rem;color:var(--txt2)">RADIUS R</div></div>
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center"><div style="font-size:1.5rem;font-weight:bold;color:#ffd700">${tot}</div><div style="font-size:.75rem;color:var(--txt2)">TOTAL POINTS</div></div>
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center"><div style="font-size:1.5rem;font-weight:bold;color:#00ff88">${prim}</div><div style="font-size:.75rem;color:var(--txt2)">PRIMITIVE</div></div>
</div>
<div style="margin-bottom:12px;padding-bottom:10px;border-bottom:1px solid var(--bord)">
<strong style="color:var(--acc)">View Settings</strong>
<div style="display:grid;grid-template-columns:1fr 1fr;gap:4px;margin-top:6px;font-size:.8rem">
<span>X-Rotation:</span><span style="color:#ff6496;font-weight:bold">${rotXdeg}°</span>
<span>Y-Rotation:</span><span style="color:#00d9ff;font-weight:bold">${rotYdeg}°</span>
<span>Z-Rotation:</span><span style="color:#ffd700;font-weight:bold">${rotZdeg}°</span>
<span>Zoom Level:</span><span style="color:var(--txt)">${zm}x</span>
<span>View Mode:</span><span style="color:${vm==='inv'?'#ff8c00':'#00ff88'}">${vm==='inv'?'INVERTED':'Normal'}</span>
<span>Auto-Rotate:</span><span style="color:${anim3d?'#00ff88':'#ff6496'}">${anim3d?'ON':'OFF'}</span>
${smithEnabled?`<span>Smith Chart:</span><span style="color:#00ff88">ON (α=${smithAlpha}°)</span>`:`<span>Smith Chart:</span><span style="color:#ff6496">OFF</span>`}
</div>
</div>
<div style="margin-bottom:12px;padding-bottom:10px;border-bottom:1px solid var(--bord)">
<strong style="color:var(--acc)">Basel Problem Analysis (3D)</strong>
<div style="display:grid;grid-template-columns:1fr 1fr;gap:4px;margin-top:6px;font-size:.8rem">
<span>Coprime Density:</span><span style="color:#ffd700;font-weight:bold">${fmt(100*prim/tot)}%</span>
<span>Basel Limit (1/ζ(3)):</span><span style="color:#9664ff">${fmt(100/z3)}%</span>
<span>Ratio to Basel:</span><span style="color:${basel3dRatio>0.9&&basel3dRatio<1.1?'#00ff88':'#ff8c00'}">${fmt(basel3dRatio*100)}%</span>
<span>Predicted Count:</span><span style="color:#9664ff">${fmt(tot/z3)}</span>
<span>Theory (3D):</span><span style="color:#ff8c00">${fmt(th)}</span>
<span>Abs Error:</span><span style="color:${Math.abs(prim-th)<10?'#00ff88':'#ff6496'}">${fmt(Math.abs(prim-th))}</span>
</div>
</div>
<div style="margin-bottom:12px;padding-bottom:10px;border-bottom:1px solid var(--bord)">
<strong style="color:var(--acc)">GCD Distribution</strong>
<div style="display:grid;grid-template-columns:1fr 1fr;gap:4px;margin-top:6px;font-size:.8rem">
<span>Min GCD:</span><span style="color:var(--txt)">${rawPts.reduce((m,p)=>Math.min(m,p.g),Infinity)}</span>
<span>Max GCD:</span><span style="color:var(--txt)">${rawPts.reduce((m,p)=>Math.max(m,p.g),0)}</span>
<span>Unique GCDs:</span><span style="color:var(--txt)">${gcd3dKeys.length}</span>
</div>
<div style="margin-top:8px;font-size:.75rem">
${gcd3dKeys.slice(0,6).map(g=>`<span style="display:inline-block;padding:2px 6px;margin:2px;border-radius:3px;background:${+g===1?'#ffd700':+g===2?'#00d9ff':'#9664ff'};color:#000;font-weight:bold">GCD=${g}: ${gcd3dDist[g]}</span>`).join('')}
${gcd3dKeys.length>6?'<span style="color:var(--txt2)">...</span>':''}
</div>
</div>
<div>
<strong style="color:var(--acc)">Quick Properties</strong>
<div style="margin-top:6px;font-size:.8rem;line-height:1.6">
• Volume: (4/3)πR³ ≈ ${fmt(4/3*Math.PI*R*R*R)}<br>
• Points per unit vol: ${fmt(tot/(4/3*Math.PI*R*R*R))}<br>
• ζ(3) ≈ ${fmt(z3)} (Apéry's constant)<br>
• 1/ζ(3) ≈ ${fmt(1/z3)} (coprime prob)
</div>
</div>
${fareySectorStatsHTML3D(rawPts, R)}
${singularSeriesHTML(Math.max(2,Math.round(R)), 2, 'Modular Sieve (R as M)')}`;

// Update 3D Farey Sector Analysis stats
if (document.getElementById('sec3dStats')) {
  const secFromVal = +document.getElementById('sec3dFrom')?.value || 36;
  const secToVal = +document.getElementById('sec3dTo')?.value || 72;
  
  // Count points in polar band
  let sectorPrims = 0, sectorTotal = 0;
  for (const pt of rawPts) {
    const r3 = Math.sqrt(pt.x*pt.x + pt.y*pt.y + pt.z*pt.z);
    if (r3 > 0) {
      const phi = Math.acos(pt.z / r3) * 180 / Math.PI;
      if (phi >= secFromVal && phi <= secToVal) {
        sectorTotal++;
        if (pt.p) sectorPrims++;
      }
    }
  }
  
  document.getElementById('sec3dCoprime').textContent = sectorPrims;
  document.getElementById('sec3dTotal').textContent = sectorTotal;
  document.getElementById('sec3dWidth').textContent = Math.abs(secToVal - secFromVal) + '°';
  
  let bandName = 'Custom';
  if (secFromVal === 0 && secToVal === 18) bandName = 'Polar Cap';
  else if (secFromVal === 18 && secToVal === 36) bandName = 'Arctic';
  else if (secFromVal === 36 && secToVal === 72) bandName = 'Temperate';
  else if (secFromVal === 72 && secToVal === 108) bandName = 'Equatorial';
  else if (secFromVal === 108 && secToVal === 144) bandName = 'S. Temperate';
  else if (secFromVal === 144 && secToVal === 180) bandName = 'S. Polar';
  
  const statsDiv = document.getElementById('sec3dStats');
  const labelDiv = statsDiv.querySelector('div');
  if (labelDiv) labelDiv.innerHTML = `<span style="color:#9664ff;font-weight:bold">Polar Band: ${secFromVal}° – ${secToVal}° (${bandName})</span>`;
}

c.onclick=e=>{const rect=c.getBoundingClientRect(),mx=(e.clientX-rect.left)*(c.width/rect.width),my=(e.clientY-rect.top)*(c.height/rect.height);for(const p of[...proj].reverse())if(Math.hypot(mx-p.px,my-p.py)<10){const theta=Math.atan2(p.oy,p.ox);const sm=smithEnabled?smithTransform(1,theta,smithAlpha):{x:0,y:0};modal('3D Point Analysis',[['Position',`(${fmt(p.ox)}, ${fmt(p.oy)}, ${fmt(p.oz)})`],['GCD',p.g],['Primitive',p.p?'Yes':'No'],['Distance',Math.sqrt(p.ox*p.ox+p.oy*p.oy+p.oz*p.oz)],smithEnabled?['Γ (Smith)',`${sm.x.toFixed(4)} + ${sm.y.toFixed(4)}i`]:['Z-depth',p.z]]);break;}};}
let drag=false,rmd=false,lx,ly;
function syncRotInputs(){document.getElementById('rotX').value=Math.round(rx*180/Math.PI)%360;document.getElementById('rotY').value=Math.round(ry*180/Math.PI)%360;document.getElementById('rotZ').value=Math.round(rz*180/Math.PI)%360;document.getElementById('rotXr').value=Math.round(rx*180/Math.PI)%360;document.getElementById('rotYr').value=Math.round(ry*180/Math.PI)%360;document.getElementById('rotZr').value=Math.round(rz*180/Math.PI)%360;}
// c3d handlers wrapped in null check (not in standalone)
if(document.getElementById('c3d')){
document.getElementById('c3d').onmousedown=e=>{if(e.button===0){drag=true;}else if(e.button===2){rmd=true;}lx=e.clientX;ly=e.clientY;e.preventDefault();};
document.getElementById('c3d').oncontextmenu=e=>e.preventDefault();
document.getElementById('c3d').onwheel=e=>{const z=document.getElementById('zm3d');z.value=Math.max(.2,Math.min(5,+z.value+(e.deltaY>0?-.1:.1)));document.getElementById('zmv').textContent=z.value+'x';draw3D();e.preventDefault();};
}
document.onmousemove=e=>{if(drag){ry+=(e.clientX-lx)*.01;rx+=(e.clientY-ly)*.01;lx=e.clientX;ly=e.clientY;if(typeof syncRotInputs==='function')syncRotInputs();if(typeof draw3D==='function')draw3D();}else if(rmd){panX+=(e.clientX-lx);panY+=(e.clientY-ly);lx=e.clientX;ly=e.clientY;if(typeof draw3D==='function')draw3D();}};
document.onmouseup=()=>{drag=false;rmd=false;};
setInterval(()=>{if(anim3d && typeof draw3D==='function'){ry+=.015;if(typeof syncRotInputs==='function')syncRotInputs();draw3D();}},50);
function csv3D(){let s='x,y,z,gcd,primitive\n';for(const p of enum3D(+document.getElementById('r3dv').value||+document.getElementById('r3d').value))s+=`${p.x},${p.y},${p.z},${p.g},${p.p}\n`;dl(s,'mobius_3d.csv');}

function runErr(){runErrNew();}

function runErrNew(){
const maxR=+document.getElementById('errRv').value||+document.getElementById('errR').value;
const sh=document.getElementById('errSh').value;
const step=+document.getElementById('errStep').value;
const theta=+document.getElementById('errTheta').value;
const showBounds=document.getElementById('errBounds').checked;
const useLog=document.getElementById('errLog').checked;
const compare=document.getElementById('errCompare').value;

const rs=[],totals=[],prims=[],ths=[],primThs=[],errs=[],normErrs=[],relEs=[];
D.err=[];

for(let r=step;r<=maxR;r+=step){
const pts=enum2D(r,sh);
const total=pts.length;
const prim=pts.filter(x=>x.p).length;
const th=sh==='circle'?Math.PI*r*r:(2*Math.floor(r)+1)**2;
const primTh=th/zeta(2);
const err=total-th;
const primErr=prim-primTh;
const normErr=r>0?err/Math.pow(r,theta):0;

rs.push(r);
totals.push(total);
prims.push(prim);
ths.push(th);
primThs.push(primTh);
errs.push(err);
normErrs.push(normErr);
relEs.push(th>0?Math.abs(err)/th*100:0);
D.err.push({r,total,prim,th,primTh,err,primErr,normErr,relE:th>0?Math.abs(err)/th*100:0,sqrtR:Math.abs(err)/Math.sqrt(r)});}

// Statistics
const meanErr=errs.reduce((a,b)=>a+b,0)/errs.length;
const rmsErr=Math.sqrt(errs.reduce((a,b)=>a+b*b,0)/errs.length);
const maxAbsErr=errs.reduce((m,e)=>Math.max(m,Math.abs(e)),0);
const minAbsErr=errs.reduce((m,e)=>Math.min(m,Math.abs(e)),Infinity);

// Chart 1: Theory vs Actual
const traces1=[
{x:rs,y:ths,name:`Theory ${sh==='circle'?'πR²':'(2R+1)²'}`,mode:'lines',line:{color:'#ff8c00',width:3}},
{x:rs,y:totals,name:'Actual Total',mode:'markers',marker:{color:'#00d9ff',size:5}}
];
if(compare==='primitive'||compare==='both'){
traces1.push({x:rs,y:primThs,name:'Prim Theory',mode:'lines',line:{color:'#00ff88',width:2,dash:'dash'}});
traces1.push({x:rs,y:prims,name:'Primitive',mode:'markers',marker:{color:'#ffd700',size:4}});}
Plotly.newPlot('pe1',traces1,{...plo(),xaxis:{title:'Radius R'},yaxis:{title:'Count',type:useLog?'log':'linear'}});
legend('ale1','Count Comparison',[['Max Total',totals.reduce((a,b)=>Math.max(a,b),0),'#00d9ff'],['Max Prim',prims.reduce((a,b)=>Math.max(a,b),0),'#ffd700']]);

// Chart 2: Absolute Error
const traces2=[{x:rs,y:errs,name:'Error',mode:'lines+markers',line:{color:'#ff006e',width:2},marker:{size:4}}];
if(showBounds){
traces2.push({x:rs,y:rs.map(r=>Math.sqrt(r)*2),name:'O(√R)',mode:'lines',line:{color:'#666',dash:'dot'}});
traces2.push({x:rs,y:rs.map(r=>-Math.sqrt(r)*2),name:'-O(√R)',mode:'lines',line:{color:'#666',dash:'dot'}});}
Plotly.newPlot('pe2',traces2,{...plo(),xaxis:{title:'R'},yaxis:{title:'Error N(R)-πR²'}});
legend('ale2','Absolute Error',[['Max',fmt(maxAbsErr),'#ff006e'],['RMS',fmt(rmsErr),'#ff8c00']]);

// Chart 3: Relative Error %
Plotly.newPlot('pe3',[{x:rs,y:relEs,mode:'lines+markers',line:{color:'#00ff88',width:2},marker:{size:3}}],{...plo(),xaxis:{title:'R'},yaxis:{title:'|Error|/Theory %',type:useLog?'log':'linear'}});
legend('ale3','Relative Error',[['Max %',fmt(relEs.reduce((a,b)=>Math.max(a,b),0)),'#ff006e'],['Min %',fmt(relEs.reduce((a,b)=>Math.min(a,b),Infinity)),'#00ff88']]);

// Chart 4: Normalized Error
Plotly.newPlot('pe4',[
{x:rs,y:normErrs,name:`Error/R^${theta}`,mode:'lines+markers',line:{color:'#9664ff',width:2},marker:{size:3}},
{x:rs,y:rs.map(()=>0),mode:'lines',line:{color:'#666',dash:'dash'}}
],{...plo(),xaxis:{title:'R'},yaxis:{title:`Error / R^${theta}`}});
const maxNormErr=normErrs.reduce((m,e)=>Math.max(m,Math.abs(e)),0);
legend('ale4','Normalized',[['θ =',theta,'#9664ff'],['Bounded?',maxNormErr<10?'Yes':'No','#00ff88']]);

// Chart 5: Error histogram
const errBins=[],binSize=Math.max(1,Math.ceil(maxAbsErr/10));
for(let b=-10;b<=10;b++){const lo=b*binSize,hi=(b+1)*binSize;
errBins.push({bin:`${lo}`,count:errs.filter(e=>e>=lo&&e<hi).length});}
Plotly.newPlot('peHist',[{x:errBins.map(b=>b.bin),y:errBins.map(b=>b.count),type:'bar',marker:{color:errBins.map(b=>+b.bin>=0?'#00d9ff':'#ff006e')}}],{...plo(),xaxis:{title:'Error Range'},yaxis:{title:'Frequency'}});

// Live stats
document.getElementById('errLiveStats').innerHTML=`
<div style="background:linear-gradient(135deg,rgba(0,217,255,.15),rgba(255,215,0,.1));padding:10px;border-radius:8px;margin-bottom:12px;border:1px solid var(--acc)">
<div style="font-size:.7rem;color:var(--txt2);margin-bottom:4px">TAB: Error Analysis | FIELD: ℤ² Lattice | TYPE: Primitive Point Counting</div>
<div style="display:grid;grid-template-columns:repeat(4,1fr);gap:6px;font-size:.75rem">
<span>Max R: <strong style="color:#00d9ff">${maxR}</strong></span>
<span>Shape: <strong style="color:#ffd700">${sh}</strong></span>
<span>Step: <strong style="color:#00ff88">${step}</strong></span>
<span>θ: <strong style="color:#ff6496">${theta}</strong></span>
</div>
</div>
<div style="display:grid;grid-template-columns:repeat(3,1fr);gap:8px;margin-bottom:12px">
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center"><div style="font-size:1.4rem;font-weight:bold;color:#00d9ff">${maxR}</div><div style="font-size:.7rem;color:var(--txt2)">MAX R</div></div>
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center"><div style="font-size:1.4rem;font-weight:bold;color:#ffd700">${D.err.length}</div><div style="font-size:.7rem;color:var(--txt2)">DATA POINTS</div></div>
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center"><div style="font-size:1.4rem;font-weight:bold;color:#00ff88">${sh}</div><div style="font-size:.7rem;color:var(--txt2)">SHAPE</div></div>
</div>
<div style="display:grid;grid-template-columns:repeat(3,1fr);gap:8px;margin-bottom:12px">
<div style="background:var(--bg1);padding:8px;border-radius:6px;text-align:center"><div style="font-size:1.1rem;font-weight:bold;color:#9664ff">${totals[totals.length-1]}</div><div style="font-size:.65rem;color:var(--txt2)">TOTAL COUNT</div></div>
<div style="background:var(--bg1);padding:8px;border-radius:6px;text-align:center"><div style="font-size:1.1rem;font-weight:bold;color:#ff8c00">${fmt(ths[ths.length-1])}</div><div style="font-size:.65rem;color:var(--txt2)">PREDICTED</div></div>
<div style="background:var(--bg1);padding:8px;border-radius:6px;text-align:center"><div style="font-size:1.1rem;font-weight:bold;color:${Math.abs(errs[errs.length-1])<10?'#00ff88':'#ff6496'}">${fmt(errs[errs.length-1])}</div><div style="font-size:.65rem;color:var(--txt2)">ERROR</div></div>
</div>
<div style="margin-bottom:10px;padding-bottom:8px;border-bottom:1px solid var(--bord)">
<strong style="color:var(--acc)">Error Statistics</strong>
<div style="display:grid;grid-template-columns:1fr 1fr;gap:3px;margin-top:5px;font-size:.8rem">
<span>Mean Error:</span><span style="color:#00d9ff">${fmt(meanErr)}</span>
<span>RMS Error:</span><span style="color:#ff8c00">${fmt(rmsErr)}</span>
<span>Max |Error|:</span><span style="color:#ff006e">${fmt(maxAbsErr)}</span>
<span>Min |Error|:</span><span style="color:#00ff88">${fmt(minAbsErr)}</span>
</div>
</div>
<div style="margin-bottom:10px;padding-bottom:8px;border-bottom:1px solid var(--bord)">
<strong style="color:var(--acc)">Normalized Analysis (θ=${theta})</strong>
<div style="display:grid;grid-template-columns:1fr 1fr;gap:3px;margin-top:5px;font-size:.8rem">
<span>Max |Err|/R^θ:</span><span style="color:#9664ff">${fmt(maxNormErr)}</span>
<span>Avg |Err|/√R:</span><span style="color:#ffd700">${fmt(D.err.reduce((a,d)=>a+d.sqrtR,0)/D.err.length)}</span>
<span>Bounded:</span><span style="color:${maxNormErr<20?'#00ff88':'#ff6496'}">${maxNormErr<20?'Likely':'Unclear'}</span>
</div>
</div>
<div style="margin-bottom:10px;padding-bottom:8px;border-bottom:1px solid var(--bord)">
<strong style="color:var(--acc)">Primitive Analysis</strong>
<div style="display:grid;grid-template-columns:1fr 1fr;gap:3px;margin-top:5px;font-size:.8rem">
<span>Final Prim Count:</span><span style="color:#ffd700">${prims[prims.length-1]}</span>
<span>Theory P(R)/ζ(2):</span><span style="color:#ff8c00">${fmt(primThs[primThs.length-1])}</span>
<span>Prim Density:</span><span style="color:#00ff88">${fmt(100*prims[prims.length-1]/totals[totals.length-1])}%</span>
<span>6/π² theory:</span><span style="color:#9664ff">${fmt(100/zeta(2))}%</span>
</div>
</div>
<div>
<strong style="color:var(--acc)">Observations</strong>
<div style="margin-top:5px;font-size:.75rem;line-height:1.5;color:var(--txt2)">
• Error oscillates around 0 (unbiased)<br>
• |Error| grows roughly as O(R^0.5)<br>
• Best known: O(R^0.63)<br>
• Conjecture: O(R^0.5+ε)
</div>
</div>`;

// Table
document.getElementById('te').innerHTML='<tr><th>R</th><th>Theory</th><th>Actual</th><th>Primitive</th><th>Error</th><th>|Err|/√R</th><th>Rel %</th></tr>'+
D.err.map(d=>`<tr onclick="modal('R=${d.r}',[['Total',${d.total}],['Primitive',${d.prim}],['Theory',${fmt(d.th)}],['Error',${fmt(d.err)}],['|Error|/√R',${fmt(d.sqrtR)}],['Rel Error %',${fmt(d.relE)}]])" style="cursor:pointer;color:${Math.abs(d.err)<Math.sqrt(d.r)*2?'#00ff88':'inherit'}"><td>${fmt(d.r)}</td><td>${fmt(d.th)}</td><td>${d.total}</td><td>${d.prim}</td><td>${fmt(d.err)}</td><td>${fmt(d.sqrtR)}</td><td>${fmt(d.relE)}</td></tr>`).join('');}

function runErrConvergence(){
// Convergence study: test if |Error|/R^θ stays bounded
const Rs=[5,10,15,20,25,30,40,50,60,75,100,125,150,175,200];
const theta=+document.getElementById('errTheta').value||0.5;
const shape=document.getElementById('errSh').value;
const results=[];
for(const R of Rs){
const pts=enum2D(R,shape);
const th=shape==='circle'?Math.PI*R*R:(2*Math.floor(R)+1)**2;
const err=pts.length-th;
const sqrtNorm=Math.abs(err)/Math.sqrt(R);
const thetaNorm=Math.abs(err)/Math.pow(R,theta);
results.push({R,total:pts.length,th,err,sqrtNorm,thetaNorm});}
// Update all error charts with convergence data
Plotly.newPlot('pe1',[
{x:Rs,y:results.map(d=>d.th),name:'Theory πR²',mode:'lines',line:{color:'#ff8c00',width:2}},
{x:Rs,y:results.map(d=>d.total),name:'Actual N(R)',mode:'markers',marker:{color:'#00d9ff',size:8}}
],{...plo(),title:'Convergence: Theory vs Actual',xaxis:{title:'R'},yaxis:{title:'Count'}});
Plotly.newPlot('pe2',[
{x:Rs,y:results.map(d=>d.err),mode:'lines+markers',line:{color:'#ff006e',width:2},marker:{size:6}},
{x:Rs,y:Rs.map(r=>2*Math.sqrt(r)),name:'2√R',mode:'lines',line:{color:'#666',dash:'dot'}},
{x:Rs,y:Rs.map(r=>-2*Math.sqrt(r)),name:'-2√R',mode:'lines',line:{color:'#666',dash:'dot'}}
],{...plo(),title:'Convergence: Error with √R Bounds',xaxis:{title:'R'},yaxis:{title:'Error'}});
Plotly.newPlot('pe4',[
{x:Rs,y:results.map(d=>d.sqrtNorm),name:'|Err|/√R',mode:'lines+markers',line:{color:'#9664ff',width:2}},
{x:Rs,y:results.map(d=>d.thetaNorm),name:`|Err|/R^${theta}`,mode:'lines+markers',line:{color:'#00ff88',width:2}}
],{...plo(),title:`Convergence: Normalized Error (θ=${theta})`,xaxis:{title:'R'},yaxis:{title:'Normalized Error'}});
legend('ale1','Convergence',[['Points',Rs.length,'#00d9ff']]);
legend('ale2','Bounds',[['Within √R?',results.every(d=>Math.abs(d.err)<3*Math.sqrt(d.R))?'Yes':'Some exceed','#ff006e']]);
legend('ale4','Scaling',[['√R trend',fmt(results[results.length-1].sqrtNorm),'#9664ff'],['θ trend',fmt(results[results.length-1].thetaNorm),'#00ff88']]);
// Show summary modal
const maxSqrt=Math.max(...results.map(d=>d.sqrtNorm));
const minSqrt=Math.min(...results.map(d=>d.sqrtNorm));
const avgSqrt=results.reduce((a,d)=>a+d.sqrtNorm,0)/results.length;
modal('Convergence Study Results',[
['Test Range',`R = 5 to 200 (${Rs.length} points)`],
['Shape',shape],
['Error Exponent θ',theta],
['|Error|/√R Range',`${fmt(minSqrt)} to ${fmt(maxSqrt)}`],
['|Error|/√R Average',fmt(avgSqrt)],
['Bounded?',maxSqrt<10?'Yes - stays bounded':'May be unbounded'],
['Hardy Conjecture',avgSqrt<5?'Consistent with O(R^{1/2+ε})':'Need more data']
]);}

function csvErr(){let s='R,Theory,Total,Primitive,Error,NormErr,RelError%,SqrtR\n';for(const d of D.err)s+=`${d.r},${d.th},${d.total},${d.prim},${d.err},${d.normErr},${d.relE},${d.sqrtR}\n`;dl(s,'error.csv');}

function runDim(){const R=+document.getElementById('rdim').value;D.dim=[];for(let n=2;n<=7;n++){const v=vol(n),z=zeta(n),th=theory(R,n),prim=Math.round(th),err=Math.abs(prim-th);D.dim.push({n,v,z,th,prim,err});}
document.getElementById('tdimT').innerHTML='<tr><th>n</th><th>Vol(B_n)</th><th>ζ(n)</th><th>Theory</th><th>Computed</th><th>Error</th></tr>'+D.dim.map(d=>`<tr onclick="modal('Dimension ${d.n}',[['Volume',${d.v}],['ζ(${d.n})',${d.z}],['1/ζ(${d.n})',${1/d.z}],['Theory',${d.th}]])" style="cursor:pointer"><td>${d.n}</td><td>${fmt(d.v)}</td><td>${fmt(d.z)}</td><td>${fmt(d.th)}</td><td>${d.prim}</td><td>${fmt(d.err)}</td></tr>`).join('');
legend('aldim','Primitive Density 1/ζ(k)',D.dim.map(d=>[`n=${d.n}`,1/d.z,`hsl(${d.n*50},100%,50%)`]));}
function csvDim(){let s='n,Vol,Zeta,Theory,Computed,Error\n';for(const d of D.dim)s+=`${d.n},${d.v},${d.z},${d.th},${d.prim},${d.err}\n`;dl(s,'dimensions.csv');}

// Möbius function - heart of the sieve
function mobius(n){if(n===1)return 1;let cnt=0;for(let p=2;p*p<=n;p++){if(n%p===0){cnt++;n/=p;if(n%p===0)return 0;}}if(n>1)cnt++;return cnt%2===0?1:-1;}
function factorize(n){if(n===1)return '1';const f=[];for(let p=2;p*p<=n;p++){let e=0;while(n%p===0){e++;n/=p;}if(e>0)f.push(e>1?`${p}^${e}`:p);}if(n>1)f.push(n);return f.join('·');}
function mertens(N){let m=0;for(let n=1;n<=N;n++)m+=mobius(n);return m;}

let mobData=[];
function drawMobius(){
if(!document.getElementById("cmob")) return;

// Get N from the number input (which is always synced with slider)
const nInput = document.getElementById('mobNv');
const nSlider = document.getElementById('mobN');
const N = Math.max(10, parseInt(nInput.value) || parseInt(nSlider.value) || 150);

// Sync slider if needed
if (nSlider && parseInt(nSlider.value) !== Math.min(2000, N)) {
  nSlider.value = Math.min(2000, N);
}

const viz=document.getElementById('mobViz').value;
const col=document.getElementById('mobCol').value;
const ptSz=+document.getElementById('mobPtSz').value||6;
const showBound=document.getElementById('mobShowBound')?.checked!==false;
const showGrid=document.getElementById('mobShowGrid')?.checked!==false;
const showLabels=document.getElementById('mobShowLabels')?.checked;
const c=document.getElementById('cmob'),ctx=c.getContext('2d');
ctx.fillStyle=canvBg();ctx.fillRect(0,0,c.width,c.height);

mobData=[];let M=0,sum1=0,cnt1=0,cnt0=0,cntM1=0;
const mertensVals=[];

for(let n=1;n<=N;n++){
const mu=mobius(n);
M+=mu;
sum1+=mu/n;
const sf=mu!==0;
if(mu===1)cnt1++;else if(mu===0)cnt0++;else cntM1++;
mobData.push({n,mu,M,sum1,sf,fac:factorize(n)});
mertensVals.push({x:n,y:M,bound:Math.sqrt(n)});
}

const cx=c.width/2,cy=c.height/2;
const pad=50;

// Grid
if(showGrid){
ctx.strokeStyle=gridC();
ctx.lineWidth=0.5;
ctx.setLineDash([3,3]);
ctx.beginPath();
ctx.moveTo(pad,cy);ctx.lineTo(c.width-pad,cy);
ctx.stroke();
ctx.setLineDash([]);
}

if(viz==='strip'){
const w=c.width-2*pad,h=c.height-2*pad;
const cols=Math.ceil(Math.sqrt(N*1.5)),rows=Math.ceil(N/cols);
const dx=w/cols,dy=h/rows;

ctx.font='bold 14px Segoe UI';ctx.fillStyle=isDark()?'#ffd700':'#cc8800';
ctx.textAlign='left';
ctx.fillText(`μ(n) Strip: N=${N} | Blue=+1, Gray=0, Red=-1`,pad,25);

for(let i=0;i<mobData.length;i++){
const d=mobData[i];
const x=pad+(i%cols)*dx;
const y=pad+20+Math.floor(i/cols)*dy;

let clr;
if(col==='classic') clr=d.mu===1?'#4ECDC4':d.mu===-1?'#FF6B6B':'#444';
else if(col==='prime'){
const pf=d.fac.split('·').filter(s=>s).length;
clr=d.mu===0?'#333':`hsl(${pf*50},80%,55%)`;
}else if(col==='gradient'){
clr=d.mu===0?'#333':`hsl(${(d.n/N)*270},70%,${d.mu===1?60:45}%)`;
}else{
clr=d.sf?'#ffd700':'#333';
}

ctx.fillStyle=clr;
ctx.fillRect(x,y,dx-1,dy-1);

if(showLabels&&dx>15&&dy>12&&N<=200){
ctx.fillStyle=isDark()?'#fff':'#000';
ctx.font=`${Math.min(10,dy-2)}px Segoe UI`;
ctx.textAlign='center';
ctx.fillText(d.n.toString(),x+dx/2,y+dy/2+3);
}
}
}
else if(viz==='mertens'){
const maxM=mobData.reduce((m,d)=>Math.max(m,Math.abs(d.M)),0)||1;
const w=c.width-2*pad,h=c.height-2*pad;
const scX=w/N,scY=(h/2)/maxM;

// Axes
ctx.strokeStyle=gridC();ctx.lineWidth=1;
ctx.beginPath();ctx.moveTo(pad,cy);ctx.lineTo(c.width-pad,cy);ctx.stroke();
ctx.beginPath();ctx.moveTo(pad,pad);ctx.lineTo(pad,c.height-pad);ctx.stroke();

// Labels
ctx.fillStyle=isDark()?'#ffd700':'#cc8800';ctx.font='bold 14px Segoe UI';
ctx.textAlign='left';
ctx.fillText(`Mertens Function M(x) = Σμ(n) for n≤x | N=${N}`,pad+10,25);

ctx.font='10px Segoe UI';ctx.textAlign='right';
ctx.fillText('0',pad-5,cy+4);
ctx.fillText(`${maxM}`,pad-5,pad+10);
ctx.fillText(`-${maxM}`,pad-5,c.height-pad);

// √x bound lines
if(showBound){
ctx.strokeStyle='rgba(255,100,100,0.3)';
ctx.lineWidth=1;
ctx.beginPath();
for(let n=1;n<=N;n++){
const x=pad+n*scX;
const bound=Math.sqrt(n);
if(n===1)ctx.moveTo(x,cy-bound*scY);
else ctx.lineTo(x,cy-bound*scY);
}
ctx.stroke();
ctx.beginPath();
for(let n=1;n<=N;n++){
const x=pad+n*scX;
const bound=Math.sqrt(n);
if(n===1)ctx.moveTo(x,cy+bound*scY);
else ctx.lineTo(x,cy+bound*scY);
}
ctx.stroke();
}

// M(x) line
ctx.beginPath();ctx.strokeStyle='#00d9ff';ctx.lineWidth=2;
mobData.forEach((d,i)=>{
const x=pad+d.n*scX,y=cy-d.M*scY;
if(i===0)ctx.moveTo(x,y);else ctx.lineTo(x,y);
});
ctx.stroke();

// Points at sign changes
ctx.fillStyle='#ff6496';
let lastSign=0;
mobData.forEach(d=>{
const sign=Math.sign(d.M);
if(sign!==0&&sign!==lastSign&&lastSign!==0){
const x=pad+d.n*scX,y=cy-d.M*scY;
ctx.beginPath();ctx.arc(x,y,4,0,2*Math.PI);ctx.fill();
}
lastSign=sign||lastSign;
});
}
else if(viz==='cumsum'){
const w=c.width-2*pad,h=c.height-2*pad,scX=w/N;
const vals=mobData.map(d=>d.sum1);
const minV=vals.reduce((a,b)=>Math.min(a,b),Infinity);
const maxV=vals.reduce((a,b)=>Math.max(a,b),-Infinity);
const range=maxV-minV||1;
const scY=h/range;

ctx.fillStyle=isDark()?'#ffd700':'#cc8800';ctx.font='bold 14px Segoe UI';
ctx.textAlign='left';
ctx.fillText(`Σμ(n)/n → 0 as N→∞ (equivalent to PNT) | N=${N}`,pad,25);

// Zero line
const y0=c.height-pad-(0-minV)*scY;
ctx.strokeStyle=gridC();ctx.lineWidth=1;
ctx.beginPath();ctx.moveTo(pad,y0);ctx.lineTo(c.width-pad,y0);ctx.stroke();
ctx.fillStyle='#888';ctx.font='10px Segoe UI';ctx.textAlign='right';
ctx.fillText('0',pad-5,y0+4);

// Curve
ctx.beginPath();ctx.strokeStyle='#00ff88';ctx.lineWidth=2;
mobData.forEach((d,i)=>{
const x=pad+d.n*scX,y=c.height-pad-(d.sum1-minV)*scY;
if(i===0)ctx.moveTo(x,y);else ctx.lineTo(x,y);
});
ctx.stroke();

// Current value
ctx.fillStyle='#00ff88';ctx.font='bold 12px Segoe UI';ctx.textAlign='right';
ctx.fillText(`Current: ${sum1.toFixed(6)}`,c.width-pad,c.height-pad+20);
}
else if(viz==='spiral'){
const maxR=Math.min(c.width,c.height)/2-40;
ctx.fillStyle=isDark()?'#ffd700':'#cc8800';ctx.font='bold 14px Segoe UI';
ctx.textAlign='center';
ctx.fillText(`Ulam-like Möbius Spiral | N=${N}`,cx,25);

for(let i=0;i<mobData.length;i++){
const d=mobData[i];
const ang=Math.sqrt(d.n)*2.4;
const r=Math.sqrt(d.n)/Math.sqrt(N)*maxR;
const x=cx+r*Math.cos(ang),y=cy+r*Math.sin(ang);

let clr;
if(col==='classic')clr=d.mu===1?'#4ECDC4':d.mu===-1?'#FF6B6B':'#333';
else if(col==='gradient')clr=d.mu===0?'#333':`hsl(${(d.n/N)*270},70%,55%)`;
else clr=d.sf?'#ffd700':'#333';

ctx.fillStyle=clr;
ctx.beginPath();ctx.arc(x,y,ptSz/2,0,2*Math.PI);ctx.fill();
}
}
else if(viz==='heatmap'){
// Divisor heatmap - show μ(d) for each divisor of each n
const maxShow=Math.min(N,100);
const cellW=(c.width-2*pad)/maxShow;
const cellH=(c.height-2*pad)/maxShow;

ctx.fillStyle=isDark()?'#ffd700':'#cc8800';ctx.font='bold 14px Segoe UI';
ctx.textAlign='left';
ctx.fillText(`Möbius Divisor Heatmap: μ(d) where d|n | N=${maxShow}`,pad,25);

for(let n=1;n<=maxShow;n++){
for(let d=1;d<=maxShow;d++){
if(n%d===0){
const mu=mobius(d);
const clr=mu===1?'rgba(78,205,196,0.8)':mu===-1?'rgba(255,107,107,0.8)':'rgba(80,80,80,0.5)';
ctx.fillStyle=clr;
ctx.fillRect(pad+(d-1)*cellW,pad+30+(n-1)*cellH,cellW-0.5,cellH-0.5);
}
}
}

ctx.fillStyle='#888';ctx.font='10px Segoe UI';
ctx.textAlign='center';
ctx.fillText('divisor d →',cx,c.height-10);
ctx.save();
ctx.translate(15,cy);
ctx.rotate(-Math.PI/2);
ctx.fillText('n →',0,0);
ctx.restore();
}

// Click handler
c.onclick=e=>{
const rect=c.getBoundingClientRect();
const mx=(e.clientX-rect.left)*(c.width/rect.width);
const my=(e.clientY-rect.top)*(c.height/rect.height);
if(viz==='strip'){
const w=c.width-2*pad,cols=Math.ceil(Math.sqrt(N*1.5));
const dx=w/cols,dy=(c.height-2*pad-20)/Math.ceil(N/cols);
const col=Math.floor((mx-pad)/dx),row=Math.floor((my-pad-20)/dy);
const idx=row*cols+col;
if(idx>=0&&idx<mobData.length){
const d=mobData[idx];
modal('Möbius Analysis',[['n',d.n],['μ(n)',d.mu],['M(n)',d.M],['Σμ(k)/k',fmt(d.sum1)],['Factorization',d.fac],['Squarefree',d.sf?'Yes':'No'],['|M(n)|/√n',fmt(Math.abs(d.M)/Math.sqrt(d.n))]]);
}
}
};

// Plotly charts
const sqfreeC=mobData.filter(d=>d.sf).length;

// Distribution bar chart
Plotly.newPlot('pmobDist',[{
x:['μ=+1','μ=0','μ=-1'],
y:[cnt1,cnt0,cntM1],
type:'bar',
marker:{color:['#4ECDC4','#555','#FF6B6B']}
}],{...plo(),xaxis:{title:'μ(n) value'},yaxis:{title:'Count'}});

// Mertens function plot
Plotly.newPlot('pmobMertens',[
{x:mobData.map(d=>d.n),y:mobData.map(d=>d.M),mode:'lines',name:'M(x)',line:{color:'#00d9ff',width:2}},
{x:mobData.map(d=>d.n),y:mobData.map(d=>Math.sqrt(d.n)),mode:'lines',name:'√x',line:{color:'#ff6496',width:1,dash:'dot'}},
{x:mobData.map(d=>d.n),y:mobData.map(d=>-Math.sqrt(d.n)),mode:'lines',name:'-√x',line:{color:'#ff6496',width:1,dash:'dot'},showlegend:false}
],{...plo(),xaxis:{title:'x'},yaxis:{title:'M(x)'}});

// Squarefree density plot
const sqfreeData=[];
for(let i=10;i<=N;i+=Math.max(1,Math.floor(N/50))){
const actual=mobData.slice(0,i).filter(d=>d.sf).length;
const theory=i*6/Math.PI/Math.PI;
sqfreeData.push({x:i,actual,theory});
}
Plotly.newPlot('pmobSqfree',[
{x:sqfreeData.map(d=>d.x),y:sqfreeData.map(d=>d.actual/d.x*100),mode:'lines+markers',name:'Actual %',line:{color:'#ffd700'},marker:{size:4}},
{x:sqfreeData.map(d=>d.x),y:sqfreeData.map(d=>600/Math.PI/Math.PI),mode:'lines',name:'6/π² ≈ 60.79%',line:{color:'#9664ff',dash:'dash'}}
],{...plo(),xaxis:{title:'N'},yaxis:{title:'Squarefree %',range:[55,65]}});

// Legend
legend('almob','Möbius Statistics',[['Σμ(n)/n',fmt(sum1),'#00ff88'],['M(N)',M,'#00d9ff'],['Squarefree',sqfreeC,'#ffd700']]);

// Live stats
document.getElementById('mobLiveStats').innerHTML=`
<div style="background:linear-gradient(135deg,rgba(150,100,255,.2),rgba(255,215,0,.1));padding:10px;border-radius:8px;margin-bottom:12px;border:1px solid #9664ff">
<div style="font-size:.7rem;color:var(--txt2);margin-bottom:4px">TAB: Möbius Function | FIELD: ℤ | TYPE: μ(n) Analysis</div>
<div style="display:grid;grid-template-columns:repeat(3,1fr);gap:6px;font-size:.75rem">
<span>N: <strong style="color:#ffd700">${N}</strong></span>
<span>Mode: <strong style="color:#00d9ff">${viz}</strong></span>
<span>M(N): <strong style="color:#00ff88">${M}</strong></span>
</div>
</div>
<div style="display:grid;grid-template-columns:repeat(3,1fr);gap:8px;margin-bottom:12px">
<div style="background:linear-gradient(135deg,rgba(78,205,196,.2),rgba(78,205,196,.05));padding:10px;border-radius:6px;text-align:center">
<div style="font-size:1.4rem;font-weight:bold;color:#4ECDC4">${cnt1}</div>
<div style="font-size:.7rem;color:var(--txt2)">μ(n)=+1</div>
</div>
<div style="background:linear-gradient(135deg,rgba(100,100,100,.2),rgba(100,100,100,.05));padding:10px;border-radius:6px;text-align:center">
<div style="font-size:1.4rem;font-weight:bold;color:#888">${cnt0}</div>
<div style="font-size:.7rem;color:var(--txt2)">μ(n)=0</div>
</div>
<div style="background:linear-gradient(135deg,rgba(255,107,107,.2),rgba(255,107,107,.05));padding:10px;border-radius:6px;text-align:center">
<div style="font-size:1.4rem;font-weight:bold;color:#FF6B6B">${cntM1}</div>
<div style="font-size:.7rem;color:var(--txt2)">μ(n)=-1</div>
</div>
</div>
<div style="display:grid;grid-template-columns:1fr 1fr;gap:8px;margin-bottom:12px">
<div style="background:var(--bg1);padding:8px;border-radius:6px;text-align:center">
<div style="font-size:1.1rem;font-weight:bold;color:#ffd700">${sqfreeC}</div>
<div style="font-size:.6rem;color:var(--txt2)">SQUAREFREE</div>
</div>
<div style="background:var(--bg1);padding:8px;border-radius:6px;text-align:center">
<div style="font-size:1.1rem;font-weight:bold;color:#9664ff">${fmt(100*sqfreeC/N)}%</div>
<div style="font-size:.6rem;color:var(--txt2)">vs 60.79%</div>
</div>
</div>
<div style="margin-bottom:10px;padding:8px;background:var(--bg1);border-radius:6px">
<strong style="color:var(--acc)">Key Values</strong>
<div style="display:grid;grid-template-columns:1fr 1fr;gap:3px;margin-top:5px;font-size:.8rem">
<span>Mertens M(N):</span><span style="color:#00d9ff;font-weight:bold">${M}</span>
<span>Σμ(n)/n:</span><span style="color:#00ff88;font-weight:bold">${fmt(sum1)}</span>
<span>|M(N)|/√N:</span><span style="color:${Math.abs(M)/Math.sqrt(N)<1?'#00ff88':'#ff8c00'};font-weight:bold">${fmt(Math.abs(M)/Math.sqrt(N))}</span>
<span>Theory 6/π²:</span><span style="color:#9664ff">${fmt(6/Math.PI/Math.PI)}</span>
</div>
</div>
<div style="padding:8px;background:${Math.abs(M)/Math.sqrt(N)<1?'rgba(0,255,136,.1)':'rgba(255,100,150,.1)'};border-radius:6px;font-size:.75rem">
<strong style="color:var(--acc)">RH Connection</strong>
<div style="margin-top:4px;color:var(--txt2)">
RH  M(x) = O(x^{½+ε}) for all ε>0<br>
Current: |M(${N})|/√${N} = ${fmt(Math.abs(M)/Math.sqrt(N))} ${Math.abs(M)/Math.sqrt(N)<1?'(within √x)':'(exceeds √x)'}
</div>
</div>`;

// Data table
document.getElementById('tmobT').innerHTML='<tr><th>n</th><th>μ(n)</th><th>M(n)</th><th>Factorization</th><th>Squarefree</th></tr>'+
mobData.slice(0,100).map(d=>`<tr onclick="modal('n=${d.n}',[['μ(${d.n})',${d.mu}],['M(${d.n})',${d.M}],['Σμ(k)/k','${fmt(d.sum1)}'],['Factorization','${d.fac}'],['Squarefree','${d.sf?'Yes':'No'}'],['|M|/√n','${fmt(Math.abs(d.M)/Math.sqrt(d.n))}']])" style="cursor:pointer;color:${d.mu===1?'#4ECDC4':d.mu===-1?'#FF6B6B':'#666'}"><td>${d.n}</td><td>${d.mu}</td><td>${d.M}</td><td>${d.fac}</td><td>${d.sf?'Yes':'No'}</td></tr>`).join('');
}
function csvMob(){let s='n,mu,M,sumMuOverN,factorization,squarefree\n';for(const d of mobData)s+=`${d.n},${d.mu},${d.M},${d.sum1},"${d.fac}",${d.sf}\n`;dl(s,'mobius.csv');}
async function screenshotMob(){
const N=document.getElementById('mobNv').value,viz=document.getElementById('mobViz').value;
await screenshotUnified('cmob','mobLiveStats',`Möbius Function μ(n) — N=${N}, Mode: ${viz}`,'mobius_function_complete.png');
}

// ==================== MÖBIUS EXPONENTIAL SUM ====================
let mobExpData = { spectrum: [], major: [], mu: null };

function drawMobiusExp() {
if(!document.getElementById("cmobexp")) return;

const N = +document.getElementById('mobexpN').value || 300;
const resolution = +document.getElementById('mobexpRes').value || 256;
const Q0 = +document.getElementById('mobexpQ').value || 20;
const viz = document.getElementById('mobexpViz').value;
const c = document.getElementById('cmobexp'), ctx = c.getContext('2d');
ctx.fillStyle = canvBg(); ctx.fillRect(0, 0, c.width, c.height);

// Generate Möbius function using existing mobius() helper
const mu = [];
const muStats = { positive: 0, negative: 0, zero: 0 };
for (let n = 1; n <= N; n++) {
  const m = mobius(n);
  mu[n] = m;
  if (m > 0) muStats.positive++;
  else if (m < 0) muStats.negative++;
  else muStats.zero++;
}
mobExpData.mu = mu;

const sqrtN = Math.sqrt(N);
const pad = 60, w = c.width - 2 * pad, h = c.height - 2 * pad;

// Compute exponential sum S(N, alpha) - returns magnitude and complex components
function computeSumComplex(alpha) {
  let re = 0, im = 0;
  for (let n = 1; n <= N; n++) {
    if (mu[n] !== 0) {
      re += mu[n] * Math.cos(2 * Math.PI * alpha * n);
      im += mu[n] * Math.sin(2 * Math.PI * alpha * n);
    }
  }
  return { mag: Math.sqrt(re * re + im * im), re, im, phase: Math.atan2(im, re) };
}

// Full spectrum computation with complex data
const spectrumData = [];
const complexData = [];
const alphaValues = [];
let maxSum = 0, bestAlpha = 0;

for (let j = 0; j < resolution; j++) {
  const alpha = j / resolution;
  const result = computeSumComplex(alpha);
  spectrumData.push(result.mag);
  complexData.push(result);
  alphaValues.push(alpha);
  if (result.mag > maxSum) {
    maxSum = result.mag;
    bestAlpha = alpha;
  }
}
mobExpData.spectrum = spectrumData;
mobExpData.complex = complexData;

// Major arcs computation
const majorData = [], majorLabels = [];
for (let q = 1; q <= Q0; q++) {
  for (let a = 1; a <= q; a++) {
    if (gcdM(a, q) === 1) {
      const alpha = a / q;
      const result = computeSumComplex(alpha);
      majorData.push({ a, q, alpha, sum: result.mag, re: result.re, im: result.im, phase: result.phase });
      majorLabels.push(`${a}/${q}`);
    }
  }
}
majorData.sort((x, y) => y.sum - x.sum);
mobExpData.major = majorData;

// Create histogram
const histBins = 20;
const binSize = maxSum / histBins;
const histogram = new Array(histBins).fill(0);
spectrumData.forEach(v => {
  const idx = Math.min(Math.floor(v / binSize), histBins - 1);
  histogram[idx]++;
});

if (viz === 'spectrum') {
  // Draw spectrum
  ctx.fillStyle = isDark() ? '#667eea' : '#5a6fd8';
  ctx.font = 'bold 14px Segoe UI'; ctx.textAlign = 'center';
  ctx.fillText(`Möbius Exponential Sum |S(N,α)| — N=${N}`, c.width / 2, 25);

  // Grid
  ctx.strokeStyle = gridC(); ctx.lineWidth = 0.5;
  for (let i = 0; i <= 5; i++) {
    const y = pad + h - i * h / 5;
    ctx.beginPath(); ctx.moveTo(pad, y); ctx.lineTo(pad + w, y); ctx.stroke();
    ctx.fillStyle = isDark() ? '#666' : '#999'; ctx.font = '10px Arial'; ctx.textAlign = 'right';
    ctx.fillText(fmt(maxSum * i / 5), pad - 5, y + 3);
  }

  // √N reference line
  const sqrtY = pad + h - h * sqrtN / maxSum;
  ctx.strokeStyle = '#ff6496'; ctx.lineWidth = 2; ctx.setLineDash([5, 5]);
  ctx.beginPath(); ctx.moveTo(pad, sqrtY); ctx.lineTo(pad + w, sqrtY); ctx.stroke();
  ctx.setLineDash([]);
  ctx.fillStyle = '#ff6496'; ctx.font = '10px Segoe UI'; ctx.textAlign = 'left';
  ctx.fillText(`√N = ${sqrtN.toFixed(2)}`, pad + 5, sqrtY - 5);

  // Spectrum curve
  ctx.strokeStyle = '#667eea'; ctx.lineWidth = 2;
  ctx.beginPath();
  for (let i = 0; i < spectrumData.length; i++) {
    const x = pad + (i / (spectrumData.length - 1)) * w;
    const y = pad + h - (spectrumData[i] / maxSum) * h;
    if (i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
  }
  ctx.stroke();

  // Fill under curve
  ctx.fillStyle = 'rgba(102, 126, 234, 0.2)';
  ctx.lineTo(pad + w, pad + h); ctx.lineTo(pad, pad + h); ctx.closePath(); ctx.fill();

  // Mark maximum
  const maxIdx = spectrumData.indexOf(maxSum);
  const maxX = pad + (maxIdx / (spectrumData.length - 1)) * w;
  const maxY = pad;
  ctx.fillStyle = '#ffd700';
  ctx.beginPath(); ctx.arc(maxX, maxY, 6, 0, 2 * Math.PI); ctx.fill();
  ctx.fillStyle = isDark() ? '#fff' : '#000'; ctx.font = '10px Segoe UI'; ctx.textAlign = 'center';
  ctx.fillText(`Max: ${maxSum.toFixed(2)} at α=${bestAlpha.toFixed(4)}`, maxX, maxY - 10);

  // Axis labels
  ctx.fillStyle = isDark() ? '#aaa' : '#666'; ctx.font = '11px Segoe UI';
  ctx.textAlign = 'center'; ctx.fillText('α', c.width / 2, c.height - 10);

} else if (viz === 'major') {
  // Major arcs bar chart
  ctx.fillStyle = isDark() ? '#764ba2' : '#5a3a82';
  ctx.font = 'bold 14px Segoe UI'; ctx.textAlign = 'center';
  ctx.fillText(`Major Arc Resonances |S(N,a/q)| — Top ${Math.min(30, majorData.length)}`, c.width / 2, 25);

  const showData = majorData.slice(0, 30);
  const barW = w / showData.length;
  const maxMajor = showData[0]?.sum || 1;

  for (let i = 0; i < showData.length; i++) {
    const d = showData[i];
    const x = pad + i * barW;
    const barH = (d.sum / maxMajor) * h;
    ctx.fillStyle = d.sum > sqrtN ? '#ff6496' : '#764ba2';
    ctx.fillRect(x, pad + h - barH, barW - 2, barH);
    if (showData.length < 20) {
      ctx.fillStyle = isDark() ? '#fff' : '#000'; ctx.font = '8px Arial'; ctx.textAlign = 'center';
      ctx.fillText(`${d.a}/${d.q}`, x + barW / 2, pad + h + 12);
    }
  }

  // √N line
  const sqrtY = pad + h - (sqrtN / maxMajor) * h;
  ctx.strokeStyle = '#ffd700'; ctx.lineWidth = 2; ctx.setLineDash([5, 5]);
  ctx.beginPath(); ctx.moveTo(pad, sqrtY); ctx.lineTo(pad + w, sqrtY); ctx.stroke();
  ctx.setLineDash([]);

} else if (viz === 'heatmap') {
  // N vs α heatmap
  ctx.fillStyle = isDark() ? '#667eea' : '#5a6fd8';
  ctx.font = 'bold 14px Segoe UI'; ctx.textAlign = 'center';
  ctx.fillText('Heatmap: |S(n,α)| for varying n and α', c.width / 2, 25);

  const nSteps = 50, aSteps = 100;
  const cellW = w / aSteps, cellH = h / nSteps;
  let heatMax = 0;

  for (let ni = 1; ni <= nSteps; ni++) {
    const n = Math.floor(ni * N / nSteps);
    for (let ai = 0; ai < aSteps; ai++) {
      const alpha = ai / aSteps;
      let re = 0, im = 0;
      for (let k = 1; k <= n; k++) {
        if (mu[k] !== 0) {
          re += mu[k] * Math.cos(2 * Math.PI * alpha * k);
          im += mu[k] * Math.sin(2 * Math.PI * alpha * k);
        }
      }
      const mag = Math.sqrt(re * re + im * im);
      heatMax = Math.max(heatMax, mag);
    }
  }

  for (let ni = 1; ni <= nSteps; ni++) {
    const n = Math.floor(ni * N / nSteps);
    for (let ai = 0; ai < aSteps; ai++) {
      const alpha = ai / aSteps;
      let re = 0, im = 0;
      for (let k = 1; k <= n; k++) {
        if (mu[k] !== 0) {
          re += mu[k] * Math.cos(2 * Math.PI * alpha * k);
          im += mu[k] * Math.sin(2 * Math.PI * alpha * k);
        }
      }
      const mag = Math.sqrt(re * re + im * im);
      const t = mag / heatMax;
      ctx.fillStyle = `hsl(${270 - t * 180}, 80%, ${30 + t * 40}%)`;
      ctx.fillRect(pad + ai * cellW, pad + (nSteps - ni) * cellH, cellW + 1, cellH + 1);
    }
  }

  ctx.fillStyle = isDark() ? '#aaa' : '#666'; ctx.font = '11px Segoe UI';
  ctx.textAlign = 'center'; ctx.fillText('α', c.width / 2, c.height - 10);
  ctx.save(); ctx.translate(15, c.height / 2); ctx.rotate(-Math.PI / 2);
  ctx.fillText('n', 0, 0); ctx.restore();

} else if (viz === 'polar') {
  // Polar plot
  ctx.fillStyle = isDark() ? '#667eea' : '#5a6fd8';
  ctx.font = 'bold 14px Segoe UI'; ctx.textAlign = 'center';
  ctx.fillText('Polar Plot of |S(N,α)|', c.width / 2, 25);

  const cx = c.width / 2, cy = c.height / 2 + 20;
  const maxR = Math.min(w, h) / 2 - 20;

  // Reference circles
  ctx.strokeStyle = gridC(); ctx.lineWidth = 0.5;
  for (let r = 0.25; r <= 1; r += 0.25) {
    ctx.beginPath(); ctx.arc(cx, cy, maxR * r, 0, 2 * Math.PI); ctx.stroke();
  }

  // √N circle
  const sqrtNorm = sqrtN / maxSum;
  ctx.strokeStyle = '#ff6496'; ctx.lineWidth = 2; ctx.setLineDash([5, 5]);
  ctx.beginPath(); ctx.arc(cx, cy, maxR * sqrtNorm, 0, 2 * Math.PI); ctx.stroke();
  ctx.setLineDash([]);

  // Polar curve
  ctx.strokeStyle = '#667eea'; ctx.lineWidth = 2;
  ctx.beginPath();
  for (let i = 0; i < spectrumData.length; i++) {
    const theta = 2 * Math.PI * i / spectrumData.length;
    const r = (spectrumData[i] / maxSum) * maxR;
    const x = cx + r * Math.cos(theta - Math.PI / 2);
    const y = cy + r * Math.sin(theta - Math.PI / 2);
    if (i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
  }
  ctx.closePath(); ctx.stroke();
  ctx.fillStyle = 'rgba(102, 126, 234, 0.2)'; ctx.fill();

} else if (viz === 'waterfall') {
  // Waterfall plot showing evolution as N increases
  ctx.fillStyle = isDark() ? '#ff8c00' : '#cc6600';
  ctx.font = 'bold 14px Segoe UI'; ctx.textAlign = 'center';
  ctx.fillText('Waterfall: |S(n,α)| Evolution as n Increases', c.width / 2, 25);

  const nSteps = 20;
  const aSteps = Math.min(resolution, 128);
  const stepH = h / nSteps;
  let globalMax = 0;

  // First pass: find global max
  for (let ni = 1; ni <= nSteps; ni++) {
    const n = Math.floor(ni * N / nSteps);
    for (let ai = 0; ai < aSteps; ai++) {
      const alpha = ai / aSteps;
      let re = 0, im = 0;
      for (let k = 1; k <= n; k++) {
        if (mu[k] !== 0) {
          re += mu[k] * Math.cos(2 * Math.PI * alpha * k);
          im += mu[k] * Math.sin(2 * Math.PI * alpha * k);
        }
      }
      globalMax = Math.max(globalMax, Math.sqrt(re * re + im * im));
    }
  }

  // Second pass: draw waterfall
  for (let ni = 1; ni <= nSteps; ni++) {
    const n = Math.floor(ni * N / nSteps);
    const baseY = pad + (nSteps - ni) * stepH + stepH;
    
    ctx.beginPath();
    ctx.moveTo(pad, baseY);
    
    for (let ai = 0; ai < aSteps; ai++) {
      const alpha = ai / aSteps;
      let re = 0, im = 0;
      for (let k = 1; k <= n; k++) {
        if (mu[k] !== 0) {
          re += mu[k] * Math.cos(2 * Math.PI * alpha * k);
          im += mu[k] * Math.sin(2 * Math.PI * alpha * k);
        }
      }
      const mag = Math.sqrt(re * re + im * im);
      const x = pad + (ai / aSteps) * w;
      const peakH = (mag / globalMax) * stepH * 2.5;
      ctx.lineTo(x, baseY - peakH);
    }
    ctx.lineTo(pad + w, baseY);
    
    const hue = 270 - (ni / nSteps) * 180;
    ctx.fillStyle = `hsla(${hue}, 70%, 55%, 0.6)`;
    ctx.fill();
    ctx.strokeStyle = `hsl(${hue}, 80%, 40%)`;
    ctx.lineWidth = 1;
    ctx.stroke();

    // Label
    ctx.fillStyle = isDark() ? '#aaa' : '#666';
    ctx.font = '9px Segoe UI';
    ctx.textAlign = 'right';
    ctx.fillText(`n=${n}`, pad - 5, baseY - stepH / 2);
  }

  ctx.fillStyle = isDark() ? '#aaa' : '#666';
  ctx.font = '11px Segoe UI';
  ctx.textAlign = 'center';
  ctx.fillText('α', c.width / 2, c.height - 10);

} else if (viz === 'ratio') {
  // Ratio to √N visualization
  ctx.fillStyle = isDark() ? '#00ff88' : '#00aa55';
  ctx.font = 'bold 14px Segoe UI'; ctx.textAlign = 'center';
  ctx.fillText('Ratio |S(N,α)|/√N — Values > 1 Exceed RH Bound', c.width / 2, 25);

  const ratioData = spectrumData.map(v => v / sqrtN);
  const maxRatio = Math.max(...ratioData);

  // Grid
  ctx.strokeStyle = gridC(); ctx.lineWidth = 0.5;
  for (let i = 0; i <= 5; i++) {
    const y = pad + h - i * h / 5;
    ctx.beginPath(); ctx.moveTo(pad, y); ctx.lineTo(pad + w, y); ctx.stroke();
    ctx.fillStyle = isDark() ? '#666' : '#999'; ctx.font = '10px Arial'; ctx.textAlign = 'right';
    ctx.fillText((maxRatio * i / 5).toFixed(2), pad - 5, y + 3);
  }

  // Reference line at ratio = 1
  const ratio1Y = pad + h - h / maxRatio;
  ctx.strokeStyle = '#ffd700'; ctx.lineWidth = 2; ctx.setLineDash([5, 5]);
  ctx.beginPath(); ctx.moveTo(pad, ratio1Y); ctx.lineTo(pad + w, ratio1Y); ctx.stroke();
  ctx.setLineDash([]);
  ctx.fillStyle = '#ffd700'; ctx.font = '10px Segoe UI'; ctx.textAlign = 'left';
  ctx.fillText('Ratio = 1 (RH bound)', pad + 5, ratio1Y - 5);

  // Plot with color coding
  for (let i = 0; i < ratioData.length; i++) {
    const x = pad + (i / (ratioData.length - 1)) * w;
    const y = pad + h - (ratioData[i] / maxRatio) * h;
    const clr = ratioData[i] > 1 ? '#ff6496' : '#00ff88';
    ctx.fillStyle = clr;
    ctx.beginPath(); ctx.arc(x, y, 2, 0, 2 * Math.PI); ctx.fill();
  }

  // Count exceedances
  const exceedCount = ratioData.filter(r => r > 1).length;
  ctx.fillStyle = isDark() ? '#fff' : '#000';
  ctx.font = '11px Segoe UI'; ctx.textAlign = 'right';
  ctx.fillText(`Exceeds √N: ${exceedCount}/${ratioData.length} (${(exceedCount/ratioData.length*100).toFixed(1)}%)`, pad + w - 10, pad + 20);

} else if (viz === 'phase') {
  // Phase diagram
  ctx.fillStyle = isDark() ? '#9664ff' : '#7a52cc';
  ctx.font = 'bold 14px Segoe UI'; ctx.textAlign = 'center';
  ctx.fillText('Phase Diagram arg(S(N,α))', c.width / 2, 25);

  // Grid
  ctx.strokeStyle = gridC(); ctx.lineWidth = 0.5;
  for (let i = 0; i <= 4; i++) {
    const y = pad + i * h / 4;
    ctx.beginPath(); ctx.moveTo(pad, y); ctx.lineTo(pad + w, y); ctx.stroke();
    const val = Math.PI - i * Math.PI / 2;
    ctx.fillStyle = isDark() ? '#666' : '#999'; ctx.font = '10px Arial'; ctx.textAlign = 'right';
    ctx.fillText(`${(val * 180 / Math.PI).toFixed(0)}°`, pad - 5, y + 3);
  }

  // Phase curve
  ctx.strokeStyle = '#9664ff'; ctx.lineWidth = 2;
  ctx.beginPath();
  for (let i = 0; i < complexData.length; i++) {
    const x = pad + (i / (complexData.length - 1)) * w;
    const y = pad + h / 2 - (complexData[i].phase / Math.PI) * h / 2;
    if (i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
  }
  ctx.stroke();

  // Axis labels
  ctx.fillStyle = isDark() ? '#aaa' : '#666'; ctx.font = '11px Segoe UI';
  ctx.textAlign = 'center'; ctx.fillText('α', c.width / 2, c.height - 10);

} else if (viz === 'complex') {
  // Complex plane plot
  ctx.fillStyle = isDark() ? '#00d9ff' : '#00b8cc';
  ctx.font = 'bold 14px Segoe UI'; ctx.textAlign = 'center';
  ctx.fillText('Complex Plane: S(N,α) = Re + i·Im', c.width / 2, 25);

  const cx = c.width / 2, cy = c.height / 2 + 10;
  const maxRe = Math.max(...complexData.map(d => Math.abs(d.re)));
  const maxIm = Math.max(...complexData.map(d => Math.abs(d.im)));
  const scale = Math.min(w / 2, h / 2) / Math.max(maxRe, maxIm) * 0.9;

  // Axes
  ctx.strokeStyle = gridC(); ctx.lineWidth = 1;
  ctx.beginPath(); ctx.moveTo(pad, cy); ctx.lineTo(c.width - pad, cy); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(cx, pad); ctx.lineTo(cx, c.height - pad); ctx.stroke();

  // Labels
  ctx.fillStyle = isDark() ? '#aaa' : '#666'; ctx.font = '10px Segoe UI';
  ctx.textAlign = 'center'; ctx.fillText('Re', c.width - pad + 15, cy + 3);
  ctx.fillText('Im', cx, pad - 8);

  // Plot points with color gradient by α
  for (let i = 0; i < complexData.length; i++) {
    const d = complexData[i];
    const x = cx + d.re * scale;
    const y = cy - d.im * scale;
    const hue = (i / complexData.length) * 270;
    ctx.fillStyle = `hsl(${hue}, 80%, 55%)`;
    ctx.beginPath(); ctx.arc(x, y, 3, 0, 2 * Math.PI); ctx.fill();
  }

  // Origin marker
  ctx.strokeStyle = '#ffd700'; ctx.lineWidth = 2;
  ctx.beginPath(); ctx.arc(cx, cy, 4, 0, 2 * Math.PI); ctx.stroke();
}

// Update fraction displays using global showFractions toggle
const sfCount = muStats.positive + muStats.negative;
if (showFractions) {
  document.getElementById('mobexpPosFrac').textContent = `${muStats.positive}/${N}`;
  document.getElementById('mobexpNegFrac').textContent = `${muStats.negative}/${N}`;
  document.getElementById('mobexpZeroFrac').textContent = `${muStats.zero}/${N}`;
} else {
  document.getElementById('mobexpPosFrac').textContent = `${fmt(muStats.positive/N*100)}%`;
  document.getElementById('mobexpNegFrac').textContent = `${fmt(muStats.negative/N*100)}%`;
  document.getElementById('mobexpZeroFrac').textContent = `${fmt(muStats.zero/N*100)}%`;
}

// Plotly charts
Plotly.newPlot('pmobexpMajor', [{
  x: majorData.slice(0, 40).map(d => `${d.a}/${d.q}`),
  y: majorData.slice(0, 40).map(d => d.sum),
  type: 'bar',
  marker: { color: majorData.slice(0, 40).map(d => d.sum > sqrtN ? '#ff6496' : '#764ba2') }
}], { ...plo(), xaxis: { title: 'α = a/q' }, yaxis: { title: '|S(N,α)|' } });


Plotly.newPlot('pmobexpHist', [{
  x: histogram.map((_, i) => `${(i * binSize).toFixed(1)}-${((i + 1) * binSize).toFixed(1)}`),
  y: histogram,
  type: 'bar',
  marker: { color: '#00d9ff' }
}], { ...plo(), xaxis: { title: '|S(N,α)| Range' }, yaxis: { title: 'Frequency' } });

// Live stats using global fmt() for precision
const ratio = maxSum / sqrtN;
const rhStatus = ratio < 2 ? ['Good (< 2√N)', '#00ff88'] : ratio < 5 ? ['Notable (< 5√N)', '#ffd700'] : ['High (≥ 5√N)', '#ff6496'];

// Format alpha as fraction if showFractions is enabled
const formatBestAlpha = () => {
  if (showFractions) {
    for (let d = 1; d <= 20; d++) {
      for (let n = 0; n < d; n++) {
        if (Math.abs(bestAlpha - n / d) < 1e-10 && gcdM(n, d) === 1) return `${n}/${d}`;
      }
    }
  }
  return fmt(bestAlpha);
};

document.getElementById('mobexpLiveStats').innerHTML = `
<div style="background:linear-gradient(135deg,rgba(102,126,234,.15),rgba(118,75,162,.1));padding:10px;border-radius:8px;margin-bottom:12px;border:1px solid #667eea">
<div style="font-size:.7rem;color:var(--txt2);margin-bottom:4px">TAB: Möbius Exponential Sum | TYPE: S(N,α) Analysis | DECIMALS: ${P}</div>
<div style="display:grid;grid-template-columns:repeat(3,1fr);gap:6px;font-size:.75rem">
<span>N: <strong style="color:#667eea">${N.toLocaleString()}</strong></span>
<span>Resolution: <strong style="color:#ffd700">${resolution}</strong></span>
<span>Q₀: <strong style="color:#00ff88">${Q0}</strong></span>
</div>
</div>
<div style="display:grid;grid-template-columns:repeat(3,1fr);gap:8px;margin-bottom:12px">
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center"><div style="font-size:1.3rem;font-weight:bold;color:#667eea">${N.toLocaleString()}</div><div style="font-size:.7rem;color:var(--txt2)">N (Upper Limit)</div></div>
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center"><div style="font-size:1.3rem;font-weight:bold;color:#ffd700">${fmt(sqrtN)}</div><div style="font-size:.7rem;color:var(--txt2)">√N (RH Bound)</div></div>
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center"><div style="font-size:1.3rem;font-weight:bold;color:#ff6496">${fmt(maxSum)}</div><div style="font-size:.7rem;color:var(--txt2)">Max |S(N,α)|</div></div>
</div>
<div style="display:grid;grid-template-columns:repeat(2,1fr);gap:8px;margin-bottom:12px">
<div style="background:var(--bg1);padding:8px;border-radius:6px;text-align:center"><div style="font-size:1rem;font-weight:bold;color:#00d9ff">${formatBestAlpha()}</div><div style="font-size:.65rem;color:var(--txt2)">Optimal α</div></div>
<div style="background:var(--bg1);padding:8px;border-radius:6px;text-align:center"><div style="font-size:1rem;font-weight:bold;color:${rhStatus[1]}">${fmt(ratio)}</div><div style="font-size:.65rem;color:var(--txt2)">Max/√N Ratio</div></div>
</div>
<div style="background:${ratio<2?'rgba(0,255,136,.15)':ratio<5?'rgba(255,215,0,.15)':'rgba(255,100,150,.15)'};padding:10px;border-radius:8px;text-align:center;border:2px solid ${rhStatus[1]};margin-bottom:12px">
<strong style="color:${rhStatus[1]}">${rhStatus[0]}</strong>
<div style="font-size:.8rem;color:var(--txt2);margin-top:4px">RH Compliance Test</div>
</div>
<div style="margin-bottom:10px;padding-bottom:8px;border-bottom:1px solid var(--bord)">
<strong style="color:var(--acc)">Möbius Statistics</strong>
<div style="display:grid;grid-template-columns:1fr 1fr;gap:3px;margin-top:5px;font-size:.8rem">
<span>Square-free count:</span><span style="color:#00ff88">${sfCount} (${fmt(sfCount/N*100)}%)</span>
<span>μ(n)=+1:</span><span style="color:#00d9ff">${muStats.positive}</span>
<span>μ(n)=-1:</span><span style="color:#ff6496">${muStats.negative}</span>
<span>μ(n)=0:</span><span style="color:#9664ff">${muStats.zero}</span>
</div>
</div>
<div style="margin-bottom:10px;padding-bottom:8px;border-bottom:1px solid var(--bord)">
<strong style="color:var(--acc)">Top Major Arcs</strong>
<div style="font-size:.75rem;color:var(--txt2);margin-top:5px;line-height:1.6">
${majorData.slice(0,5).map(d => `α=${showFractions ? d.a+'/'+d.q : fmt(d.alpha)}: |S|=${fmt(d.sum)}`).join(' · ')}
</div>
</div>`;
}

function csvMobExp() {
  let s = 'alpha,magnitude\n';
  mobExpData.spectrum.forEach((v, i) => {
    s += `${(i / mobExpData.spectrum.length).toFixed(6)},${v}\n`;
  });
  dl(s, 'mobius_exp_sum.csv');
}

async function screenshotMobExp() {
  const N = document.getElementById('mobexpN').value;
  await screenshotUnified('cmobexp', 'mobexpLiveStats', `Möbius Exponential Sum — N=${N}`, 'mobius_exp_sum.png');
}

function exportAllMobExp() {
  screenshotTabAll({ canvases: ['cmobexp'], charts: ['pmobexpMajor', 'pmobexpHist'], dashId: 'mobexpLiveStats', title: 'Möbius Exponential Sum', filename: 'mobius_exp_all.png' });
}

// Sub-tab view switching for Möbius Exponential Sum
function setMobExpView(view, btn) {
  document.getElementById('mobexpSpectrum').style.display = view === 'spectrum' ? 'block' : 'none';
  document.getElementById('mobexpCosmic').style.display = view === 'cosmic' ? 'block' : 'none';
  document.getElementById('mobexpStats').style.display = view === 'stats' ? 'block' : 'none';
  
  // Update button styles
  btn.parentElement.querySelectorAll('.tbtn').forEach(b => {
    b.style.background = 'var(--bg2)';
    b.style.color = 'var(--txt)';
  });
  btn.style.background = view === 'spectrum' ? 'linear-gradient(135deg,#667eea,#764ba2)' : 
                          view === 'cosmic' ? 'linear-gradient(135deg,#ff6b6b,#ee5a52)' : 
                          'linear-gradient(135deg,#00ff88,#00d9ff)';
  btn.style.color = '#fff';
  
  if (view === 'spectrum') drawMobiusExp();
}

// Export JSON for mobexp
function exportMobExpJSON() {
  if (!mobExpData.spectrum.length) { alert('Run computation first'); return; }
  const data = {
    timestamp: new Date().toISOString(),
    N: +document.getElementById('mobexpN').value,
    resolution: +document.getElementById('mobexpRes').value,
    spectrum: mobExpData.spectrum,
    majorArcs: mobExpData.major,
    statistics: {
      max: Math.max(...mobExpData.spectrum),
      mean: mobExpData.spectrum.reduce((a,b)=>a+b,0)/mobExpData.spectrum.length,
      sqrtN: Math.sqrt(+document.getElementById('mobexpN').value)
    }
  };
  dl(JSON.stringify(data, null, 2), 'mobius_exp_sum.json');
}

// Export text report for mobexp
function exportMobExpReport() {
  if (!mobExpData.spectrum.length) { alert('Run computation first'); return; }
  const N = +document.getElementById('mobexpN').value;
  const sqrtN = Math.sqrt(N);
  const maxS = Math.max(...mobExpData.spectrum);
  const ratio = maxS / sqrtN;
  
  let report = `Möbius Exponential Sum Analysis Report\n`;
  report += `${'='.repeat(50)}\n\n`;
  report += `Generated: ${new Date().toISOString()}\n`;
  report += `Platform: Möbius Shell Sieve\n\n`;
  report += `Parameters:\n`;
  report += `- N (upper limit): ${N.toLocaleString()}\n`;
  report += `- Grid resolution: ${document.getElementById('mobexpRes').value}\n`;
  report += `- Major arc Q₀: ${document.getElementById('mobexpQ').value}\n\n`;
  report += `Results:\n`;
  report += `- √N bound: ${fmt(sqrtN)}\n`;
  report += `- Max |S(N,α)|: ${fmt(maxS)}\n`;
  report += `- Ratio Max/√N: ${fmt(ratio)}\n\n`;
  report += `Top Major Arcs:\n`;
  mobExpData.major.slice(0, 10).forEach((d, i) => {
    report += `${i+1}. α = ${d.a}/${d.q} → |S| = ${fmt(d.sum)}\n`;
  });
  report += `\nRH Assessment: ${ratio < 1 ? 'Excellent' : ratio < 2 ? 'Good' : ratio < 5 ? 'Notable' : 'High'}\n`;
  
  dl(report, 'mobius_exp_report.txt');
}

// ==================== COSMIC RH TESTER ====================
let cosmicData = { results: [], statistics: null };
let cosmicComputing = false;

function setCosmicPreset(n) {
  document.getElementById('cosmicN').value = n;
  updateCosmicPerfHint(n);
  
  if (n >= 10000000) {
    document.getElementById('cosmicSamples').value = 30;
    document.getElementById('cosmicDenom').value = 8;
    document.getElementById('cosmicGrid').value = 32;
  } else if (n >= 1000000) {
    document.getElementById('cosmicSamples').value = 50;
    document.getElementById('cosmicDenom').value = 10;
    document.getElementById('cosmicGrid').value = 48;
  } else {
    document.getElementById('cosmicSamples').value = 75;
    document.getElementById('cosmicDenom').value = 12;
    document.getElementById('cosmicGrid').value = 64;
  }
}

function updateCosmicPerfHint(n) {
  const hint = document.getElementById('cosmicPerfHint');
  if (n < 100000) {
    hint.innerHTML = ' Expected: < 1 second';
    hint.style.borderColor = '#4ecdc4';
  } else if (n < 1000000) {
    hint.innerHTML = ' Expected: 1-3 seconds';
    hint.style.borderColor = '#96ceb4';
  } else if (n < 10000000) {
    hint.innerHTML = ' Expected: 5-15 seconds';
    hint.style.borderColor = '#feca57';
  } else {
    hint.innerHTML = ' Expected: 15+ seconds (large computation)';
    hint.style.borderColor = '#ff6b6b';
  }
}

function updateCosmicProgress(msg, pct) {
  document.getElementById('cosmicStatus').textContent = msg;
  document.getElementById('cosmicProgressBar').style.width = pct + '%';
}

// Optimized Möbius sieve for large N
function mobiusSieveLarge(n) {
  const mu = new Int8Array(n + 1);
  const isComposite = new Uint8Array(n + 1);
  
  // Initialize all to 1
  for (let i = 1; i <= n; i++) mu[i] = 1;
  
  for (let p = 2; p <= n; p++) {
    if (!isComposite[p]) {
      // p is prime - mark multiples as composite
      for (let j = 2 * p; j <= n; j += p) {
        isComposite[j] = 1;
      }
      // Multiply mu by -1 for all multiples of p
      for (let j = p; j <= n; j += p) {
        mu[j] *= -1;
      }
      // Set mu to 0 for all multiples of p²
      const p2 = p * p;
      for (let j = p2; j <= n; j += p2) {
        mu[j] = 0;
      }
    }
  }
  
  return mu;
}

// Generate alpha values based on test mode
function generateCosmicAlphas(mode, numSamples, maxDenom, gridSize) {
  const alphas = [];
  
  if (mode === 'major-arcs' || mode === 'comprehensive') {
    for (let q = 1; q <= maxDenom; q++) {
      for (let p = 0; p < q; p++) {
        if (gcdM(p, q) === 1) alphas.push(p / q);
      }
    }
  }
  
  if (mode === 'uniform' || mode === 'comprehensive') {
    const g = mode === 'comprehensive' ? Math.min(gridSize, 32) : gridSize;
    for (let i = 0; i < g && i < numSamples; i++) {
      alphas.push(i / g);
    }
  }
  
  if (mode === 'stochastic' || mode === 'comprehensive' || mode === 'major-arcs') {
    const count = mode === 'stochastic' ? numSamples : Math.min(numSamples, 50);
    for (let i = 0; i < count; i++) {
      alphas.push(Math.random());
    }
  }
  
  return [...new Set(alphas)];
}

function determineAlphaType(alpha) {
  for (let denom = 1; denom <= 20; denom++) {
    for (let num = 0; num < denom; num++) {
      if (Math.abs(alpha - num / denom) < 1e-10 && gcdM(num, denom) === 1) {
        return denom <= 12 ? 'Major Arc' : 'Rational';
      }
    }
  }
  return 'Irrational';
}

function formatAlphaFraction(alpha) {
  for (let d = 1; d <= 20; d++) {
    for (let n = 0; n < d; n++) {
      if (Math.abs(alpha - n / d) < 1e-10 && gcdM(n, d) === 1) {
        return showFractions ? `${n}/${d}` : (n / d).toFixed(P);
      }
    }
  }
  return alpha.toFixed(P);
}

async function runCosmicTest() {
  if (cosmicComputing) return;
  cosmicComputing = true;
  
  const btn = document.getElementById('cosmicStartBtn');
  btn.disabled = true;
  btn.textContent = 'Computing...';
  document.getElementById('cosmicProgress').style.display = 'block';
  
  const maxN = +document.getElementById('cosmicN').value;
  const testMode = document.getElementById('cosmicMode').value;
  const numSamples = +document.getElementById('cosmicSamples').value;
  const maxDenom = +document.getElementById('cosmicDenom').value;
  const gridSize = +document.getElementById('cosmicGrid').value;
  
  if (maxN < 1000 || maxN > 100000000) {
    alert('N must be between 1,000 and 100,000,000');
    btn.disabled = false;
    btn.textContent = 'Launch Cosmic Test';
    cosmicComputing = false;
    return;
  }
  
  const startTime = performance.now();
  
  try {
    updateCosmicProgress('Computing Möbius function...', 10);
    await new Promise(r => setTimeout(r, 50));
    
    const mu = mobiusSieveLarge(maxN);
    
    updateCosmicProgress('Generating α values...', 30);
    await new Promise(r => setTimeout(r, 50));
    
    const alphas = generateCosmicAlphas(testMode, numSamples, maxDenom, gridSize);
    
    updateCosmicProgress('Computing exponential sums...', 50);
    await new Promise(r => setTimeout(r, 50));
    
    const results = [];
    let maxSum = 0, bestAlpha = 0;
    const sqrtN = Math.sqrt(maxN);
    
    for (let i = 0; i < alphas.length; i++) {
      const alpha = alphas[i];
      let re = 0, im = 0;
      
      for (let n = 1; n <= maxN; n++) {
        if (mu[n] !== 0) {
          const angle = 2 * Math.PI * n * alpha;
          re += mu[n] * Math.cos(angle);
          im += mu[n] * Math.sin(angle);
        }
      }
      
      const mag = Math.sqrt(re * re + im * im);
      results.push({
        alpha, sum: mag, real: re, imaginary: im,
        phase: Math.atan2(im, re),
        type: determineAlphaType(alpha)
      });
      
      if (mag > maxSum) { maxSum = mag; bestAlpha = alpha; }
      
      if (i % Math.max(1, Math.floor(alphas.length / 10)) === 0) {
        updateCosmicProgress(`Testing α values... ${i + 1}/${alphas.length}`, 50 + 40 * i / alphas.length);
        await new Promise(r => setTimeout(r, 1));
      }
    }
    
    results.sort((a, b) => b.sum - a.sum);
    
    updateCosmicProgress('Finalizing...', 95);
    await new Promise(r => setTimeout(r, 50));
    
    const endTime = performance.now();
    const ratio = maxSum / sqrtN;
    
    // Calculate statistics
    const sums = results.map(r => r.sum);
    const mean = sums.reduce((a, b) => a + b, 0) / sums.length;
    const variance = sums.reduce((s, v) => s + (v - mean) ** 2, 0) / sums.length;
    const stdDev = Math.sqrt(variance);
    const sortedSums = [...sums].sort((a, b) => a - b);
    const median = sortedSums.length % 2 === 0 
      ? (sortedSums[sortedSums.length / 2 - 1] + sortedSums[sortedSums.length / 2]) / 2
      : sortedSums[Math.floor(sortedSums.length / 2)];
    
    cosmicData = {
      maxN, sqrtN, maxSum, ratio, bestAlpha,
      computeTime: endTime - startTime,
      results,
      statistics: {
        mean, median, stdDev, variance,
        min: Math.min(...sums), max: maxSum,
        majorArcCount: results.filter(r => r.type === 'Major Arc').length,
        rationalCount: results.filter(r => r.type === 'Rational').length,
        irrationalCount: results.filter(r => r.type === 'Irrational').length
      }
    };
    
    displayCosmicResults();
    updateCosmicProgress('Complete!', 100);
    
  } catch (error) {
    alert('Error: ' + error.message);
    console.error(error);
  } finally {
    cosmicComputing = false;
    btn.disabled = false;
    btn.textContent = 'Launch Cosmic Test';
    setTimeout(() => { document.getElementById('cosmicProgress').style.display = 'none'; }, 1000);
  }
}

function displayCosmicResults() {
  const { maxN, sqrtN, maxSum, ratio, bestAlpha, computeTime, results, statistics } = cosmicData;
  
  // Update metrics using global fmt() function
  document.getElementById('cosmicResultN').textContent = maxN.toLocaleString();
  document.getElementById('cosmicResultSqrtN').textContent = fmt(sqrtN);
  document.getElementById('cosmicResultMax').textContent = fmt(maxSum);
  document.getElementById('cosmicResultRatio').textContent = fmt(ratio);
  document.getElementById('cosmicResultAlpha').textContent = formatAlphaFraction(bestAlpha);
  document.getElementById('cosmicResultTime').textContent = fmt(computeTime / 1000);
  
  // Cosmic status - NOTE: ALL bounded ratios are consistent with RH!
  // Higher ratios at certain α are expected "resonance" behavior
  let status, clr, bg;
  if (ratio < 1.0) { status = 'EXCELLENT — Well below √N'; clr = '#00ff88'; bg = 'rgba(0,255,136,.15)'; }
  else if (ratio < 2.0) { status = 'VERY GOOD — Near √N bound'; clr = '#4ecdc4'; bg = 'rgba(78,205,196,.15)'; }
  else if (ratio < 4.0) { status = 'GOOD — Moderate resonance'; clr = '#feca57'; bg = 'rgba(254,202,87,.15)'; }
  else if (ratio < 8.0) { status = 'NORMAL — Expected at some α'; clr = '#ff9a56'; bg = 'rgba(255,154,86,.15)'; }
  else { status = 'HIGH — Strong resonance'; clr = '#ff6b6b'; bg = 'rgba(255,107,107,.15)'; }
  
  const statusBox = document.getElementById('cosmicStatusBox');
  statusBox.textContent = `${status} — Ratio: ${fmt(ratio)}`;
  statusBox.style.background = bg;
  statusBox.style.borderColor = clr;
  statusBox.style.color = clr;
  
  // Top results table
  const tbody = document.getElementById('cosmicTopBody');
  tbody.innerHTML = '';
  results.slice(0, 15).forEach((r, i) => {
    const row = document.createElement('tr');
    row.innerHTML = `
      <td style="padding:8px;border-bottom:1px solid rgba(255,255,255,.1)">${i + 1}</td>
      <td style="padding:8px;border-bottom:1px solid rgba(255,255,255,.1)">${formatAlphaFraction(r.alpha)}</td>
      <td style="padding:8px;border-bottom:1px solid rgba(255,255,255,.1)">${fmt(r.sum)}</td>
      <td style="padding:8px;border-bottom:1px solid rgba(255,255,255,.1)">${fmt(r.sum / sqrtN)}</td>
      <td style="padding:8px;border-bottom:1px solid rgba(255,255,255,.1);color:${r.type === 'Major Arc' ? '#ff6b6b' : r.type === 'Rational' ? '#feca57' : '#4ecdc4'}">${r.type}</td>
    `;
    tbody.appendChild(row);
  });
  
  // Insights
  let insights = `<p><strong>Major Arc Dominance:</strong> ${statistics.majorArcCount} major arc, ${statistics.rationalCount} rational, ${statistics.irrationalCount} irrational samples tested.</p>`;
  insights += `<p><strong>Statistical Profile:</strong> Mean ratio = ${fmt(statistics.mean / sqrtN)}, σ = ${fmt(statistics.stdDev / sqrtN)}</p>`;
  
  if (ratio < 0.5) {
    insights += `<p><strong>RH Interpretation:</strong> Ratio ${fmt(ratio)} provides <span style="color:#00ff88">exceptional</span> support for RH predictions at N = ${maxN.toLocaleString()}.</p>`;
  } else if (ratio < 1.5) {
    insights += `<p><strong>RH Interpretation:</strong> Ratio ${fmt(ratio)} is well within theoretical bounds, providing solid RH support.</p>`;
  } else {
    insights += `<p><strong>RH Interpretation:</strong> Ratio ${fmt(ratio)} is elevated and warrants further investigation.</p>`;
  }
  
  insights += `<p><strong>Computation:</strong> Verified RH predictions for ${maxN.toLocaleString()} integers in ${fmt(computeTime / 1000)}s using browser-based algorithms.</p>`;
  document.getElementById('cosmicInsights').innerHTML = insights;
  
  // Draw visualizations
  drawCosmicCharts();
  
  document.getElementById('cosmicResults').style.display = 'block';
  
  // Update shared Möbius fraction display
  let pos = 0, neg = 0, zero = 0;
  const mu = mobiusSieveLarge(Math.min(maxN, 10000));
  for (let n = 1; n <= Math.min(maxN, 10000); n++) {
    if (mu[n] > 0) pos++;
    else if (mu[n] < 0) neg++;
    else zero++;
  }
  const total = Math.min(maxN, 10000);
  document.getElementById('mobexpPosFrac').textContent = showFractions ? `${pos}/${total}` : `${(pos/total*100).toFixed(1)}%`;
  document.getElementById('mobexpNegFrac').textContent = showFractions ? `${neg}/${total}` : `${(neg/total*100).toFixed(1)}%`;
  document.getElementById('mobexpZeroFrac').textContent = showFractions ? `${zero}/${total}` : `${(zero/total*100).toFixed(1)}%`;
}

function drawCosmicCharts() {
  const { sqrtN, results, statistics, maxN } = cosmicData;
  const maxSum = statistics.max;
  const displayResults = results.slice(0, 100);
  
  // Main chart - Exponential Sum Distribution (scatter plot)
  const majorArcs = displayResults.filter(r => r.type === 'Major Arc');
  const rationals = displayResults.filter(r => r.type === 'Rational');
  const irrationals = displayResults.filter(r => r.type === 'Irrational');
  
  const traces1 = [];
  if (majorArcs.length) traces1.push({
    x: majorArcs.map((r, i) => i),
    y: majorArcs.map(r => r.sum),
    mode: 'markers',
    name: 'Major Arc',
    marker: { color: '#ff6b6b', size: 8 },
    text: majorArcs.map(r => `α=${formatAlphaFraction(r.alpha)}<br>|S|=${fmt(r.sum)}`),
    hovertemplate: '%{text}<extra></extra>'
  });
  if (rationals.length) traces1.push({
    x: rationals.map((r, i) => majorArcs.length + i),
    y: rationals.map(r => r.sum),
    mode: 'markers',
    name: 'Rational',
    marker: { color: '#feca57', size: 7 },
    text: rationals.map(r => `α=${formatAlphaFraction(r.alpha)}<br>|S|=${fmt(r.sum)}`),
    hovertemplate: '%{text}<extra></extra>'
  });
  if (irrationals.length) traces1.push({
    x: irrationals.map((r, i) => majorArcs.length + rationals.length + i),
    y: irrationals.map(r => r.sum),
    mode: 'markers',
    name: 'Irrational',
    marker: { color: '#4ecdc4', size: 6 },
    text: irrationals.map(r => `α=${r.alpha.toFixed(6)}<br>|S|=${fmt(r.sum)}`),
    hovertemplate: '%{text}<extra></extra>'
  });
  
  // Add √N reference line
  traces1.push({
    x: [0, displayResults.length - 1],
    y: [sqrtN, sqrtN],
    mode: 'lines',
    name: `√N = ${fmt(sqrtN)}`,
    line: { color: '#ff6b6b', dash: 'dash', width: 2 }
  });
  
  Plotly.newPlot('pcosmicMain', traces1, {
    ...plo(),
    xaxis: { title: 'Sample Index (sorted by |S|)' },
    yaxis: { title: '|S(N,α)|' },
    showlegend: true,
    legend: { x: 0.02, y: 0.98 }
  });
  
  // Heatmap - α vs |S| intensity
  const gridSize = 20;
  const heatData = [];
  for (let y = 0; y < gridSize; y++) {
    heatData.push([]);
    for (let x = 0; x < gridSize; x++) {
      const idx = y * gridSize + x;
      heatData[y].push(idx < results.length ? results[idx].sum : 0);
    }
  }
  
  Plotly.newPlot('pcosmicHeat', [{
    z: heatData,
    type: 'heatmap',
    colorscale: [[0, '#1a1a2e'], [0.25, '#4a1942'], [0.5, '#ff6b6b'], [0.75, '#feca57'], [1, '#4ecdc4']],
    colorbar: { title: '|S(N,α)|' }
  }], {
    ...plo(),
    xaxis: { title: 'Grid X' },
    yaxis: { title: 'Grid Y' }
  });
  
  // Ratio Analysis - scatter plot of ratio vs α
  Plotly.newPlot('pcosmicRatio', [{
    x: results.slice(0, 200).map(r => r.alpha),
    y: results.slice(0, 200).map(r => r.sum / sqrtN),
    mode: 'markers',
    marker: {
      color: results.slice(0, 200).map(r => r.sum / sqrtN > 1 ? '#ff6b6b' : '#4ecdc4'),
      size: 6
    },
    text: results.slice(0, 200).map(r => `α=${formatAlphaFraction(r.alpha)}<br>Ratio=${fmt(r.sum/sqrtN)}`),
    hovertemplate: '%{text}<extra></extra>'
  }, {
    x: [0, 1],
    y: [1, 1],
    mode: 'lines',
    name: 'Ratio = 1',
    line: { color: '#ffd700', dash: 'dash', width: 2 }
  }], {
    ...plo(),
    xaxis: { title: 'α', range: [0, 1] },
    yaxis: { title: 'Ratio |S|/√N' },
    showlegend: false
  });
  
  // Histogram of |S| distribution
  Plotly.newPlot('pcosmicHist', [{
    x: results.map(r => r.sum),
    type: 'histogram',
    nbinsx: 20,
    marker: { color: '#4ecdc4', line: { color: '#2a9d8f', width: 1 } }
  }, {
    x: [sqrtN, sqrtN],
    y: [0, results.length / 3],
    mode: 'lines',
    name: '√N',
    line: { color: '#ff6b6b', dash: 'dash', width: 2 }
  }], {
    ...plo(),
    xaxis: { title: '|S(N,α)|' },
    yaxis: { title: 'Count' },
    showlegend: false
  });
}

// Export functions for cosmic tester
function exportCosmicCSV() {
  if (!cosmicData.results.length) { alert('Run test first'); return; }
  let csv = 'Alpha,Sum,Ratio,Type,Real,Imaginary,Phase\n';
  cosmicData.results.forEach(r => {
    csv += `${r.alpha},${r.sum},${r.sum / cosmicData.sqrtN},${r.type},${r.real},${r.imaginary},${r.phase}\n`;
  });
  dl(csv, `cosmic_rh_test_${cosmicData.maxN}.csv`);
}

function exportCosmicJSON() {
  if (!cosmicData.results.length) { alert('Run test first'); return; }
  dl(JSON.stringify(cosmicData, null, 2), `cosmic_rh_test_${cosmicData.maxN}.json`);
}

function exportCosmicReport() {
  if (!cosmicData.results.length) { alert('Run test first'); return; }
  const { maxN, sqrtN, maxSum, ratio, bestAlpha, computeTime, results, statistics } = cosmicData;
  
  let report = `Cosmic Scale Riemann Hypothesis Test Report\n`;
  report += `${'='.repeat(50)}\n\n`;
  report += `Generated: ${new Date().toISOString()}\n`;
  report += `Platform: Möbius Shell Sieve — Cosmic RH Tester\n\n`;
  report += `Test Parameters:\n`;
  report += `- Maximum N: ${maxN.toLocaleString()}\n`;
  report += `- √N bound: ${sqrtN.toFixed(6)}\n`;
  report += `- Test mode: ${document.getElementById('cosmicMode').value}\n\n`;
  report += `Results:\n`;
  report += `- Maximum |S(N,α)|: ${maxSum.toFixed(6)}\n`;
  report += `- Ratio: ${ratio.toFixed(8)}\n`;
  report += `- Best α: ${formatAlphaFraction(bestAlpha)}\n`;
  report += `- Computation time: ${(computeTime / 1000).toFixed(3)}s\n\n`;
  report += `Statistics:\n`;
  report += `- Mean: ${statistics.mean.toFixed(6)}\n`;
  report += `- Median: ${statistics.median.toFixed(6)}\n`;
  report += `- Std Dev: ${statistics.stdDev.toFixed(6)}\n`;
  report += `- Major arcs: ${statistics.majorArcCount}\n`;
  report += `- Rational: ${statistics.rationalCount}\n`;
  report += `- Irrational: ${statistics.irrationalCount}\n\n`;
  report += `Top 15 Results:\n`;
  results.slice(0, 15).forEach((r, i) => {
    report += `${i + 1}. α=${formatAlphaFraction(r.alpha)}, |S|=${r.sum.toFixed(6)}, ratio=${(r.sum / sqrtN).toFixed(6)}, ${r.type}\n`;
  });
  
  dl(report, `cosmic_rh_report_${maxN}.txt`);
}

function saveCosmicCanvas() {
  if (!cosmicData.results.length) { alert('Run test first'); return; }
  Plotly.downloadImage('pcosmicMain', {format: 'png', filename: `cosmic_rh_chart_${cosmicData.maxN}`, width: 1200, height: 700});
}

// Statistical Analysis functions
function runMobExpStats() {
  const N = +document.getElementById('mobexpStatsNv').value;
  const numSamples = +document.getElementById('mobexpStatsSamples').value;
  const sqrtN = Math.sqrt(N);
  
  // Generate Möbius
  const mu = [];
  for (let n = 1; n <= N; n++) mu[n] = mobius(n);
  
  // Sample random alphas
  const alphas = [];
  for (let i = 0; i < numSamples; i++) alphas.push(Math.random());
  
  // Compute sums
  const sums = [];
  alphas.forEach(alpha => {
    let re = 0, im = 0;
    for (let n = 1; n <= N; n++) {
      if (mu[n] !== 0) {
        re += mu[n] * Math.cos(2 * Math.PI * alpha * n);
        im += mu[n] * Math.sin(2 * Math.PI * alpha * n);
      }
    }
    sums.push(Math.sqrt(re * re + im * im));
  });
  
  // Statistics
  const mean = sums.reduce((a, b) => a + b, 0) / sums.length;
  const variance = sums.reduce((s, v) => s + (v - mean) ** 2, 0) / sums.length;
  const stdDev = Math.sqrt(variance);
  const sortedSums = [...sums].sort((a, b) => a - b);
  const median = sortedSums[Math.floor(sortedSums.length / 2)];
  
  // Skewness and kurtosis
  const m3 = sums.reduce((s, v) => s + ((v - mean) / stdDev) ** 3, 0) / sums.length;
  const m4 = sums.reduce((s, v) => s + ((v - mean) / stdDev) ** 4, 0) / sums.length - 3;
  
  const exceedCount = sums.filter(s => s > sqrtN).length;
  
  document.getElementById('statsMean').textContent = fmt(mean);
  document.getElementById('statsMedian').textContent = fmt(median);
  document.getElementById('statsStdDev').textContent = fmt(stdDev);
  document.getElementById('statsSkewness').textContent = fmt(m3);
  document.getElementById('statsKurtosis').textContent = fmt(m4);
  document.getElementById('statsExceed').textContent = `${exceedCount}/${numSamples}`;
  
  // Distribution chart
  const bins = 20;
  const binSize = Math.max(...sums) / bins;
  const hist = new Array(bins).fill(0);
  sums.forEach(s => {
    const idx = Math.min(Math.floor(s / binSize), bins - 1);
    hist[idx]++;
  });
  
  Plotly.newPlot('pmobexpStatsDist', [{
    x: hist.map((_, i) => `${fmt(i * binSize)}-${fmt((i + 1) * binSize)}`),
    y: hist,
    type: 'bar',
    marker: { color: '#4ecdc4' }
  }], { ...plo(), xaxis: { title: '|S(N,α)|' }, yaxis: { title: 'Count' } });
  
  // Q-Q plot
  const theoretical = sortedSums.map((_, i) => {
    const p = (i + 0.5) / sortedSums.length;
    return mean + stdDev * Math.sqrt(2) * (p < 0.5 ? -1 : 1) * Math.sqrt(-Math.log(2 * Math.min(p, 1 - p)));
  });
  
  Plotly.newPlot('pmobexpStatsQQ', [{
    x: theoretical,
    y: sortedSums,
    mode: 'markers',
    marker: { color: '#ff6496', size: 4 }
  }, {
    x: [Math.min(...sortedSums), Math.max(...sortedSums)],
    y: [Math.min(...sortedSums), Math.max(...sortedSums)],
    mode: 'lines',
    line: { color: '#ffd700', dash: 'dash' }
  }], { ...plo(), xaxis: { title: 'Theoretical' }, yaxis: { title: 'Sample' } });
  
  // Ratio vs alpha
  Plotly.newPlot('pmobexpStatsRatio', [{
    x: alphas,
    y: sums.map(s => s / sqrtN),
    mode: 'markers',
    marker: { color: sums.map(s => s > sqrtN ? '#ff6496' : '#00ff88'), size: 5 }
  }, {
    x: [0, 1],
    y: [1, 1],
    mode: 'lines',
    line: { color: '#ffd700', dash: 'dash' }
  }], { ...plo(), xaxis: { title: 'α' }, yaxis: { title: 'Ratio' } });
  
  // Running mean
  const runningMean = [];
  let cumSum = 0;
  sums.forEach((s, i) => {
    cumSum += s;
    runningMean.push(cumSum / (i + 1));
  });
  
  Plotly.newPlot('pmobexpStatsRunning', [{
    y: runningMean,
    mode: 'lines',
    line: { color: '#00d9ff' },
    name: 'Running Mean'
  }, {
    y: runningMean.map(() => mean),
    mode: 'lines',
    line: { color: '#ffd700', dash: 'dash' },
    name: 'Final Mean'
  }], { ...plo(), xaxis: { title: 'Sample #' }, yaxis: { title: 'Mean |S|' } });
  
  document.getElementById('mobexpStatsResults').style.display = 'block';
}

function screenshotMobExpStats() {
  screenshotTabAll({ charts: ['pmobexpStatsDist', 'pmobexpStatsQQ', 'pmobexpStatsRatio', 'pmobexpStatsRunning'], title: 'Möbius Exp Sum Statistics', filename: 'mobexp_stats.png' });
}

function csvMobExpStats() {
  alert('Run analysis first, then use individual chart CSV exports');
}

// Initialize cosmic N input listener
document.getElementById('cosmicN')?.addEventListener?.('input', function() {
  updateCosmicPerfHint(+this.value);
});

// Upgraded Dimension function
function gamma(n){if(n===1)return 1;if(n===0.5)return Math.sqrt(Math.PI);return(n-1)*gamma(n-1);}
function ballVol(n){return Math.pow(Math.PI,n/2)/gamma(n/2+1);}

function runDimNew(){
if(!document.getElementById("pdimVol")) return;

const maxD=+document.getElementById('dimMaxV').value||+document.getElementById('dimMax').value;
const R=+document.getElementById('rdimv').value||+document.getElementById('rdim').value;
const mode=document.getElementById('dimMode').value;
D.dim=[];const ns=[],zs=[],invZs=[],vols=[],comps=[];
let exactCount=0;

for(let n=2;n<=maxD;n++){
const v=ballVol(n),z=zeta(n),invZ=1/z,th=v*Math.pow(R,n)*invZ;
let computed=Math.round(th),err=0,method='theory';
if(mode==='full'||(mode==='hybrid'&&n<=5)){
if(n===2){let tot=0,prim=0;for(let x=-Math.ceil(R);x<=Math.ceil(R);x++)for(let y=-Math.ceil(R);y<=Math.ceil(R);y++)if(x*x+y*y<=R*R){tot++;if(gcdM(x,y)===1)prim++;}computed=prim;err=Math.abs(prim-th);method='exact';exactCount++;}
else if(n===3){let tot=0,prim=0;const m=Math.ceil(R);for(let x=-m;x<=m;x++)for(let y=-m;y<=m;y++)for(let z=-m;z<=m;z++)if(x*x+y*y+z*z<=R*R){tot++;if(gcdM(x,y,z)===1)prim++;}computed=prim;err=Math.abs(prim-th);method='exact';exactCount++;}
else if(n<=5&&R<=8){let tot=0,prim=0;const m=Math.min(Math.ceil(R),5);
(function en(dim,coords){if(coords.length===n){const s=coords.reduce((a,x)=>a+x*x,0);if(s<=R*R){tot++;if(gcdM(...coords)===1)prim++;}return;}for(let i=-m;i<=m;i++)en(dim,[...coords,i]);})(n,[]);
computed=prim;err=Math.abs(prim-th);method='exact';exactCount++;}}
ns.push(n);zs.push(z);invZs.push(invZ);vols.push(v*Math.pow(R,n));comps.push(computed);
D.dim.push({n,v,z,invZ,th,computed,err,method,volRn:v*Math.pow(R,n)});}

// Chart 1: ζ(n) convergence
Plotly.newPlot('pdimZeta',[
{x:ns,y:zs,mode:'lines+markers',name:'ζ(n)',line:{color:'#ff8c00',width:2},marker:{size:6}},
{x:ns,y:ns.map(()=>1),mode:'lines',name:'Limit=1',line:{color:'#666',dash:'dash'}}
],{...plo(),xaxis:{title:'Dimension n'},yaxis:{title:'ζ(n)',range:[0.9,zs.reduce((a,b)=>Math.max(a,b),0)+0.2]}});

// Chart 2: 1/ζ(n) density
Plotly.newPlot('pdimDens',[
{x:ns,y:invZs,mode:'lines+markers',name:'1/ζ(n)',line:{color:'#00ff88',width:2},marker:{size:6}},
{x:ns,y:ns.map(()=>1),mode:'lines',name:'Limit=1',line:{color:'#666',dash:'dash'}}
],{...plo(),xaxis:{title:'Dimension n'},yaxis:{title:'1/ζ(n) = P(coprime)',range:[0.5,1.05]}});

// Chart 3: Volume
Plotly.newPlot('pdimVol',[
{x:ns,y:vols,mode:'lines+markers',name:'Vol(Bⁿ)·Rⁿ',line:{color:'#9664ff',width:2},marker:{size:6}}
],{...plo(),xaxis:{title:'Dimension n'},yaxis:{title:'Volume·Rⁿ',type:maxD>15?'log':'linear'}});

// Find special values
const maxVolIdx=vols.indexOf(vols.reduce((a,b)=>Math.max(a,b),0));
const z2=zeta(2),z3=zeta(3),z4=zeta(4);

// Live stats
document.getElementById('dimLiveStats').innerHTML=`
<div style="background:linear-gradient(135deg,rgba(0,217,255,.15),rgba(255,215,0,.1));padding:10px;border-radius:8px;margin-bottom:12px;border:1px solid var(--acc)">
<div style="font-size:.7rem;color:var(--txt2);margin-bottom:4px">TAB: Higher Dimensions | FIELD: ℤᵏ Ball | TYPE: Primitive Density 1/ζ(k)</div>
<div style="display:grid;grid-template-columns:repeat(3,1fr);gap:6px;font-size:.75rem">
<span>Max Dim: <strong style="color:#00d9ff">${maxD}</strong></span>
<span>R: <strong style="color:#ffd700">${R}</strong></span>
<span>Mode: <strong style="color:#00ff88">${mode}</strong></span>
</div>
</div>
<div style="display:grid;grid-template-columns:repeat(3,1fr);gap:8px;margin-bottom:12px">
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center"><div style="font-size:1.4rem;font-weight:bold;color:#00d9ff">${maxD}</div><div style="font-size:.7rem;color:var(--txt2)">MAX DIM</div></div>
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center"><div style="font-size:1.4rem;font-weight:bold;color:#ffd700">${R}</div><div style="font-size:.7rem;color:var(--txt2)">RADIUS R</div></div>
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center"><div style="font-size:1.4rem;font-weight:bold;color:#00ff88">${mode}</div><div style="font-size:.7rem;color:var(--txt2)">MODE</div></div>
</div>
<div style="display:grid;grid-template-columns:repeat(3,1fr);gap:8px;margin-bottom:12px">
<div style="background:var(--bg1);padding:8px;border-radius:6px;text-align:center"><div style="font-size:1rem;font-weight:bold;color:#9664ff">${fmt(1/z2)}</div><div style="font-size:.6rem;color:var(--txt2)">1/ζ(2) DENSITY</div></div>
<div style="background:var(--bg1);padding:8px;border-radius:6px;text-align:center"><div style="font-size:1rem;font-weight:bold;color:#ff8c00">${fmt(1/z3)}</div><div style="font-size:.6rem;color:var(--txt2)">1/ζ(3) DENSITY</div></div>
<div style="background:var(--bg1);padding:8px;border-radius:6px;text-align:center"><div style="font-size:1rem;font-weight:bold;color:#00ff88">${fmt(1/zeta(maxD))}</div><div style="font-size:.6rem;color:var(--txt2)">1/ζ(${maxD}) DENSITY</div></div>
</div>
<div style="margin-bottom:10px;padding-bottom:8px;border-bottom:1px solid var(--bord)">
<strong style="color:var(--acc)">Key ζ Values</strong>
<div style="display:grid;grid-template-columns:1fr 1fr;gap:3px;margin-top:5px;font-size:.8rem">
<span>ζ(2) = π²/6:</span><span style="color:#ff8c00">${fmt(z2)}</span>
<span>ζ(3) Apéry:</span><span style="color:#00d9ff">${fmt(z3)}</span>
<span>ζ(4) = π⁴/90:</span><span style="color:#9664ff">${fmt(z4)}</span>
<span>ζ(${maxD}):</span><span style="color:#ffd700">${fmt(zeta(maxD))}</span>
</div>
</div>
<div style="margin-bottom:10px;padding-bottom:8px;border-bottom:1px solid var(--bord)">
<strong style="color:var(--acc)">Coprime Densities 1/ζ(n)</strong>
<div style="display:grid;grid-template-columns:1fr 1fr;gap:3px;margin-top:5px;font-size:.8rem">
<span>1/ζ(2) = 6/π²:</span><span style="color:#00ff88">${fmt(1/z2)} (${fmt(100/z2)}%)</span>
<span>1/ζ(3):</span><span style="color:#00d9ff">${fmt(1/z3)} (${fmt(100/z3)}%)</span>
<span>1/ζ(${maxD}):</span><span style="color:#ffd700">${fmt(1/zeta(maxD))} (${fmt(100/zeta(maxD))}%)</span>
<span>Limit as n→∞:</span><span style="color:#00ff88">1 (100%)</span>
</div>
</div>
<div style="margin-bottom:10px;padding-bottom:8px;border-bottom:1px solid var(--bord)">
<strong style="color:var(--acc)">Volume Analysis (R=${R})</strong>
<div style="display:grid;grid-template-columns:1fr 1fr;gap:3px;margin-top:5px;font-size:.8rem">
<span>Max Vol at n=:</span><span style="color:#9664ff">${ns[maxVolIdx]}</span>
<span>Max Vol value:</span><span style="color:#9664ff">${fmt(vols[maxVolIdx])}</span>
<span>Vol(B²)·R²:</span><span style="color:#00d9ff">${fmt(vols[0])}</span>
<span>Vol(B${maxD})·R^${maxD}:</span><span style="color:#ffd700">${fmt(vols[vols.length-1])}</span>
</div>
</div>
<div>
<strong style="color:var(--acc)">Computation</strong>
<div style="display:grid;grid-template-columns:1fr 1fr;gap:3px;margin-top:5px;font-size:.8rem">
<span>Dimensions:</span><span style="color:var(--txt)">${D.dim.length}</span>
<span>Exact computed:</span><span style="color:#00ff88">${exactCount}</span>
<span>Theory only:</span><span style="color:#ffd700">${D.dim.length-exactCount}</span>
<span>Total primitives:</span><span style="color:#00d9ff">${comps.reduce((a,b)=>a+b,0)}</span>
</div>
</div>`;

// Table
document.getElementById('tdimT').innerHTML='<tr><th>n</th><th>Vol(Bⁿ)</th><th>ζ(n)</th><th>1/ζ(n)</th><th>Computed</th><th>Error</th><th>Method</th></tr>'+
D.dim.map(d=>`<tr onclick="modal('Dimension ${d.n}',[['Vol(B${d.n})',${d.v}],['Vol×R^${d.n}',${d.volRn}],['ζ(${d.n})',${d.z}],['1/ζ(${d.n})',${d.invZ}],['Theory',${d.th}],['Computed',${d.computed}],['Method','${d.method}']])" style="cursor:pointer"><td>${d.n}</td><td>${fmt(d.v)}</td><td>${fmt(d.z)}</td><td>${fmt(d.invZ)}</td><td>${d.computed}</td><td>${fmt(d.err)}</td><td style="color:${d.method==='exact'?'#00ff88':'#ffd700'}">${d.method}</td></tr>`).join('');}


function runSh(){runShNew();}

let shAnimId=null;
function runShNew(){
if(!document.getElementById("pSH")) return;

const R=+document.getElementById('rshv').value||+document.getElementById('rsh').value;
const maxK=+document.getElementById('shKv').value||+document.getElementById('shK').value;
const shape=document.getElementById('shShape').value;
const display=document.getElementById('shDisplay').value;
const colorMode=document.getElementById('shColor').value;
const sfOnly=document.getElementById('shSquarefree').checked;
const markPrimes=document.getElementById('shPrimes').checked;
const showZero=document.getElementById('shShowZero').checked;

const ks=[],cs=[],Ls=[],mus=[];
D.sh=[];
let cum=0,pos=0,neg=0,actualPrim=0;

// Compute actual primitive count for comparison
const pts=enum2D(R,shape);
actualPrim=pts.filter(p=>p.p).length;

for(let k=1;k<=maxK;k++){
if(R/k<0.5)break;
const L=enum2D(R/k,shape).length;
const m=mob(k);
const c=m*L;
cum+=c;
if(c>0)pos+=c;
if(c<0)neg+=c;
const sf=isSquarefree(k);
const isPrime=k>1&&factorizeN(k).indexOf('·')===-1&&factorizeN(k).indexOf('^')===-1;
ks.push(k);
cs.push(c);
Ls.push(L);
mus.push(m);
D.sh.push({k,m,L,c,cum,sf,isPrime,pctTotal:0,fac:factorizeN(k)});}

// Calculate percentages
const absTotal=D.sh.reduce((a,d)=>a+Math.abs(d.c),0);
D.sh.forEach(d=>{d.pctTotal=absTotal>0?100*Math.abs(d.c)/absTotal:0;});

// Filter for display
const filtered=sfOnly?D.sh.filter(d=>d.sf):showZero?D.sh:D.sh.filter(d=>d.m!==0);

// Chart 1: Main contributions
let barColors;
if(colorMode==='sign')barColors=filtered.map(d=>d.c>0?'#00ff88':d.c<0?'#ff006e':'#666');
else if(colorMode==='mobius')barColors=filtered.map(d=>d.m===1?'#00d9ff':d.m===-1?'#ff8c00':'#666');
else{const maxAbsC=cs.reduce((m,c)=>Math.max(m,Math.abs(c)),0)||1;barColors=filtered.map(d=>`hsl(${Math.abs(d.c)/maxAbsC*240},70%,50%)`);}

const traces1=[];
if(display==='contrib'||display==='both'){
traces1.push({x:filtered.map(d=>d.k),y:filtered.map(d=>d.c),name:'μ(k)·L(R/k)',type:'bar',marker:{color:barColors}});}
if(display==='cumul'||display==='both'){
traces1.push({x:filtered.map(d=>d.k),y:filtered.map(d=>d.cum),name:'Cumulative',mode:'lines+markers',line:{color:'#ffd700',width:2},yaxis:display==='both'?'y2':'y'});}

const layout1={...plo(),xaxis:{title:'Shell k'},yaxis:{title:'Contribution'}};
if(display==='both')layout1.yaxis2={title:'Cumulative',overlaying:'y',side:'right'};
Plotly.newPlot('psh',traces1,layout1);
legend('alsh','Shell Decomposition',[['Positive',pos,'#00ff88'],['Negative',Math.abs(neg),'#ff006e'],['Net (Σ)',cum,'#ffd700']]);

// Chart 2: Cumulative convergence
Plotly.newPlot('pshCum',[
{x:D.sh.map(d=>d.k),y:D.sh.map(d=>d.cum),name:'Running Sum',mode:'lines+markers',line:{color:'#00d9ff',width:2}},
{x:D.sh.map(d=>d.k),y:D.sh.map(()=>actualPrim),name:'Actual P(R)',mode:'lines',line:{color:'#ffd700',dash:'dash'}}
],{...plo(),xaxis:{title:'Max Shell k'},yaxis:{title:'Σμ(k)·L(R/k)'}});

// Chart 3: Magnitude chart
Plotly.newPlot('pshMag',[{x:D.sh.map(d=>d.k),y:D.sh.map(d=>Math.abs(d.c)),type:'bar',marker:{color:D.sh.map(d=>d.sf?'#00ff88':'#9664ff')}}],{...plo(),xaxis:{title:'k'},yaxis:{title:'|μ(k)·L(R/k)|'}});

// Chart 4: Möbius function
Plotly.newPlot('pshMob',[{x:D.sh.map(d=>d.k),y:D.sh.map(d=>d.m),type:'bar',marker:{color:D.sh.map(d=>d.m===1?'#00d9ff':d.m===-1?'#ff006e':'#666')}}],{...plo(),xaxis:{title:'k'},yaxis:{title:'μ(k)',range:[-1.5,1.5]}});

// Chart 5: Shell sizes
Plotly.newPlot('pshL',[{x:D.sh.map(d=>d.k),y:D.sh.map(d=>d.L),mode:'lines+markers',line:{color:'#ff8c00',width:2}}],{...plo(),xaxis:{title:'k'},yaxis:{title:'L(R/k)'}});

// Live stats
const nonZeroCount=D.sh.filter(d=>d.m!==0).length;
const sfCount=D.sh.filter(d=>d.sf).length;
const primeCount=D.sh.filter(d=>d.isPrime).length;
const convergenceErr=Math.abs(cum-actualPrim);

document.getElementById('shLiveStats').innerHTML=`
<div style="display:grid;grid-template-columns:repeat(3,1fr);gap:8px;margin-bottom:12px">
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center"><div style="font-size:1.4rem;font-weight:bold;color:#00d9ff">${R}</div><div style="font-size:.7rem;color:var(--txt2)">RADIUS R</div></div>
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center"><div style="font-size:1.4rem;font-weight:bold;color:#ffd700">${cum}</div><div style="font-size:.7rem;color:var(--txt2)">SHELL SUM</div></div>
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center"><div style="font-size:1.4rem;font-weight:bold;color:#00ff88">${actualPrim}</div><div style="font-size:.7rem;color:var(--txt2)">ACTUAL P(R)</div></div>
</div>
<div style="margin-bottom:10px;padding-bottom:8px;border-bottom:1px solid var(--bord)">
<strong style="color:var(--acc)">Configuration</strong>
<div style="display:grid;grid-template-columns:1fr 1fr;gap:3px;margin-top:5px;font-size:.8rem">
<span>Shape:</span><span style="color:var(--txt)">${shape}</span>
<span>Max k:</span><span style="color:var(--txt)">${maxK}</span>
<span>Active Shells:</span><span style="color:var(--txt)">${D.sh.length}</span>
<span>Non-zero μ:</span><span style="color:var(--txt)">${nonZeroCount}</span>
</div>
</div>
<div style="margin-bottom:10px;padding-bottom:8px;border-bottom:1px solid var(--bord)">
<strong style="color:var(--acc)">Contribution Analysis</strong>
<div style="display:grid;grid-template-columns:1fr 1fr;gap:3px;margin-top:5px;font-size:.8rem">
<span>Positive sum:</span><span style="color:#00ff88">+${pos}</span>
<span>Negative sum:</span><span style="color:#ff006e">${neg}</span>
<span>Net (Möbius):</span><span style="color:#ffd700">${cum}</span>
<span>Actual P(R):</span><span style="color:#00d9ff">${actualPrim}</span>
</div>
</div>
<div style="margin-bottom:10px;padding-bottom:8px;border-bottom:1px solid var(--bord)">
<strong style="color:var(--acc)">Convergence</strong>
<div style="display:grid;grid-template-columns:1fr 1fr;gap:3px;margin-top:5px;font-size:.8rem">
<span>Error |Σ - P(R)|:</span><span style="color:${convergenceErr<5?'#00ff88':'#ff8c00'}">${convergenceErr}</span>
<span>Rel Error:</span><span style="color:var(--txt)">${actualPrim>0?fmt(100*convergenceErr/actualPrim)+'%':'—'}</span>
<span>k=1 contrib:</span><span style="color:#00d9ff">${D.sh[0]?.c||0}</span>
<span>k=2 contrib:</span><span style="color:#ff006e">${D.sh[1]?.c||0}</span>
</div>
</div>
<div>
<strong style="color:var(--acc)">Shell Composition</strong>
<div style="display:grid;grid-template-columns:1fr 1fr;gap:3px;margin-top:5px;font-size:.8rem">
<span>Squarefree k:</span><span style="color:#00ff88">${sfCount}</span>
<span>Prime k:</span><span style="color:#9664ff">${primeCount}</span>
<span>μ(k)=0 shells:</span><span style="color:#666">${D.sh.length-nonZeroCount}</span>
<span>Largest |contrib|:</span><span style="color:#ffd700">${D.sh.reduce((m,d)=>Math.max(m,Math.abs(d.c)),0)}</span>
</div>
</div>`;

// Table
document.getElementById('tshT').innerHTML='<tr><th>k</th><th>μ(k)</th><th>L(R/k)</th><th>Contribution</th><th>Cumulative</th><th>% of |Total|</th><th>SF?</th></tr>'+
D.sh.map(d=>`<tr onclick="modal('Shell k=${d.k}',[['μ(${d.k})',${d.m}],['L(R/${d.k})',${d.L}],['Contribution',${d.c}],['Cumulative',${d.cum}],['Factorization','${d.fac}'],['Squarefree',${d.sf}]])" style="cursor:pointer;color:${d.m===0?'#666':d.c>0?'#00ff88':'#ff006e'}"><td>${d.k}${d.isPrime?' ':''}</td><td>${d.m}</td><td>${d.L}</td><td>${d.c>0?'+':''}${d.c}</td><td>${d.cum}</td><td>${fmt(d.pctTotal)}%</td><td>${d.sf?'OK':''}</td></tr>`).join('');}

function animateShells(){
const R=+document.getElementById('rshv').value,maxK=+document.getElementById('shKv').value;
if(shAnimId)cancelAnimationFrame(shAnimId);
let step=1;
function frame(){
document.getElementById('shKv').value=step;
document.getElementById('shK').value=Math.min(50,step);
runShNew();
if(step<maxK){step++;shAnimId=setTimeout(()=>requestAnimationFrame(frame),200);}else{shAnimId=null;}}
frame();}

function csvSh(){let s='k,mu,L,Contribution,Cumulative,PctTotal,Squarefree,Factorization\n';for(const d of D.sh)s+=`${d.k},${d.m},${d.L},${d.c},${d.cum},${d.pctTotal},${d.sf},"${d.fac}"\n`;dl(s,'shells.csv');}

function isSquarefree(n){if(n<=1)return n===1;for(let p=2;p*p<=n;p++)if(n%(p*p)===0)return false;return true;}
function factorizeN(n){if(n<=1)return n===1?'1':'0';let s='',m=n;for(let p=2;p*p<=m;p++){let e=0;while(m%p===0){m/=p;e++;}if(e>0)s+=(s?'·':'')+p+(e>1?'^'+e:'');}if(m>1)s+=(s?'·':'')+m;return s||'1';}

function runGCD(){
if(!document.getElementById("pGCD")) return;

const R=+document.getElementById('rgcdv').value||+document.getElementById('rgcd').value;
const shape=document.getElementById('gcdShape').value;
const topN=+document.getElementById('gcdTopN').value;
const m=Math.ceil(R)+1,gc={},all=[];

for(let x=-m;x<=m;x++){
for(let y=-m;y<=m;y++){
const inRegion=shape==='circle'?(x*x+y*y<=R*R):(Math.abs(x)<=R&&Math.abs(y)<=R);
if(inRegion){const g=gcdM(x,y);gc[g]=(gc[g]||0)+1;all.push(g);}}}

const sorted=Object.entries(gc).sort((a,b)=>+a[0]-+b[0]);
const tot=all.length;
const gcd1=gc[1]||0;
const z2=zeta(2);

// Compute statistics
const mean=all.reduce((a,b)=>a+b,0)/tot;
const sortedAll=[...all].sort((a,b)=>a-b);
const median=sortedAll[Math.floor(tot/2)];
const mode=sorted.reduce((a,b)=>b[1]>a[1]?b:a)[0];
const maxGcd=all.reduce((a,b)=>Math.max(a,b),0);
const variance=all.reduce((a,b)=>a+(b-mean)**2,0)/tot;
const stddev=Math.sqrt(variance);

// Squarefree analysis
const sfCount=all.filter(g=>isSquarefree(g)).length;
const sfGcds=sorted.filter(([g])=>isSquarefree(+g));

// Prepare data
D.gcd=sorted.map(([g,c])=>{
const pct=100*c/tot;
return{g:+g,count:c,pct,sf:isSquarefree(+g),fac:factorizeN(+g)};});

// Cumulative
let cumul=0;
D.gcd.forEach(d=>{cumul+=d.pct;d.cumul=cumul;});

// Theory: P(gcd=k) ≈ 1/(k²·ζ(2)) for primitive scaling
D.gcd.forEach(d=>{d.theory=100/(d.g*d.g*z2);});

// Charts
const top=D.gcd.slice(0,topN);
Plotly.newPlot('pgcd1',[{x:top.map(d=>d.g),y:top.map(d=>d.count),type:'bar',marker:{color:top.map(d=>d.g===1?'#ffd700':d.sf?'#00d9ff':'#9664ff')}}],{...plo(),xaxis:{title:'GCD'},yaxis:{title:'Count'}});
legend('algcd1','GCD Distribution',[['GCD=1',gcd1,'#ffd700'],['Total',tot,'#00d9ff']]);

// Cumulative chart
Plotly.newPlot('pgcd2',[{x:D.gcd.slice(0,30).map(d=>d.g),y:D.gcd.slice(0,30).map(d=>d.cumul),mode:'lines+markers',line:{color:'#00ff88',width:2}}],{...plo(),xaxis:{title:'GCD ≤ k'},yaxis:{title:'Cumulative %',range:[0,105]}});
legend('algcd2','Cumulative',[['50% at GCD≤',D.gcd.find(d=>d.cumul>=50)?.g||'—','#00ff88']]);

// Theory comparison
Plotly.newPlot('pgcd3',[
{x:top.map(d=>d.g),y:top.map(d=>d.pct),name:'Actual %',type:'bar',marker:{color:'#00d9ff'}},
{x:top.map(d=>d.g),y:top.map(d=>d.theory),name:'Theory %',type:'scatter',mode:'markers',marker:{color:'#ff8c00',size:10,symbol:'diamond'}}
],{...plo(),xaxis:{title:'GCD'},yaxis:{title:'Percentage'},barmode:'group'});

// Squarefree chart
const sfData=D.gcd.filter(d=>d.sf).slice(0,15);
const nonSfData=D.gcd.filter(d=>!d.sf).slice(0,10);
Plotly.newPlot('pgcdSF',[
{x:sfData.map(d=>d.g),y:sfData.map(d=>d.count),name:'Squarefree',type:'bar',marker:{color:'#00ff88'}},
{x:nonSfData.map(d=>d.g),y:nonSfData.map(d=>d.count),name:'Non-SF',type:'bar',marker:{color:'#ff6496'}}
],{...plo(),xaxis:{title:'GCD'},yaxis:{title:'Count'},barmode:'group'});

// Divisibility by small primes
const div2=all.filter(g=>g%2===0).length;
const div3=all.filter(g=>g%3===0).length;
const div5=all.filter(g=>g%5===0).length;
const div6=all.filter(g=>g%6===0).length;
Plotly.newPlot('pgcdDiv',[{x:['2|gcd','3|gcd','5|gcd','6|gcd'],y:[div2,div3,div5,div6],type:'bar',marker:{color:['#00d9ff','#ff8c00','#9664ff','#00ff88']}}],{...plo(),yaxis:{title:'Count'}});

// Live stats
document.getElementById('gcdLiveStats').innerHTML=`
<div style="display:grid;grid-template-columns:repeat(3,1fr);gap:8px;margin-bottom:12px">
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center"><div style="font-size:1.4rem;font-weight:bold;color:#ffd700">${gcd1}</div><div style="font-size:.7rem;color:var(--txt2)">GCD = 1</div></div>
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center"><div style="font-size:1.4rem;font-weight:bold;color:#00d9ff">${tot}</div><div style="font-size:.7rem;color:var(--txt2)">TOTAL</div></div>
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center"><div style="font-size:1.4rem;font-weight:bold;color:#00ff88">${fmt(100*gcd1/tot)}%</div><div style="font-size:.7rem;color:var(--txt2)">COPRIME %</div></div>
</div>
<div style="margin-bottom:10px;padding-bottom:8px;border-bottom:1px solid var(--bord)">
<strong style="color:var(--acc)">Configuration</strong>
<div style="display:grid;grid-template-columns:1fr 1fr;gap:3px;margin-top:5px;font-size:.8rem">
<span>Radius R:</span><span style="color:var(--txt)">${R}</span>
<span>Shape:</span><span style="color:var(--txt)">${shape}</span>
<span>Unique GCDs:</span><span style="color:var(--txt)">${sorted.length}</span>
<span>Max GCD:</span><span style="color:var(--txt)">${maxGcd}</span>
</div>
</div>
<div style="margin-bottom:10px;padding-bottom:8px;border-bottom:1px solid var(--bord)">
<strong style="color:var(--acc)">Statistics</strong>
<div style="display:grid;grid-template-columns:1fr 1fr;gap:3px;margin-top:5px;font-size:.8rem">
<span>Mean GCD:</span><span style="color:#00d9ff">${fmt(mean)}</span>
<span>Median GCD:</span><span style="color:#ff8c00">${median}</span>
<span>Mode GCD:</span><span style="color:#ffd700">${mode}</span>
<span>Std Dev:</span><span style="color:#9664ff">${fmt(stddev)}</span>
</div>
</div>
<div style="margin-bottom:10px;padding-bottom:8px;border-bottom:1px solid var(--bord)">
<strong style="color:var(--acc)">Theory Comparison</strong>
<div style="display:grid;grid-template-columns:1fr 1fr;gap:3px;margin-top:5px;font-size:.8rem">
<span>Actual P(gcd=1):</span><span style="color:#ffd700">${fmt(100*gcd1/tot)}%</span>
<span>Theory 6/π²:</span><span style="color:#ff8c00">${fmt(100/z2)}%</span>
<span>Error:</span><span style="color:${Math.abs(gcd1/tot-1/z2)<0.02?'#00ff88':'#ff6496'}">${fmt(Math.abs(100*gcd1/tot-100/z2))}%</span>
<span>Ratio:</span><span style="color:#00d9ff">${fmt((gcd1/tot)/(1/z2))}</span>
</div>
</div>
<div>
<strong style="color:var(--acc)">Squarefree Analysis</strong>
<div style="display:grid;grid-template-columns:1fr 1fr;gap:3px;margin-top:5px;font-size:.8rem">
<span>SF GCDs:</span><span style="color:#00ff88">${sfCount} (${fmt(100*sfCount/tot)}%)</span>
<span>Theory 6/π²:</span><span style="color:#ff8c00">${fmt(100/z2)}%</span>
<span>Non-SF GCDs:</span><span style="color:#ff6496">${tot-sfCount}</span>
<span>Unique SF values:</span><span style="color:#9664ff">${sfGcds.length}</span>
</div>
</div>`;

// Table
document.getElementById('tgcdT').innerHTML='<tr><th>GCD</th><th>Count</th><th>Percent</th><th>Cumulative</th><th>Theory</th><th>SF?</th><th>Factors</th></tr>'+
D.gcd.slice(0,50).map(d=>`<tr onclick="modal('GCD ${d.g}',[['Count',${d.count}],['Percent','${fmt(d.pct)}%'],['Cumulative','${fmt(d.cumul)}%'],['Theory','${fmt(d.theory)}%'],['Squarefree',${d.sf}],['Factorization','${d.fac}']])" style="cursor:pointer;color:${d.g===1?'#ffd700':d.sf?'inherit':'#9664ff'}"><td>${d.g}</td><td>${d.count}</td><td>${fmt(d.pct)}%</td><td>${fmt(d.cumul)}%</td><td>${fmt(d.theory)}%</td><td>${d.sf?'OK':''}</td><td>${d.fac}</td></tr>`).join('');}

function runGCDConvergence(){
const Rs=[5,10,15,20,25,30,40,50];
const densities=[];
for(const R of Rs){
let tot=0,gcd1=0;const m=Math.ceil(R);
for(let x=-m;x<=m;x++)for(let y=-m;y<=m;y++)if(x*x+y*y<=R*R){tot++;if(gcdM(x,y)===1)gcd1++;}
densities.push({R,density:gcd1/tot,theory:1/zeta(2)});}
Plotly.newPlot('pgcd3',[
{x:Rs,y:densities.map(d=>d.density*100),name:'Actual',mode:'lines+markers',line:{color:'#00d9ff',width:2}},
{x:Rs,y:densities.map(d=>d.theory*100),name:'6/π²',mode:'lines',line:{color:'#ff8c00',dash:'dash'}}
],{...plo(),xaxis:{title:'Radius R'},yaxis:{title:'P(gcd=1) %',range:[58,65]}});}

function csvGCD(){let s='GCD,Count,Percent,Cumulative,Theory,Squarefree,Factorization\n';for(const d of D.gcd)s+=`${d.g},${d.count},${d.pct},${d.cumul},${d.theory},${d.sf},"${d.fac}"\n`;dl(s,'gcd.csv');}

function isGausPrime(a,b){
const n2=a*a+b*b;if(n2===0)return false;if(n2===1)return false;
if(a===0){const bAbs=Math.abs(b);if(bAbs<2)return false;if(bAbs===2)return false;if(bAbs%4===3){for(let i=2;i*i<=bAbs;i++)if(bAbs%i===0)return false;return true;}return false;}
if(b===0){const aAbs=Math.abs(a);if(aAbs<2)return false;if(aAbs===2)return false;if(aAbs%4===3){for(let i=2;i*i<=aAbs;i++)if(aAbs%i===0)return false;return true;}return false;}
for(let i=2;i*i<=n2;i++)if(n2%i===0)return false;return true;
}

// Toggle between Gaussian Integers and Circle Problem views
function drawGaus(){
const c=document.getElementById('cgaus'),ctx=c.getContext('2d');
const R=+document.getElementById('rgausv').value||+document.getElementById('rgaus').value;
const zm=+document.getElementById('zmgaus').value,ptSz=+document.getElementById('ptszgaus').value;
const col=document.getElementById('colGaus').value,filt=document.getElementById('filtGaus').value;
const lbl=document.getElementById('lblGaus').value;
const showNormC=document.getElementById('gausNormC').checked,showAxes=document.getElementById('gausAxes').checked;
const showGrid=document.getElementById('gausGrid').checked,showUnits=document.getElementById('gausUnits').checked;
const showAssoc=document.getElementById('gausAssoc').checked,showConj=document.getElementById('gausConj').checked;
ctx.fillStyle=canvBg();ctx.fillRect(0,0,c.width,c.height);
const cx=c.width/2,cy=c.height/2,sc=(c.width/2)/(R*1.15)*zm,nc={};
gausP=[];let tot=0,prim=0,gprimeC=0;
const quadC={0:0,1:0,2:0,3:0};
for(let a=-Math.ceil(R);a<=Math.ceil(R);a++)for(let b=-Math.ceil(R);b<=Math.ceil(R);b++){
const n2=a*a+b*b;if(Math.sqrt(n2)<=R){
const g=gcdM(a,b),isPrim=g===1,isGP=isGausPrime(a,b);
const arg=Math.atan2(b,a);
const quad=a>=0?(b>=0?0:3):(b>=0?1:2);
const isUnit=(a===1&&b===0)||(a===-1&&b===0)||(a===0&&b===1)||(a===0&&b===-1);
if(filt==='prim'&&!isPrim)continue;
if(filt==='gprime'&&!isGP)continue;
if(filt==='units'&&isUnit)continue;
tot++;if(isPrim)prim++;if(isGP)gprimeC++;
nc[n2]=(nc[n2]||0)+1;quadC[quad]++;
gausP.push({a,b,n2,g,isPrim,isGP,arg,quad,isUnit});}}
if(showGrid){ctx.strokeStyle=gridC();ctx.lineWidth=0.5;
for(let i=-Math.ceil(R);i<=Math.ceil(R);i++){ctx.beginPath();ctx.moveTo(cx+i*sc,0);ctx.lineTo(cx+i*sc,c.height);ctx.stroke();ctx.beginPath();ctx.moveTo(0,cy-i*sc);ctx.lineTo(c.width,cy-i*sc);ctx.stroke();}}
if(showAxes){ctx.strokeStyle=isDark()?'rgba(255,215,0,0.6)':'rgba(200,150,0,0.6)';ctx.lineWidth=2;
ctx.beginPath();ctx.moveTo(0,cy);ctx.lineTo(c.width,cy);ctx.stroke();
ctx.beginPath();ctx.moveTo(cx,0);ctx.lineTo(cx,c.height);ctx.stroke();
ctx.fillStyle=isDark()?'#ffd700':'#cc8800';ctx.font='bold 12px Segoe UI';
ctx.fillText('Re',c.width-25,cy-8);ctx.fillText('Im',cx+8,15);}
if(showNormC){ctx.strokeStyle='rgba(150,100,255,0.3)';ctx.lineWidth=1;
for(let n=1;n<=R*R;n++){const r=Math.sqrt(n);if(r<=R){ctx.beginPath();ctx.arc(cx,cy,r*sc,0,2*Math.PI);ctx.stroke();}}}
ctx.strokeStyle=bordC();ctx.lineWidth=2;ctx.beginPath();ctx.arc(cx,cy,R*sc,0,2*Math.PI);ctx.stroke();
if(showConj){ctx.strokeStyle='rgba(0,217,255,0.15)';ctx.lineWidth=1;
for(const p of gausP){if(p.b>0){ctx.beginPath();ctx.moveTo(cx+p.a*sc,cy-p.b*sc);ctx.lineTo(cx+p.a*sc,cy+p.b*sc);ctx.stroke();}}}
if(showAssoc){ctx.strokeStyle='rgba(255,136,0,0.2)';ctx.lineWidth=1;
for(const p of gausP){if(p.a>0&&p.b>=0){const pts=[[p.a,p.b],[-p.a,p.b],[-p.a,-p.b],[p.a,-p.b],[p.b,p.a],[-p.b,p.a],[-p.b,-p.a],[p.b,-p.a]];
ctx.beginPath();pts.forEach((q,i)=>{if(i===0)ctx.moveTo(cx+q[0]*sc,cy-q[1]*sc);else ctx.lineTo(cx+q[0]*sc,cy-q[1]*sc);});ctx.closePath();ctx.stroke();}}}
for(const p of gausP){
let clr;
if(col==='gcd')clr=p.isPrim?'#ffd700':'#555';
else if(col==='gprime')clr=p.isGP?'#00ff88':p.isPrim?'#ffd700':'#444';
else if(col==='norm')clr=`hsl(${(p.n2/R/R*300)%360},80%,60%)`;
else if(col==='arg')clr=`hsl(${((p.arg+Math.PI)/(2*Math.PI)*360)},85%,55%)`;
else if(col==='quadrant'){const qc=['#FF6B6B','#4ECDC4','#FFE66D','#95E1D3'];clr=qc[p.quad];}
else if(col==='parity')clr=(p.a+p.b)%2===0?'#00d9ff':'#ff6496';
else if(col==='sum2sq')clr=p.n2>0?'#00ff88':'#666';
else clr=p.isPrim?'#00d9ff':'#64c8ff';
if(showUnits&&p.isUnit){ctx.strokeStyle='#ff006e';ctx.lineWidth=3;ctx.beginPath();ctx.arc(cx+p.a*sc,cy-p.b*sc,ptSz+4,0,2*Math.PI);ctx.stroke();}
ctx.fillStyle=clr;ctx.beginPath();ctx.arc(cx+p.a*sc,cy-p.b*sc,p.isGP?ptSz+1:ptSz,0,2*Math.PI);ctx.fill();}
if(lbl!=='none'){ctx.font='9px Segoe UI';ctx.textAlign='center';ctx.fillStyle=isDark()?'rgba(255,255,255,0.8)':'rgba(0,0,0,0.8)';
for(const p of gausP){let t='';
if(lbl==='val')t=p.b>=0?`${p.a}+${p.b}i`:`${p.a}${p.b}i`;
else if(lbl==='norm')t=p.n2;
else if(lbl==='arg')t=Math.round(p.arg*180/Math.PI)+'°';
else if(lbl==='rad'){const piF=p.arg/Math.PI;t=Math.abs(piF)<0.01?'0':Math.abs(piF-1)<0.01?'π':Math.abs(piF+1)<0.01?'-π':fmt(piF)+'π';}
else if(lbl==='coords')t=`(${p.a},${p.b})`;
else if(lbl==='gcd')t=p.g;
else if(lbl==='coprime')t=p.isPrim?'OK':'X';
else if(lbl==='gprime')t=p.isGP?'*':'·';
else if(lbl==='polar'){const r=Math.sqrt(p.n2);t=`${fmt(r)}∠${Math.round(p.arg*180/Math.PI)}°`;}
ctx.fillText(t,cx+p.a*sc,cy-p.b*sc-ptSz-3);}}
const z2=zeta(2),baselRatio=tot>0?(prim/tot)/(1/z2):0;
const norms=Object.entries(nc).sort((a,b)=>+a[0]-+b[0]).slice(0,25);
const uniqueNorms=Object.keys(nc).length;
const sum2sqCount=Object.keys(nc).filter(n=>+n>0).length;
legend('algaus1','ℤ[i] Theory',[['1/ζ(2) Pred',fmt(tot/z2),'#9664ff'],['Coprime 6/π²',fmt(100/z2)+'%','#ff8c00']]);
legend('algaus2','Norm Analysis',[['Unique |z|²',uniqueNorms,'#9664ff'],['Max Norm²',gausP.reduce((m,p)=>Math.max(m,p.n2),0),'#ff8c00']]);
Plotly.newPlot('pgaus',[{x:norms.map(x=>+x[0]),y:norms.map(x=>x[1]),type:'bar',marker:{color:norms.map((_,i)=>`hsl(${i*12},70%,55%)`)}}],{...plo(),xaxis:{title:'|z|² (Norm²)'},yaxis:{title:'Count'}});
document.getElementById('stgaus').innerHTML='';
document.getElementById('gausLiveStats').innerHTML=`
<div style="display:grid;grid-template-columns:repeat(3,1fr);gap:8px;margin-bottom:12px">
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center"><div style="font-size:1.4rem;font-weight:bold;color:#00d9ff">${tot}</div><div style="font-size:.7rem;color:var(--txt2)">TOTAL</div></div>
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center"><div style="font-size:1.4rem;font-weight:bold;color:#ffd700">${prim}</div><div style="font-size:.7rem;color:var(--txt2)">PRIMITIVE</div></div>
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center"><div style="font-size:1.4rem;font-weight:bold;color:#00ff88">${gprimeC}</div><div style="font-size:.7rem;color:var(--txt2)">GAUSS PRIMES</div></div>
</div>
<div style="margin-bottom:10px;padding-bottom:8px;border-bottom:1px solid var(--bord)">
<strong style="color:var(--acc)">Configuration</strong>
<div style="display:grid;grid-template-columns:1fr 1fr;gap:3px;margin-top:5px;font-size:.8rem">
<span>Radius:</span><span style="color:var(--txt)">${R}</span>
<span>Zoom:</span><span style="color:var(--txt)">${zm}x</span>
<span>Color:</span><span style="color:var(--txt)">${col}</span>
<span>Filter:</span><span style="color:var(--txt)">${filt}</span>
</div>
</div>
<div style="margin-bottom:10px;padding-bottom:8px;border-bottom:1px solid var(--bord)">
<strong style="color:var(--acc)">Coprime Density (ℤ[i] Lattice)</strong>
<div style="display:grid;grid-template-columns:1fr 1fr;gap:3px;margin-top:5px;font-size:.8rem">
<span>Prim Density:</span><span style="color:#ffd700;font-weight:bold">${fmt(100*prim/tot)}%</span>
<span>Theory 1/ζ(2):</span><span style="color:#9664ff">${fmt(100/z2)}%</span>
<span>Ratio:</span><span style="color:${baselRatio>.95&&baselRatio<1.05?'#00ff88':'#ff8c00'}">${fmt(baselRatio*100)}%</span>
</div>
</div>
<div style="margin-bottom:10px;padding-bottom:8px;border-bottom:1px solid var(--bord)">
<strong style="color:var(--acc)">Quadrant Distribution</strong>
<div style="display:grid;grid-template-columns:1fr 1fr;gap:3px;margin-top:5px;font-size:.8rem">
<span style="color:#FF6B6B">Q1 (a≥0,b≥0):</span><span>${quadC[0]}</span>
<span style="color:#4ECDC4">Q2 (a<0,b≥0):</span><span>${quadC[1]}</span>
<span style="color:#FFE66D">Q3 (a<0,b<0):</span><span>${quadC[2]}</span>
<span style="color:#95E1D3">Q4 (a≥0,b<0):</span><span>${quadC[3]}</span>
</div>
</div>
<div style="margin-bottom:10px;padding-bottom:8px;border-bottom:1px solid var(--bord)">
<strong style="color:var(--acc)">Norm Statistics</strong>
<div style="display:grid;grid-template-columns:1fr 1fr;gap:3px;margin-top:5px;font-size:.8rem">
<span>Unique Norms:</span><span style="color:#9664ff">${uniqueNorms}</span>
<span>Max |z|²:</span><span>${gausP.reduce((m,p)=>Math.max(m,p.n2),0)}</span>
<span>Sum-2-Sq Norms:</span><span style="color:#00ff88">${sum2sqCount}</span>
</div>
</div>
<div>
<strong style="color:var(--acc)">Gaussian Prime Facts</strong>
<div style="margin-top:5px;font-size:.75rem;line-height:1.5;color:var(--txt2)">
• p≡1(mod 4): splits as π·π̄<br>
• p≡3(mod 4): stays prime in ℤ[i]<br>
• 2 = -i(1+i)² (ramifies)<br>
• Units: {1, -1, i, -i}
</div>
</div>`;
c.onclick=e=>{const rect=c.getBoundingClientRect(),mx=(e.clientX-rect.left)*(c.width/rect.width),my=(e.clientY-rect.top)*(c.height/rect.height);
for(const p of gausP){const px=cx+p.a*sc,py=cy-p.b*sc;
if(Math.hypot(mx-px,my-py)<12){
const assoc=`±${Math.abs(p.a)}±${Math.abs(p.b)}i, ±${Math.abs(p.b)}±${Math.abs(p.a)}i`;
modal('Gaussian Integer Analysis',[
['Value',p.b>=0?`${p.a} + ${p.b}i`:`${p.a} - ${Math.abs(p.b)}i`],
['Norm |z|',fmt(Math.sqrt(p.n2))],
['Norm² |z|²',p.n2],
['Argument θ',fmt(p.arg*180/Math.PI)+'°'],
['GCD(Re,Im)',p.g],
['Primitive',p.isPrim?'Yes':'No'],
['Gaussian Prime',p.isGP?'Yes':'No'],
['Unit',p.isUnit?'Yes':'No'],
['Quadrant','Q'+(p.quad+1)],
['Associates',assoc]
]);break;}}};}
function expGaus(){const c=document.getElementById('cgaus');c.toBlob(b=>{const a=document.createElement('a');a.href=URL.createObjectURL(b);a.download='gaussian.png';a.click();});}
function csvGaus(){let s='Re,Im,Norm2,GCD,Primitive,GaussianPrime,Argument,Quadrant,Unit\n';for(const p of gausP)s+=`${p.a},${p.b},${p.n2},${p.g},${p.isPrim},${p.isGP},${p.arg},${p.quad},${p.isUnit}\n`;dl(s,'gaussian.csv');}

function runCirc(){runCircNew();}

function runCircNew(){
const maxR=+document.getElementById('circVizRv')?.value||+document.getElementById('circVizR').value;
const step=+document.getElementById('circStep').value;
const showBounds=document.getElementById('circBounds').checked;
const primOnly=document.getElementById('circPrim').checked;

const rs=[],cs=[],ps=[],ths=[],es=[],sqrtEs=[],normEs=[];
D.circ=[];

for(let r=step;r<=maxR;r+=step){
let cnt=0,prim=0;
const m=Math.ceil(r)+1;
for(let x=-m;x<=m;x++)for(let y=-m;y<=m;y++)if(x*x+y*y<=r*r){cnt++;if(gcdM(x,y)===1)prim++;}
const th=Math.PI*r*r,err=cnt-th;
rs.push(r);cs.push(cnt);ps.push(prim);ths.push(th);es.push(err);
sqrtEs.push(r>0?err/Math.sqrt(r):0);
normEs.push(r>0?Math.abs(err)/Math.pow(r,0.5):0);
D.circ.push({r,cnt,prim,th,err,sqrtR:err/Math.sqrt(r),normR:Math.abs(err)/Math.pow(r,0.5),relE:th>0?Math.abs(err)/th*100:0});}

// Statistics
const maxErr=Math.max(...es);
const minErr=Math.min(...es);
const avgErr=es.reduce((a,b)=>a+b,0)/es.length;
const maxNorm=Math.max(...normEs);

// Chart 1: Count vs Theory
Plotly.newPlot('pc1',[
{x:rs,y:ths,name:'πR²',mode:'lines',line:{color:'#ff8c00',width:3}},
{x:rs,y:cs,name:'N(R)',mode:'markers',marker:{color:'#00d9ff',size:5}},
{x:rs,y:ps,name:'Primitive',mode:'markers',marker:{color:'#ffd700',size:4,symbol:'diamond'}}
],{...plo(),xaxis:{title:'Radius R'},yaxis:{title:'Count'}});
legend('alc1','Lattice Count',[['N(max)',cs[cs.length-1],'#00d9ff'],['πR²',fmt(ths[ths.length-1]),'#ff8c00']]);

// Chart 2: Error r(R)
const traces2=[{x:rs,y:es,name:'r(R)=N(R)-πR²',mode:'lines+markers',line:{color:'#ff006e',width:2},marker:{size:3}}];
if(showBounds){
traces2.push({x:rs,y:rs.map(r=>2*Math.sqrt(r)),name:'O(√R)',mode:'lines',line:{color:'#666',dash:'dot'}});
traces2.push({x:rs,y:rs.map(r=>-2*Math.sqrt(r)),name:'-O(√R)',mode:'lines',line:{color:'#666',dash:'dot'}});}
Plotly.newPlot('pc2',traces2,{...plo(),xaxis:{title:'R'},yaxis:{title:'r(R) = N(R) - πR²'}});
legend('alc2','Error r(R)',[['Max',fmt(maxErr),'#ff006e'],['Min',fmt(minErr),'#00ff88']]);

// Chart 3: Normalized error
Plotly.newPlot('pc3',[
{x:rs,y:sqrtEs,name:'r(R)/√R',mode:'lines+markers',line:{color:'#9664ff',width:2},marker:{size:3}},
{x:rs,y:rs.map(()=>0),mode:'lines',line:{color:'#666',dash:'dash'}}
],{...plo(),xaxis:{title:'R'},yaxis:{title:'r(R)/√R'}});
legend('alc3','Normalized',[['Max |r|/√R',fmt(maxNorm),'#9664ff']]);

// Chart 4: Absolute error magnitude
Plotly.newPlot('pcircAbs',[{x:rs,y:es.map(Math.abs),mode:'lines+markers',line:{color:'#00ff88',width:2}}],{...plo(),xaxis:{title:'R'},yaxis:{title:'|r(R)|'}});

// Chart 5: Running average
const runAvg=sqrtEs.map((e,i)=>sqrtEs.slice(0,i+1).reduce((a,b)=>a+b,0)/(i+1));
Plotly.newPlot('pcircAvg',[{x:rs,y:runAvg,mode:'lines',line:{color:'#ffd700',width:2}}],{...plo(),xaxis:{title:'R'},yaxis:{title:'Running Avg r(R)/√R'}});

// Live stats
document.getElementById('circLiveStats').innerHTML=`
<div style="background:linear-gradient(135deg,rgba(0,217,255,.15),rgba(255,215,0,.1));padding:10px;border-radius:8px;margin-bottom:12px;border:1px solid var(--acc)">
<div style="font-size:.7rem;color:var(--txt2);margin-bottom:4px">TAB: Circle Problem | FIELD: ℤ² Disc | TYPE: Gauss Lattice Counting</div>
<div style="display:grid;grid-template-columns:repeat(3,1fr);gap:6px;font-size:.75rem">
<span>Max R: <strong style="color:#00d9ff">${maxR}</strong></span>
<span>Step: <strong style="color:#ffd700">${step}</strong></span>
<span>Points: <strong style="color:#00ff88">${D.circ.length}</strong></span>
</div>
</div>
<div style="display:grid;grid-template-columns:repeat(3,1fr);gap:8px;margin-bottom:12px">
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center"><div style="font-size:1.4rem;font-weight:bold;color:#00d9ff">${maxR}</div><div style="font-size:.7rem;color:var(--txt2)">MAX R</div></div>
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center"><div style="font-size:1.4rem;font-weight:bold;color:#ffd700">${cs[cs.length-1]}</div><div style="font-size:.7rem;color:var(--txt2)">N(R) ACTUAL</div></div>
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center"><div style="font-size:1.4rem;font-weight:bold;color:#00ff88">${fmt(ths[ths.length-1])}</div><div style="font-size:.7rem;color:var(--txt2)">πR² PREDICTED</div></div>
</div>
<div style="display:grid;grid-template-columns:repeat(3,1fr);gap:8px;margin-bottom:12px">
<div style="background:var(--bg1);padding:8px;border-radius:6px;text-align:center"><div style="font-size:1rem;font-weight:bold;color:#9664ff">${ps[ps.length-1]}</div><div style="font-size:.6rem;color:var(--txt2)">PRIMITIVE</div></div>
<div style="background:var(--bg1);padding:8px;border-radius:6px;text-align:center"><div style="font-size:1rem;font-weight:bold;color:#ff8c00">${fmt(es[es.length-1])}</div><div style="font-size:.6rem;color:var(--txt2)">ERROR r(R)</div></div>
<div style="background:var(--bg1);padding:8px;border-radius:6px;text-align:center"><div style="font-size:1rem;font-weight:bold;color:${Math.abs(es[es.length-1]/Math.sqrt(maxR))<2?'#00ff88':'#ff6496'}">${fmt(es[es.length-1]/Math.sqrt(maxR))}</div><div style="font-size:.6rem;color:var(--txt2)">r(R)/√R</div></div>
</div>
<div style="margin-bottom:10px;padding-bottom:8px;border-bottom:1px solid var(--bord)">
<strong style="color:var(--acc)">Error Statistics</strong>
<div style="display:grid;grid-template-columns:1fr 1fr;gap:3px;margin-top:5px;font-size:.8rem">
<span>Max r(R):</span><span style="color:#ff006e">${fmt(maxErr)}</span>
<span>Min r(R):</span><span style="color:#00ff88">${fmt(minErr)}</span>
<span>Avg r(R):</span><span style="color:#00d9ff">${fmt(avgErr)}</span>
<span>Max |r|/√R:</span><span style="color:#9664ff">${fmt(maxNorm)}</span>
</div>
</div>
<div style="margin-bottom:10px;padding-bottom:8px;border-bottom:1px solid var(--bord)">
<strong style="color:var(--acc)">Final Values (R=${maxR})</strong>
<div style="display:grid;grid-template-columns:1fr 1fr;gap:3px;margin-top:5px;font-size:.8rem">
<span>N(R):</span><span style="color:#00d9ff">${cs[cs.length-1]}</span>
<span>πR²:</span><span style="color:#ff8c00">${fmt(ths[ths.length-1])}</span>
<span>r(R):</span><span style="color:${es[es.length-1]>=0?'#00ff88':'#ff006e'}">${fmt(es[es.length-1])}</span>
<span>Primitive:</span><span style="color:#ffd700">${ps[ps.length-1]}</span>
</div>
</div>
<div>
<strong style="color:var(--acc)">Gauss Circle Bounds</strong>
<div style="margin-top:5px;font-size:.75rem;line-height:1.5;color:var(--txt2)">
• Trivial: |r(R)| = O(R)<br>
• Best known: |r(R)| = O(R^0.6298...)<br>
• Conjectured: |r(R)| = O(R^(1/2+ε))<br>
• Ω-result: r(R) = Ω(R^0.5 (log R)^0.25)
</div>
</div>`;

// Table
document.getElementById('tcircT').innerHTML='<tr><th>R</th><th>N(R)</th><th>πR²</th><th>r(R)</th><th>r(R)/√R</th><th>|r(R)|/R^0.5</th></tr>'+
D.circ.map(d=>`<tr onclick="modal('R=${d.r}',[['N(R)',${d.cnt}],['πR²',${fmt(d.th)}],['r(R)',${fmt(d.err)}],['Primitive',${d.prim}],['r(R)/√R',${fmt(d.sqrtR)}]])" style="cursor:pointer"><td>${fmt(d.r)}</td><td>${d.cnt}</td><td>${fmt(d.th)}</td><td>${fmt(d.err)}</td><td>${fmt(d.sqrtR)}</td><td>${fmt(d.normR)}</td></tr>`).join('');}

function drawCircleViz(){
const R=+document.getElementById('circVizRv')?.value||+document.getElementById('circVizR').value;
const colorMode=document.getElementById('circColor')?.value||'prim';
const primOnly=document.getElementById('circPrim')?.checked;
const c=document.getElementById('ccirc'),ctx=c.getContext('2d');
ctx.fillStyle=canvBg();ctx.fillRect(0,0,c.width,c.height);
const cx=c.width/2,cy=c.height/2,scale=Math.min(cx,cy-30)/(R+1);

// Grid
ctx.strokeStyle=gridC();ctx.lineWidth=0.5;
for(let i=-R;i<=R;i++){
  ctx.beginPath();ctx.moveTo(cx+i*scale,cy-R*scale);ctx.lineTo(cx+i*scale,cy+R*scale);ctx.stroke();
  ctx.beginPath();ctx.moveTo(cx-R*scale,cy+i*scale);ctx.lineTo(cx+R*scale,cy+i*scale);ctx.stroke();
}

// Circle
ctx.strokeStyle='#ff8c00';ctx.lineWidth=2;ctx.beginPath();ctx.arc(cx,cy,R*scale,0,2*Math.PI);ctx.stroke();

// Color legend helper
const getColor = (x, y, r, isPrim) => {
  if(colorMode === 'prim') return isPrim ? '#ffd700' : '#00d9ff';
  if(colorMode === 'r') {
    const t = r / R;
    return `hsl(${240 - t * 240}, 100%, 50%)`;
  }
  if(colorMode === 'm') {
    const m = x*x + y*y;
    const t = m / (R*R);
    return `hsl(${t * 300}, 100%, 50%)`;
  }
  if(colorMode === 'rm') {
    const m = x*x + y*y;
    const ratio = m > 0 ? r / Math.sqrt(m) : 1;
    return `hsl(${ratio * 120}, 100%, 50%)`;
  }
  if(colorMode === 'angle') {
    const angle = Math.atan2(y, x);
    const t = (angle + Math.PI) / (2 * Math.PI);
    return `hsl(${t * 360}, 100%, 50%)`;
  }
  if(colorMode === 'quad') {
    if(x >= 0 && y >= 0) return '#00d9ff';
    if(x < 0 && y >= 0) return '#00ff88';
    if(x < 0 && y < 0) return '#ffd700';
    return '#ff6496';
  }
  return '#00d9ff';
};

// Points
let cnt=0,prim=0;
const m=Math.ceil(R);
for(let x=-m;x<=m;x++){
  for(let y=-m;y<=m;y++){
    const r2=x*x+y*y;
    if(r2<=R*R){
      const r=Math.sqrt(r2);
      const isPrim=gcdM(x,y)===1;
      cnt++;
      if(isPrim)prim++;
      if(primOnly && !isPrim) continue;
      ctx.fillStyle=getColor(x,y,r,isPrim);
      ctx.beginPath();ctx.arc(cx+x*scale,cy-y*scale,3,0,2*Math.PI);ctx.fill();
    }
  }
}

// Title
ctx.fillStyle=isDark()?'#00d9ff':'#0066cc';ctx.font='bold 14px Segoe UI';ctx.textAlign='center';
ctx.fillText(`Gauss Circle: R=${R}, N(R)=${cnt}, πR²=${fmt(Math.PI*R*R)}, r(R)=${fmt(cnt-Math.PI*R*R)}`,cx,25);

// Color legend
const colorLabels = {
  prim: 'Gold=Primitive, Cyan=Composite',
  r: 'Blue→Red by distance r',
  m: 'Violet→Yellow by m=x²+y²',
  rm: 'By r/√m ratio',
  angle: 'By angle θ (rainbow)',
  quad: 'By quadrant (4 colors)'
};
ctx.fillStyle=isDark()?'#aaa':'#666';ctx.font='12px Segoe UI';
ctx.fillText(`Coloring: ${colorLabels[colorMode]} | Primitive: ${prim} (${fmt(100*prim/cnt)}%)`,cx,c.height-10);
}

function csvCirc(){let s='R,Count,Primitive,Theory,Error,SqrtR,NormR,RelError\n';for(const d of D.circ)s+=`${d.r},${d.cnt},${d.prim},${d.th},${d.err},${d.sqrtR},${d.normR},${d.relE}\n`;dl(s,'circle.csv');}

// Euler product approximation
function eulerProduct(s,maxP){let prod=1;for(let p=2;p<=maxP;p++){let isPrime=true;for(let i=2;i*i<=p;i++)if(p%i===0){isPrime=false;break;}if(isPrime)prod*=1/(1-Math.pow(p,-s));}return prod;}

// Monte Carlo sampling for high dimensions
function monteCarloDensity(k,R,samples){let inside=0,coprime=0;
for(let s=0;s<samples;s++){
const coords=[];for(let i=0;i<k;i++)coords.push(Math.floor(Math.random()*(2*R+1))-R);
const r2=coords.reduce((a,x)=>a+x*x,0);
if(r2<=R*R){inside++;if(gcdM(...coords)===1)coprime++;}}
return{tot:inside,prim:coprime,emp:inside>0?coprime/inside:0};}

function runDensNew(){
if(!document.getElementById("pDens")) return;

const R=+document.getElementById('densR').value;
const maxK=+document.getElementById('densMaxK').value;
const mode=document.getElementById('densMode').value;
const samples=+document.getElementById('densSample').value;
const ks=[],ths=[],emps=[],zetaVals=[],eulerVals=[];
D.dens=[];

for(let k=2;k<=maxK;k++){
let tot=0,prim=0,emp=0;
const z=zeta(k),th=1/z;

if(mode==='theory'){
emp=th;tot=0;prim=0;
}else if(mode==='sample'||k>4){
const mc=monteCarloDensity(k,R,samples);
tot=mc.tot;prim=mc.prim;emp=mc.emp;
}else{
// Exact computation for k<=4
const m=Math.ceil(R);
if(k===2){for(let x=-m;x<=m;x++)for(let y=-m;y<=m;y++)if(x*x+y*y<=R*R){tot++;if(gcdM(x,y)===1)prim++;}}
else if(k===3){for(let x=-m;x<=m;x++)for(let y=-m;y<=m;y++)for(let z=-m;z<=m;z++)if(x*x+y*y+z*z<=R*R){tot++;if(gcdM(x,y,z)===1)prim++;}}
else if(k===4){const sm=Math.min(6,m);for(let a=-sm;a<=sm;a++)for(let b=-sm;b<=sm;b++)for(let c=-sm;c<=sm;c++)for(let d=-sm;d<=sm;d++)if(a*a+b*b+c*c+d*d<=R*R){tot++;if(gcdM(a,b,c,d)===1)prim++;}}
emp=tot>0?prim/tot:th;}

const euler=eulerProduct(k,100);
ks.push(k);ths.push(th);emps.push(emp);zetaVals.push(z);eulerVals.push(euler);
D.dens.push({k,z,th,emp,tot,prim,err:Math.abs(emp-th),relE:th>0?Math.abs(emp-th)/th*100:0,euler});}

// Chart 1: Density convergence
Plotly.newPlot('pdens1',[
{x:ks,y:ths,name:'Theory 1/ζ(k)',mode:'lines+markers',line:{color:'#ff8c00',width:3},marker:{size:8}},
{x:ks,y:emps,name:'Empirical',mode:'markers',marker:{color:'#00d9ff',size:10,symbol:'diamond'}},
{x:ks,y:ks.map(()=>1),name:'Limit (1)',mode:'lines',line:{color:'#666',dash:'dash',width:1}}
],{...plo(),xaxis:{title:'Dimension k'},yaxis:{title:'P(coprime)',range:[0.5,1.05]}});
legend('aldens1','Density Analysis',[['1/ζ(2)',ths[0],'#ff8c00'],['1/ζ('+maxK+')',ths[ths.length-1],'#00d9ff']]);

// Chart 2: Zeta convergence to 1
Plotly.newPlot('pdensZeta',[
{x:ks,y:zetaVals,name:'ζ(k)',mode:'lines+markers',line:{color:'#9664ff',width:2},marker:{size:6}},
{x:ks,y:ks.map(()=>1),name:'Limit',mode:'lines',line:{color:'#666',dash:'dash'}}
],{...plo(),xaxis:{title:'Dimension k'},yaxis:{title:'ζ(k)',range:[0.95,Math.max(...zetaVals)+0.1]}});

// Chart 3: Error bars
Plotly.newPlot('pdens2',[{x:ks,y:D.dens.map(d=>d.relE),type:'bar',marker:{color:D.dens.map(d=>d.relE<1?'#00ff88':d.relE<5?'#ffd700':'#ff6496')}}],{...plo(),xaxis:{title:'Dimension k'},yaxis:{title:'Relative Error %'}});
legend('aldens2','Error Analysis',[['Max Error',fmt(Math.max(...D.dens.map(d=>d.relE)))+'%','#ff6496'],['Min Error',fmt(Math.min(...D.dens.map(d=>d.relE)))+'%','#00ff88']]);

// Chart 4: Euler product verification
Plotly.newPlot('pdensEuler',[
{x:ks,y:zetaVals,name:'ζ(k) (Series)',mode:'lines+markers',line:{color:'#ff8c00',width:2}},
{x:ks,y:eulerVals,name:'Euler Product (p≤100)',mode:'markers',marker:{color:'#00ff88',size:8,symbol:'cross'}}
],{...plo(),xaxis:{title:'Dimension k'},yaxis:{title:'Value'}});

// Chart 5: Convergence rate
const convRate=ks.map((k,i)=>i>0?Math.abs(ths[i]-1)/Math.abs(ths[i-1]-1):1);
Plotly.newPlot('pdensConv',[{x:ks.slice(1),y:convRate.slice(1),type:'scatter',mode:'lines+markers',line:{color:'#00d9ff',width:2},marker:{size:6}}],{...plo(),xaxis:{title:'Dimension k'},yaxis:{title:'|1/ζ(k)-1|/|1/ζ(k-1)-1|'}});

// Live stats
const avgErr=D.dens.reduce((a,d)=>a+d.relE,0)/D.dens.length;
const totalPts=D.dens.reduce((a,d)=>a+d.tot,0);
const totalPrim=D.dens.reduce((a,d)=>a+d.prim,0);
document.getElementById('densLiveStats').innerHTML=`
<div style="display:grid;grid-template-columns:repeat(3,1fr);gap:8px;margin-bottom:12px">
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center"><div style="font-size:1.4rem;font-weight:bold;color:#00d9ff">${maxK-1}</div><div style="font-size:.7rem;color:var(--txt2)">DIMENSIONS</div></div>
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center"><div style="font-size:1.4rem;font-weight:bold;color:#ffd700">${totalPts.toLocaleString()}</div><div style="font-size:.7rem;color:var(--txt2)">TOTAL SAMPLES</div></div>
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center"><div style="font-size:1.4rem;font-weight:bold;color:#00ff88">${totalPrim.toLocaleString()}</div><div style="font-size:.7rem;color:var(--txt2)">COPRIME</div></div>
</div>
<div style="margin-bottom:10px;padding-bottom:8px;border-bottom:1px solid var(--bord)">
<strong style="color:var(--acc)">Configuration</strong>
<div style="display:grid;grid-template-columns:1fr 1fr;gap:3px;margin-top:5px;font-size:.8rem">
<span>Radius R:</span><span style="color:var(--txt)">${R}</span>
<span>Max Dimension:</span><span style="color:var(--txt)">${maxK}</span>
<span>Mode:</span><span style="color:var(--txt)">${mode}</span>
<span>Monte Carlo:</span><span style="color:var(--txt)">${samples.toLocaleString()}</span>
</div>
</div>
<div style="margin-bottom:10px;padding-bottom:8px;border-bottom:1px solid var(--bord)">
<strong style="color:var(--acc)">Error Summary</strong>
<div style="display:grid;grid-template-columns:1fr 1fr;gap:3px;margin-top:5px;font-size:.8rem">
<span>Avg Error:</span><span style="color:${avgErr<2?'#00ff88':'#ff8c00'}">${fmt(avgErr)}%</span>
<span>Max Error:</span><span style="color:#ff6496">${fmt(Math.max(...D.dens.map(d=>d.relE)))}%</span>
<span>Min Error:</span><span style="color:#00ff88">${fmt(Math.min(...D.dens.map(d=>d.relE)))}%</span>
<span>Best k:</span><span style="color:#ffd700">k=${D.dens.reduce((a,d)=>d.relE<a.relE?d:a).k}</span>
</div>
</div>
<div style="margin-bottom:10px;padding-bottom:8px;border-bottom:1px solid var(--bord)">
<strong style="color:var(--acc)">Key Zeta Values</strong>
<div style="display:grid;grid-template-columns:1fr 1fr;gap:3px;margin-top:5px;font-size:.8rem">
<span>ζ(2) = π²/6:</span><span style="color:#9664ff">${fmt(zeta(2))}</span>
<span>ζ(3) (Apéry):</span><span style="color:#ff8c00">${fmt(zeta(3))}</span>
<span>ζ(4) = π⁴/90:</span><span style="color:#00d9ff">${fmt(zeta(4))}</span>
<span>ζ(${maxK}):</span><span style="color:#00ff88">${fmt(zeta(maxK))}</span>
</div>
</div>
<div>
<strong style="color:var(--acc)">Observations</strong>
<div style="margin-top:5px;font-size:.75rem;line-height:1.5;color:var(--txt2)">
• As k↑, ζ(k)→1 exponentially fast<br>
• P(coprime in k-dim) = 1/ζ(k) → 1<br>
• Higher dimensions ≈ almost always coprime<br>
• Euler product: ζ(s) = Π(1-p⁻ˢ)⁻¹
</div>
</div>
${singularSeriesHTML(R, 2, 'Modular Sieve (R as M)')}`;

// Table
document.getElementById('tdensT').innerHTML='<tr><th>k</th><th>ζ(k)</th><th>1/ζ(k)</th><th>Empirical</th><th>Total</th><th>Primitive</th><th>Abs Err</th><th>Rel Err %</th></tr>'+
D.dens.map(d=>`<tr onclick="modal('Dimension ${d.k} Analysis',[['ζ(${d.k})',${d.z}],['1/ζ(${d.k})',${d.th}],['Empirical',${d.emp}],['Total Points',${d.tot}],['Primitive',${d.prim}],['Euler Product',${d.euler}],['Abs Error',${d.err}],['Rel Error %',${d.relE}]])" style="cursor:pointer;color:${d.relE<1?'#00ff88':d.relE<5?'inherit':'#ff6496'}"><td>${d.k}</td><td>${fmt(d.z)}</td><td>${fmt(d.th)}</td><td>${fmt(d.emp)}</td><td>${d.tot}</td><td>${d.prim}</td><td>${fmt(d.err)}</td><td>${fmt(d.relE)}</td></tr>`).join('');}

function runConvergence(){
const Rs=[5,8,10,12,15,20];
const conv2d=[],conv3d=[];
for(const R of Rs){
let tot2=0,prim2=0,tot3=0,prim3=0;
const m=Math.ceil(R);
for(let x=-m;x<=m;x++)for(let y=-m;y<=m;y++)if(x*x+y*y<=R*R){tot2++;if(gcdM(x,y)===1)prim2++;}
for(let x=-m;x<=m;x++)for(let y=-m;y<=m;y++)for(let z=-m;z<=m;z++)if(x*x+y*y+z*z<=R*R){tot3++;if(gcdM(x,y,z)===1)prim3++;}
conv2d.push({R,emp:prim2/tot2,th:1/zeta(2),err:Math.abs(prim2/tot2-1/zeta(2))});
conv3d.push({R,emp:prim3/tot3,th:1/zeta(3),err:Math.abs(prim3/tot3-1/zeta(3))});}
Plotly.newPlot('pdensConv',[
{x:Rs,y:conv2d.map(c=>c.err),name:'2D Error',mode:'lines+markers',line:{color:'#00d9ff',width:2}},
{x:Rs,y:conv3d.map(c=>c.err),name:'3D Error',mode:'lines+markers',line:{color:'#ff8c00',width:2}}
],{...plo(),xaxis:{title:'Radius R'},yaxis:{title:'|Empirical - Theory|',type:'log'}});}

function runDens(){runDensNew();}
function csvDens(){let s='k,Zeta,InvZeta,Empirical,Total,Primitive,AbsError,RelError,EulerProd\n';for(const d of D.dens)s+=`${d.k},${d.z},${d.th},${d.emp},${d.tot},${d.prim},${d.err},${d.relE},${d.euler}\n`;dl(s,'density.csv');}

async function screenshotPlotly(plotIds,legends,title,filename){
const scale=2,pad=30,gap=20;
const plots=plotIds.map(id=>document.getElementById(id)).filter(p=>p);
if(!plots.length)return alert('Run analysis first');
const imgs=await Promise.all(plots.map(p=>Plotly.toImage(p,{format:'png',width:p.offsetWidth,height:p.offsetHeight,scale:2})));
const loaded=await Promise.all(imgs.map(src=>new Promise(r=>{const i=new Image();i.onload=()=>r(i);i.src=src;})));
const legEls=legends.map(id=>document.getElementById(id)).filter(l=>l);
const legH=legEls.length?100:0;
const cols=Math.min(2,loaded.length),rows=Math.ceil(loaded.length/cols);
const pw=loaded[0].width/2,ph=loaded[0].height/2;
const out=document.createElement('canvas');
out.width=(pw*cols+gap*(cols-1)+pad*2)*scale;
out.height=(ph*rows+gap*(rows-1)+pad*2+40+legH)*scale;
const ctx=out.getContext('2d');ctx.scale(scale,scale);
ctx.fillStyle=canvBg();ctx.fillRect(0,0,out.width/scale,out.height/scale);
ctx.fillStyle=isDark()?'#00d9ff':'#0066cc';ctx.font='bold 18px Segoe UI';ctx.fillText(title,pad,pad+20);
loaded.forEach((img,i)=>{const col=i%cols,row=Math.floor(i/cols);ctx.drawImage(img,pad+col*(pw+gap),pad+40+row*(ph+gap),pw,ph);});
if(legEls.length){let ly=pad+40+rows*(ph+gap)+10;
ctx.fillStyle=isDark()?'#00d9ff':'#0066cc';ctx.font='bold 14px Segoe UI';ctx.fillText('Statistics',pad,ly);ly+=20;
ctx.font='12px Segoe UI';let lx=pad;
legEls.forEach(leg=>{leg.querySelectorAll('.li').forEach((li,j)=>{const l=li.querySelector('strong')?.textContent||'',v=li.querySelector('.v')?.textContent||'';
ctx.fillStyle=isDark()?'#b0b8d8':'#4a5568';ctx.fillText(l+': '+v,lx,ly);lx+=160;if(lx>out.width/scale-pad){lx=pad;ly+=18;}});});}
out.toBlob(b=>{const a=document.createElement('a');a.href=URL.createObjectURL(b);a.download=filename;a.click();},'image/png',1.0);}

async function screenshotErr(){
const dashData=extractDashboardData('errLiveStats');
const maxR=document.getElementById('errRv').value,shape=document.getElementById('errSh').value;
const plotIds=['pe1','pe2','pe3','pe4'];
const scale=2,pad=30,gap=10,dashH=350;
const plots=plotIds.map(id=>document.getElementById(id)).filter(p=>p&&p.offsetWidth);
if(!plots.length)return alert('Run analysis first');
const imgs=await Promise.all(plots.map(p=>Plotly.toImage(p,{format:'png',width:380,height:220,scale:2})));
const loaded=await Promise.all(imgs.map(src=>new Promise(r=>{const i=new Image();i.onload=()=>r(i);i.src=src;})));
const pw=190,ph=110;
const out=document.createElement('canvas');
out.width=(pw*2+gap+pad*2)*scale;out.height=(ph*2+gap+dashH+pad*4)*scale;
const ctx=out.getContext('2d');ctx.scale(scale,scale);
const isDk=isDark();
ctx.fillStyle=isDk?'#0d1321':'#ffffff';ctx.fillRect(0,0,out.width/scale,out.height/scale);
ctx.fillStyle=isDk?'#00d9ff':'#0066cc';ctx.font='bold 18px Segoe UI';ctx.textAlign='center';
ctx.fillText(`Error Analysis — R≤${maxR}, ${shape}`,out.width/scale/2,pad);
loaded.forEach((img,i)=>{const col=i%2,row=Math.floor(i/2);ctx.drawImage(img,pad+col*(pw+gap),pad+30+row*(ph+gap),pw,ph);});
const dashY=pad+30+2*(ph+gap)+10;
ctx.fillStyle=isDk?'#151b2d':'#f5f5f5';ctx.fillRect(pad,dashY,pw*2+gap,dashH-30);
ctx.textAlign='left';
renderDashboard(ctx,dashData,pad+10,dashY+10,pw*2+gap-20,isDk,dashH-50);
ctx.fillStyle=isDk?'#506080':'#888';ctx.font='10px Segoe UI';ctx.textAlign='center';
ctx.fillText('Möbius Shell Sieve — wessengetachew.github.io',out.width/scale/2,out.height/scale-10);
out.toBlob(b=>{const a=document.createElement('a');a.href=URL.createObjectURL(b);a.download='error_complete.png';a.click();},'image/png',1.0);}

async function screenshotSh(){
const dashData=extractDashboardData('shLiveStats');
const R=document.getElementById('rshv').value,maxK=document.getElementById('shKv').value;
const plotIds=['psh','pshCum'];
const scale=2,pad=30,gap=15,dashH=350;
const plots=plotIds.map(id=>document.getElementById(id)).filter(p=>p&&p.offsetWidth);
if(!plots.length)return alert('Run analysis first');
const imgs=await Promise.all(plots.map(p=>Plotly.toImage(p,{format:'png',width:400,height:250,scale:2})));
const loaded=await Promise.all(imgs.map(src=>new Promise(r=>{const i=new Image();i.onload=()=>r(i);i.src=src;})));
const pw=200,ph=125;
const out=document.createElement('canvas');
out.width=(pw*2+gap+pad*2)*scale;out.height=(ph+dashH+pad*4)*scale;
const ctx=out.getContext('2d');ctx.scale(scale,scale);
const isDk=isDark();
ctx.fillStyle=isDk?'#0d1321':'#ffffff';ctx.fillRect(0,0,out.width/scale,out.height/scale);
ctx.fillStyle=isDk?'#00d9ff':'#0066cc';ctx.font='bold 18px Segoe UI';ctx.textAlign='center';
ctx.fillText(`Möbius Shell Decomposition — R=${R}, k≤${maxK}`,out.width/scale/2,pad);
loaded.forEach((img,i)=>{ctx.drawImage(img,pad+i*(pw+gap),pad+30,pw,ph);});
const dashY=pad+30+ph+15;
ctx.fillStyle=isDk?'#151b2d':'#f5f5f5';ctx.fillRect(pad,dashY,pw*2+gap,dashH-30);
ctx.textAlign='left';
renderDashboard(ctx,dashData,pad+10,dashY+10,pw*2+gap-20,isDk,dashH-50);
ctx.fillStyle=isDk?'#506080':'#888';ctx.font='10px Segoe UI';ctx.textAlign='center';
ctx.fillText('Möbius Shell Sieve — wessengetachew.github.io',out.width/scale/2,out.height/scale-10);
out.toBlob(b=>{const a=document.createElement('a');a.href=URL.createObjectURL(b);a.download='shells_complete.png';a.click();},'image/png',1.0);}
async function screenshotGCD(){
const dashData=extractDashboardData('gcdLiveStats');
const R=document.getElementById('rgcdv').value,shape=document.getElementById('gcdShape').value;
const plotIds=['pgcd1','pgcd2'];
const scale=2,pad=30,gap=15,dashH=350;
const plots=plotIds.map(id=>document.getElementById(id)).filter(p=>p&&p.offsetWidth);
if(!plots.length)return alert('Run analysis first');
const imgs=await Promise.all(plots.map(p=>Plotly.toImage(p,{format:'png',width:400,height:250,scale:2})));
const loaded=await Promise.all(imgs.map(src=>new Promise(r=>{const i=new Image();i.onload=()=>r(i);i.src=src;})));
const pw=200,ph=125;
const out=document.createElement('canvas');
out.width=(pw*2+gap+pad*2)*scale;out.height=(ph+dashH+pad*4)*scale;
const ctx=out.getContext('2d');ctx.scale(scale,scale);
const isDk=isDark();
ctx.fillStyle=isDk?'#0d1321':'#ffffff';ctx.fillRect(0,0,out.width/scale,out.height/scale);
ctx.fillStyle=isDk?'#00d9ff':'#0066cc';ctx.font='bold 18px Segoe UI';ctx.textAlign='center';
ctx.fillText(`GCD Distribution Analysis — R=${R}, ${shape}`,out.width/scale/2,pad);
loaded.forEach((img,i)=>{ctx.drawImage(img,pad+i*(pw+gap),pad+30,pw,ph);});
const dashY=pad+30+ph+15;
ctx.fillStyle=isDk?'#151b2d':'#f5f5f5';ctx.fillRect(pad,dashY,pw*2+gap,dashH-30);
ctx.textAlign='left';
renderDashboard(ctx,dashData,pad+10,dashY+10,pw*2+gap-20,isDk,dashH-50);
ctx.fillStyle=isDk?'#506080':'#888';ctx.font='10px Segoe UI';ctx.textAlign='center';
ctx.fillText('Möbius Shell Sieve — wessengetachew.github.io',out.width/scale/2,out.height/scale-10);
out.toBlob(b=>{const a=document.createElement('a');a.href=URL.createObjectURL(b);a.download='gcd_complete.png';a.click();},'image/png',1.0);}

async function screenshotCirc(){
const dashData=extractDashboardData('circLiveStats');
const maxR=document.getElementById('circVizRv')?.value||document.getElementById('circVizR').value;
const plotIds=['pc1','pc2'];
const scale=2,pad=30,gap=15,dashH=350;
const plots=plotIds.map(id=>document.getElementById(id)).filter(p=>p&&p.offsetWidth);
if(!plots.length)return alert('Run analysis first');
const imgs=await Promise.all(plots.map(p=>Plotly.toImage(p,{format:'png',width:400,height:250,scale:2})));
const loaded=await Promise.all(imgs.map(src=>new Promise(r=>{const i=new Image();i.onload=()=>r(i);i.src=src;})));
const pw=200,ph=125;
const out=document.createElement('canvas');
out.width=(pw*2+gap+pad*2)*scale;out.height=(ph+dashH+pad*4)*scale;
const ctx=out.getContext('2d');ctx.scale(scale,scale);
const isDk=isDark();
ctx.fillStyle=isDk?'#0d1321':'#ffffff';ctx.fillRect(0,0,out.width/scale,out.height/scale);
ctx.fillStyle=isDk?'#00d9ff':'#0066cc';ctx.font='bold 18px Segoe UI';ctx.textAlign='center';
ctx.fillText(`Gauss Circle Problem — R≤${maxR}`,out.width/scale/2,pad);
loaded.forEach((img,i)=>{ctx.drawImage(img,pad+i*(pw+gap),pad+30,pw,ph);});
const dashY=pad+30+ph+15;
ctx.fillStyle=isDk?'#151b2d':'#f5f5f5';ctx.fillRect(pad,dashY,pw*2+gap,dashH-30);
ctx.textAlign='left';
renderDashboard(ctx,dashData,pad+10,dashY+10,pw*2+gap-20,isDk,dashH-50);
ctx.fillStyle=isDk?'#506080':'#888';ctx.font='10px Segoe UI';ctx.textAlign='center';
ctx.fillText('Möbius Shell Sieve — wessengetachew.github.io',out.width/scale/2,out.height/scale-10);
out.toBlob(b=>{const a=document.createElement('a');a.href=URL.createObjectURL(b);a.download='circle_complete.png';a.click();},'image/png',1.0);}
async function screenshotDens(){
const dashData=extractDashboardData('densLiveStats');
const R=document.getElementById('densR').value;
const maxK=document.getElementById('densMaxK').value;
const mode=document.getElementById('densMode').value;
const plotIds=['pdens1','pdensZeta','pdens2','pdensEuler'];
const scale=2,pad=30,gap=15;
const plots=plotIds.map(id=>document.getElementById(id)).filter(p=>p&&p.offsetWidth);
if(!plots.length)return alert('Run analysis first');
const imgs=await Promise.all(plots.map(p=>Plotly.toImage(p,{format:'png',width:400,height:250,scale:2})));
const loaded=await Promise.all(imgs.map(src=>new Promise(r=>{const i=new Image();i.onload=()=>r(i);i.src=src;})));
const pw=200,ph=125,dashH=300;
const out=document.createElement('canvas');
out.width=(pw*2+gap+pad*2)*scale;out.height=(ph*2+gap+dashH+pad*4+50)*scale;
const ctx=out.getContext('2d');ctx.scale(scale,scale);
const isDk=isDark();
ctx.fillStyle=isDk?'#0d1321':'#ffffff';ctx.fillRect(0,0,out.width/scale,out.height/scale);
ctx.fillStyle=isDk?'#00d9ff':'#0066cc';ctx.font='bold 18px Segoe UI';ctx.textAlign='center';
ctx.fillText(`Primitive Density 1/ζ(k) — R=${R}, k=2→${maxK}, ${mode}`,out.width/scale/2,pad);
// 2x2 grid of charts
loaded.forEach((img,i)=>{const col=i%2,row=Math.floor(i/2);ctx.drawImage(img,pad+col*(pw+gap),pad+35+row*(ph+gap),pw,ph);});
// Dashboard
const dashY=pad+35+2*(ph+gap)+10;
ctx.fillStyle=isDk?'#151b2d':'#f5f5f5';ctx.fillRect(pad,dashY,pw*2+gap,dashH-20);
ctx.textAlign='left';
renderDashboard(ctx,dashData,pad+10,dashY+10,pw*2+gap-20,isDk,dashH-40);
ctx.fillStyle=isDk?'#506080':'#888';ctx.font='10px Segoe UI';ctx.textAlign='center';
ctx.fillText('Möbius Shell Sieve — wessengetachew.github.io',out.width/scale/2,out.height/scale-10);
out.toBlob(b=>{const a=document.createElement('a');a.href=URL.createObjectURL(b);a.download='density_complete.png';a.click();},'image/png',1.0);}
async function screenshotDim(){
const dashData=extractDashboardData('dimLiveStats');
const maxD=document.getElementById('dimMaxV').value,R=document.getElementById('rdimv').value;
const plotIds=['pdimZeta','pdimDens'];
const scale=2,pad=30,gap=15,dashH=350;
const plots=plotIds.map(id=>document.getElementById(id)).filter(p=>p&&p.offsetWidth);
if(!plots.length)return alert('Run analysis first');
const imgs=await Promise.all(plots.map(p=>Plotly.toImage(p,{format:'png',width:400,height:250,scale:2})));
const loaded=await Promise.all(imgs.map(src=>new Promise(r=>{const i=new Image();i.onload=()=>r(i);i.src=src;})));
const pw=200,ph=125;
const out=document.createElement('canvas');
out.width=(pw*2+gap+pad*2)*scale;out.height=(ph+dashH+pad*4)*scale;
const ctx=out.getContext('2d');ctx.scale(scale,scale);
const isDk=isDark();
ctx.fillStyle=isDk?'#0d1321':'#ffffff';ctx.fillRect(0,0,out.width/scale,out.height/scale);
ctx.fillStyle=isDk?'#00d9ff':'#0066cc';ctx.font='bold 18px Segoe UI';ctx.textAlign='center';
ctx.fillText(`Dimension Analysis — n=2→${maxD}, R=${R}`,out.width/scale/2,pad);
loaded.forEach((img,i)=>{ctx.drawImage(img,pad+i*(pw+gap),pad+30,pw,ph);});
const dashY=pad+30+ph+15;
ctx.fillStyle=isDk?'#151b2d':'#f5f5f5';ctx.fillRect(pad,dashY,pw*2+gap,dashH-30);
ctx.textAlign='left';
renderDashboard(ctx,dashData,pad+10,dashY+10,pw*2+gap-20,isDk,dashH-50);
ctx.fillStyle=isDk?'#506080':'#888';ctx.font='10px Segoe UI';ctx.textAlign='center';
ctx.fillText('Möbius Shell Sieve — wessengetachew.github.io',out.width/scale/2,out.height/scale-10);
out.toBlob(b=>{const a=document.createElement('a');a.href=URL.createObjectURL(b);a.download='dimensions_complete.png';a.click();},'image/png',1.0);}

let cayleyPts=[],primRootData={};

function cayley(z){const x=z.x,y=z.y,d=(1-x)*(1-x)+y*y;if(d<1e-10)return{x:0,y:1e6};return{x:-2*y/d,y:(1-x*x-y*y)/d};}
function invCayley(w){const x=w.x,y=w.y,d=x*x+(y+1)*(y+1);if(d<1e-10)return{x:0,y:0};return{x:-2*x/d,y:(x*x+y*y-1)/d};}
function cayleyInverse(z){const x=z.x,y=z.y,d=(1+x)*(1+x)+y*y;if(d<1e-10)return{x:0,y:1e6};return{x:2*y/d,y:(1-x*x-y*y)/d};}
function cayleyFTT(z){const x=z.x,y=z.y-1,dx=z.x,dy=z.y+1,d=dx*dx+dy*dy;if(d<1e-10)return{x:0,y:0};return{x:(z.x*z.x+z.y*z.y-1)/d,y:-2*z.x/d};}
function cayleySmith(z){const d=(z.x+1)*(z.x+1)+z.y*z.y;if(d<1e-10)return{x:-1,y:0};return{x:(z.x*z.x-1+z.y*z.y)/d,y:2*z.y/d};}
function applyTransform(z,type){if(type==='inverse')return cayleyInverse(z);if(type==='ftt')return cayleyFTT(z);if(type==='smith')return cayleySmith(z);return cayley(z);}
function fareyLevel(p,q){if(q===0)return 0;return q;}

function drawCayley(){
if(!document.getElementById("cCayley")) return;

const c=document.getElementById('ccay'),ctx=c.getContext('2d');
const viewMode=document.getElementById('cayViewMode')?.value||'dual';
const N=+document.getElementById('cayFordQ').value||8;
const range=+document.getElementById('cayRange').value||4;
const ptSz=+document.getElementById('caySz').value||3;
const col=document.getElementById('colCay').value;
const filt=document.getElementById('cayFilt').value;
const lbl=document.getElementById('cayLbl').value;
const transformType=document.getElementById('cayTransform')?.value||'standard';

// Per-ring rotation settings
const ringInc=(+document.getElementById('cayRingInc')?.value||0)*Math.PI/180;
const phase=(+document.getElementById('cayPhase')?.value||0)*Math.PI/180;
const invertRings=document.getElementById('cayInvertRings')?.checked||false;
const showRingLabels=document.getElementById('cayShowRingLabels')?.checked||false;

// Overlays
const showGrid=document.getElementById('cayGrid')?.checked;
const showGeo=document.getElementById('cayGeo')?.checked;
const showFord=document.getElementById('cayFord')?.checked;
const showFarey=document.getElementById('cayFarey')?.checked;
const showComplement=document.getElementById('cayComplement')?.checked;
const showFund=document.getElementById('cayFund')?.checked;
const showHoro=document.getElementById('cayHoro')?.checked;
const showFareyTriangle=document.getElementById('cayFareyTriangle')?.checked;

// Smith Chart mode
const smithEnabled=document.getElementById('caySmith')?.checked||false;
const smithAlpha=(+document.getElementById('caySmithAlpha')?.value||90)*Math.PI/180;
document.getElementById('caySmithControls').style.display=smithEnabled?'flex':'none';
if(document.getElementById('caySmithAlphaV'))document.getElementById('caySmithAlphaV').textContent=(smithAlpha*180/Math.PI).toFixed(0)+'°';

ctx.fillStyle=canvBg();ctx.fillRect(0,0,c.width,c.height);

// Generate Farey sequence up to denominator N
const fareyPoints=[];
for(let q=1;q<=N;q++){
  for(let p=0;p<=q;p++){
    if(gcd(p,q)===1){
      fareyPoints.push({p,q,frac:p/q});
    }
  }
}

// Calculate ring rotation for each denominator q
const getAngleForFarey=(p,q)=>{
  const ringIdx=invertRings?(N-q):(q-1);
  const ringRotation=ringIdx*ringInc;
  return 2*Math.PI*(p/q)+phase+ringRotation;
};

// Cayley transform: w = i(1+z)/(1-z)
const cayleyTransform=(z)=>{
  const numRe=1+z.re,numIm=z.im;
  const denRe=1-z.re,denIm=-z.im;
  const denMagSq=denRe*denRe+denIm*denIm;
  if(denMagSq<1e-10)return{re:0,im:1000}; // Near singularity
  const quotRe=(numRe*denRe+numIm*denIm)/denMagSq;
  const quotIm=(numIm*denRe-numRe*denIm)/denMagSq;
  // Multiply by i: i*(a+bi) = -b+ai
  return{re:-quotIm,im:quotRe};
};

// Apply selected transform
const applyTransformLocal=(z)=>{
  if(transformType==='standard')return cayleyTransform(z);
  if(transformType==='inverse'){
    const numRe=1-z.re,numIm=-z.im;
    const denRe=1+z.re,denIm=z.im;
    const denMagSq=denRe*denRe+denIm*denIm;
    if(denMagSq<1e-10)return{re:0,im:1000};
    const quotRe=(numRe*denRe+numIm*denIm)/denMagSq;
    const quotIm=(numIm*denRe-numRe*denIm)/denMagSq;
    return{re:-quotIm,im:quotRe};
  }
  if(transformType==='ftt'){
    const numRe=z.re,numIm=z.im-1;
    const denRe=z.re,denIm=z.im+1;
    const denMagSq=denRe*denRe+denIm*denIm;
    if(denMagSq<1e-10)return{re:0,im:0};
    return{re:(numRe*denRe+numIm*denIm)/denMagSq,im:(numIm*denRe-numRe*denIm)/denMagSq};
  }
  if(transformType==='smith'){
    const numRe=z.re-1,numIm=z.im;
    const denRe=z.re+1,denIm=z.im;
    const denMagSq=denRe*denRe+denIm*denIm;
    if(denMagSq<1e-10)return{re:-1,im:0};
    return{re:(numRe*denRe+numIm*denIm)/denMagSq,im:(numIm*denRe-numRe*denIm)/denMagSq};
  }
  return cayleyTransform(z);
};

// Layout based on view mode
let diskCx,diskCy,diskR,hpOx,hpOy,hpScX,hpScY,hpRange;
if(viewMode==='dual'){
  // Side by side: disk on left, half-plane on right
  diskCx=c.width*0.25;diskCy=c.height/2;diskR=Math.min(c.width*0.22,c.height*0.42);
  hpOx=c.width*0.5+c.width*0.25;hpOy=c.height-30;
  hpRange=range;hpScX=(c.width*0.45)/(2*hpRange);hpScY=(c.height-60)/hpRange;
}else if(viewMode==='disk'){
  diskCx=c.width/2;diskCy=c.height/2;diskR=Math.min(c.width,c.height)*0.42;
  hpOx=0;hpOy=0;hpScX=0;hpScY=0;hpRange=range;
}else{
  // halfplane only
  diskCx=0;diskCy=0;diskR=0;
  hpOx=c.width/2;hpOy=c.height-30;hpRange=range;
  hpScX=c.width/(2*hpRange);hpScY=(c.height-60)/hpRange;
}

// ===== DRAW UNIT DISK =====
if(viewMode==='disk'||viewMode==='dual'){
  // Disk background circle
  ctx.strokeStyle='rgba(231,76,60,0.8)';ctx.lineWidth=2;
  ctx.beginPath();ctx.arc(diskCx,diskCy,diskR,0,2*Math.PI);ctx.stroke();
  
  // Grid in disk
  if(showGrid){
    ctx.strokeStyle='rgba(255,255,255,0.1)';ctx.lineWidth=0.5;
    ctx.beginPath();ctx.moveTo(diskCx-diskR,diskCy);ctx.lineTo(diskCx+diskR,diskCy);ctx.stroke();
    ctx.beginPath();ctx.moveTo(diskCx,diskCy-diskR);ctx.lineTo(diskCx,diskCy+diskR);ctx.stroke();
    // Concentric circles for rings
    for(let q=2;q<=N;q++){
      const ringR=diskR*(q-1)/(N-1||1)*0.9;
      ctx.beginPath();ctx.arc(diskCx,diskCy,ringR,0,2*Math.PI);ctx.stroke();
    }
  }
  
  // Farey triangle (polygon connecting Farey points)
  if(showFareyTriangle&&fareyPoints.length>2&&!smithEnabled){
    ctx.strokeStyle='rgba(255,215,0,0.4)';ctx.lineWidth=1;
    ctx.beginPath();
    fareyPoints.forEach((fp,i)=>{
      const ang=getAngleForFarey(fp.p,fp.q);
      const x=diskCx+diskR*Math.cos(ang);
      const y=diskCy-diskR*Math.sin(ang);
      if(i===0)ctx.moveTo(x,y);else ctx.lineTo(x,y);
    });
    ctx.closePath();ctx.stroke();
  }
  
  // Smith Chart grid (when enabled)
  if(smithEnabled){
    ctx.strokeStyle='rgba(255,255,255,0.15)';ctx.lineWidth=0.5;
    // Constant resistance circles
    [0.2,0.5,1,2,5].forEach(r=>{
      const cx=diskCx+diskR*r/(1+r);
      const cr=diskR/(1+r);
      ctx.beginPath();ctx.arc(cx,diskCy,cr,0,2*Math.PI);ctx.stroke();
    });
    // Constant reactance arcs
    [0.2,0.5,1,2,5].forEach(x=>{
      const cx=diskCx+diskR;
      const cy=diskCy-diskR/x;
      const cr=diskR/x;
      ctx.beginPath();ctx.arc(cx,cy,cr,Math.PI*0.5,Math.PI);ctx.stroke();
      ctx.beginPath();ctx.arc(cx,diskCy+diskR/x,cr,Math.PI,Math.PI*1.5);ctx.stroke();
    });
    // Unit circle
    ctx.strokeStyle='rgba(231,76,60,0.8)';ctx.lineWidth=2;
    ctx.beginPath();ctx.arc(diskCx,diskCy,diskR,0,2*Math.PI);ctx.stroke();
  }
  
  // Draw Farey points on unit circle with per-ring rotation (and optional Smith transform)
  const diskPts=[];
  fareyPoints.forEach(fp=>{
    if(filt==='prim'&&fp.q===1)return;
    const ang=getAngleForFarey(fp.p,fp.q);
    
    let x,y;
    if(smithEnabled){
      // Apply Smith chart transform
      const sm=smithTransform(0.95,ang,smithAlpha);
      x=diskCx+sm.x*diskR;
      y=diskCy-sm.y*diskR;
    }else{
      x=diskCx+diskR*Math.cos(ang);
      y=diskCy-diskR*Math.sin(ang);
    }
    
    // Color by scheme
    let clr;
    if(col==='gcd')clr='#ffd700';
    else if(col==='prim')clr=fp.q===1?'#888':'#ffd700';
    else if(col==='ring')clr=`hsl(${(fp.q/N)*300},75%,55%)`;
    else if(col==='farey')clr=`hsl(${fp.q*30},70%,55%)`;
    else if(col==='arg')clr=`hsl(${(fp.frac)*360},80%,55%)`;
    else clr='#ffd700';
    
    ctx.fillStyle=clr;ctx.beginPath();ctx.arc(x,y,ptSz,0,2*Math.PI);ctx.fill();
    ctx.strokeStyle='rgba(255,255,255,0.5)';ctx.lineWidth=1;ctx.stroke();
    
    // Labels
    if(lbl==='frac'&&fp.q<=8){
      ctx.fillStyle='rgba(255,255,255,0.8)';ctx.font='9px Segoe UI';ctx.textAlign='center';
      ctx.fillText(`${fp.p}/${fp.q}`,x,y-ptSz-4);
    }else if(lbl==='angle'){
      ctx.fillStyle='rgba(255,255,255,0.7)';ctx.font='8px Segoe UI';ctx.textAlign='center';
      ctx.fillText(`${Math.round(ang*180/Math.PI)}°`,x,y-ptSz-3);
    }
    
    diskPts.push({...fp,x,y,ang,z:{re:Math.cos(ang),im:Math.sin(ang)}});
  });
  
  // Ring labels
  if(showRingLabels){
    ctx.fillStyle='rgba(255,215,0,0.7)';ctx.font='10px Segoe UI';ctx.textAlign='center';
    for(let q=2;q<=Math.min(N,12);q++){
      const ringIdx=invertRings?(N-q):(q-1);
      const ringRotation=ringIdx*ringInc+phase;
      const labelAng=-Math.PI/2+ringRotation;
      const ringR=diskR*(q-1)/(N-1||1)*0.9;
      const lx=diskCx+ringR*Math.cos(labelAng);
      const ly=diskCy-ringR*Math.sin(labelAng);
      ctx.fillText(`q=${q}`,lx,ly-8);
    }
  }
  
  // ===== UNIT GROUP VISUALIZATION =====
  const showUnits=document.getElementById('cayShowUnits')?.checked;
  const showDistances=document.getElementById('cayShowDistances')?.checked;
  const unitMod=+document.getElementById('cayUnitMod')?.value||8;
  const highlightR=document.getElementById('cayHighlightR')?.value||'';
  
  if(showUnits){
    // Get unit group (ℤ/Mℤ)×
    const units=[];
    for(let r=0;r<unitMod;r++){
      if(gcd(r,unitMod)===1) units.push(r);
    }
    
    // Draw unit group points
    const unitPts=[];
    units.forEach((r,idx)=>{
      const ang=2*Math.PI*r/unitMod+phase;
      
      let x,y,lx,ly;
      if(smithEnabled){
        const sm=smithTransform(0.95,ang,smithAlpha);
        x=diskCx+sm.x*diskR;
        y=diskCy-sm.y*diskR;
        const smL=smithTransform(1.1,ang,smithAlpha);
        lx=diskCx+smL.x*diskR;
        ly=diskCy-smL.y*diskR;
      }else{
        x=diskCx+diskR*Math.cos(ang);
        y=diskCy-diskR*Math.sin(ang);
        const labelR=diskR+15;
        lx=diskCx+labelR*Math.cos(ang);
        ly=diskCy-labelR*Math.sin(ang);
      }
      
      ctx.fillStyle='#00ff88';ctx.beginPath();ctx.arc(x,y,ptSz+2,0,2*Math.PI);ctx.fill();
      ctx.strokeStyle='#fff';ctx.lineWidth=2;ctx.stroke();
      
      // Label
      ctx.fillStyle='#00ff88';ctx.font='bold 10px Segoe UI';ctx.textAlign='center';
      ctx.fillText(`${r}/${unitMod}`,lx,ly+3);
      
      // Angle label
      ctx.fillStyle='rgba(255,255,255,0.6)';ctx.font='8px Segoe UI';
      ctx.fillText(`${Math.round(ang*180/Math.PI)}°`,lx,ly+13);
      
      unitPts.push({r,ang,x,y});
    });
    
    // Draw distance chords and measurements
    if(showDistances&&unitPts.length>1){
      let distanceInfo='<strong style="color:#00ff88">Unit Group (ℤ/'+unitMod+'ℤ)× Distances:</strong><br>';
      distanceInfo+=`<span style="color:#ffd700">φ(${unitMod}) = ${units.length} units: {${units.join(', ')}}</span><br><br>`;
      
      // Draw chords between consecutive units
      ctx.strokeStyle='rgba(0,255,136,0.4)';ctx.lineWidth=1;
      const distances=[];
      for(let i=0;i<unitPts.length;i++){
        const p1=unitPts[i];
        const p2=unitPts[(i+1)%unitPts.length];
        
        // Draw chord
        ctx.beginPath();ctx.moveTo(p1.x,p1.y);ctx.lineTo(p2.x,p2.y);ctx.stroke();
        
        // Calculate chord distance (on unit circle, d = 2*sin(Δθ/2))
        let dTheta=Math.abs(p2.ang-p1.ang);
        if(dTheta>Math.PI)dTheta=2*Math.PI-dTheta;
        const chordDist=2*Math.sin(dTheta/2);
        distances.push({from:p1.r,to:p2.r,dist:chordDist,dTheta:dTheta*180/Math.PI});
        
        // Label distance at midpoint
        const mx=(p1.x+p2.x)/2,my=(p1.y+p2.y)/2;
        ctx.fillStyle='rgba(0,255,200,0.9)';ctx.font='bold 9px Segoe UI';
        ctx.fillText(chordDist.toFixed(3),mx,my);
      }
      
      // Show distance table
      distanceInfo+='<table style="width:100%;font-size:.75rem;border-collapse:collapse">';
      distanceInfo+='<tr style="border-bottom:1px solid var(--bord)"><th>From</th><th>To</th><th>Δθ</th><th>Chord d</th><th>Exact</th></tr>';
      distances.forEach(d=>{
        // Try to identify exact values
        let exact='';
        if(Math.abs(d.dist-Math.sqrt(2))<0.001)exact='√2';
        else if(Math.abs(d.dist-Math.sqrt(3))<0.001)exact='√3';
        else if(Math.abs(d.dist-2)<0.001)exact='2';
        else if(Math.abs(d.dist-1)<0.001)exact='1';
        else if(Math.abs(d.dist-(Math.sqrt(6)-Math.sqrt(2))/2)<0.001)exact='(√6-√2)/2';
        else if(Math.abs(d.dist-(Math.sqrt(6)+Math.sqrt(2))/2)<0.001)exact='(√6+√2)/2';
        else if(Math.abs(d.dist-2*Math.sin(Math.PI/12))<0.001)exact='2sin(15°)';
        
        distanceInfo+=`<tr><td>${d.from}/${unitMod}</td><td>${d.to}/${unitMod}</td><td>${d.dTheta.toFixed(1)}°</td><td>${d.dist.toFixed(4)}</td><td style="color:#ffd700">${exact}</td></tr>`;
      });
      distanceInfo+='</table>';
      
      // Special distances
      distanceInfo+='<br><strong style="color:#00d9ff">Notable Distances:</strong><br>';
      distanceInfo+=`• Diameter (180°): d = 2<br>`;
      distanceInfo+=`• Quarter (90°): d = √2 ≈ 1.414<br>`;
      distanceInfo+=`• Third (120°): d = √3 ≈ 1.732<br>`;
      distanceInfo+=`• Sixth (60°): d = 1<br>`;
      
      document.getElementById('cayDistanceInfo').innerHTML=distanceInfo;
      document.getElementById('cayDistanceInfo').style.display='block';
    }else{
      document.getElementById('cayDistanceInfo').style.display='none';
    }
  }else{
    document.getElementById('cayDistanceInfo').style.display='none';
  }
  
  // Highlight specific residue
  if(highlightR){
    const parts=highlightR.split('/');
    if(parts.length===2){
      const r=+parts[0],m=+parts[1];
      if(!isNaN(r)&&!isNaN(m)&&m>0){
        const ang=2*Math.PI*r/m+phase;
        const x=diskCx+diskR*Math.cos(ang);
        const y=diskCy-diskR*Math.sin(ang);
        
        // Highlight circle
        ctx.strokeStyle='#ff6496';ctx.lineWidth=3;
        ctx.beginPath();ctx.arc(x,y,ptSz+6,0,2*Math.PI);ctx.stroke();
        
        // Label
        ctx.fillStyle='#ff6496';ctx.font='bold 11px Segoe UI';ctx.textAlign='center';
        ctx.fillText(`${r}/${m} = ${Math.round(ang*180/Math.PI)}°`,x,y-ptSz-10);
      }
    }
  }
  
  // Title
  ctx.fillStyle='#e74c3c';ctx.font='bold 12px Segoe UI';ctx.textAlign='center';
  ctx.fillText('Unit Disk 𝔻',diskCx,diskCy-diskR-15);
}

// ===== DRAW UPPER HALF-PLANE =====
if(viewMode==='halfplane'||viewMode==='dual'){
  const hpLeft=viewMode==='dual'?c.width*0.5+10:0;
  const hpWidth=viewMode==='dual'?c.width*0.5-20:c.width;
  
  // Grid
  if(showGrid){
    ctx.strokeStyle='rgba(255,255,255,0.1)';ctx.lineWidth=0.5;
    for(let i=-Math.ceil(hpRange);i<=Math.ceil(hpRange);i++){
      ctx.beginPath();ctx.moveTo(hpOx+i*hpScX,30);ctx.lineTo(hpOx+i*hpScX,hpOy);ctx.stroke();
    }
    for(let i=0;i<=hpRange;i++){
      ctx.beginPath();ctx.moveTo(hpLeft,hpOy-i*hpScY);ctx.lineTo(hpLeft+hpWidth,hpOy-i*hpScY);ctx.stroke();
    }
  }
  
  // Real axis
  ctx.strokeStyle='rgba(255,255,255,0.5)';ctx.lineWidth=2;
  ctx.beginPath();ctx.moveTo(hpLeft,hpOy);ctx.lineTo(hpLeft+hpWidth,hpOy);ctx.stroke();
  
  // Imaginary axis
  ctx.strokeStyle='rgba(255,255,255,0.3)';ctx.lineWidth=1;
  ctx.beginPath();ctx.moveTo(hpOx,30);ctx.lineTo(hpOx,hpOy);ctx.stroke();
  
  // Fundamental domain
  if(showFund){
    ctx.fillStyle='rgba(255,215,0,0.1)';ctx.strokeStyle='rgba(255,215,0,0.6)';ctx.lineWidth=2;
    ctx.beginPath();
    ctx.moveTo(hpOx-0.5*hpScX,30);
    ctx.lineTo(hpOx-0.5*hpScX,hpOy-Math.sqrt(0.75)*hpScY);
    ctx.arc(hpOx,hpOy,hpScY,Math.PI*2/3,Math.PI/3,true);
    ctx.lineTo(hpOx+0.5*hpScX,30);
    ctx.closePath();ctx.fill();ctx.stroke();
    ctx.fillStyle='#ffd700';ctx.font='11px Segoe UI';ctx.fillText('ℱ',hpOx-8,hpOy-0.5*hpScY);
  }
  
  // Horocycles
  if(showHoro){
    ctx.strokeStyle='rgba(0,255,136,0.3)';ctx.lineWidth=1;
    for(let h=1;h<=Math.min(5,hpRange);h++){
      const r=0.5/h*hpScY;
      ctx.beginPath();ctx.arc(hpOx,hpOy-h*hpScY+r,r,0,2*Math.PI);ctx.stroke();
    }
  }
  
  // Ford circles at rationals p/q
  if(showFord){
    ctx.lineWidth=1;
    for(let q=1;q<=N;q++){
      for(let p=-q*Math.ceil(hpRange);p<=q*Math.ceil(hpRange);p++){
        if(gcd(Math.abs(p),q)!==1)continue;
        const cx=hpOx+(p/q)*hpScX;
        const r=1/(2*q*q)*hpScY;
        if(r<1||cx<hpLeft-50||cx>hpLeft+hpWidth+50)continue;
        const alpha=Math.max(0.15,0.7-q*0.06);
        ctx.strokeStyle=`hsla(${(p+q)*30},70%,60%,${alpha})`;
        ctx.beginPath();ctx.arc(cx,hpOy-r,r,0,2*Math.PI);ctx.stroke();
      }
    }
  }
  
  // Farey arcs (geodesics between Farey neighbors)
  if(showFarey){
    ctx.strokeStyle='rgba(255,100,150,0.4)';ctx.lineWidth=1;
    for(let i=0;i<fareyPoints.length;i++){
      for(let j=i+1;j<fareyPoints.length;j++){
        const fp1=fareyPoints[i],fp2=fareyPoints[j];
        if(Math.abs(fp1.p*fp2.q-fp2.p*fp1.q)===1){
          const x1=fp1.frac,x2=fp2.frac;
          const mid=(x1+x2)/2,r=Math.abs(x2-x1)/2;
          if(r*hpScX>2&&Math.abs(mid)<hpRange){
            ctx.beginPath();ctx.arc(hpOx+mid*hpScX,hpOy,r*hpScX,Math.PI,0);ctx.stroke();
          }
        }
      }
    }
  }
  
  // Complement arcs
  if(showComplement){
    ctx.strokeStyle='rgba(0,255,200,0.6)';ctx.lineWidth=2;
    for(let q=2;q<=Math.min(N,20);q++){
      for(let p=1;p<q;p++){
        if(gcd(p,q)!==1)continue;
        const comp=q-p;
        if(p>=comp)continue;
        const x1=p/q,x2=comp/q;
        const mid=(x1+x2)/2,r=Math.abs(x2-x1)/2;
        if(r*hpScX>3){
          ctx.beginPath();ctx.arc(hpOx+mid*hpScX,hpOy,r*hpScX,Math.PI,0);ctx.stroke();
        }
      }
    }
  }
  
  // Geodesics
  if(showGeo){
    ctx.strokeStyle='rgba(255,136,0,0.25)';ctx.lineWidth=1;
    for(let i=1;i<=8;i++){
      const r=i*0.3*hpScY;
      ctx.beginPath();ctx.arc(hpOx,hpOy,r,Math.PI,0);ctx.stroke();
    }
  }
  
  // Transform and draw Farey points in half-plane
  const hpPts=[];
  fareyPoints.forEach(fp=>{
    if(filt==='prim'&&fp.q===1)return;
    
    // Get disk position with per-ring rotation
    const ang=getAngleForFarey(fp.p,fp.q);
    const z={re:Math.cos(ang),im:Math.sin(ang)};
    
    // Apply Cayley transform
    const w=applyTransformLocal(z);
    
    // Skip if out of view
    if(w.im<=0||w.im>hpRange*2||Math.abs(w.re)>hpRange*2)return;
    
    // Screen coordinates
    const px=hpOx+w.re*hpScX;
    const py=hpOy-w.im*hpScY;
    
    if(px<hpLeft-20||px>hpLeft+hpWidth+20||py<20||py>hpOy+20)return;
    
    // Color
    let clr;
    if(col==='gcd')clr='#ffd700';
    else if(col==='prim')clr=fp.q===1?'#888':'#ffd700';
    else if(col==='ring')clr=`hsl(${(fp.q/N)*300},75%,55%)`;
    else if(col==='farey')clr=`hsl(${fp.q*30},70%,55%)`;
    else if(col==='imag')clr=`hsl(${(w.im/hpRange)*240},80%,55%)`;
    else if(col==='arg')clr=`hsl(${(fp.frac)*360},80%,55%)`;
    else if(col==='fire'){const d=w.im/hpRange;clr=d<.33?`rgb(${Math.floor(d*3*255)},0,0)`:d<.66?`rgb(255,${Math.floor((d-.33)*3*255)},0)`:`rgb(255,200,${Math.floor((d-.66)*3*255)})`;}
    else if(col==='plasma'){const d=w.im/hpRange;clr=`rgb(${Math.floor(13+d*230)},${Math.floor(8+d*92+Math.sin(d*Math.PI)*100)},${Math.floor(135+d*80)})`;}
    else if(col==='viridis'){const d=w.im/hpRange;clr=`rgb(${Math.floor(68+d*187)},${Math.floor(1+d*206)},${Math.floor(84+d*50)})`;}
    else clr='#ffd700';
    
    ctx.fillStyle=clr;ctx.beginPath();ctx.arc(px,py,ptSz,0,2*Math.PI);ctx.fill();
    ctx.strokeStyle='rgba(255,255,255,0.4)';ctx.lineWidth=1;ctx.stroke();
    
    // Labels
    if(lbl==='frac'&&fp.q<=6){
      ctx.fillStyle='rgba(255,255,255,0.8)';ctx.font='9px Segoe UI';ctx.textAlign='center';
      ctx.fillText(`${fp.p}/${fp.q}`,px,py-ptSz-3);
    }else if(lbl==='w'&&fp.q<=4){
      ctx.fillStyle='rgba(255,255,255,0.7)';ctx.font='8px Segoe UI';ctx.textAlign='center';
      ctx.fillText(`${w.re.toFixed(1)}+${w.im.toFixed(1)}i`,px,py-ptSz-3);
    }
    
    // Mark cusp on real axis
    if(fp.q<=12){
      ctx.fillStyle='rgba(230,126,34,0.6)';
      ctx.beginPath();ctx.arc(hpOx+(fp.p/fp.q)*hpScX,hpOy,2,0,2*Math.PI);ctx.fill();
    }
    
    hpPts.push({...fp,w,px,py});
  });
  
  // Axis labels
  ctx.fillStyle='#00d9ff';ctx.font='bold 11px Segoe UI';
  ctx.fillText('Re(w)',hpLeft+hpWidth-40,hpOy-8);
  ctx.fillText('Im(w)',hpOx+8,45);
  for(let i=-Math.floor(hpRange);i<=Math.floor(hpRange);i++){
    if(i!==0){ctx.fillStyle='#888';ctx.font='9px Segoe UI';ctx.fillText(i+'',hpOx+i*hpScX-5,hpOy+12);}
  }
  for(let i=1;i<=Math.floor(hpRange);i++){
    ctx.fillStyle='#888';ctx.font='9px Segoe UI';ctx.fillText(i+'i',hpOx+5,hpOy-i*hpScY+3);
  }
  
  // Title
  ctx.fillStyle='#9664ff';ctx.font='bold 12px Segoe UI';ctx.textAlign='center';
  ctx.fillText('Upper Half-Plane ℍ',hpOx,20);
}

// ===== STATISTICS =====
const totalPts=fareyPoints.length;
const primPts=fareyPoints.filter(fp=>fp.q>1).length;
const ringIncDeg=(ringInc*180/Math.PI);
const phaseDeg=(phase*180/Math.PI);

cayleyPts=fareyPoints.map(fp=>({...fp}));

document.getElementById('cayLiveStats').innerHTML=`
<div style="display:grid;grid-template-columns:repeat(3,1fr);gap:8px;margin-bottom:12px">
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center"><div style="font-size:1.4rem;font-weight:bold;color:#ffd700">${totalPts}</div><div style="font-size:.7rem;color:var(--txt2)">FAREY POINTS</div></div>
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center"><div style="font-size:1.4rem;font-weight:bold;color:#00d9ff">${N}</div><div style="font-size:.7rem;color:var(--txt2)">MAX DENOM</div></div>
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center"><div style="font-size:1.4rem;font-weight:bold;color:#00ff88">${fmt(6/Math.PI/Math.PI*100)}%</div><div style="font-size:.7rem;color:var(--txt2)">6/π² DENSITY</div></div>
</div>
<div style="margin-bottom:10px;padding-bottom:8px;border-bottom:1px solid var(--bord)">
<strong style="color:var(--acc)">Per-Ring Rotation</strong>
<div style="display:grid;grid-template-columns:1fr 1fr;gap:3px;margin-top:5px;font-size:.8rem">
<span>Ring Increment:</span><span style="color:#ffd700;font-weight:bold">${ringIncDeg.toFixed(2)}°</span>
<span>Global Phase:</span><span style="color:#00d9ff">${phaseDeg.toFixed(1)}°</span>
<span>Invert Rings:</span><span>${invertRings?'Yes':'No'}</span>
<span>Transform:</span><span style="color:#9664ff">${transformType}</span>
</div>
</div>
<div style="font-size:.8rem;color:var(--txt2)">
<strong style="color:var(--acc)">Formula</strong><br>
<code style="background:var(--bg1);padding:2px 6px;border-radius:3px">θ(p/q) = 2π(p/q) + phase + (q-1)×Δθ</code><br>
<code style="background:var(--bg1);padding:2px 6px;border-radius:3px;margin-top:4px;display:inline-block">w = i(1+z)/(1-z)</code>
</div>
`;

legend('alcay',viewMode==='dual'?'Dual View':viewMode==='disk'?'Unit Disk':'Half-Plane',[
  ['Farey Pts',totalPts,'#ffd700'],
  ['Max q',N,'#00d9ff'],
  ['Δθ',ringIncDeg.toFixed(1)+'°','#ff6496']
]);

// Farey Distribution chart - count by denominator q
const qCounts={};
fareyPoints.forEach(fp=>{qCounts[fp.q]=(qCounts[fp.q]||0)+1;});
const qKeys=Object.keys(qCounts).map(Number).sort((a,b)=>a-b);
const distDiv=document.getElementById('pcayDist');
if(distDiv&&qKeys.length>0&&typeof Plotly!=='undefined'){
  try{
    distDiv.style.height='250px';
    distDiv.style.width='100%';
    Plotly.newPlot('pcayDist',[{
      x:qKeys,
      y:qKeys.map(q=>qCounts[q]),
      type:'bar',
      marker:{color:qKeys.map(q=>`hsl(${q*30},70%,55%)`)},
      name:'φ(q)'
    }],{
      plot_bgcolor:isDark()?'rgba(10,14,39,0.8)':'rgba(245,247,250,0.95)',
      paper_bgcolor:isDark()?'rgba(10,14,39,0.8)':'rgba(245,247,250,0.95)',
      font:{color:isDark()?'#e0e0ff':'#1a1a1a',size:10},
      xaxis:{title:'Denominator q',color:isDark()?'#aaa':'#333',gridcolor:isDark()?'rgba(255,255,255,0.1)':'rgba(0,0,0,0.1)'},
      yaxis:{title:'Count φ(q)',color:isDark()?'#aaa':'#333',gridcolor:isDark()?'rgba(255,255,255,0.1)':'rgba(0,0,0,0.1)'},
      height:250,
      margin:{l:50,r:20,t:20,b:50}
    },{responsive:true,displayModeBar:false});
  }catch(e){console.log('Farey plot error:',e);}
}else if(distDiv){
  distDiv.innerHTML='<div style="color:#888;padding:1rem;text-align:center">Farey distribution: '+qKeys.length+' denominators, '+fareyPoints.length+' total points</div>';
}

// Setup click handler for distance measurement
setupCayleyClick();
}

// Per-ring rotation helpers for Cayley
function applyCayFraction(){
  const input=document.getElementById('cayRingFrac').value;
  const deg=parseFraction(input);
  if(deg!==null){
    const clampedDeg=Math.min(180,Math.max(0,deg%360));
    document.getElementById('cayRingInc').value=clampedDeg;
    document.getElementById('cayRingIncV').textContent=clampedDeg.toFixed(2)+'°';
    document.getElementById('cayFracDeg').textContent='= '+deg.toFixed(2)+'°';
    drawCayley();
  }else{
    document.getElementById('cayFracDeg').textContent='Invalid';
  }
}

function setCayRingFrac(frac){
  document.getElementById('cayRingFrac').value=frac;
  applyCayFraction();
}

// Unit group helper functions
function setCayUnitMod(m){
  document.getElementById('cayUnitMod').value=m;
  document.getElementById('cayShowUnits').checked=true;
  document.getElementById('cayShowDistances').checked=true;
  drawCayley();
}

function clearCayHighlight(){
  document.getElementById('cayHighlightR').value='';
  drawCayley();
}

// Click handler for Cayley canvas - measure distances
let caySelectedPts=[];
function setupCayleyClick(){
  const c=document.getElementById('ccay');
  if(!c)return;
  c.onclick=e=>{
    const rect=c.getBoundingClientRect();
    const mx=(e.clientX-rect.left)*(c.width/rect.width);
    const my=(e.clientY-rect.top)*(c.height/rect.height);
    
    // Find closest point
    let closest=null,minDist=Infinity;
    for(const p of cayleyPts){
      // Check if we have screen coordinates
      const px=p.px||p.x;
      const py=p.py||p.y;
      if(px===undefined)continue;
      const d=Math.hypot(mx-px,my-py);
      if(d<minDist&&d<20){
        minDist=d;
        closest=p;
      }
    }
    
    if(closest){
      caySelectedPts.push(closest);
      if(caySelectedPts.length>=2){
        // Calculate distance between two points
        const p1=caySelectedPts[0],p2=caySelectedPts[1];
        const ang1=2*Math.PI*(p1.frac||p1.p/p1.q);
        const ang2=2*Math.PI*(p2.frac||p2.p/p2.q);
        let dTheta=Math.abs(ang2-ang1);
        if(dTheta>Math.PI)dTheta=2*Math.PI-dTheta;
        const chordDist=2*Math.sin(dTheta/2);
        
        modal('Distance Measurement',[
          ['Point 1',`${p1.p}/${p1.q}`],
          ['Point 2',`${p2.p}/${p2.q}`],
          ['Angle 1',`${(ang1*180/Math.PI).toFixed(2)}°`],
          ['Angle 2',`${(ang2*180/Math.PI).toFixed(2)}°`],
          ['Δθ',`${(dTheta*180/Math.PI).toFixed(2)}°`],
          ['Chord Distance',chordDist.toFixed(6)],
          ['Formula','d = 2·sin(Δθ/2)'],
          ['√2 ≈',Math.sqrt(2).toFixed(6)],
          ['√3 ≈',Math.sqrt(3).toFixed(6)]
        ]);
        caySelectedPts=[];
      }else{
        // First point selected, indicate waiting for second
        const info=document.getElementById('cayDistanceInfo');
        if(info){
          info.style.display='block';
          info.innerHTML=`<span style="color:#ff6496">Selected: ${closest.p}/${closest.q} — Click another point to measure distance</span>`;
        }
      }
    }
  };
}

function csvCayley(){let s='p,q,fraction,angle_deg\n';for(const p of cayleyPts)s+=`${p.p},${p.q},${p.frac},${(p.frac*360).toFixed(2)}\n`;dl(s,'cayley_farey.csv');}

async function screenshotCayley(){
const N=document.getElementById('cayFordQ').value,range=document.getElementById('cayRange').value;
const col=document.getElementById('colCay').value;
const viewMode=document.getElementById('cayViewMode')?.value||'dual';
await screenshotUnified('ccay','cayLiveStats',`Cayley ${viewMode} — N=${N}, Range=${range}, ${col}`,'cayley_complete.png',{legend:'w = i(1+z)/(1-z) · θ(p/q) = 2π(p/q) + phase + (q-1)×Δθ'});
}

function mulOrd(a,m){if(gcd(a,m)!==1)return 0;let ord=1,x=a%m;while(x!==1&&ord<=m){x=(x*a)%m;ord++;}return ord;}

function findPrimRoot(){const M=+document.getElementById('mprimv').value||+document.getElementById('mprim').value,phi=eulerPhi(M);for(let g=2;g<M;g++)if(gcd(g,M)===1&&mulOrd(g,M)===phi){document.getElementById('gprim').value=g;drawPrimRoot();return;}alert('No primitive root exists for M='+M);}

function findAllPrimRoots(){const M=+document.getElementById('mprimv').value,phi=eulerPhi(M);const roots=[];for(let g=1;g<M;g++)if(gcd(g,M)===1&&mulOrd(g,M)===phi)roots.push(g);if(roots.length>0){modal('All Primitive Roots mod '+M,[['Count',roots.length],['φ(φ(M))',eulerPhi(phi)],['Roots',roots.slice(0,30).join(', ')+(roots.length>30?' ...':'')]]);}else{alert('No primitive roots exist for M='+M);}}

function setM(m){document.getElementById('mprim').value=m;document.getElementById('mprimv').value=m;findPrimRoot();}

function isQuadraticResidue(a,p){if(gcd(a,p)!==1)return false;return modPow(a,(p-1)/2,p)===1;}
function modPow(b,e,m){let r=1;b=b%m;while(e>0){if(e%2===1)r=(r*b)%m;e=Math.floor(e/2);b=(b*b)%m;}return r;}

function eulerPhi(n){let r=n,m=n;for(let p=2;p*p<=m;p++)if(m%p===0){while(m%p===0)m/=p;r-=r/p;}if(m>1)r-=r/m;return Math.round(r);}

// ===== MODULAR SIEVE ANALYSIS =====
// Computes exact modular arithmetic properties for any integer M
// Key result: GapPairs(M,H) = ∏(p - νₚ) for squarefree M
// where νₚ = 1 if p|H, else 2
function modularSieve(M, gap=2) {
const phi = eulerPhi(M);
const C_M = phi / M; // Coprime density φ(M)/M

// Prime factorization with exponents
const primeFactors = [];
const primeFactorsWithExp = [];
let temp = M;
let isSquarefree = true;
for (let p = 2; p * p <= temp; p++) {
if (temp % p === 0) {
let exp = 0;
while (temp % p === 0) { temp /= p; exp++; }
primeFactors.push(p);
primeFactorsWithExp.push({p, exp});
if (exp > 1) isSquarefree = false;
}}
if (temp > 1) {
primeFactors.push(temp);
primeFactorsWithExp.push({p: temp, exp: 1});
}

// Euler product: ∏(1-1/p) for p|M - ALWAYS equals φ(M)/M
let eulerProduct = 1;
primeFactors.forEach(p => eulerProduct *= (1 - 1/p));

// Count actual gap pairs (r where both r and r+gap are coprime to M)
let gapPairs = 0;
const coprimes = [];
for (let r = 0; r < M; r++) if (gcd(r, M) === 1) coprimes.push(r);
const coprimeSet = new Set(coprimes);
coprimes.forEach(r => {
if (coprimeSet.has((r + gap) % M)) gapPairs++;
});

// EXACT formula for squarefree M: Pairs = ∏(p - νₚ) where νₚ = 1 if p|H, else 2
let predictedPairs = 1;
let pairFormula = [];
if (isSquarefree) {
primeFactors.forEach(p => {
const nu = (gap % p === 0) ? 1 : 2;
predictedPairs *= (p - nu);
pairFormula.push(`(${p}-${nu})`);
});
}

// Pair density
const pairDensity = gapPairs / M;

// Check if M is a primorial (consecutive primes from 2)
const primorials = [2, 6, 30, 210, 2310, 30030, 510510];
const isPrimorial = primorials.includes(M);

return {
M, phi, C_M, primeFactors, primeFactorsWithExp, eulerProduct,
isSquarefree, isPrimorial,
gap, gapPairs, pairDensity, predictedPairs, pairFormula,
coprimeCount: coprimes.length
};
}

// Generate modular sieve HTML block for live stats with step-by-step
function modularSieveHTML(M, gap=2, title='Modular Sieve') {
const a = modularSieve(M, gap);
const factorStr = a.primeFactorsWithExp.map(f => f.exp > 1 ? `${f.p}<sup>${f.exp}</sup>` : f.p).join('×') || '1';

// Build step-by-step for φ(M)/M = ∏(1-1/p)
let phiSteps = [];
let phiProduct = 1;
a.primeFactors.forEach(p => {
const factor = 1 - 1/p;
phiProduct *= factor;
phiSteps.push(`(1-1/${p})`);
});
const phiStepStr = phiSteps.length > 0 ? phiSteps.join(' × ') + ' = ' + phiProduct.toFixed(4) : '1';

// Build step-by-step for gap pairs ∏(p - νₚ)
let gapSteps = [];
let gapDetails = [];
if(a.isSquarefree) {
a.primeFactors.forEach(p => {
const nu = (gap % p === 0) ? 1 : 2;
const result = p - nu;
gapSteps.push(`(${p}-${nu})`);
gapDetails.push({p, nu, result, divides: gap % p === 0});
});
}

return `
<div style="margin-top:10px;padding:10px;background:linear-gradient(135deg,rgba(0,217,255,.1),rgba(255,215,0,.1));border-radius:6px;border:1px solid rgba(0,217,255,.3);position:relative;z-index:1;overflow:visible">
<strong style="color:#00d9ff;font-size:.85rem;display:block;margin-bottom:4px">${title} (M=${M})</strong>
<div style="font-size:.65rem;color:var(--txt2);margin:2px 0">${factorStr}${a.isSquarefree ? '' : ' <span style="color:#ff8c00">(non-squarefree)</span>'}${a.isPrimorial ? ' <span style="color:#00ff88">* primorial</span>' : ''}</div>

<div style="margin-top:8px;position:relative">
<div style="font-size:.75rem;color:#ffd700;font-weight:bold;margin-bottom:4px">1. φ(M)/M Step-by-Step</div>
<div style="background:rgba(0,0,0,.2);padding:8px;border-radius:4px;font-size:.7rem">
<div style="color:var(--txt2);margin-bottom:4px">Formula: φ(M)/M = ∏(1 - 1/p) for each prime p|M</div>
<div style="color:#00ff88;font-family:monospace">${phiStepStr}</div>
<div style="margin-top:6px;color:var(--txt)">Result: φ(${M})/${M} = ${a.phi}/${M} = <strong style="color:#00ff88">${a.C_M.toFixed(4)}</strong></div>
</div>
</div>

<div style="margin-top:10px;position:relative">
<div style="font-size:.75rem;color:#ff6496;font-weight:bold;margin-bottom:4px">2. Gap ${gap} Pairs Step-by-Step</div>
<div style="background:rgba(0,0,0,.2);padding:8px;border-radius:4px;font-size:.7rem">
<div style="color:var(--txt2);margin-bottom:4px">Formula: GapPairs = ∏(p - νₚ) where νₚ = 1 if p|${gap}, else 2</div>
${a.isSquarefree ? `
<div style="display:grid;grid-template-columns:repeat(auto-fit,minmax(90px,1fr));gap:4px;margin-top:6px">
${gapDetails.map(d => `<div style="background:rgba(${d.divides?'0,255,136':'255,100,150'},.15);padding:4px;border-radius:3px;text-align:center">
<div style="font-size:.6rem;color:var(--txt2)">p=${d.p}</div>
<div style="color:#ffd700;font-size:.65rem">${d.result}</div>
</div>`).join('')}
</div>
` : '<div style="color:#ff8c00">Formula only exact for squarefree M</div>'}
<div style="margin-top:6px;border-top:1px solid rgba(255,255,255,.1);padding-top:6px">
<span>Counted pairs: <strong style="color:#00ff88">${a.gapPairs}</strong></span>
<span style="margin-left:10px">Density: <strong style="color:#ffd700">${(a.pairDensity*100).toFixed(2)}%</strong></span>
</div>
<div style="margin-top:4px;color:var(--txt)">Result: φ(${M})/${M} = ${a.phi}/${M} = <strong style="color:#00ff88">${a.C_M.toFixed(4)}</strong></div>
</div>
</div>
</div>`;
}

// Backward compatibility aliases
function singularSeriesCalc(M, gap=2) { return modularSieve(M, gap); }
function singularSeriesHTML(M, gap=2, title='Modular Sieve') { return modularSieveHTML(M, gap, title); }

// Farey Sector Analysis Stats HTML for 2D Lattice
function fareySectorStatsHTML2D(pts, R) {
  const sec2dHighlight = document.getElementById('sec2dHighlight')?.checked;
  if (!sec2dHighlight) return '';
  
  const secFromVal = +document.getElementById('sec2dFrom')?.value || 3;
  const secToVal = +document.getElementById('sec2dTo')?.value || 2;
  const secDepth = +document.getElementById('sec2dDepth')?.value || 6;
  const angLoRad = Math.atan2(1, secFromVal);
  const angHiRad = Math.atan2(1, secToVal);
  const angLoDeg = angLoRad * 180 / Math.PI;
  const angHiDeg = angHiRad * 180 / Math.PI;
  
  let sectorPrims = 0, sectorTotal = 0;
  for (const pt of pts) {
    if (pt.x > 0 && pt.y >= 0) {
      const ang = Math.atan2(pt.y, pt.x);
      if (ang >= angLoRad && ang <= angHiRad) {
        sectorTotal++;
        if (pt.p) sectorPrims++;
      }
    }
  }
  
  const n = secToVal;
  const asymp = Math.round(3 * R * R / (Math.PI * Math.PI * n * (n + 1)));
  const absErr = Math.abs(sectorPrims - asymp);
  const relErr = asymp > 0 ? (absErr / asymp * 100) : 0;
  const rootNum = 2, rootDen = 2 * n + 1;
  let rating = asymp > 0 ? (relErr < 5 ? 'Excellent' : relErr < 15 ? 'Good' : relErr < 30 ? 'Fair' : 'Poor') : '—';
  const ratingColor = rating === 'Excellent' ? '#00ff88' : rating === 'Good' ? '#ffd700' : rating === 'Fair' ? '#ff8c00' : '#ff6496';
  
  return `<div style="margin-bottom:12px;padding:12px;background:rgba(150,100,255,.12);border-radius:8px;border:2px solid rgba(150,100,255,.4)">
<strong style="color:#9664ff">Farey Sector Analysis</strong>
<div style="font-size:.7rem;color:var(--txt2);margin:4px 0">Sector S<sub>${secToVal}</sub>: 1/${secFromVal} → 1/${secToVal} (${angLoDeg.toFixed(1)}° – ${angHiDeg.toFixed(1)}°)</div>
<div style="display:grid;grid-template-columns:repeat(3,1fr);gap:8px;margin:8px 0">
<div style="background:var(--bg1);padding:8px;border-radius:6px;text-align:center"><div style="font-size:1.2rem;font-weight:bold;color:#ffd700">${sectorPrims}</div><div style="font-size:.6rem;color:var(--txt2)">OBSERVED</div></div>
<div style="background:var(--bg1);padding:8px;border-radius:6px;text-align:center"><div style="font-size:1.2rem;font-weight:bold;color:#9664ff">${asymp}</div><div style="font-size:.6rem;color:var(--txt2)">ASYMPTOTIC</div></div>
<div style="background:var(--bg1);padding:8px;border-radius:6px;text-align:center"><div style="font-size:1.2rem;font-weight:bold;color:#00d9ff">${sectorTotal}</div><div style="font-size:.6rem;color:var(--txt2)">TOTAL PTS</div></div>
</div>
<div style="display:grid;grid-template-columns:repeat(4,1fr);gap:4px;font-size:.75rem">
<span>Abs Err: <strong style="color:#00d9ff">${absErr}</strong></span>
<span>Rel Err: <strong style="color:${relErr<15?'#00ff88':relErr<30?'#ffd700':'#ff6496'}">${relErr.toFixed(1)}%</strong></span>
<span>Root: <strong style="color:#00ff88">${rootNum}/${rootDen}</strong></span>
<span>Rating: <strong style="color:${ratingColor}">${rating}</strong></span>
</div>
<div style="margin-top:8px;padding-top:8px;border-top:1px solid var(--bord);font-size:.65rem;color:var(--txt2)">
<strong>Formula:</strong> C(n,N) ≈ 3N²/(π²·n(n+1)) — Depth: ${secDepth} | Width: ${(angHiDeg-angLoDeg).toFixed(1)}°
</div>
</div>`;
}

// Farey Sector Analysis Stats HTML for 3D Lattice
function fareySectorStatsHTML3D(pts, R) {
  const sec3dHighlight = document.getElementById('sec3dHighlight')?.checked;
  if (!sec3dHighlight) return '';
  
  const secFromVal = +document.getElementById('sec3dFrom')?.value || 36;
  const secToVal = +document.getElementById('sec3dTo')?.value || 72;
  
  let sectorPrims = 0, sectorTotal = 0;
  for (const pt of pts) {
    const r3 = Math.sqrt(pt.x*pt.x + pt.y*pt.y + pt.z*pt.z);
    if (r3 > 0) {
      const phi = Math.acos(pt.z / r3) * 180 / Math.PI;
      if (phi >= secFromVal && phi <= secToVal) {
        sectorTotal++;
        if (pt.p) sectorPrims++;
      }
    }
  }
  
  let bandName = 'Custom';
  if (secFromVal === 0 && secToVal === 18) bandName = 'Polar Cap';
  else if (secFromVal === 18 && secToVal === 36) bandName = 'Arctic';
  else if (secFromVal === 36 && secToVal === 72) bandName = 'Temperate';
  else if (secFromVal === 72 && secToVal === 108) bandName = 'Equatorial';
  else if (secFromVal === 108 && secToVal === 144) bandName = 'S. Temperate';
  else if (secFromVal === 144 && secToVal === 180) bandName = 'S. Polar';
  
  const bandWidth = Math.abs(secToVal - secFromVal);
  const solidAngle = 2 * Math.PI * Math.abs(Math.cos(secFromVal * Math.PI / 180) - Math.cos(secToVal * Math.PI / 180));
  const expectedFrac = solidAngle / (4 * Math.PI);
  
  return `<div style="margin-bottom:12px;padding:12px;background:rgba(150,100,255,.12);border-radius:8px;border:2px solid rgba(150,100,255,.4)">
<strong style="color:#9664ff">3D Polar Sector Analysis</strong>
<div style="font-size:.7rem;color:var(--txt2);margin:4px 0">${bandName}: φ = ${secFromVal}° to ${secToVal}° (width: ${bandWidth}°)</div>
<div style="display:grid;grid-template-columns:repeat(3,1fr);gap:8px;margin:8px 0">
<div style="background:var(--bg1);padding:8px;border-radius:6px;text-align:center"><div style="font-size:1.2rem;font-weight:bold;color:#ffd700">${sectorPrims}</div><div style="font-size:.6rem;color:var(--txt2)">PRIMITIVES</div></div>
<div style="background:var(--bg1);padding:8px;border-radius:6px;text-align:center"><div style="font-size:1.2rem;font-weight:bold;color:#00d9ff">${sectorTotal}</div><div style="font-size:.6rem;color:var(--txt2)">TOTAL PTS</div></div>
<div style="background:var(--bg1);padding:8px;border-radius:6px;text-align:center"><div style="font-size:1.2rem;font-weight:bold;color:#9664ff">${(expectedFrac*100).toFixed(1)}%</div><div style="font-size:.6rem;color:var(--txt2)">SOLID ANGLE</div></div>
</div>
<div style="font-size:.65rem;color:var(--txt2)">
Solid angle Ω = ${solidAngle.toFixed(3)} sr | Expected fraction: ${(expectedFrac*100).toFixed(1)}%
</div>
</div>`;
}
function modularAnalysis(M, gap=2) { return modularSieve(M, gap); }
function modularStatsHTML(M, gap=2, title='Modular Sieve') { return modularSieveHTML(M, gap, title); }

function discreteLog(a,g,M,phi){if(gcd(a,M)!==1)return-1;let x=1;for(let i=0;i<phi;i++){if(x===a)return i;x=(x*g)%M;}return-1;}

let primAnimId=null;
function animatePowerSeq(){
const M=+document.getElementById('mprimv').value,g=+document.getElementById('gprim').value,phi=eulerPhi(M);
if(gcd(g,M)!==1||mulOrd(g,M)!==phi){alert('g must be a primitive root');return;}
if(primAnimId)cancelAnimationFrame(primAnimId);
let step=0;const c=document.getElementById('cprim'),ctx=c.getContext('2d');
const cx=c.width/2,cy=c.height/2,rad=Math.min(cx,cy)-80;
function frame(){
drawPrimRoot();ctx.strokeStyle='rgba(255,215,0,0.8)';ctx.lineWidth=3;ctx.beginPath();
let x=1;for(let i=0;i<=step;i++){const ang=2*Math.PI*x/M-Math.PI/2,px=cx+rad*Math.cos(ang),py=cy+rad*Math.sin(ang);
if(i===0)ctx.moveTo(px,py);else ctx.lineTo(px,py);x=(x*g)%M;}
ctx.stroke();
if(step<phi){step++;primAnimId=requestAnimationFrame(frame);}else{primAnimId=null;}}
frame();}

function drawPrimRoot(){
if(!document.getElementById("cPrim")) return;

const c=document.getElementById('cprim'),ctx=c.getContext('2d');
const M=+document.getElementById('mprimv').value||+document.getElementById('mprim').value;
const g=+document.getElementById('gprim').value,col=document.getElementById('colPrim').value;
const ptSz=+document.getElementById('primPtSz').value,lbl=document.getElementById('primLbl').value;
const showSeq=document.getElementById('primSeq').checked,showOrd=document.getElementById('primOrd').checked;
const showSubgrp=document.getElementById('primSubgrp').checked,showQR=document.getElementById('primQR').checked;
const showCosets=document.getElementById('primCosets').checked;
ctx.fillStyle=canvBg();ctx.fillRect(0,0,c.width,c.height);
const cx=c.width/2,cy=c.height/2,rad=Math.min(cx,cy)-80;

// Draw circle
ctx.strokeStyle=gridC();ctx.lineWidth=2;ctx.beginPath();ctx.arc(cx,cy,rad,0,2*Math.PI);ctx.stroke();

const phi=eulerPhi(M),isPrimRoot=gcd(g,M)===1&&mulOrd(g,M)===phi;
const elements=[],orders={},ordCounts={},qrCount=[];
let maxOrd=0;

// Compute discrete logs if g is primitive root
const dlogs={};
if(isPrimRoot){let x=1;for(let i=0;i<phi;i++){dlogs[x]=i;x=(x*g)%M;}}

for(let k=1;k<M;k++){
const ord=mulOrd(k,M);
const isUnit=gcd(k,M)===1;
const isQR=M>2&&isUnit?isQuadraticResidue(k,M):false;
const dlog=isPrimRoot&&isUnit?dlogs[k]:-1;
orders[k]=ord;
if(ord>0)ordCounts[ord]=(ordCounts[ord]||0)+1;
if(ord>maxOrd)maxOrd=ord;
elements.push({k,ord,isUnit,isQR,dlog});}

// Draw subgroup circles
if(showSubgrp&&isPrimRoot){
const divs=[];for(let d=1;d<=phi;d++)if(phi%d===0)divs.push(d);
divs.forEach((d,i)=>{if(d<phi&&d>1){
ctx.strokeStyle=`hsla(${i*60},70%,50%,0.3)`;ctx.lineWidth=1;ctx.setLineDash([5,5]);
ctx.beginPath();ctx.arc(cx,cy,rad*d/phi,0,2*Math.PI);ctx.stroke();ctx.setLineDash([]);}});}

// Highlight quadratic residues arc
if(showQR&&M>2){
ctx.fillStyle='rgba(0,255,136,0.1)';ctx.beginPath();ctx.moveTo(cx,cy);
elements.filter(e=>e.isQR).forEach(e=>{const ang=2*Math.PI*e.k/M-Math.PI/2;ctx.lineTo(cx+rad*Math.cos(ang),cy+rad*Math.sin(ang));});
ctx.closePath();ctx.fill();}

// Draw cosets
if(showCosets&&isPrimRoot){
const H=elements.filter(e=>e.isQR).map(e=>e.k);
ctx.strokeStyle='rgba(150,100,255,0.4)';ctx.lineWidth=1;
H.forEach(h=>{const ang=2*Math.PI*h/M-Math.PI/2;ctx.beginPath();ctx.moveTo(cx,cy);ctx.lineTo(cx+rad*Math.cos(ang),cy+rad*Math.sin(ang));ctx.stroke();});}

// Draw elements
for(const e of elements){
const ang=2*Math.PI*e.k/M-Math.PI/2,px=cx+rad*Math.cos(ang),py=cy+rad*Math.sin(ang);
let clr;
if(col==='order')clr=e.ord===0?'#666':e.ord===phi?'#ffd700':`hsl(${Math.floor(e.ord/maxOrd*300)},100%,50%)`;
else if(col==='power')clr=e.isUnit?'#00d9ff':'#ff6496';
else if(col==='unit')clr=e.isUnit?'#00ff88':'#ff6496';
else if(col==='quadres')clr=e.isQR?'#00ff88':e.isUnit?'#ff8c00':'#666';
else if(col==='generator')clr=e.ord===phi?'#ffd700':e.isUnit?'#00d9ff':'#666';
else if(col==='discrete')clr=e.dlog>=0?`hsl(${e.dlog/phi*360},80%,50%)`:'#666';
else clr=e.isUnit?'#00d9ff':'#ff6496';

ctx.fillStyle=clr;
const sz=e.ord===phi?ptSz+2:ptSz;
ctx.beginPath();ctx.arc(px,py,sz,0,2*Math.PI);ctx.fill();

// Labels
if(lbl!=='none'||(showOrd&&e.ord>0)){
ctx.fillStyle=isDark()?'rgba(255,255,255,0.85)':'rgba(0,0,0,0.85)';ctx.font='10px Arial';ctx.textAlign='center';
let txt='';
if(lbl==='value')txt=e.k;
else if(lbl==='order')txt=e.ord>0?e.ord:'';
else if(lbl==='dlog')txt=e.dlog>=0?e.dlog:'';
else if(showOrd&&e.ord>0)txt=e.ord;
if(txt!=='')ctx.fillText(txt,px,py-ptSz-5);}}

// Power sequence
if(showSeq&&isPrimRoot){
ctx.strokeStyle='rgba(255,215,0,0.6)';ctx.lineWidth=2;ctx.beginPath();
let x=1;for(let i=0;i<=phi;i++){
const ang=2*Math.PI*x/M-Math.PI/2,px=cx+rad*Math.cos(ang),py=cy+rad*Math.sin(ang);
if(i===0)ctx.moveTo(px,py);else ctx.lineTo(px,py);x=(x*g)%M;}
ctx.stroke();}

// Title
ctx.fillStyle=isDark()?'#00d9ff':'#0066cc';ctx.font='bold 14px Segoe UI';ctx.textAlign='center';
ctx.fillText(`M = ${M}, φ(M) = ${phi}, g = ${g}`,cx,25);
ctx.fillStyle=isPrimRoot?'#00ff88':'#ff6496';
ctx.fillText(isPrimRoot?'OK g is a PRIMITIVE ROOT':'X g is NOT a primitive root',cx,45);

const primRoots=elements.filter(e=>e.ord===phi).map(e=>e.k);
const qrs=elements.filter(e=>e.isQR).length;
const units=elements.filter(e=>e.isUnit).length;

// Legend
legend('alprim','Primitive Roots',[]);
document.getElementById('stprim').innerHTML='';

// Live stats
document.getElementById('primLiveStats').innerHTML=`
<div style="display:grid;grid-template-columns:repeat(3,1fr);gap:8px;margin-bottom:12px">
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center"><div style="font-size:1.4rem;font-weight:bold;color:#00d9ff">${M}</div><div style="font-size:.7rem;color:var(--txt2)">MODULUS M</div></div>
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center"><div style="font-size:1.4rem;font-weight:bold;color:#ffd700">${phi}</div><div style="font-size:.7rem;color:var(--txt2)">φ(M)</div></div>
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center"><div style="font-size:1.4rem;font-weight:bold;color:#00ff88">${primRoots.length}</div><div style="font-size:.7rem;color:var(--txt2)">PRIM ROOTS</div></div>
</div>
<div style="margin-bottom:10px;padding-bottom:8px;border-bottom:1px solid var(--bord)">
<strong style="color:var(--acc)">Generator Analysis</strong>
<div style="display:grid;grid-template-columns:1fr 1fr;gap:3px;margin-top:5px;font-size:.8rem">
<span>g:</span><span style="color:var(--txt)">${g}</span>
<span>ord(g):</span><span style="color:${mulOrd(g,M)===phi?'#00ff88':'#ff6496'}">${mulOrd(g,M)}</span>
<span>Is Prim Root:</span><span style="color:${isPrimRoot?'#00ff88':'#ff6496'}">${isPrimRoot?'Yes':'No'}</span>
<span>gcd(g,M):</span><span style="color:var(--txt)">${gcd(g,M)}</span>
</div>
</div>
<div style="margin-bottom:10px;padding-bottom:8px;border-bottom:1px solid var(--bord)">
<strong style="color:var(--acc)">Group Structure</strong>
<div style="display:grid;grid-template-columns:1fr 1fr;gap:3px;margin-top:5px;font-size:.8rem">
<span>Units |(ℤ/Mℤ)×|:</span><span style="color:#00d9ff">${units}</span>
<span>Quadratic Residues:</span><span style="color:#00ff88">${qrs}</span>
<span>Non-Residues:</span><span style="color:#ff8c00">${units-qrs}</span>
<span>Max Order:</span><span style="color:#ffd700">${maxOrd}</span>
</div>
</div>
<div style="margin-bottom:10px;padding-bottom:8px;border-bottom:1px solid var(--bord)">
<strong style="color:var(--acc)">Primitive Roots</strong>
<div style="margin-top:5px;font-size:.8rem">
<span>Count: <strong style="color:#ffd700">${primRoots.length}</strong></span>
<span style="margin-left:10px">φ(φ(M)): <strong style="color:#9664ff">${eulerPhi(phi)}</strong></span>
<div style="margin-top:5px;color:var(--txt2);word-break:break-all">${primRoots.slice(0,15).join(', ')}${primRoots.length>15?' ...':''}</div>
</div>
</div>
<div>
<strong style="color:var(--acc)">Existence Test</strong>
<div style="margin-top:5px;font-size:.75rem;line-height:1.5;color:var(--txt2)">
Prim roots exist for M = 1,2,4,pᵏ,2pᵏ<br>
M=${M}: ${primRoots.length>0?'<span style="color:#00ff88">OK Has primitive roots</span>':'<span style="color:#ff6496">X No primitive roots</span>'}
</div>
</div>`;

// Order distribution chart
const ordData=Object.entries(ordCounts).sort((a,b)=>+a[0]-+b[0]);
Plotly.newPlot('pprimord',[{x:ordData.map(d=>d[0]),y:ordData.map(d=>d[1]),type:'bar',marker:{color:ordData.map(d=>+d[0]===phi?'#ffd700':'#00d9ff')}}],{...plo(),xaxis:{title:'Order'},yaxis:{title:'Count'},height:200});

// Power sequence plot
if(isPrimRoot){
const seqX=[],seqY=[];let x=1;
for(let i=0;i<=phi;i++){seqX.push(i);seqY.push(x);x=(x*g)%M;}
Plotly.newPlot('pprimseq',[{x:seqX,y:seqY,mode:'lines+markers',line:{color:'#ffd700'},marker:{size:4}}],{...plo(),xaxis:{title:'Power n'},yaxis:{title:'gⁿ mod M'},height:180});}
else{Plotly.newPlot('pprimseq',[{x:[],y:[]}],{...plo(),height:180,annotations:[{text:'Select a primitive root to see power sequence',showarrow:false,font:{size:12,color:'#888'}}]});}

// Table
document.getElementById('tprimT').innerHTML='<tr><th>k</th><th>ord(k)</th><th>Unit?</th><th>Prim Root?</th><th>QR?</th><th>Disc Log</th></tr>'+
elements.slice(0,100).map(e=>`<tr onclick="modal('Element ${e.k} mod ${M}',[['k',${e.k}],['ord(k)',${e.ord}],['Unit',${e.isUnit}],['Prim Root',${e.ord===phi}],['QR',${e.isQR}],['Discrete Log',${e.dlog}]])" style="cursor:pointer;color:${e.ord===phi?'#ffd700':e.isUnit?'inherit':'#666'}"><td>${e.k}</td><td>${e.ord}</td><td>${e.isUnit?'OK':'X'}</td><td>${e.ord===phi?'OK':''}</td><td>${e.isQR?'OK':''}</td><td>${e.dlog>=0?e.dlog:'—'}</td></tr>`).join('');

primRootData={M,phi,g,isPrimRoot,elements,primRoots,maxOrd};

// Click handler
c.onclick=e=>{const rect=c.getBoundingClientRect(),mx=(e.clientX-rect.left)*(c.width/rect.width),my=(e.clientY-rect.top)*(c.height/rect.height);
for(const el of elements){const ang=2*Math.PI*el.k/M-Math.PI/2,px=cx+rad*Math.cos(ang),py=cy+rad*Math.sin(ang);
if(Math.hypot(mx-px,my-py)<ptSz+5){
modal('Element Analysis',[['k',el.k],['Order',el.ord],['Unit',el.isUnit?'Yes':'No'],['Primitive Root',el.ord===phi?'Yes':'No'],['Quadratic Residue',el.isQR?'Yes':'No'],['Discrete Log',el.dlog>=0?el.dlog:'N/A']]);break;}}};}

function csvPrim(){let s='k,order,isUnit,isPrimRoot,isQR,discreteLog\n';for(const e of primRootData.elements||[])s+=`${e.k},${e.ord},${e.isUnit},${e.ord===primRootData.phi},${e.isQR},${e.dlog}\n`;dl(s,'primitive_roots.csv');}

// ==================== FAREY SEQUENCES ====================
let fareyData={seq:[],Q:0};

function setFareyQ(q){document.getElementById('fareyQ').value=Math.min(50,q);document.getElementById('fareyQv').value=q;drawFarey();}

function generateFarey(Q){
const seq=[{p:0,q:1,level:1,value:0}];
for(let q=1;q<=Q;q++){for(let p=0;p<=q;p++){if(gcd(p,q)===1&&!(p===0&&q>1)){
seq.push({p,q,level:q,value:p/q});}}}
seq.sort((a,b)=>a.value-b.value);
// Find neighbors
for(let i=0;i<seq.length;i++){
seq[i].idx=i;
seq[i].left=i>0?seq[i-1]:null;
seq[i].right=i<seq.length-1?seq[i+1]:null;}
return seq;}

function fareyLevel(p,q){return q;}

function mediant(a,b){return{p:a.p+b.p,q:a.q+b.q};}

function highlightFraction(){
const p=+document.getElementById('fareyP').value,q=+document.getElementById('fareyQh').value;
if(q<=0||gcd(p,q)!==1){alert('Enter valid coprime p/q');return;}
const found=fareyData.seq.find(f=>f.p===p&&f.q===q);
if(found){
modal(`Fraction ${p}/${q}`,[
['Value',found.value],['Level (first appears)',found.q],['Index',found.idx],
['Left Neighbor',found.left?`${found.left.p}/${found.left.q}`:'—'],
['Right Neighbor',found.right?`${found.right.p}/${found.right.q}`:'—'],
['Ford Circle Center',`(${p/q}, ${1/(2*q*q)})`],['Ford Circle Radius',1/(2*q*q)]
]);}else{alert(`${p}/${q} not in F_${fareyData.Q} (need q≤${fareyData.Q})`);}drawFarey();}

function drawFarey(){
if(!document.getElementById("cFarey")) return;

const c=document.getElementById('cfarey'),ctx=c.getContext('2d');
const Q=+document.getElementById('fareyQv').value||+document.getElementById('fareyQ').value;
const viz=document.getElementById('fareyViz').value,col=document.getElementById('fareyCol').value;
const ptSz=+document.getElementById('fareySz').value;
const showLabels=document.getElementById('fareyLabels').checked;
const showMediant=document.getElementById('fareyMediant').checked;
const showNeighbor=document.getElementById('fareyNeighbor').checked;
const showGrid=document.getElementById('fareyGrid').checked;
const showCircles=document.getElementById('fareyCircles').checked;
const highlightP=+document.getElementById('fareyP').value,highlightQ=+document.getElementById('fareyQh').value;

ctx.fillStyle=canvBg();ctx.fillRect(0,0,c.width,c.height);
document.getElementById('fareyQdisp').textContent=Q;

// Generate Farey sequence
fareyData.seq=generateFarey(Q);
fareyData.Q=Q;
const seq=fareyData.seq;

const pad=50,w=c.width-2*pad,h=c.height-2*pad;

if(viz==='sequence'){
// Line visualization
if(showGrid){ctx.strokeStyle=gridC();ctx.lineWidth=0.5;
for(let i=0;i<=10;i++){const x=pad+i*w/10;ctx.beginPath();ctx.moveTo(x,pad);ctx.lineTo(x,c.height-pad);ctx.stroke();
ctx.fillStyle=isDark()?'#666':'#999';ctx.font='10px Arial';ctx.textAlign='center';ctx.fillText((i/10).toFixed(1),x,c.height-pad+15);}}
// Real line
ctx.strokeStyle=bordC();ctx.lineWidth=2;ctx.beginPath();ctx.moveTo(pad,c.height/2);ctx.lineTo(c.width-pad,c.height/2);ctx.stroke();
// Points
seq.forEach((f,i)=>{
const x=pad+f.value*w,y=c.height/2;
let clr;
if(col==='denom')clr=`hsl(${f.q/Q*300},80%,50%)`;
else if(col==='level')clr=`hsl(${f.level/Q*300},80%,50%)`;
else if(col==='depth')clr=`hsl(${Math.log2(f.q+1)/Math.log2(Q+1)*300},80%,50%)`;
else if(col==='parent')clr=f.q<=2?'#ffd700':'#00d9ff';
else clr=`hsl(${i/seq.length*360},80%,50%)`;
if(f.p===highlightP&&f.q===highlightQ)clr='#ff006e';
ctx.fillStyle=clr;
const sz=f.p===highlightP&&f.q===highlightQ?ptSz+4:ptSz;
ctx.beginPath();ctx.arc(x,y,sz,0,2*Math.PI);ctx.fill();
// Labels
if(showLabels&&(f.q<=Math.min(8,Q)||f.p===highlightP&&f.q===highlightQ)){
ctx.fillStyle=isDark()?'#fff':'#000';ctx.font='10px Arial';ctx.textAlign='center';
ctx.fillText(`${f.p}/${f.q}`,x,y-ptSz-8);}});}

else if(viz==='ford'){
// Ford circles
const scale=w,ox=pad,oy=c.height-80;
if(showGrid){ctx.strokeStyle=gridC();ctx.lineWidth=0.5;
for(let i=0;i<=10;i++){const x=ox+i*scale/10;ctx.beginPath();ctx.moveTo(x,50);ctx.lineTo(x,oy);ctx.stroke();}}
ctx.strokeStyle=bordC();ctx.lineWidth=2;ctx.beginPath();ctx.moveTo(ox,oy);ctx.lineTo(ox+scale,oy);ctx.stroke();
seq.forEach(f=>{
if(f.q===0)return;
const cx=ox+f.value*scale,r=scale/(2*f.q*f.q);
if(r<1)return;
let clr;
if(col==='denom')clr=`hsla(${f.q/Q*300},70%,50%,0.7)`;
else if(col==='level')clr=`hsla(${f.level/Q*300},70%,50%,0.7)`;
else clr=`hsla(${f.value*360},70%,50%,0.7)`;
if(f.p===highlightP&&f.q===highlightQ)clr='rgba(255,0,110,0.9)';
ctx.strokeStyle=clr;ctx.lineWidth=f.q<=5?2:1;
ctx.beginPath();ctx.arc(cx,oy-r,r,0,2*Math.PI);ctx.stroke();
if(showLabels&&r>10){ctx.fillStyle=isDark()?'#fff':'#000';ctx.font='9px Arial';ctx.textAlign='center';
ctx.fillText(`${f.p}/${f.q}`,cx,oy-2*r-5);}});
// Tangency lines
if(showCircles){ctx.strokeStyle='rgba(255,215,0,0.3)';ctx.lineWidth=1;
for(let i=0;i<seq.length-1;i++){
const a=seq[i],b=seq[i+1];
if(Math.abs(a.p*b.q-b.p*a.q)===1){
const cx1=ox+a.value*scale,r1=scale/(2*a.q*a.q);
const cx2=ox+b.value*scale,r2=scale/(2*b.q*b.q);
ctx.beginPath();ctx.moveTo(cx1,oy-r1);ctx.lineTo(cx2,oy-r2);ctx.stroke();}}}}

else if(viz==='arc'){
// Farey arcs (geodesics in upper half-plane)
const scale=w,ox=pad,oy=c.height-50;
ctx.strokeStyle=bordC();ctx.lineWidth=2;ctx.beginPath();ctx.moveTo(ox,oy);ctx.lineTo(ox+scale,oy);ctx.stroke();
// Draw arcs between neighbors
for(let i=0;i<seq.length-1;i++){
const a=seq[i],b=seq[i+1];
const x1=a.value,x2=b.value;
const mid=(x1+x2)/2,r=Math.abs(x2-x1)/2;
let clr;
if(col==='denom')clr=`hsla(${(a.q+b.q)/2/Q*300},70%,50%,0.6)`;
else clr=`hsla(${i/seq.length*360},70%,50%,0.6)`;
ctx.strokeStyle=clr;ctx.lineWidth=1;
ctx.beginPath();ctx.arc(ox+mid*scale,oy,r*scale,Math.PI,0,true);ctx.stroke();}
// Points on real line
seq.forEach(f=>{
const x=ox+f.value*scale;
ctx.fillStyle=f.p===highlightP&&f.q===highlightQ?'#ff006e':'#ffd700';
ctx.beginPath();ctx.arc(x,oy,3,0,2*Math.PI);ctx.fill();
if(showLabels&&f.q<=6){ctx.fillStyle=isDark()?'#fff':'#000';ctx.font='9px Arial';ctx.textAlign='center';
ctx.fillText(`${f.p}/${f.q}`,x,oy+15);}});}

else if(viz==='tree'){
// Stern-Brocot tree visualization
const levels=Math.min(6,Math.ceil(Math.log2(Q)));
ctx.strokeStyle=gridC();ctx.lineWidth=1;
function drawTree(left,right,depth,x,y,w){
if(depth>levels)return;
const m=mediant(left,right);
if(m.q>Q)return;
const mx=x,my=y;
let clr=`hsl(${depth*50},70%,50%)`;
if(m.p===highlightP&&m.q===highlightQ)clr='#ff006e';
ctx.fillStyle=clr;ctx.beginPath();ctx.arc(mx,my,ptSz+2-depth*0.3,0,2*Math.PI);ctx.fill();
if(showLabels&&depth<=4){ctx.fillStyle=isDark()?'#fff':'#000';ctx.font='10px Arial';ctx.textAlign='center';
ctx.fillText(`${m.p}/${m.q}`,mx,my-10);}
if(depth<levels){
const nextY=my+60;
// Left child
ctx.strokeStyle='rgba(100,200,255,0.4)';ctx.beginPath();ctx.moveTo(mx,my+ptSz);ctx.lineTo(x-w/4,nextY-ptSz);ctx.stroke();
drawTree(left,m,depth+1,x-w/4,nextY,w/2);
// Right child  
ctx.strokeStyle='rgba(255,140,0,0.4)';ctx.beginPath();ctx.moveTo(mx,my+ptSz);ctx.lineTo(x+w/4,nextY-ptSz);ctx.stroke();
drawTree(m,right,depth+1,x+w/4,nextY,w/2);}}
// Root nodes 0/1 and 1/1
ctx.fillStyle='#ffd700';
ctx.beginPath();ctx.arc(pad+w*0.1,60,8,0,2*Math.PI);ctx.fill();
ctx.beginPath();ctx.arc(pad+w*0.9,60,8,0,2*Math.PI);ctx.fill();
ctx.fillStyle=isDark()?'#fff':'#000';ctx.font='12px Arial';ctx.textAlign='center';
ctx.fillText('0/1',pad+w*0.1,45);ctx.fillText('1/1',pad+w*0.9,45);
drawTree({p:0,q:1},{p:1,q:1},1,c.width/2,120,w*0.8);}

else if(viz==='spiral'){
// Farey spiral
const cx=c.width/2,cy=c.height/2,maxR=Math.min(cx,cy)-60;
seq.forEach((f,i)=>{
const theta=f.value*4*Math.PI;
const r=20+i/seq.length*maxR;
const x=cx+r*Math.cos(theta),y=cy+r*Math.sin(theta);
let clr;
if(col==='denom')clr=`hsl(${f.q/Q*300},80%,50%)`;
else clr=`hsl(${i/seq.length*360},80%,50%)`;
ctx.fillStyle=clr;ctx.beginPath();ctx.arc(x,y,ptSz,0,2*Math.PI);ctx.fill();});}

// Mediant lines
if(showMediant&&viz==='sequence'){
ctx.strokeStyle='rgba(255,215,0,0.3)';ctx.lineWidth=1;
for(let i=0;i<seq.length-1;i++){
const m=mediant(seq[i],seq[i+1]);
if(m.q<=Q){const x=pad+m.p/m.q*w;
ctx.beginPath();ctx.moveTo(x,c.height/2-20);ctx.lineTo(x,c.height/2+20);ctx.stroke();}}}

// Stats
const denomCounts={};seq.forEach(f=>{denomCounts[f.q]=(denomCounts[f.q]||0)+1;});
const denomData=Object.entries(denomCounts).sort((a,b)=>+a[0]-+b[0]);

// Error analysis
const fareyTheory=3*Q*Q/(Math.PI*Math.PI);
const fareyError=Math.abs(seq.length-fareyTheory);
const fareyRelError=(fareyError/seq.length)*100;
let fareyReliability='EXCELLENT';
if(fareyRelError>0.5)fareyReliability='VERY GOOD';
if(fareyRelError>1)fareyReliability='GOOD';
if(fareyRelError>3)fareyReliability='FAIR';
if(fareyRelError>8)fareyReliability='POOR';
const fareyCi95=Math.ceil(1.96*Math.sqrt(seq.length));

// Sector counts
const sectorCounts={};
for(let n=1;n<=Math.min(Q,15);n++)sectorCounts[n]=0;
seq.forEach(f=>{
  for(let n=1;n<=Math.min(Q,15);n++){
    if(f.value>1/(n+1)&&f.value<=1/n){sectorCounts[n]++;break;}
  }
});

// Live stats
document.getElementById('fareyLiveStats').innerHTML=`
<div style="display:grid;grid-template-columns:repeat(3,1fr);gap:8px;margin-bottom:12px">
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center"><div style="font-size:1.4rem;font-weight:bold;color:#00d9ff">${Q}</div><div style="font-size:.7rem;color:var(--txt2)">MAX DENOM Q</div></div>
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center"><div style="font-size:1.4rem;font-weight:bold;color:#ffd700">${seq.length}</div><div style="font-size:.7rem;color:var(--txt2)">|F_Q| OBSERVED</div></div>
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center"><div style="font-size:1.4rem;font-weight:bold;color:#00ff88">${fmt(fareyTheory)}</div><div style="font-size:.7rem;color:var(--txt2)">THEORY 3Q²/π²</div></div>
</div>
<div style="background:rgba(0,200,255,.1);padding:8px;border-radius:6px;margin-bottom:10px;border:1px solid rgba(0,200,255,.3)">
<strong style="color:#00d9ff;font-size:.8rem">Error Bounds Analysis</strong>
<div style="display:grid;grid-template-columns:repeat(4,1fr);gap:4px;margin-top:6px;font-size:.7rem">
<div style="background:var(--bg1);padding:4px;border-radius:3px;text-align:center"><span style="color:var(--txt2)">Abs Err:</span> <strong style="color:#ffd700">${fmt(fareyError)}</strong></div>
<div style="background:var(--bg1);padding:4px;border-radius:3px;text-align:center"><span style="color:var(--txt2)">Rel Err:</span> <strong style="color:${fareyRelError<1?'#00ff88':fareyRelError<3?'#ffd700':'#ff8c00'}">${fmt(fareyRelError)}%</strong></div>
<div style="background:var(--bg1);padding:4px;border-radius:3px;text-align:center"><span style="color:var(--txt2)">95% CI:</span> <strong style="color:#9664ff">±${fareyCi95}</strong></div>
<div style="background:var(--bg1);padding:4px;border-radius:3px;text-align:center"><span style="color:var(--txt2)">Rating:</span> <strong style="color:${fareyReliability==='EXCELLENT'||fareyReliability==='VERY GOOD'?'#00ff88':'#ffd700'}">${fareyReliability}</strong></div>
</div>
</div>
<div style="background:rgba(150,100,255,.1);padding:8px;border-radius:6px;margin-bottom:10px;border:1px solid rgba(150,100,255,.3)">
<strong style="color:#9664ff;font-size:.8rem">Sector Distribution S<sub>n</sub> = (1/(n+1), 1/n)</strong>
<div style="display:flex;flex-wrap:wrap;gap:3px;margin-top:6px;font-size:.6rem">
${[1,2,3,4,5,6].filter(n=>sectorCounts[n]>0||n<=3).map(n=>{
  const asymp=3*Q*Q/(Math.PI*Math.PI*n*(n+1));
  const err=sectorCounts[n]>0?Math.abs(100*(sectorCounts[n]-asymp)/sectorCounts[n]):0;
  return `<span style="background:rgba(255,255,255,.05);padding:2px 4px;border-radius:3px" title="Asymp: ${asymp.toFixed(1)}">S<sub>${n}</sub>: <strong style="color:hsl(${n*50},70%,60%)">${sectorCounts[n]}</strong></span>`;
}).join('')}
</div>
</div>
<div style="margin-bottom:10px;padding-bottom:8px;border-bottom:1px solid var(--bord)">
<strong style="color:var(--acc)">Sequence Properties</strong>
<div style="display:grid;grid-template-columns:1fr 1fr;gap:3px;margin-top:5px;font-size:.8rem">
<span>Σφ(k) for k≤Q:</span><span style="color:#9664ff">${seq.length-1}</span>
<span>Error formula:</span><span style="color:#888">O(Q log Q)</span>
</div>
</div>
<div style="margin-bottom:10px;padding-bottom:8px;border-bottom:1px solid var(--bord)">
<strong style="color:var(--acc)">Visualization</strong>
<div style="display:grid;grid-template-columns:1fr 1fr;gap:3px;margin-top:5px;font-size:.8rem">
<span>Mode:</span><span style="color:var(--txt)">${viz}</span>
<span>Color:</span><span style="color:var(--txt)">${col}</span>
<span>Point Size:</span><span style="color:var(--txt)">${ptSz}px</span>
<span>Labels:</span><span style="color:var(--txt)">${showLabels?'On':'Off'}</span>
</div>
</div>
<div>
<strong style="color:var(--acc)">Key Facts</strong>
<div style="margin-top:5px;font-size:.75rem;line-height:1.5;color:var(--txt2)">
• Neighbors p/q, r/s satisfy |ps-qr|=1<br>
• Mediant (p+r)/(q+s) lies between<br>
• Ford circles tangent  neighbors<br>
• |F_Q| = 1 + Σφ(k) ≈ 3Q²/π²
</div>
</div>`;

// Growth chart
const growthX=[],growthY=[],growthTh=[];
for(let q=1;q<=Q;q++){growthX.push(q);growthY.push(generateFarey(q).length);growthTh.push(1+3*q*q/(Math.PI*Math.PI));}
Plotly.newPlot('pfareyGrowth',[
{x:growthX,y:growthY,name:'|F_Q|',mode:'lines+markers',line:{color:'#00d9ff',width:2},marker:{size:4}},
{x:growthX,y:growthTh,name:'3Q²/π²',mode:'lines',line:{color:'#ff8c00',dash:'dash'}}
],{...plo(),xaxis:{title:'Q'},yaxis:{title:'|F_Q|'},height:180});

// Denominator distribution
Plotly.newPlot('pfareyDenom',[{x:denomData.map(d=>d[0]),y:denomData.map(d=>d[1]),type:'bar',marker:{color:denomData.map(d=>`hsl(${+d[0]/Q*300},70%,50%)`)}}],{...plo(),xaxis:{title:'Denominator q'},yaxis:{title:'Count φ(q)'},height:180});

// Legend and stats bar
legend('alfarey','Farey F_'+Q,[]);
document.getElementById('stfarey').innerHTML='';

// Table
document.getElementById('tfareyT').innerHTML='<tr><th>Index</th><th>p/q</th><th>Value</th><th>Level</th><th>Left</th><th>Right</th></tr>'+
seq.slice(0,80).map(f=>`<tr onclick="modal('${f.p}/${f.q}',[['Value',${f.value}],['First appears in F_',${f.q}],['Index',${f.idx}],['Left','${f.left?f.left.p+'/'+f.left.q:'—'}'],['Right','${f.right?f.right.p+'/'+f.right.q:'—'}'],['Ford radius',${1/(2*f.q*f.q)}]])" style="cursor:pointer;color:${f.p===highlightP&&f.q===highlightQ?'#ff006e':'inherit'}"><td>${f.idx}</td><td>${f.p}/${f.q}</td><td>${f.value.toFixed(6)}</td><td>F_${f.q}</td><td>${f.left?f.left.p+'/'+f.left.q:'—'}</td><td>${f.right?f.right.p+'/'+f.right.q:'—'}</td></tr>`).join('');

// Click handler
c.onclick=e=>{const rect=c.getBoundingClientRect(),mx=(e.clientX-rect.left)*(c.width/rect.width),my=(e.clientY-rect.top)*(c.height/rect.height);
if(viz==='sequence'){
const y0=c.height/2;
for(const f of seq){const x=pad+f.value*w;
if(Math.hypot(mx-x,my-y0)<ptSz+5){
modal(`Fraction ${f.p}/${f.q}`,[['Value',f.value],['Level',f.q],['Index',f.idx],['Left',f.left?f.left.p+'/'+f.left.q:'—'],['Right',f.right?f.right.p+'/'+f.right.q:'—'],['Ford Center',`(${f.value.toFixed(4)}, ${(1/(2*f.q*f.q)).toFixed(6)})`],['Ford Radius',(1/(2*f.q*f.q)).toFixed(6)]]);break;}}}};}

function csvFarey(){let s='index,p,q,value,level,left_p,left_q,right_p,right_q\n';
for(const f of fareyData.seq)s+=`${f.idx},${f.p},${f.q},${f.value},${f.q},${f.left?f.left.p:''},${f.left?f.left.q:''},${f.right?f.right.p:''},${f.right?f.right.q:''}\n`;
dl(s,'farey.csv');}

async function screenshotFarey(){
const Q=document.getElementById('fareyQv').value,viz=document.getElementById('fareyViz').value;
await screenshotUnified('cfarey','fareyLiveStats',`Farey Sequence F_${Q} — ${viz} view`,'farey_complete.png',{dashH:300});
}

// ==================== END FAREY ====================

async function screenshotPrim(){
const M=document.getElementById('mprimv').value;
await screenshotUnified('cprim','primLiveStats',`Primitive Roots & Cyclic Structure (ℤ/${M}ℤ)×`,'primitive_roots_complete.png',{dashH:320});
}

// ========== ENHANCED MODULAR LIFTING RINGS ==========
let enhAnimating=false;
// enhAnimFrame already declared at script start
let enhAnimTimer=null;
// enhRingsData already declared at script start

// Audio context for enhanced modular harmonic analysis
let enhAudioCtx=null;
let enhOscPlaying=null;
let enhGainPlaying=null;
let enhSBPath=[];  // Stern-Brocot path for audio playback

function initEnhAudio(){
  if(!enhAudioCtx){
    enhAudioCtx=new(window.AudioContext||window.webkitAudioContext)();
  }
  // Resume audio context if suspended (browser autoplay policy)
  if(enhAudioCtx.state==='suspended'){enhAudioCtx.resume();}
  return enhAudioCtx;
}

// Get volume from input fields - returns gain value (0.0 to 10.0+)
function getEnhVolume(){
  const volInput=parseFloat(document.getElementById('enhVolInput')?.value)||parseFloat(document.getElementById('enhAudioVol')?.value)||500;
  return Math.max(0.01, volInput/250); // 500 = 2.0 gain, 1000 = 4.0 gain, more audible
}

function playEnhFrequency(freq,dur){
  const ctx=initEnhAudio();
  if(enhOscPlaying){try{enhOscPlaying.stop();}catch(e){}}
  
  const wave=document.getElementById('enhAudioWave')?.value||'sine';
  const volume=getEnhVolume();
  dur=dur||parseFloat(document.getElementById('enhAudioDur')?.value||'0.3');
  
  const osc=ctx.createOscillator();
  const gain=ctx.createGain();
  osc.frequency.value=Math.max(20,Math.min(20000,freq));
  osc.type=wave;
  osc.connect(gain);
  gain.connect(ctx.destination);
  gain.gain.setValueAtTime(volume,ctx.currentTime);
  gain.gain.exponentialRampToValueAtTime(0.001,ctx.currentTime+dur);
  osc.start(ctx.currentTime);
  osc.stop(ctx.currentTime+dur);
  enhOscPlaying=osc;
  enhGainPlaying=gain;
  
  const status=document.getElementById('enhAudioStatus');
  if(status){status.textContent='Playing: '+freq.toFixed(1)+'Hz';setTimeout(()=>status.textContent='',dur*1000+100);}
}

function playEnhFreq(p,q){
  const baseFreq=parseFloat(document.getElementById('enhBaseFreq')?.value||440);
  const detuneRatio=typeof getEnhDetuneRatio==='function'?getEnhDetuneRatio():1;
  playEnhFrequency(baseFreq*p/q*detuneRatio);
}

function applyEnhFreqPreset(){
  const sel=document.getElementById('enhFreqPreset');
  if(!sel||!sel.value)return;
  const freq=parseFloat(sel.value);
  const input=document.getElementById('enhBaseFreq');
  if(input)input.value=freq;
  sel.value='';
  // Play the base frequency to hear it
  playEnhFrequency(freq);
}

function playEnhPath(reverse=false){
  if(!enhSBPath||enhSBPath.length<2){
    const status=document.getElementById('enhAudioStatus');
    if(status)status.textContent='No path. Click a point first!';
    return;
  }
  const baseFreq=parseFloat(document.getElementById('enhBaseFreq')?.value||440);
  const noteDur=parseFloat(document.getElementById('enhAudioDur')?.value||'0.3');
  const arpSpeed=parseInt(document.getElementById('enhArpSpeed')?.value||150);
  const detuneRatio=typeof getEnhDetuneRatio==='function'?getEnhDetuneRatio():1;
  const path=reverse?[...enhSBPath].reverse():enhSBPath;
  let delay=0;
  path.forEach((node,i)=>{
    setTimeout(()=>{
      playEnhFrequency(baseFreq*node.p/node.q*detuneRatio,noteDur*0.8);
    },delay);
    delay+=arpSpeed;
  });
  const status=document.getElementById('enhAudioStatus');
  if(status){status.textContent=`Playing path ${reverse?'(reverse) ':''}(${path.length} notes)...`;}
}

function playEnhScale(type){
  const baseFreq=parseFloat(document.getElementById('enhBaseFreq')?.value||440);
  const noteDur=parseFloat(document.getElementById('enhAudioDur')?.value||'0.3');
  const arpSpeed=parseInt(document.getElementById('enhArpSpeed')?.value||150);
  const detuneRatio=typeof getEnhDetuneRatio==='function'?getEnhDetuneRatio():1;
  let ratios=[];
  if(type==='major'){ratios=[[1,1],[9,8],[5,4],[4,3],[3,2],[5,3],[15,8],[2,1]];}
  else if(type==='minor'){ratios=[[1,1],[9,8],[6,5],[4,3],[3,2],[8,5],[9,5],[2,1]];}
  else if(type==='farey'){ratios=[[1,5],[1,4],[1,3],[2,5],[1,2],[3,5],[2,3],[3,4],[4,5],[1,1]];}
  let delay=0;
  ratios.forEach(([p,q])=>{
    setTimeout(()=>playEnhFrequency(baseFreq*p/q*detuneRatio,noteDur*0.8),delay);
    delay+=arpSpeed;
  });
  const status=document.getElementById('enhAudioStatus');
  if(status){status.textContent='Playing '+type+' scale...';}
}

// Manual fraction selection - auto-adjusts sector and updates tree
function selectEnhFraction(autoPlay=false){
  const p=parseInt(document.getElementById('enhManualP')?.value)||0;
  const q=parseInt(document.getElementById('enhManualQ')?.value)||1;
  const result=document.getElementById('enhManualResult');
  
  if(q<=0){if(result)result.innerHTML='<span style="color:#ff6496">Invalid: q must be > 0</span>';return;}
  
  const g=gcd(p,q);
  const rp=p/g,rq=q/g;
  const frac=rp/rq;
  
  if(frac<=0||frac>=1){
    if(result)result.innerHTML=`<span style="color:#ff6496">${rp}/${rq} = ${frac.toFixed(4)} must be in (0,1)</span>`;
    return;
  }
  
  // Find appropriate sector: 1/(n+1) < frac < 1/n
  let sectorN=Math.floor(1/frac);
  if(frac===1/sectorN)sectorN++;  // Edge case: exactly on boundary
  const fromN=sectorN+1;
  const toN=sectorN;
  
  // Update sector controls
  const sectorFrom=document.getElementById('enhSectorFrom');
  const sectorTo=document.getElementById('enhSectorTo');
  if(sectorFrom)sectorFrom.value=fromN;
  if(sectorTo)sectorTo.value=toN;
  
  // Update sector and redraw
  updateEnhSector();
  
  // Highlight in tree - this also populates enhSBPath
  highlightInSBTree(rp,rq);
  
  // Update result display
  const baseFreq=parseFloat(document.getElementById('enhBaseFreq')?.value||440);
  const freq=baseFreq*rp/rq;
  const musName=getEnhMusicalName(rp,rq);
  const pathLen=enhSBPath?.length||0;
  
  // Find Farey neighbors
  const neighbors=findEnhFareyNeighbors(rp,rq);
  updateEnhFareyNeighborLegend(rp,rq,neighbors);
  
  let html=`<span style="color:#00ff88">${rp}/${rq}</span> → Sector S<sub>${sectorN}</sub> (1/${fromN} – 1/${toN})`;
  html+=` | <span style="color:#ffd700">${freq.toFixed(1)}Hz</span>`;
  if(musName)html+=` | <span style="color:#00d9ff">${musName}</span>`;
  html+=` | Path: ${pathLen} nodes`;
  html+=` | <span style="color:#ff6496">${neighbors.length} neighbors</span>`;
  if(result)result.innerHTML=html;
  
  // Play single note
  playEnhFrequency(freq);
  
  // If autoPlay, play the full path after a short delay
  if(autoPlay && pathLen>1){
    setTimeout(()=>playEnhPath(),500);
  }
  
  // Simulate point selection for canvas highlight
  enhSelectedPoint={
    residue:rp,
    mod:rq,
    isCoprime:true,
    reducedFrac:`${rp}/${rq}`,
    gcd:1,
    fareyNeighbors:neighbors
  };
  drawEnhanced();
}

function selectAndPlayEnhFraction(){
  selectEnhFraction(true);
}

// Quick sector preset dropdown
function applyQuickSector(){
  const sel=document.getElementById('enhQuickSector');
  if(!sel||!sel.value)return;
  
  const[from,to]=sel.value.split(',').map(Number);
  const sectorFrom=document.getElementById('enhSectorFrom');
  const sectorTo=document.getElementById('enhSectorTo');
  if(sectorFrom)sectorFrom.value=from;
  if(sectorTo)sectorTo.value=to;
  
  updateEnhSector();
  
  // Reset dropdown
  sel.value='';
  
  const result=document.getElementById('enhManualResult');
  if(result)result.innerHTML=`<span style="color:#9664ff">Sector set to 1/${from} – 1/${to}</span>`;
}

// Farey fraction preset dropdown
function applyFareyPreset(){
  const sel=document.getElementById('enhFareyPreset');
  if(!sel||!sel.value)return;
  
  const[p,q]=sel.value.split(',').map(Number);
  const manP=document.getElementById('enhManualP');
  const manQ=document.getElementById('enhManualQ');
  if(manP)manP.value=p;
  if(manQ)manQ.value=q;
  
  // Reset dropdown and select the fraction
  sel.value='';
  selectEnhFraction(false);
}

// Resize Stern-Brocot tree canvas
function resizeSBTreeCanvas(){
  const sel=document.getElementById('enhTreeCanvSz');
  if(!sel)return;
  const[w,h]=sel.value.split(',').map(Number);
  const c=document.getElementById('cSternBrocot');
  if(c){
    c.width=w;
    c.height=h;
    drawSternBrocotTree(window.enhSBTreeBounds?.fromN||3,window.enhSBTreeBounds?.toN||2);
  }
}

// Find Farey neighbors for a fraction p/q
// Neighbors satisfy |p₁q₂ - p₂q₁| = 1
function findEnhFareyNeighbors(p,q,maxQ=50){
  const neighbors=[];
  const g=gcd(p,q);
  const rp=p/g,rq=q/g;
  
  // Search in tree nodes if available
  if(window.enhSBTreeNodes&&window.enhSBTreeNodes.length>0){
    window.enhSBTreeNodes.forEach(node=>{
      if(node.p===rp&&node.q===rq)return; // Skip self
      const det=Math.abs(rp*node.q-node.p*rq);
      if(det===1){
        neighbors.push({p:node.p,q:node.q,inTree:true});
      }
    });
  }
  
  // Also search in rings data for more neighbors
  if(enhRingsData&&enhRingsData.length>0){
    enhRingsData.forEach(ring=>{
      ring.coprimes.forEach(r=>{
        const[np,nq]=reduceFrac(r,ring.mod);
        if(np===rp&&nq===rq)return; // Skip self
        if(nq>maxQ)return; // Skip large denominators
        const det=Math.abs(rp*nq-np*rq);
        if(det===1){
          // Check if already in list
          if(!neighbors.some(n=>n.p===np&&n.q===nq)){
            neighbors.push({p:np,q:nq,inTree:false,mod:ring.mod});
          }
        }
      });
    });
  }
  
  // Sort by q then p
  neighbors.sort((a,b)=>a.q-b.q||a.p-b.p);
  return neighbors;
}

// Update Farey neighbor legend display
function updateEnhFareyNeighborLegend(p,q,neighbors){
  const legend=document.getElementById('enhFareyNeighborLegend');
  const countEl=document.getElementById('enhFareyNeighborCount');
  const listEl=document.getElementById('enhFareyNeighborList');
  
  if(!legend||!countEl||!listEl)return;
  
  if(!neighbors||neighbors.length===0){
    legend.style.display='none';
    return;
  }
  
  legend.style.display='block';
  countEl.textContent=`${neighbors.length} neighbor${neighbors.length!==1?'s':''}`;
  
  // Show up to 20 neighbors
  const shown=neighbors.slice(0,20);
  const baseFreq=parseFloat(document.getElementById('enhBaseFreq')?.value||440);
  
  listEl.innerHTML=shown.map(n=>{
    const freq=(baseFreq*n.p/n.q).toFixed(1);
    const inTreeMark=n.inTree?'':'';
    const clr=n.inTree?'#00ff88':'#ff6496';
    return `<span onclick="selectNeighborFraction(${n.p},${n.q})" style="padding:2px 6px;background:rgba(255,100,150,.15);border:1px solid ${clr};border-radius:3px;cursor:pointer;color:${clr};font-size:.7rem" title="${freq}Hz">${inTreeMark}${n.p}/${n.q}</span>`;
  }).join('');
  
  if(neighbors.length>20){
    listEl.innerHTML+=`<span style="color:var(--txt2);font-size:.65rem;padding:2px 4px">+${neighbors.length-20} more</span>`;
  }
}

// Click on a neighbor to select it
function selectNeighborFraction(p,q){
  const manP=document.getElementById('enhManualP');
  const manQ=document.getElementById('enhManualQ');
  if(manP)manP.value=p;
  if(manQ)manQ.value=q;
  selectEnhFraction(false);
}

// Harmonic color based on denominator q (musical consonance)
// ============================================================
// COMPREHENSIVE HARMONIC ANALYSIS SYSTEM
// ============================================================

// Multi-select for chord building
let enhChordSelection = [];
let enhChordMode = false;

// === CONSONANCE METRICS ===

// Tenney Height: log₂(p) + log₂(q) - measures interval complexity
function tenneyHeight(p, q) {
  const g = gcd(p, q);
  const rp = p / g, rq = q / g;
  return Math.log2(rp) + Math.log2(rq);
}

// Benedetti Height: p × q - simpler multiplicative complexity
function benedettiHeight(p, q) {
  const g = gcd(p, q);
  return (p / g) * (q / g);
}

// Euler's Gradus Suavitatis - classical consonance measure
// Based on prime factorization: Γ(n) = 1 + Σ(eᵢ × (pᵢ - 1))
function eulerGradus(n) {
  if (n <= 1) return 1;
  let gradus = 1;
  let temp = n;
  for (let p = 2; p * p <= temp; p++) {
    while (temp % p === 0) {
      gradus += (p - 1);
      temp /= p;
    }
  }
  if (temp > 1) gradus += (temp - 1);
  return gradus;
}

function eulerGradusInterval(p, q) {
  const g = gcd(p, q);
  // Euler's formula for interval p/q: Γ(p) + Γ(q) - 1
  return eulerGradus(p / g) + eulerGradus(q / g) - 1;
}

// Harmonic Entropy approximation (Erlich model)
// Lower values = more consonant (near simple ratios)
function harmonicEntropy(p, q) {
  const g = gcd(p, q);
  const rp = p / g, rq = q / g;
  const ratio = rp / rq;
  
  // Check proximity to simple ratios (1-9 limit)
  const simpleRatios = [
    [1,1],[2,1],[3,2],[4,3],[5,4],[6,5],[5,3],[8,5],[9,8],
    [3,1],[4,1],[5,2],[7,4],[7,5],[8,7],[9,5],[7,6]
  ];
  
  let minDist = 1;
  simpleRatios.forEach(([a, b]) => {
    const dist = Math.abs(ratio - a/b);
    if (dist < minDist) minDist = dist;
  });
  
  // Entropy increases with distance from simple ratios and complexity
  const complexity = Math.log2(rp * rq);
  return minDist * 100 + complexity * 0.5;
}

// === CENTS CONVERSION ===

// Cents: 1200 × log₂(ratio) - standard musical measurement
function ratioToCents(p, q) {
  return 1200 * Math.log2(p / q);
}

function centsToRatio(cents) {
  return Math.pow(2, cents / 1200);
}

// === PRIME LIMIT DETECTION ===

// Get prime factorization
function primeFactors(n) {
  const factors = {};
  let temp = Math.abs(n);
  for (let p = 2; p * p <= temp; p++) {
    while (temp % p === 0) {
      factors[p] = (factors[p] || 0) + 1;
      temp /= p;
    }
  }
  if (temp > 1) factors[temp] = 1;
  return factors;
}

// Get highest prime in factorization (prime limit)
function primeLimit(p, q) {
  const g = gcd(p, q);
  const rp = p / g, rq = q / g;
  const pFactors = primeFactors(rp);
  const qFactors = primeFactors(rq);
  const allPrimes = [...new Set([...Object.keys(pFactors), ...Object.keys(qFactors)])].map(Number);
  return allPrimes.length > 0 ? Math.max(...allPrimes) : 1;
}

// Check if interval is within a given prime limit
function isWithinPrimeLimit(p, q, limit) {
  return primeLimit(p, q) <= limit;
}

// Prime limit names
const primeLimitNames = {
  2: '2-limit (Octaves)',
  3: '3-limit (Pythagorean)',
  5: '5-limit (Just)',
  7: '7-limit (Septimal)',
  11: '11-limit (Undecimal)',
  13: '13-limit (Tridecimal)'
};

// === INTERVAL CLASSIFICATION ===

// Comprehensive interval database with names and properties
const enhMusicalIntervals = {
  // Unisons and octaves
  '1,1': {name: 'Unison', cents: 0, limit: 2, consonance: 'perfect'},
  '2,1': {name: 'Octave', cents: 1200, limit: 2, consonance: 'perfect'},
  '4,1': {name: 'Double Octave', cents: 2400, limit: 2, consonance: 'perfect'},
  '3,1': {name: '12th (Oct+5th)', cents: 1902, limit: 3, consonance: 'perfect'},
  
  // Pythagorean (3-limit)
  '3,2': {name: 'Perfect Fifth', cents: 702, limit: 3, consonance: 'perfect'},
  '4,3': {name: 'Perfect Fourth', cents: 498, limit: 3, consonance: 'perfect'},
  '9,8': {name: 'Major Tone', cents: 204, limit: 3, consonance: 'dissonant'},
  '27,16': {name: 'Pythagorean Maj 6th', cents: 906, limit: 3, consonance: 'imperfect'},
  '32,27': {name: 'Pythagorean Min 3rd', cents: 294, limit: 3, consonance: 'imperfect'},
  
  // Just (5-limit)  
  '5,4': {name: 'Major 3rd', cents: 386, limit: 5, consonance: 'imperfect'},
  '6,5': {name: 'Minor 3rd', cents: 316, limit: 5, consonance: 'imperfect'},
  '5,3': {name: 'Major 6th', cents: 884, limit: 5, consonance: 'imperfect'},
  '8,5': {name: 'Minor 6th', cents: 814, limit: 5, consonance: 'imperfect'},
  '10,9': {name: 'Minor Tone', cents: 182, limit: 5, consonance: 'dissonant'},
  '16,15': {name: 'Just Semitone', cents: 112, limit: 5, consonance: 'dissonant'},
  '15,8': {name: 'Major 7th', cents: 1088, limit: 5, consonance: 'dissonant'},
  '9,5': {name: 'Minor 7th', cents: 1018, limit: 5, consonance: 'dissonant'},
  '25,24': {name: 'Chromatic Semitone', cents: 71, limit: 5, consonance: 'dissonant'},
  '81,80': {name: 'Syntonic Comma', cents: 22, limit: 5, consonance: 'comma'},
  '5,2': {name: 'Major 10th', cents: 1586, limit: 5, consonance: 'imperfect'},
  '45,32': {name: 'Tritone (Aug 4th)', cents: 590, limit: 5, consonance: 'dissonant'},
  
  // Septimal (7-limit)
  '7,4': {name: 'Septimal Min 7th', cents: 969, limit: 7, consonance: 'imperfect'},
  '8,7': {name: 'Septimal Maj 2nd', cents: 231, limit: 7, consonance: 'dissonant'},
  '7,6': {name: 'Septimal Min 3rd', cents: 267, limit: 7, consonance: 'imperfect'},
  '9,7': {name: 'Septimal Maj 3rd', cents: 435, limit: 7, consonance: 'imperfect'},
  '7,5': {name: 'Septimal Tritone', cents: 583, limit: 7, consonance: 'dissonant'},
  '10,7': {name: 'Septimal Tritone', cents: 617, limit: 7, consonance: 'dissonant'},
  '12,7': {name: 'Septimal Maj 6th', cents: 933, limit: 7, consonance: 'imperfect'},
  '14,9': {name: 'Septimal Min 6th', cents: 765, limit: 7, consonance: 'imperfect'},
  '21,16': {name: 'Narrow 4th', cents: 471, limit: 7, consonance: 'dissonant'},
  '64,63': {name: 'Septimal Comma', cents: 27, limit: 7, consonance: 'comma'},
  
  // Undecimal (11-limit)
  '11,8': {name: 'Undecimal Tritone', cents: 551, limit: 11, consonance: 'neutral'},
  '11,9': {name: 'Undecimal Neutral 3rd', cents: 347, limit: 11, consonance: 'neutral'},
  '12,11': {name: 'Undecimal Neutral 2nd', cents: 151, limit: 11, consonance: 'neutral'},
  '11,6': {name: 'Undecimal Neutral 7th', cents: 1049, limit: 11, consonance: 'neutral'},
  '11,10': {name: 'Ptolemaic Semitone', cents: 165, limit: 11, consonance: 'dissonant'},
  
  // Tridecimal (13-limit)
  '13,8': {name: 'Tridecimal Neutral 6th', cents: 841, limit: 13, consonance: 'neutral'},
  '16,13': {name: 'Tridecimal Neutral 3rd', cents: 359, limit: 13, consonance: 'neutral'},
  '13,12': {name: 'Tridecimal 2/3-tone', cents: 139, limit: 13, consonance: 'dissonant'},
  '14,13': {name: 'Tridecimal 2/3-tone', cents: 128, limit: 13, consonance: 'dissonant'}
};

function getEnhMusicalName(p, q) {
  const g = gcd(p, q);
  const rp = p / g, rq = q / g;
  const key = rp + ',' + rq;
  const interval = enhMusicalIntervals[key];
  return interval ? interval.name : null;
}

function getEnhIntervalInfo(p, q) {
  const g = gcd(p, q);
  const rp = p / g, rq = q / g;
  const key = rp + ',' + rq;
  
  if (enhMusicalIntervals[key]) {
    return enhMusicalIntervals[key];
  }
  
  // Generate info for unlisted intervals
  return {
    name: null,
    cents: ratioToCents(rp, rq),
    limit: primeLimit(rp, rq),
    consonance: categorizeConsonance(rp, rq)
  };
}

function categorizeConsonance(p, q) {
  const tenney = tenneyHeight(p, q);
  if (tenney < 2) return 'perfect';
  if (tenney < 4) return 'imperfect';
  if (tenney < 6) return 'dissonant';
  return 'complex';
}

// === COLOR SCHEMES ===

// Color by harmonic quality (denominator q)
function getEnhHarmonicColor(q, dk) {
  if (q === 1) return '#ffd700';  // Unison - gold
  const comp = Math.log2(q);
  if (comp <= 2) return dk ? '#00ff88' : '#00cc44';  // Consonant (q≤4)
  if (comp <= 3) return dk ? '#00d9ff' : '#0099ff';  // Fairly consonant (q≤8)
  if (comp <= 4) return dk ? '#9664ff' : '#7733ff';  // Complex (q≤16)
  return dk ? '#ff6496' : '#ff3366';  // Dissonant (q>16)
}

// Color by prime limit
function getEnhPrimeLimitColor(p, q, dk) {
  const limit = primeLimit(p, q);
  if (limit <= 2) return '#ffd700';      // 2-limit: gold
  if (limit <= 3) return '#00ff88';      // 3-limit: green (Pythagorean)
  if (limit <= 5) return '#00d9ff';      // 5-limit: cyan (Just)
  if (limit <= 7) return '#9664ff';      // 7-limit: purple (Septimal)
  if (limit <= 11) return '#ff6496';     // 11-limit: pink
  return dk ? '#ff8800' : '#cc6600';     // Higher: orange
}

// Color by Tenney height (complexity)
function getEnhTenneyColor(p, q, dk) {
  const tenney = tenneyHeight(p, q);
  if (tenney < 1) return '#ffd700';       // Very simple
  if (tenney < 2) return '#00ff88';       // Simple
  if (tenney < 3.5) return '#00d9ff';     // Moderate
  if (tenney < 5) return '#9664ff';       // Complex
  if (tenney < 7) return '#ff6496';       // Very complex
  return dk ? '#666' : '#999';            // Extremely complex
}

// Color by consonance type
function getEnhConsonanceColor(p, q, dk) {
  const cons = categorizeConsonance(p, q);
  switch(cons) {
    case 'perfect': return '#ffd700';
    case 'imperfect': return '#00ff88';
    case 'dissonant': return '#ff6496';
    default: return dk ? '#666' : '#999';
  }
}

// === BEAT FREQUENCY ===

// Calculate beat frequency between two tones
function beatFrequency(freq1, freq2) {
  return Math.abs(freq1 - freq2);
}

// Roughness estimate (Plomp-Levelt model simplified)
function roughness(freq1, freq2) {
  const beatFreq = Math.abs(freq1 - freq2);
  const avgFreq = (freq1 + freq2) / 2;
  const criticalBandwidth = 25 + 75 * Math.pow(1 + 1.4 * (avgFreq / 1000) * (avgFreq / 1000), 0.69);
  const x = beatFreq / criticalBandwidth;
  return x * Math.exp(1 - x);
}

// === CHORD FUNCTIONS ===

function toggleEnhChordMode() {
  enhChordMode = !enhChordMode;
  const btn = document.getElementById('enhChordModeBtn');
  if (btn) {
    btn.style.background = enhChordMode ? 'rgba(0,255,136,.3)' : 'rgba(255,215,0,.1)';
    btn.style.borderColor = enhChordMode ? '#00ff88' : '#ffd700';
    btn.textContent = enhChordMode ? ' Chord Mode ON' : ' Chord Mode';
  }
  if (!enhChordMode) {
    enhChordSelection = [];
    updateEnhChordDisplay();
  }
}

function addToEnhChord(p, q) {
  const g = gcd(p, q);
  const rp = p / g, rq = q / g;
  
  // Check if already in chord
  const exists = enhChordSelection.find(c => c.p === rp && c.q === rq);
  if (!exists) {
    enhChordSelection.push({p: rp, q: rq});
    updateEnhChordDisplay();
  }
}

function removeFromEnhChord(index) {
  enhChordSelection.splice(index, 1);
  updateEnhChordDisplay();
}

function clearEnhChord() {
  enhChordSelection = [];
  stopEnhChord();
  updateEnhChordDisplay();
}

function updateEnhChordDisplay() {
  const display = document.getElementById('enhChordDisplay');
  if (!display) return;
  
  if (enhChordSelection.length === 0) {
    display.innerHTML = '<span style="color:var(--txt2)">No notes selected</span>';
    return;
  }
  
  const baseFreq = parseFloat(document.getElementById('enhBaseFreq')?.value || 440);
  const detuneCents = parseFloat(document.getElementById('enhDetune')?.value || 0);
  const detuneRatio = Math.pow(2, detuneCents / 1200);
  
  let html = enhChordSelection.map((c, i) => {
    const freq = (baseFreq * c.p / c.q * detuneRatio).toFixed(1);
    const name = getEnhMusicalName(c.p, c.q) || '';
    return `<span style="background:rgba(0,217,255,.2);padding:2px 6px;border-radius:3px;margin:2px;display:inline-flex;align-items:center;gap:4px">
      <span style="color:#ffd700">${c.p}/${c.q}</span>
      <span style="color:#00d9ff;font-size:.7rem">${freq}Hz</span>
      ${name ? `<span style="color:#00ff88;font-size:.65rem">${name}</span>` : ''}
      <button onclick="removeFromEnhChord(${i})" style="background:none;border:none;color:#ff6496;cursor:pointer;font-size:.8rem;padding:0 2px">×</button>
    </span>`;
  }).join('');
  
  display.innerHTML = html;
}

// Store active oscillators for stopping
let enhActiveOscs = [];
let enhArpLoopId = null;

function stopEnhChord() {
  enhActiveOscs.forEach(osc => {
    try { osc.stop(); } catch(e) {}
  });
  enhActiveOscs = [];
  if (enhArpLoopId) {
    clearInterval(enhArpLoopId);
    enhArpLoopId = null;
    const btn = document.getElementById('enhArpLoopBtn');
    if (btn) { btn.style.background = 'rgba(255,215,0,.1)'; btn.textContent = ' Loop'; }
  }
  const status = document.getElementById('enhAudioStatus');
  if (status) status.textContent = '';
}

function getEnhDetuneRatio() {
  const cents = parseFloat(document.getElementById('enhDetune')?.value || 0);
  return Math.pow(2, cents / 1200);
}

function playEnhChord() {
  if (enhChordSelection.length === 0) {
    const status = document.getElementById('enhAudioStatus');
    if (status) status.textContent = 'No notes in chord!';
    return;
  }
  
  stopEnhChord();
  const ctx = initEnhAudio();
  const baseFreq = parseFloat(document.getElementById('enhBaseFreq')?.value || 440);
  const volume = getEnhVolume();
  const dur = parseFloat(document.getElementById('enhAudioDur')?.value || '0.5');
  const wave = document.getElementById('enhAudioWave')?.value || 'sine';
  const detuneRatio = getEnhDetuneRatio();
  
  // Play all notes simultaneously
  enhChordSelection.forEach(({p, q}) => {
    const freq = baseFreq * p / q * detuneRatio;
    const osc = ctx.createOscillator();
    const gain = ctx.createGain();
    osc.frequency.value = freq;
    osc.type = wave;
    osc.connect(gain);
    gain.connect(ctx.destination);
    gain.gain.setValueAtTime(volume / Math.sqrt(enhChordSelection.length), ctx.currentTime);
    gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + dur);
    osc.start(ctx.currentTime);
    osc.stop(ctx.currentTime + dur);
    enhActiveOscs.push(osc);
  });
  
  const status = document.getElementById('enhAudioStatus');
  if (status) status.textContent = `Playing chord (${enhChordSelection.length} notes)...`;
}

function playEnhChordSustain() {
  if (enhChordSelection.length === 0) {
    const status = document.getElementById('enhAudioStatus');
    if (status) status.textContent = 'No notes in chord!';
    return;
  }
  
  stopEnhChord();
  const ctx = initEnhAudio();
  const baseFreq = parseFloat(document.getElementById('enhBaseFreq')?.value || 440);
  const volume = getEnhVolume();
  const wave = document.getElementById('enhAudioWave')?.value || 'sine';
  const detuneRatio = getEnhDetuneRatio();
  
  // Play all notes continuously until stopped
  enhChordSelection.forEach(({p, q}) => {
    const freq = baseFreq * p / q * detuneRatio;
    const osc = ctx.createOscillator();
    const gain = ctx.createGain();
    osc.frequency.value = freq;
    osc.type = wave;
    osc.connect(gain);
    gain.connect(ctx.destination);
    gain.gain.setValueAtTime(volume / Math.sqrt(enhChordSelection.length), ctx.currentTime);
    osc.start(ctx.currentTime);
    enhActiveOscs.push(osc);
  });
  
  const status = document.getElementById('enhAudioStatus');
  if (status) status.textContent = `Sustaining chord (${enhChordSelection.length} notes)... Press Stop`;
}

function playEnhArpeggio(reverse = false) {
  if (enhChordSelection.length === 0) return;
  
  stopEnhChord();
  const baseFreq = parseFloat(document.getElementById('enhBaseFreq')?.value || 440);
  const noteDur = parseFloat(document.getElementById('enhAudioDur')?.value || '0.3');
  const arpSpeed = parseInt(document.getElementById('enhArpSpeed')?.value || 150);
  const detuneRatio = getEnhDetuneRatio();
  
  // Sort by pitch
  let sorted = [...enhChordSelection].sort((a, b) => (a.p/a.q) - (b.p/b.q));
  if (reverse) sorted.reverse();
  
  let delay = 0;
  sorted.forEach(({p, q}) => {
    setTimeout(() => playEnhFrequency(baseFreq * p / q * detuneRatio, noteDur * 0.8), delay);
    delay += arpSpeed;
  });
  
  const status = document.getElementById('enhAudioStatus');
  if (status) status.textContent = `Arpeggio ${reverse ? '↓' : '↑'} (${sorted.length} notes)...`;
}

function playEnhArpeggioLoop() {
  if (enhChordSelection.length === 0) return;
  
  const btn = document.getElementById('enhArpLoopBtn');
  
  // Toggle loop
  if (enhArpLoopId) {
    stopEnhChord();
    return;
  }
  
  if (btn) { btn.style.background = 'rgba(255,215,0,.4)'; btn.textContent = ' Stop Loop'; }
  
  const baseFreq = parseFloat(document.getElementById('enhBaseFreq')?.value || 440);
  const noteDur = parseFloat(document.getElementById('enhAudioDur')?.value || '0.3');
  const arpSpeed = parseInt(document.getElementById('enhArpSpeed')?.value || 150);
  const detuneRatio = getEnhDetuneRatio();
  
  // Sort by pitch
  const sorted = [...enhChordSelection].sort((a, b) => (a.p/a.q) - (b.p/b.q));
  const cycleDur = sorted.length * arpSpeed;
  
  let noteIdx = 0;
  let direction = 1; // 1 = up, -1 = down
  
  const playNext = () => {
    const {p, q} = sorted[noteIdx];
    playEnhFrequency(baseFreq * p / q * detuneRatio, noteDur * 0.7);
    
    noteIdx += direction;
    if (noteIdx >= sorted.length) { noteIdx = sorted.length - 2; direction = -1; }
    if (noteIdx < 0) { noteIdx = 1; direction = 1; }
  };
  
  playNext();
  enhArpLoopId = setInterval(playNext, arpSpeed);
  
  const status = document.getElementById('enhAudioStatus');
  if (status) status.textContent = `Looping arpeggio...`;
}

// Arp speed slider has inline oninput handler

// === COMPREHENSIVE METRICS DISPLAY ===

function getEnhHarmonicMetrics(p, q) {
  const g = gcd(p, q);
  const rp = p / g, rq = q / g;
  const baseFreq = parseFloat(document.getElementById('enhBaseFreq')?.value || 440);
  const freq = baseFreq * rp / rq;
  
  return {
    fraction: `${rp}/${rq}`,
    decimal: (rp / rq).toFixed(6),
    cents: ratioToCents(rp, rq).toFixed(2),
    frequency: freq.toFixed(2),
    tenney: tenneyHeight(rp, rq).toFixed(3),
    benedetti: benedettiHeight(rp, rq),
    euler: eulerGradusInterval(rp, rq),
    entropy: harmonicEntropy(rp, rq).toFixed(3),
    primeLimit: primeLimit(rp, rq),
    limitName: primeLimitNames[primeLimit(rp, rq)] || `${primeLimit(rp, rq)}-limit`,
    intervalName: getEnhMusicalName(rp, rq),
    intervalInfo: getEnhIntervalInfo(rp, rq),
    consonance: categorizeConsonance(rp, rq)
  };
}

function initEnhanced(){
  // Ensure canvas has dimensions
  const c = document.getElementById('cenhanced');
  if(c && (c.width === 0 || c.height === 0)) {
    const sz = +document.getElementById('enhCanvSz')?.value || 800;
    c.width = sz;
    c.height = sz;
  }
  drawEnhanced();
  updateEnhSector();
  updateEnhCustomGapsList();
  // Initialize new visualizations
  setTimeout(() => {
    if(typeof drawArnoldTongues === 'function') drawArnoldTongues();
    if(typeof drawFreqDistribution === 'function') drawFreqDistribution();
  }, 100);
}

// Collapsible section toggle for Enhanced Modular
function toggleEnhSection(sectionId) {
  if (sectionId === 'all') {
    expandAllEnhSections();
    return;
  }
  if (sectionId === 'none') {
    collapseAllEnhSections();
    return;
  }
  
  const section = document.getElementById(sectionId);
  const icon = document.getElementById(sectionId + 'Icon');
  if (!section) return;
  
  const isHidden = section.style.display === 'none';
  section.style.display = isHidden ? 'block' : 'none';
  if (icon) icon.textContent = isHidden ? '−' : '+';
}

function expandAllEnhSections() {
  ['enhSecModulus', 'enhSecViz', 'enhSecRotation', 'enhSecSweep', 'enhSecFarey', 'enhSecLift', 'enhSecGaps', 'enhSecDisplay', 'enhSecSmith', 'enhSecAnim', 'enhSecPrime', 'enhSecTracker', 'enhSecDisplaySettings', 'enhSecAudio'].forEach(id => {
    const section = document.getElementById(id);
    const icon = document.getElementById(id + 'Icon');
    if (section) section.style.display = 'block';
    if (icon) icon.textContent = '−';
  });
}

function collapseAllEnhSections() {
  ['enhSecModulus', 'enhSecViz', 'enhSecRotation', 'enhSecSweep', 'enhSecFarey', 'enhSecLift', 'enhSecGaps', 'enhSecDisplay', 'enhSecSmith', 'enhSecAnim', 'enhSecPrime', 'enhSecTracker', 'enhSecDisplaySettings', 'enhSecAudio'].forEach(id => {
    const section = document.getElementById(id);
    const icon = document.getElementById(id + 'Icon');
    if (section) section.style.display = 'none';
    if (icon) icon.textContent = '+';
  });
}

function enhModeChange(){
const mode=document.getElementById('enhMode').value;
document.getElementById('enhRangeControls').style.display=mode==='range'?'block':'none';
document.getElementById('enhPowerControls').style.display=mode==='power'?'block':'none';
document.getElementById('enhCustomControls').style.display=mode==='custom'?'block':'none';
}

function enhSetRange(min,max){
document.getElementById('enhMode').value='range';
enhModeChange();
document.getElementById('enhMin').value=min;
document.getElementById('enhMax').value=max;
drawEnhanced();
}

function enhSetPower(base,maxExp){
document.getElementById('enhMode').value='power';
enhModeChange();
document.getElementById('enhBase').value=base;
document.getElementById('enhMaxExp').value=maxExp;
document.getElementById('enhMinExp').value=0;
drawEnhanced();
}

function enhSetPrimorials(){
document.getElementById('enhMode').value='custom';
enhModeChange();
document.getElementById('enhCustomList').value='1,2,6,30,210';
drawEnhanced();
}

function enhSetPrimes(){
document.getElementById('enhMode').value='custom';
enhModeChange();
document.getElementById('enhCustomList').value='2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59';
drawEnhanced();
}

// Modular inverse using extended Euclidean algorithm
function modInverse(a, m) {
  if (m === 1) return 0;
  let m0 = m, y = 0, x = 1;
  a = ((a % m) + m) % m;
  if (a === 0) return 0;
  while (a > 1) {
    const q = Math.floor(a / m);
    let t = m;
    m = a % m;
    a = t;
    t = y;
    y = x - q * y;
    x = t;
  }
  return x < 0 ? x + m0 : x;
}

// Custom connection preset setter
function setEnhCustomConn(expr) {
  const input = document.getElementById('enhCustomConnExpr');
  if (input) {
    input.value = expr;
    document.getElementById('enhCustomConn').checked = true;
    drawEnhanced();
  }
}

// Apply custom connection (same as enabling checkbox)
function applyEnhCustomConn() {
  document.getElementById('enhCustomConn').checked = true;
  drawEnhanced();
}

// Custom gaps storage
let enhCustomGaps = [];

function addEnhCustomGap(val) {
  const input = document.getElementById('enhCustomGapInput');
  let gap = val || parseInt(input?.value) || 14;
  
  // Ensure it's even (2n)
  if (gap % 2 !== 0) gap = gap + 1;
  if (gap < 2) gap = 2;
  if (gap > 500) gap = 500;
  
  // Don't add duplicates
  if (!enhCustomGaps.includes(gap) && ![2,4,6,8,10,12].includes(gap)) {
    enhCustomGaps.push(gap);
    enhCustomGaps.sort((a, b) => a - b);
    updateEnhCustomGapsList();
    drawEnhanced();
  }
}

function removeEnhCustomGap(gap) {
  enhCustomGaps = enhCustomGaps.filter(g => g !== gap);
  updateEnhCustomGapsList();
  drawEnhanced();
}

function clearEnhCustomGaps() {
  enhCustomGaps = [];
  updateEnhCustomGapsList();
  drawEnhanced();
}

function updateEnhCustomGapsList() {
  const container = document.getElementById('enhCustomGapsList');
  if (!container) return;
  
  if (enhCustomGaps.length === 0) {
    container.innerHTML = '<span style="color:var(--txt2)">None added</span>';
    return;
  }
  
  const colors = ['#ff6496', '#ffd700', '#00ff88', '#00d9ff', '#9664ff', '#ff9933', '#66ffcc', '#ff66cc'];
  
  container.innerHTML = enhCustomGaps.map((g, i) => 
    `<span style="display:inline-flex;align-items:center;gap:2px;padding:2px 6px;background:${colors[i % colors.length]}33;border:1px solid ${colors[i % colors.length]};border-radius:3px;color:${colors[i % colors.length]}">
      ${g}
      <span onclick="removeEnhCustomGap(${g})" style="cursor:pointer;font-weight:bold;margin-left:2px">×</span>
    </span>`
  ).join('');
}

function enhGetGaps(){
const gaps=[];
if(document.getElementById('enhGap2')?.checked)gaps.push(2);
if(document.getElementById('enhGap4')?.checked)gaps.push(4);
if(document.getElementById('enhGap6')?.checked)gaps.push(6);
if(document.getElementById('enhGap8')?.checked)gaps.push(8);
if(document.getElementById('enhGap10')?.checked)gaps.push(10);
if(document.getElementById('enhGap12')?.checked)gaps.push(12);
// Add custom gaps
enhCustomGaps.forEach(g => { if (!gaps.includes(g)) gaps.push(g); });
gaps.sort((a, b) => a - b);
return gaps;
}

function enhGetModuli(){
const mode=document.getElementById('enhMode').value;
let moduli=[];
if(mode==='range'){
const minM=Math.max(1,+document.getElementById('enhMin').value||1);
const maxM=Math.max(minM,+document.getElementById('enhMax').value||30);
for(let m=minM;m<=maxM;m++)moduli.push(m);
}else if(mode==='power'){
const base=Math.max(2,+document.getElementById('enhBase').value||2);
const minExp=Math.max(0,+document.getElementById('enhMinExp').value||0);
const maxExp=Math.max(minExp,+document.getElementById('enhMaxExp').value||10);
for(let e=minExp;e<=maxExp;e++)moduli.push(Math.pow(base,e));
}else if(mode==='custom'){
const list=document.getElementById('enhCustomList').value||'';
moduli=list.split(',').map(s=>parseInt(s.trim())).filter(n=>n>0&&!isNaN(n));
moduli.sort((a,b)=>a-b);
}
return moduli;
}

function enhCalcRadius(mod,idx,total,maxMod,invert=false){
const scale=document.getElementById('enhScale').value;
const maxR=320,minR=30;
// If invert, flip the index for uniform spacing, or invert the mod-based calculation
const effectiveIdx=invert?(total-1-idx):idx;
const effectiveMod=invert?(maxMod-mod+1):mod;
switch(scale){
case'linear':return minR+(maxR-minR)*(invert?(maxMod-mod+1)/maxMod:mod/maxMod);
case'sqrt':return minR+(maxR-minR)*Math.sqrt(invert?(maxMod-mod+1):mod)/Math.sqrt(maxMod);
case'log':return minR+(maxR-minR)*Math.log((invert?(maxMod-mod+2):mod)+1)/Math.log(maxMod+1);
case'phi':const phiMod=getCoprimes(mod).length,phiMax=getCoprimes(maxMod).length;return minR+(maxR-minR)*(invert?(phiMax-phiMod+1)/Math.max(1,phiMax):phiMod/Math.max(1,phiMax));
default:return minR+(maxR-minR)*effectiveIdx/Math.max(1,total-1);
}}

// ===== ENHANCED MODULAR OPTIMIZATION =====
// Coprime cache for fast lookups
const coprimeCache = new Map();
const totientCache = new Map();

function getCoprimesCached(m) {
  if (coprimeCache.has(m)) return coprimeCache.get(m);
  const result = [];
  if (m === 1) { result.push(0); }
  else {
    for (let r = 0; r < m; r++) if (gcd(r, m) === 1) result.push(r);
  }
  coprimeCache.set(m, result);
  totientCache.set(m, result.length);
  return result;
}

function getTotientCached(m) {
  if (totientCache.has(m)) return totientCache.get(m);
  getCoprimesCached(m);
  return totientCache.get(m);
}

// Pre-warm cache for range
function precomputeCoprimes(minM, maxM) {
  for (let m = minM; m <= maxM; m++) getCoprimesCached(m);
}

// Optimized point batch renderer
function drawPointsBatched(ctx, points, isDark) {
  if (points.length === 0) return;
  
  // Group by color for batch drawing
  const colorGroups = new Map();
  points.forEach(pt => {
    const key = pt.color;
    if (!colorGroups.has(key)) colorGroups.set(key, []);
    colorGroups.get(key).push(pt);
  });
  
  // Draw each color group
  colorGroups.forEach((pts, color) => {
    ctx.fillStyle = color;
    ctx.beginPath();
    pts.forEach(pt => {
      ctx.moveTo(pt.x + pt.size, pt.y);
      ctx.arc(pt.x, pt.y, pt.size, 0, 2 * Math.PI);
    });
    ctx.fill();
  });
}

// Progressive rendering state
let enhProgressiveState = null;

function drawEnhancedProgressive(onComplete) {
  if (enhProgressiveState) {
    cancelAnimationFrame(enhProgressiveState.frameId);
    enhProgressiveState = null;
  }
  
  const c = document.getElementById('cenhanced');
  const ctx = c.getContext('2d');
  const moduli = enhGetModuli();
  
  // Show progress
  const statusEl = document.getElementById('enhStatus');
  if (statusEl) {
    statusEl.style.display = 'block';
    statusEl.textContent = 'Computing coprimes...';
  }
  
  // Pre-compute all coprimes first (this is fast with caching)
  const t0 = performance.now();
  moduli.forEach(m => getCoprimesCached(m));
  
  // Build ring data and point list
  enhRingsData = [];
  const maxMod = Math.max(...moduli, 1);
  const enhInvertOrder = document.getElementById('enhInvertRings')?.checked || false;
  
  // Build ring data with Set for O(1) coprime lookup
  moduli.forEach((m, idx) => {
    const coprimes = getCoprimesCached(m);
    const coprimeSet = new Set(coprimes);
    const allRes = Array.from({length: m}, (_, i) => i); // All residues 0 to m-1
    const ring = { mod: m, coprimes, coprimeSet, allRes, isUnit: m === 1, idx };
    ring.radius = enhCalcRadius(m, idx, moduli.length, maxMod, enhInvertOrder);
    enhRingsData.push(ring);
  });
  
  if (statusEl) statusEl.textContent = 'Building point data...';
  
  // Get rendering options
  const zoom = +document.getElementById('enhZoom').value;
  const rot = (+document.getElementById('enhRot').value + enhAnimFrame) * Math.PI / 180;
  const userPtScale = +document.getElementById('enhPtSzNum')?.value || +document.getElementById('enhPtSz').value;
  const autoScaleEnabled = document.getElementById('autoScaleEnh')?.checked ?? true;
  const ptScale = autoScaleEnabled ? autoScaleEnhanced(moduli, userPtScale * 4) / 4 : userPtScale;
  const colMode = document.getElementById('enhCol').value;
  const showGcd1 = document.getElementById('enhShowGcd1')?.checked ?? true;
  const showNonGcd1 = document.getElementById('enhShowNonGcd1')?.checked ?? true;
  const showUnit = document.getElementById('enhShowUnit')?.checked ?? true;
  const numRings = enhRingsData.length;
  const enhRingInc = (+document.getElementById('enhRingInc')?.value || 0) * Math.PI / 180;
  const enhPhase = (+document.getElementById('enhPhase')?.value || 0) * Math.PI / 180;
  const enhInvertRings = document.getElementById('enhInvertRings')?.checked || false;
  const nonGcdOp = +document.getElementById('enhNonGcdOp').value;
  
  // Use typed arrays for better performance with large datasets
  let totalPts = 0;
  enhRingsData.forEach(ring => {
    if (ring.isUnit && !showUnit) return;
    if (showGcd1) totalPts += ring.coprimes.length;
    if (showNonGcd1 && !ring.isUnit) totalPts += ring.mod - ring.coprimes.length;
  });
  
  // Pre-allocate typed arrays
  const xArr = new Float32Array(totalPts);
  const yArr = new Float32Array(totalPts);
  const sizeArr = new Float32Array(totalPts);
  const colors = new Array(totalPts);
  let pIdx = 0;
  
  // Helper function to get color for a point
  function getPointColor(r, ring, gcd1, ringIdx) {
    const t = r / ring.mod;
    const g = gcd1 ? 1 : gcd(r, ring.mod);
    
    if (colMode === 'angular') return `hsl(${t * 360}, 80%, 60%)`;
    if (colMode === 'gcd') return gcd1 ? '#ffd700' : '#555';
    if (colMode === 'ring') return `hsl(${(ringIdx / numRings) * 300}, 70%, ${gcd1 ? 55 : 35}%)`;
    if (colMode === 'coprime') return gcd1 ? '#00ff88' : `rgba(255,64,64,${nonGcdOp})`;
    if (colMode === 'spectrum') return gcd1 ? `hsl(${(ring.coprimes.length / ring.mod) * 240}, 80%, 60%)` : '#333';
    if (colMode === 'sector') {
      let sec = 0;
      for (let n = 1; n <= 20; n++) { if (t > 1/(n+1) && t <= 1/n) { sec = n; break; } }
      return sec > 0 ? `hsl(${sec * 40}, 75%, ${gcd1 ? 55 : 35}%)` : '#444';
    }
    if (colMode === 'depth') {
      const d = Math.floor(Math.log2(ring.mod + 1));
      return `hsl(${d * 25 + 120}, ${gcd1 ? 70 : 40}%, ${gcd1 ? 55 : 35}%)`;
    }
    if (colMode === 'primality') {
      const prod = r * g;
      const isPrimeish = (prod > 1 && prod < 100) ? !Array.from({length: Math.floor(Math.sqrt(prod)) - 1}, (_, i) => i + 2).some(d => prod % d === 0) : false;
      return isPrimeish ? '#00ff88' : gcd1 ? '#ffd700' : '#666';
    }
    if (colMode === 'quadres') {
      const isQR = ring.coprimes.some(c => (c * c) % ring.mod === r % ring.mod);
      return isQR ? '#00d9ff' : '#ff6496';
    }
    if (colMode === 'discrete') {
      const cols = ['#e6194b','#3cb44b','#ffe119','#4363d8','#f58231','#911eb4','#46f0f0','#f032e6','#bcf60c','#fabebe','#008080','#e6beff','#9a6324','#fffac8','#800000','#aaffc3','#808000','#ffd8b1','#000075','#808080'];
      return cols[(g - 1) % cols.length];
    }
    if (colMode === 'multtable') {
      const prod = (r * ring.mod) % ring.mod;
      return `hsl(${(prod / ring.mod) * 360}, ${gcd1 ? 80 : 50}%, ${gcd1 ? 55 : 35}%)`;
    }
    if (colMode === 'zerodiv') return gcd1 ? '#4488ff' : '#ff4040';
    if (colMode === 'idempotent') {
      const isIdem = (r * r) % ring.mod === r;
      return isIdem ? '#ffd700' : gcd1 ? '#4488ff' : '#666';
    }
    if (colMode === 'fire') {
      if (t < 0.25) return `rgb(${Math.floor(t * 4 * 255)}, 0, 0)`;
      if (t < 0.5) return `rgb(255, ${Math.floor((t - 0.25) * 4 * 255)}, 0)`;
      if (t < 0.75) return `rgb(255, 255, ${Math.floor((t - 0.5) * 4 * 255)})`;
      return 'rgb(255, 255, 255)';
    }
    if (colMode === 'plasma') {
      const r_ = Math.floor(13 + t * 242);
      const g_ = Math.floor(8 + Math.sin(t * Math.PI) * 200);
      const b_ = Math.floor(135 + t * 120);
      return `rgb(${r_}, ${g_}, ${b_})`;
    }
    if (colMode === 'viridis') {
      const r_ = Math.floor(68 + t * 187);
      const g_ = Math.floor(1 + t * 208);
      const b_ = Math.floor(84 + t * (-60 + Math.sin(t * Math.PI) * 100));
      return `rgb(${Math.min(255, r_)}, ${Math.min(255, g_)}, ${Math.min(255, Math.max(0, b_))})`;
    }
    if (colMode === 'ocean') return `hsl(${200 + t * 60}, ${70 + t * 20}%, ${30 + t * 40}%)`;
    if (colMode === 'totient') {
      const h = (ring.coprimes.length / ring.mod) * 360;
      return `hsl(${h}, 75%, ${gcd1 ? 55 : 35}%)`;
    }
    if (colMode === 'numerator') return `hsl(${(r * 137.5) % 360}, ${gcd1 ? 80 : 50}%, ${gcd1 ? 55 : 35}%)`;
    
    return gcd1 ? '#00d9ff' : '#666';
  }
  
  enhRingsData.forEach((ring, idx) => {
    if (ring.isUnit && !showUnit) return;
    
    const ringIdx = enhInvertRings ? (numRings - 1 - ring.idx) : ring.idx;
    const ringRotation = ringIdx * enhRingInc + enhPhase;
    const baseSize = ring.isUnit ? 7 : (ring.radius > 200 ? 5 : 4);
    
    // Process coprimes first (gcd=1)
    if (showGcd1) {
      ring.coprimes.forEach(r => {
        const angle = 2 * Math.PI * (ring.mod - r) / ring.mod + ringRotation;
        xArr[pIdx] = ring.radius * Math.cos(angle);
        yArr[pIdx] = ring.radius * Math.sin(angle);
        sizeArr[pIdx] = baseSize * ptScale;
        colors[pIdx] = getPointColor(r, ring, true, ringIdx);
        pIdx++;
      });
    }
    
    // Process non-coprimes (gcd > 1)
    if (showNonGcd1 && !ring.isUnit) {
      for (let r = 0; r < ring.mod; r++) {
        if (ring.coprimeSet.has(r)) continue; // Skip coprimes - O(1) lookup
        
        const angle = 2 * Math.PI * (ring.mod - r) / ring.mod + ringRotation;
        xArr[pIdx] = ring.radius * Math.cos(angle);
        yArr[pIdx] = ring.radius * Math.sin(angle);
        sizeArr[pIdx] = baseSize * ptScale * 0.7;
        colors[pIdx] = getPointColor(r, ring, false, ringIdx);
        pIdx++;
      }
    }
  });
  
  const buildTime = performance.now() - t0;
  if (statusEl) statusEl.textContent = `Built ${pIdx.toLocaleString()} pts in ${buildTime.toFixed(0)}ms`;
  
  // Create chunks for progressive rendering
  const CHUNK_SIZE = 50000;
  const numChunks = Math.ceil(pIdx / CHUNK_SIZE);
  
  // Clear and draw background
  ctx.fillStyle = canvBg();
  ctx.fillRect(0, 0, c.width, c.height);
  
  // Center transform
  const cx = c.width / 2, cy = c.height / 2;
  ctx.save();
  ctx.translate(cx, cy);
  ctx.rotate(rot);
  ctx.scale(zoom, zoom);
  
  // Draw ring circles first - scale opacity based on ring count
  const ringOpacity = Math.max(0.02, Math.min(0.15, 5 / enhRingsData.length));
  enhRingsData.forEach((ring, idx) => {
    if (ring.isUnit && !showUnit) return;
    // Skip ring circles for large datasets (>200 rings) to reduce visual clutter
    if (enhRingsData.length > 200 && !ring.isUnit) return;
    ctx.beginPath();
    ctx.arc(0, 0, ring.radius, 0, 2 * Math.PI);
    if (ring.isUnit) { ctx.strokeStyle = 'rgba(255,215,0,.8)'; ctx.lineWidth = 3; }
    else { ctx.strokeStyle = `rgba(255,255,255,${ringOpacity})`; ctx.lineWidth = 0.5; ctx.setLineDash([2, 4]); }
    ctx.stroke();
    ctx.setLineDash([]);
  });
  
  // Progressive point rendering using typed arrays
  let chunkIdx = 0;
  
  function renderChunk() {
    const startIdx = chunkIdx * CHUNK_SIZE;
    const endIdx = Math.min(startIdx + CHUNK_SIZE, pIdx);
    
    if (startIdx >= pIdx) {
      ctx.restore();
      if (statusEl) {
        statusEl.textContent = `${pIdx.toLocaleString()} pts — ${(performance.now() - t0).toFixed(0)}ms`;
        setTimeout(() => { if (statusEl) statusEl.style.display = 'none'; }, 3000);
      }
      enhProgressiveState = null;
      updateEnhStats();
      if (onComplete) onComplete();
      return;
    }
    
    // Batch draw by color
    const colorBatches = new Map();
    for (let i = startIdx; i < endIdx; i++) {
      const col = colors[i];
      if (!colorBatches.has(col)) colorBatches.set(col, []);
      colorBatches.get(col).push(i);
    }
    
    colorBatches.forEach((indices, color) => {
      ctx.fillStyle = color;
      ctx.beginPath();
      indices.forEach(i => {
        const x = xArr[i], y = yArr[i], sz = sizeArr[i];
        ctx.moveTo(x + sz, y);
        ctx.arc(x, y, sz, 0, 2 * Math.PI);
      });
      ctx.fill();
    });
    
    const pct = Math.round(((chunkIdx + 1) / numChunks) * 100);
    if (statusEl) statusEl.textContent = `Rendering ${pct}%... (${pIdx.toLocaleString()} pts)`;
    
    chunkIdx++;
    enhProgressiveState = { frameId: requestAnimationFrame(renderChunk) };
  }
  
  // Start progressive rendering
  if (numChunks > 1) {
    enhProgressiveState = { frameId: requestAnimationFrame(renderChunk) };
  } else {
    // Small enough to render immediately
    renderChunk();
  }
}

// Legacy wrapper
function getCoprimes(m){
  return getCoprimesCached(m);
}

function getAllResidues(m){return Array.from({length:m},(_,i)=>i);}

function enhUpdateVizControls(){
const mode=document.getElementById('enhVizMode')?.value||'rings';
const cRings=document.getElementById('enhRingsControls');
const c3d=document.getElementById('enh3DControls');
const cComp=document.getElementById('enhCompControls');
const cMult=document.getElementById('enhMultTableControls');
if(cRings)cRings.style.display=mode==='rings'?'block':'none';
if(c3d)c3d.style.display=mode==='farey3d'?'block':'none';
if(cComp)cComp.style.display=mode==='composite'?'block':'none';
if(cMult)cMult.style.display=mode==='multtable'?'block':'none';
}

// Canvas click handler for point selection
let enhSelectedPoint = null;

function handleEnhCanvasClick(event) {
  const c = document.getElementById('cenhanced');
  if (!c || enhRingsData.length === 0) return;
  
  // Get canvas actual displayed size
  const rect = c.getBoundingClientRect();
  const displayW = rect.width || c.offsetWidth || c.width;
  const displayH = rect.height || c.offsetHeight || c.height;
  
  // Calculate click position in canvas internal coordinates
  const clickX = (event.clientX - rect.left) * (c.width / displayW);
  const clickY = (event.clientY - rect.top) * (c.height / displayH);
  
  // Transform to canvas coordinates (centered)
  const cx = c.width / 2;
  const cy = c.height / 2;
  let x = clickX - cx;
  let y = clickY - cy; // Canvas Y (down is positive)
  
  // Get global rotation (same as drawing code)
  const rot = ((+document.getElementById('enhRot')?.value || 0) + enhAnimFrame) * Math.PI / 180;
  
  // Un-rotate click coordinates to match un-rotated point positions
  // Drawing does ctx.rotate(rot), so we reverse it
  const cosR = Math.cos(-rot);
  const sinR = Math.sin(-rot);
  const ux = x * cosR - y * sinR;
  const uy = x * sinR + y * cosR;
  
  // Find closest point
  let closest = null;
  let minDist = Infinity;
  
  const numRings = enhRingsData.length;
  const outerR = Math.min(cx, cy) - 40;
  const innerR = 30;
  
  // Get per-ring rotation settings
  const ringInc = (+document.getElementById('enhRingInc')?.value || 0) * Math.PI / 180;
  const phase = (+document.getElementById('enhPhase')?.value || 0) * Math.PI / 180;
  const invertRings = document.getElementById('enhInvertRings')?.checked;
  
  enhRingsData.forEach((ring, ringIdx) => {
    const radius = innerR + (outerR - innerR) * ringIdx / (numRings - 1 || 1);
    const actualRingIdx = invertRings ? (numRings - 1 - ringIdx) : ringIdx;
    const ringRotation = actualRingIdx * ringInc + phase;
    
    ring.allRes.forEach(r => {
      // Use same formula as drawing: (ring.mod - r) / ring.mod
      const angle = 2 * Math.PI * (ring.mod - r) / ring.mod + ringRotation;
      const px = radius * Math.cos(angle);
      const py = radius * Math.sin(angle);
      const dist = Math.sqrt((ux - px) ** 2 + (uy - py) ** 2);
      
      if (dist < minDist && dist < 25) { // 25px click tolerance
        minDist = dist;
        closest = {
          residue: r,
          mod: ring.mod,
          angle: angle,
          angleDeg: (angle * 180 / Math.PI) % 360,
          gcd: gcd(r, ring.mod),
          isCoprime: gcd(r, ring.mod) === 1,
          fraction: `${r}/${ring.mod}`,
          reducedFrac: reduceFraction(r, ring.mod),
          ringIdx: ringIdx,
          radius: radius,
          x: px,
          y: py
        };
      }
    });
  });
  
  if (closest) {
    enhSelectedPoint = closest;
    showEnhPointDetails(closest);
    
    // Play audio for clicked point
    if(closest.isCoprime){
      const baseFreq=parseFloat(document.getElementById('enhBaseFreq')?.value||440);
      const[p,q]=closest.reducedFrac.split('/').map(Number);
      const detuneRatio=getEnhDetuneRatio();
      const freq=baseFreq*p/q*detuneRatio;
      playEnhFrequency(freq);
      // Show musical info
      const musName=getEnhMusicalName(p,q);
      const status=document.getElementById('enhAudioStatus');
      if(status){status.textContent=musName?`${p}/${q} = ${musName}`:`${p}/${q} (${freq.toFixed(1)}Hz)`;}
      
      // Add to chord if chord mode is active
      if(enhChordMode){
        addToEnhChord(p,q);
      }
      
      // Find and display Farey neighbors
      const neighbors=findEnhFareyNeighbors(p,q);
      updateEnhFareyNeighborLegend(p,q,neighbors);
      closest.fareyNeighbors=neighbors;
      
      // Update manual input fields to match clicked point
      const manP=document.getElementById('enhManualP');
      const manQ=document.getElementById('enhManualQ');
      if(manP)manP.value=p;
      if(manQ)manQ.value=q;
    }else{
      // Hide neighbor legend for non-coprime points
      const legend=document.getElementById('enhFareyNeighborLegend');
      if(legend)legend.style.display='none';
    }
    
    // Highlight in Stern-Brocot tree
    if(closest.isCoprime){
      highlightInSBTree(closest.residue, closest.mod);
    } else {
      const pathEl = document.getElementById('enhTreePath');
      if(pathEl){
        pathEl.style.display = 'block';
        pathEl.innerHTML = `<span style="color:#ff6496">${closest.residue}/${closest.mod} is not coprime (GCD=${closest.gcd}) - not in Stern-Brocot tree</span>`;
      }
    }
    
    drawEnhanced();
  }
}

function reduceFraction(a, b) {
  const g = gcd(a, b);
  return `${a/g}/${b/g}`;
}

function reduceFrac(a, b) {
  const g = gcd(a, b);
  return [a/g, b/g];
}

function showEnhPointDetails(pt) {
  const detailsDiv = document.getElementById('enhPointDetails');
  const infoDiv = document.getElementById('enhPointInfo');
  const analysisDiv = document.getElementById('enhPointAnalysis');
  
  if (!detailsDiv || !pt) return;
  detailsDiv.style.display = 'block';
  
  // Basic info
  const coprimeStatus = pt.isCoprime ? 
    '<span style="color:#00ff88;font-weight:bold"> COPRIME (Primitive)</span>' : 
    '<span style="color:#ff6496"> Non-coprime</span>';
  
  // Get harmonic metrics if coprime
  let harmonicHTML = '';
  if (pt.isCoprime) {
    const [p, q] = pt.reducedFrac.split('/').map(Number);
    const metrics = getEnhHarmonicMetrics(p, q);
    const baseFreq = parseFloat(document.getElementById('enhBaseFreq')?.value || 440);
    
    harmonicHTML = `
    <div style="background:var(--bg1);padding:8px;border-radius:6px;text-align:center">
      <div style="font-size:.7rem;color:var(--txt2)">Frequency</div>
      <div style="font-size:1.1rem;font-weight:bold;color:#00d9ff">${metrics.frequency} Hz</div>
    </div>
    <div style="background:var(--bg1);padding:8px;border-radius:6px;text-align:center">
      <div style="font-size:.7rem;color:var(--txt2)">Cents</div>
      <div style="font-size:1.1rem;font-weight:bold;color:#ffd700">${metrics.cents}¢</div>
    </div>
    <div style="background:var(--bg1);padding:8px;border-radius:6px;text-align:center">
      <div style="font-size:.7rem;color:var(--txt2)">Prime Limit</div>
      <div style="font-size:1.1rem;font-weight:bold;color:#9664ff">${metrics.primeLimit}-limit</div>
    </div>
    `;
    
    // Show harmonic metrics panel
    const metricsPanel = document.getElementById('enhHarmonicMetrics');
    const metricsContent = document.getElementById('enhMetricsContent');
    if (metricsPanel && metricsContent) {
      metricsPanel.style.display = 'block';
      metricsContent.innerHTML = `
        <div style="background:var(--bg1);padding:6px;border-radius:4px">
          <div style="font-size:.65rem;color:var(--txt2)">Interval</div>
          <div style="font-weight:bold;color:#ffd700">${metrics.intervalName || 'Unnamed'}</div>
        </div>
        <div style="background:var(--bg1);padding:6px;border-radius:4px">
          <div style="font-size:.65rem;color:var(--txt2)">Tenney Height</div>
          <div style="font-weight:bold;color:#00ff88">${metrics.tenney}</div>
          <div style="font-size:.6rem;color:var(--txt2)">log₂(p)+log₂(q)</div>
        </div>
        <div style="background:var(--bg1);padding:6px;border-radius:4px">
          <div style="font-size:.65rem;color:var(--txt2)">Benedetti Height</div>
          <div style="font-weight:bold;color:#00d9ff">${metrics.benedetti}</div>
          <div style="font-size:.6rem;color:var(--txt2)">p × q</div>
        </div>
        <div style="background:var(--bg1);padding:6px;border-radius:4px">
          <div style="font-size:.65rem;color:var(--txt2)">Euler Gradus</div>
          <div style="font-weight:bold;color:#9664ff">${metrics.euler}</div>
          <div style="font-size:.6rem;color:var(--txt2)">Γ(p)+Γ(q)-1</div>
        </div>
        <div style="background:var(--bg1);padding:6px;border-radius:4px">
          <div style="font-size:.65rem;color:var(--txt2)">Harm. Entropy</div>
          <div style="font-weight:bold;color:#ff6496">${metrics.entropy}</div>
          <div style="font-size:.6rem;color:var(--txt2)">Lower=smoother</div>
        </div>
        <div style="background:var(--bg1);padding:6px;border-radius:4px">
          <div style="font-size:.65rem;color:var(--txt2)">Consonance</div>
          <div style="font-weight:bold;color:${metrics.consonance==='perfect'?'#ffd700':metrics.consonance==='imperfect'?'#00ff88':'#ff6496'}">${metrics.consonance}</div>
        </div>
        <div style="background:var(--bg1);padding:6px;border-radius:4px">
          <div style="font-size:.65rem;color:var(--txt2)">Prime Limit</div>
          <div style="font-weight:bold;color:#00d9ff">${metrics.limitName}</div>
        </div>
        <div style="background:var(--bg1);padding:6px;border-radius:4px">
          <div style="font-size:.65rem;color:var(--txt2)">Decimal</div>
          <div style="font-weight:bold">${metrics.decimal}</div>
        </div>
      `;
    }
  } else {
    // Hide harmonic metrics for non-coprime
    const metricsPanel = document.getElementById('enhHarmonicMetrics');
    if (metricsPanel) metricsPanel.style.display = 'none';
  }
  
  infoDiv.innerHTML = `
    <div style="background:var(--bg1);padding:8px;border-radius:6px;text-align:center">
      <div style="font-size:.7rem;color:var(--txt2)">Residue</div>
      <div style="font-size:1.4rem;font-weight:bold;color:#ffd700">${pt.residue}</div>
    </div>
    <div style="background:var(--bg1);padding:8px;border-radius:6px;text-align:center">
      <div style="font-size:.7rem;color:var(--txt2)">Modulus</div>
      <div style="font-size:1.4rem;font-weight:bold;color:#00d9ff">${pt.mod}</div>
    </div>
    <div style="background:var(--bg1);padding:8px;border-radius:6px;text-align:center">
      <div style="font-size:.7rem;color:var(--txt2)">Fraction</div>
      <div style="font-size:1.1rem;font-weight:bold;color:#9664ff">${pt.fraction}</div>
      <div style="font-size:.75rem;color:var(--txt2)">= ${pt.reducedFrac}</div>
    </div>
    <div style="background:var(--bg1);padding:8px;border-radius:6px;text-align:center">
      <div style="font-size:.7rem;color:var(--txt2)">GCD</div>
      <div style="font-size:1.4rem;font-weight:bold;color:${pt.isCoprime?'#00ff88':'#ff6496'}">${pt.gcd}</div>
    </div>
    <div style="background:var(--bg1);padding:8px;border-radius:6px;text-align:center">
      <div style="font-size:.7rem;color:var(--txt2)">Angle</div>
      <div style="font-size:1.1rem;font-weight:bold;color:#00ffc8">${pt.angleDeg.toFixed(2)}°</div>
    </div>
    <div style="background:var(--bg1);padding:8px;border-radius:6px;text-align:center">
      <div style="font-size:.7rem;color:var(--txt2)">Ring #</div>
      <div style="font-size:1.1rem;font-weight:bold">${pt.ringIdx + 1}</div>
    </div>
    ${harmonicHTML}
  `;
  
  // Analysis
  const phi = eulerPhi(pt.mod);
  const inSector = checkInCurrentSector(pt.residue, pt.mod);
  
  let analysisHTML = `
    <div style="margin-bottom:8px">${coprimeStatus}</div>
    <div style="display:grid;grid-template-columns:repeat(auto-fit,minmax(200px,1fr));gap:8px;font-size:.8rem">
      <div><strong>φ(${pt.mod})</strong> = ${phi} coprimes in ring</div>
      <div><strong>Density:</strong> ${(phi/pt.mod*100).toFixed(1)}% vs 60.79% (1/ζ(2))</div>
      <div><strong>Sector:</strong> ${inSector ? '<span style="color:#9664ff">In highlighted sector</span>' : 'Outside highlighted sector'}</div>
      <div><strong>Order:</strong> ${pt.isCoprime ? `ord(${pt.residue}) mod ${pt.mod} = ${multiplicativeOrder(pt.residue, pt.mod)}` : 'N/A (not coprime)'}</div>
    </div>
  `;
  
  if (pt.isCoprime) {
    const [p, q] = pt.reducedFrac.split('/').map(Number);
    const baseFreq = parseFloat(document.getElementById('enhBaseFreq')?.value || 440);
    const freq = baseFreq * p / q;
    
    // Find nearby commas
    const commas = [];
    const syntonicDiff = Math.abs(ratioToCents(p, q) - ratioToCents(81, 80));
    if (syntonicDiff < 30) commas.push('Near syntonic comma (81/80 = 21.5¢)');
    const pythagDiff = Math.abs(ratioToCents(p, q) - 23.46);
    if (pythagDiff < 30) commas.push('Near Pythagorean comma (23.5¢)');
    
    analysisHTML += `
    <div style="margin-top:8px;padding:6px;background:rgba(0,255,136,.1);border-radius:4px;font-size:.75rem">
      <strong style="color:#00ff88">Farey sequence:</strong> ${pt.reducedFrac} is a Farey fraction with continued fraction [${getContinuedFraction(pt.residue, pt.mod).join('; ')}]
    </div>
    <div style="margin-top:6px;padding:6px;background:rgba(0,217,255,.1);border-radius:4px;font-size:.75rem">
      <strong style="color:#00d9ff">Harmonic:</strong> ${freq.toFixed(1)} Hz 
      ${getEnhMusicalName(p, q) ? `= <span style="color:#ffd700">${getEnhMusicalName(p, q)}</span>` : ''}
      | ${primeLimit(p, q)}-limit interval
      ${commas.length ? `<br><span style="color:#ff6496">${commas.join(', ')}</span>` : ''}
    </div>
    `;
    
    // Add to chord button
    analysisHTML += `
    <div style="margin-top:6px">
      <button onclick="addToEnhChord(${p},${q})" style="padding:3px 10px;font-size:.7rem;border:1px solid #00ff88;background:rgba(0,255,136,.1);color:#00ff88;border-radius:3px;cursor:pointer">+ Add to Chord</button>
      <button onclick="playEnhFreq(${p},${q})" style="padding:3px 10px;font-size:.7rem;border:1px solid #ffd700;background:rgba(255,215,0,.1);color:#ffd700;border-radius:3px;cursor:pointer;margin-left:4px"> Play ${p}/${q}</button>
    </div>
    `;
  }
  
  analysisDiv.innerHTML = analysisHTML;
}

function checkInCurrentSector(r, mod) {
  const highlightSector = document.getElementById('enhHighlightSector')?.checked;
  if (!highlightSector) return false;
  const sectorFrom = +document.getElementById('enhSectorFrom')?.value || 3;
  const sectorTo = +document.getElementById('enhSectorTo')?.value || 2;
  const frac = r / mod;
  return frac > 1/sectorFrom && frac < 1/sectorTo;
}

function multiplicativeOrder(a, n) {
  if (gcd(a, n) !== 1) return 0;
  let order = 1;
  let current = a % n;
  while (current !== 1 && order <= n) {
    current = (current * a) % n;
    order++;
  }
  return order;
}

function getContinuedFraction(p, q) {
  const cf = [];
  while (q !== 0) {
    cf.push(Math.floor(p / q));
    [p, q] = [q, p % q];
  }
  return cf;
}

function clearEnhPointSelection() {
  enhSelectedPoint = null;
  document.getElementById('enhPointDetails').style.display = 'none';
  drawEnhanced();
}

function updateEnhSectorAnalysis() {
  // Will be called when analysis mode changes
  drawEnhanced();
}

function drawEnhanced(){
enhUpdateVizControls();
const c=document.getElementById('cenhanced'),ctx=c.getContext('2d');

// Ensure canvas has dimensions
if(c.width === 0 || c.height === 0) {
  const sz = +document.getElementById('enhCanvSz')?.value || 800;
  c.width = sz;
  c.height = sz;
}

const moduli=enhGetModuli();
const vizMode=document.getElementById('enhVizMode')?.value||'rings';

// Use optimized progressive renderer for large datasets in rings mode
// Threshold: if total residues > 100,000, use progressive
if(vizMode==='rings'){
  let totalResidues=0;
  moduli.forEach(m=>{totalResidues+=m;});
  if(totalResidues>100000){
    drawEnhancedProgressive();
    return;
  }
}

const zoom=+document.getElementById('enhZoom').value;
const rot=(+document.getElementById('enhRot').value+enhAnimFrame)*Math.PI/180;
// Auto-scale point size based on total residues
const userPtScale=+document.getElementById('enhPtSzNum')?.value||+document.getElementById('enhPtSz').value;
const autoScaleEnh=document.getElementById('autoScaleEnh')?.checked??true;
const ptScale=autoScaleEnh?autoScaleEnhanced(moduli,userPtScale*4)/4:userPtScale;
const gapW=+document.getElementById('enhGapW').value;
const colMode=document.getElementById('enhCol').value;
const lblSz=+document.getElementById('enhLblSz')?.value||9;
const showGcd1=document.getElementById('enhShowGcd1')?.checked??true;
const showNonGcd1=document.getElementById('enhShowNonGcd1')?.checked??true;
const showUnit=document.getElementById('enhShowUnit')?.checked??true;
const lblFmt=document.getElementById('enhLblFmt').value;
const lblWhich=document.getElementById('enhLblWhich').value;
const nonGcdOp=+document.getElementById('enhNonGcdOp').value;
const smithEnabled=document.getElementById('enhSmith')?.checked;
const smithAlpha=+document.getElementById('enhSmithA')?.value||90;
const smithGrid=document.getElementById('enhSmithGrid')?.checked;
const smithConstR=document.getElementById('enhSmithConstR')?.checked;
const smithConstX=document.getElementById('enhSmithConstX')?.checked;
const gaps=enhGetGaps();

// Update description based on view mode
const descDiv=document.getElementById('enhCanvasDesc');
const titleDiv=document.getElementById('enhCanvasTitle');
if(descDiv&&titleDiv){
const colNames={gcd:'By GCD',coprime:'Coprime Binary',ring:'By Ring',residue:'By Residue',gap:'Gap Classes',fire:'Fire Gradient',plasma:'Plasma',viridis:'Viridis',hue:'Hue Cycle',unit:'Unit Group',channel:'By Channel',depth:'By Depth'};
const colDesc=colNames[colMode]||colMode;
if(vizMode==='rings'){
titleDiv.textContent='2D Modular Rings: θ = 2πr/M';
descDiv.innerHTML=`<strong style="color:#ffd700">2D Rings</strong>: Concentric rings showing residue classes mod M. <span style="color:#00ff88">Gold points</span> = coprime residues (gcd(r,M)=1). Each ring M has φ(M) coprime points. Per-ring rotation Δθ shifts each ring by cumulative angle, revealing modular tower structure. <br><strong>Color:</strong> <span style="color:#00d9ff">${colDesc}</span> — Gap connections show pairs r₁,r₂ where r₂-r₁ = gap.`;
}else if(vizMode==='farey3d'){
titleDiv.textContent='3D Farey Divisor Lattice';
descDiv.innerHTML=`<strong style="color:#9664ff">3D Farey Lattice</strong>: Divisor structure of composite M. Each divisor d|M forms a ring at height proportional to d. Points (r,d) represent residue r mod d. Vertical lines connect lifted residues: r mod d lifts to r mod d' when d|d'. <br><strong>Color:</strong> <span style="color:#00d9ff">${colDesc}</span> — Reveals Chinese Remainder Theorem structure.`;
}else if(vizMode==='composite'){
titleDiv.textContent='Composite Channel Structure';
descDiv.innerHTML=`<strong style="color:#ff8c00">Composite Structure</strong>: For M with divisors d₁|d₂|...|M, each divisor creates a "channel ring". Points on channel d have mod-d residue structure. <span style="color:#ff4040">Red lines</span> show projection: non-coprime r maps to r/gcd(r,M) on channel M/gcd(r,M). <br><strong>Color:</strong> <span style="color:#00d9ff">${colDesc}</span> — This is the 3D view flattened to 2D.`;
}else if(vizMode==='multtable'){
titleDiv.textContent='Multiplication Table: (ℤ/mℤ, ×)';
descDiv.innerHTML=`<strong style="color:#9664ff">Multiplication Table</strong>: Cayley table for ring (ℤ/mℤ, ×). Entry (a,b) = a×b mod m. <br><strong>Color schemes explained:</strong><br>
• <span style="color:#ffd700">Unit Group</span>: Yellow = units (gcd=1), forms group (ℤ/mℤ)×<br>
• <span style="color:#ff4040">Zero Divisors</span>: Red where ab≡0 (only for composite m)<br>
• <span style="color:#00ff88">Idempotents</span>: Green where a²≡a mod m<br>
• <span style="color:#00d9ff">Product Value</span>: Hue by result value<br>
• <span style="color:#9664ff">Nilpotents</span>: Purple where aⁿ≡0 for some n`;
}else if(vizMode==='heatmap'){
titleDiv.textContent='GCD Landscape Heatmap: gcd(r, M)';
descDiv.innerHTML=`<strong style="color:#ff8c00">GCD Landscape</strong>: 2D heatmap showing gcd(r,M) for all residues r and moduli M. Rows = moduli (M), Columns = residue fraction (r/M). <br>
• <span style="color:#ffd700">Bright/Gold</span> = gcd(r,M) = 1 (coprime)<br>
• <span style="color:#0066cc">Dark/Blue</span> = higher GCD values<br>
• Vertical patterns reveal divisibility structure<br>
• Horizontal bands show φ(M)/M ratio per row`;
}else if(vizMode==='totient'){
titleDiv.textContent='Totient Ratio Landscape: φ(M)/M';
descDiv.innerHTML=`<strong style="color:#00ff88">Totient Landscape</strong>: Visualization of Euler's totient function ratio φ(M)/M. <br>
• Ring radius ∝ φ(M)/M ratio (coprime density)<br>
• Prime moduli have ratio (M-1)/M ≈ 1 (large rings)<br>
• Highly composite M have low ratios (small rings)<br>
• Formula: φ(M)/M = ∏_{p|M}(1-1/p)<br>
• Color intensity shows how close to theoretical 6/π² density`;
}else if(vizMode==='orbit'){
titleDiv.textContent='Multiplicative Orbits: r → r·g mod M';
descDiv.innerHTML=`<strong style="color:#9664ff">Multiplicative Orbits</strong>: Trace how residues evolve under repeated multiplication by generator g. <br>
• Starting from r, compute r, r·g, r·g², ... mod M<br>
• Coprime residues form cycles (orbits)<br>
• Orbit length divides φ(M) (Lagrange)<br>
• Primitive roots generate full orbit of length φ(M)<br>
• Non-coprime elements map to smaller orbits`;
}else if(vizMode==='fordcircles'){
titleDiv.textContent='Ford Circles on Modular Rings';
descDiv.innerHTML=`<strong style="color:#00d9ff">Ford Circles</strong>: Each fraction p/q has a Ford circle of radius 1/(2q²) tangent to real axis at p/q. <br>
• Farey neighbors have tangent Ford circles<br>
• Circle size inversely proportional to q²<br>
• Visible hierarchy of rational approximations<br>
• Mediant fractions fill gaps between tangent circles<br>
• Shows hyperbolic geometry of Farey graph`;
}else if(vizMode==='trajectory'){
titleDiv.textContent='Trajectory Coherence Analysis: Phase Drift D(r)';
descDiv.innerHTML=`<strong style="color:#00d9ff">Trajectory Coherence</strong>: Track residue r through phases φ(r,m) = (r/m) mod 1 for coprime m. <br>
• <strong>Drift D(r)</strong>: Cumulative phase jumps — low drift = coherent trajectory<br>
• <strong>Shell Discovery</strong>: r = p-1 residues form anomalously coherent shells<br>
• <strong>Twin-Prime Link</strong>: p-1 has 1.76x LESS drift than primes (p < 0.001)<br>
• Click "Compute Stats" for full analysis and statistical comparison`;
}
}

// Show/hide trajectory controls
updateEnhancedVizControls();

ctx.fillStyle=canvBg();ctx.fillRect(0,0,c.width,c.height);
const cx=c.width/2,cy=c.height/2;
const smithRad=(c.width/2-40)*zoom;

// Build ring data from moduli array FIRST (needed for all modes and sector analysis)
enhRingsData=[];
const maxMod=Math.max(...moduli,1);
moduli.forEach(m=>{
const coprimes=getCoprimes(m);
const allRes=getAllResidues(m);
enhRingsData.push({mod:m,coprimes,allRes,isUnit:m===1});
});

if(enhRingsData.length===0){
ctx.fillStyle='rgba(255,255,255,.5)';ctx.font='20px Segoe UI';ctx.textAlign='center';
ctx.fillText('Set modulus range to visualize',c.width/2,c.height/2);
updateEnhStats();return;
}

// Calculate radii (check invert option for visual order)
const enhInvertOrder=document.getElementById('enhInvertRings')?.checked||false;
enhRingsData.forEach((ring,idx)=>{
ring.radius=enhCalcRadius(ring.mod,idx,enhRingsData.length,maxMod,enhInvertOrder);
ring.idx=idx;
});

// ===== TRAJECTORY MODE =====
if(vizMode==='trajectory'){
// Draw trajectory coherence on main Enhanced canvas
drawEnhancedTrajectory(ctx, c, moduli);
updateEnhStats();
return;
}

// ===== 3D FAREY LATTICE MODE =====
if(vizMode==='farey3d'){
drawEnhFarey3D(ctx,c,moduli,colMode,ptScale,zoom,lblSz,rot);
updateEnhStats();return;
}

// ===== COMPOSITE STRUCTURE MODE =====
if(vizMode==='composite'){
drawEnhComposite(ctx,c,moduli,colMode,ptScale,zoom,gaps,gapW,lblSz,rot);
updateEnhStats();return;
}

// ===== MULTIPLICATION TABLE MODE =====
if(vizMode==='multtable'){
drawMultiplicationTable(ctx,c,moduli[moduli.length-1]||30,colMode,ptScale,zoom,lblSz);
updateEnhStats();return;
}

// ===== GCD HEATMAP MODE =====
if(vizMode==='heatmap'){
drawGCDHeatmap(ctx,c,moduli,colMode,ptScale,zoom,lblSz);
updateEnhStats();return;
}

// ===== TOTIENT LANDSCAPE MODE =====
if(vizMode==='totient'){
drawTotientLandscape(ctx,c,moduli,colMode,ptScale,zoom,lblSz,rot);
updateEnhStats();return;
}

// ===== MULTIPLICATIVE ORBITS MODE =====
if(vizMode==='orbit'){
drawMultiplicativeOrbits(ctx,c,moduli,colMode,ptScale,zoom,lblSz,rot);
updateEnhStats();return;
}

// ===== FORD CIRCLES MODE =====
if(vizMode==='fordcircles'){
drawFordCirclesMode(ctx,c,moduli,colMode,ptScale,zoom,lblSz);
updateEnhStats();return;
}


// ===== STANDARD 2D RINGS MODE =====
ctx.save();
ctx.translate(cx,cy);

// Smith Chart settings
const smithLifts=document.getElementById('enhSmithLifts')?.checked??true;
const smithGaps=document.getElementById('enhSmithGaps')?.checked??true;
const smithZoom=+document.getElementById('enhSmithZoom')?.value||1;
const smithOffX=+document.getElementById('enhSmithOffX')?.value||0;
const smithOffY=+document.getElementById('enhSmithOffY')?.value||0;
const smithInvert=document.getElementById('enhSmithInvert')?.checked;
const smithReflect=document.getElementById('enhSmithReflect')?.checked;
const smithPtScale=+document.getElementById('enhSmithPtScale')?.value||1;
const smithLineW=+document.getElementById('enhSmithLineW')?.value||1;
const smithUnitCircle=document.getElementById('enhSmithUnitCircle')?.checked??true;

// Per-ring rotation settings
const enhRingInc=(+document.getElementById('enhRingInc')?.value||0)*Math.PI/180;
const enhPhase=(+document.getElementById('enhPhase')?.value||0)*Math.PI/180;
const enhInvertRings=document.getElementById('enhInvertRings')?.checked||false;
const enhShowLabels=document.getElementById('enhShowLabels')?.checked||false;
const numRings=enhRingsData.length;

// Helper: get point coordinates (Smith or polar) WITH per-ring rotation
const getPoint=(ring,r)=>{
const ringIdx=enhInvertRings?(numRings-1-ring.idx):ring.idx;
const ringRotation=ringIdx*enhRingInc+enhPhase;
if(smithEnabled){
let theta=2*Math.PI*(ring.mod-r)/ring.mod+ringRotation;
if(smithReflect)theta=-theta; // Reflect across vertical axis
const dist=ring.radius/320;
let sm=smithTransform(0.5+dist*1.5,theta,smithAlpha);
if(smithInvert){sm.x=-sm.x;sm.y=-sm.y;} // Invert through origin
// Apply Smith zoom and offset
const scaledRad=smithRad*smithZoom;
return{x:sm.x*scaledRad+smithOffX,y:-sm.y*scaledRad+smithOffY};
}else{
const angle=2*Math.PI*(ring.mod-r)/ring.mod+ringRotation;
return{x:ring.radius*Math.cos(angle),y:ring.radius*Math.sin(angle)};
}};

// Smith Chart mode
if(smithEnabled){
ctx.save();
ctx.translate(smithOffX,smithOffY);
ctx.scale(smithZoom,smithZoom);
if(smithInvert)ctx.scale(-1,-1);
if(smithReflect)ctx.scale(-1,1);
ctx.lineWidth=smithLineW;
drawSmithGrid(ctx,0,0,smithRad,smithGrid,smithConstR,smithConstX);
if(smithUnitCircle){
ctx.strokeStyle=bordC();ctx.lineWidth=2*smithLineW;
ctx.beginPath();ctx.arc(0,0,smithRad,0,2*Math.PI);ctx.stroke();
}
ctx.restore();
}else{
ctx.scale(zoom,zoom);
ctx.rotate(rot);
}

// ===== SWEEP & RAY OVERLAYS =====
const showRays=document.getElementById('enhShowRays')?.checked;
const showSectors=document.getElementById('enhShowSectors')?.checked;
const showFareySectors=document.getElementById('enhShowFareySectors')?.checked;
const showMediants=document.getElementById('enhShowMediants')?.checked;
const rayOp=+document.getElementById('enhRayOp')?.value||0.3;
const rayMode=document.getElementById('enhRayMode')?.value||'all';
const sectorDepth=+document.getElementById('enhSectorDepth')?.value||6;
const outerR=enhRingsData.length>0?Math.max(...enhRingsData.map(r=>r.radius)):300;

// Draw highlighted sector wedge (background)
const highlightSector=document.getElementById('enhHighlightSector')?.checked;
const sectorFrom=+document.getElementById('enhSectorFrom')?.value||3;
const sectorTo=+document.getElementById('enhSectorTo')?.value||2;
if(highlightSector&&!smithEnabled){
  ctx.save();
  // Angles: θ = 2π * (1/n) but we need to convert fraction to angle
  // For fraction p/q, angle = 2π * p/q, but our ring uses (M-r)/M
  // Sector from 1/fromN to 1/toN means angles 2π/fromN to 2π/toN
  const angleStart=2*Math.PI/sectorFrom; // smaller angle (larger fraction denominator)
  const angleEnd=2*Math.PI/sectorTo;     // larger angle (smaller fraction denominator)
  
  // Draw filled wedge
  ctx.fillStyle='rgba(150,100,255,0.15)';
  ctx.beginPath();
  ctx.moveTo(0,0);
  ctx.arc(0,0,outerR*1.05,angleStart,angleEnd);
  ctx.lineTo(0,0);
  ctx.fill();
  
  // Draw wedge borders
  ctx.strokeStyle='rgba(150,100,255,0.6)';
  ctx.lineWidth=2;
  ctx.setLineDash([]);
  ctx.beginPath();
  ctx.moveTo(0,0);
  ctx.lineTo(outerR*1.1*Math.cos(angleStart),outerR*1.1*Math.sin(angleStart));
  ctx.stroke();
  ctx.beginPath();
  ctx.moveTo(0,0);
  ctx.lineTo(outerR*1.1*Math.cos(angleEnd),outerR*1.1*Math.sin(angleEnd));
  ctx.stroke();
  
  // Arc at outer edge
  ctx.beginPath();
  ctx.arc(0,0,outerR*1.05,angleStart,angleEnd);
  ctx.stroke();
  
  // Labels for sector boundaries
  ctx.fillStyle='#9664ff';
  ctx.font='bold 10px Segoe UI';
  ctx.textAlign='center';
  const lx1=(outerR*1.15)*Math.cos(angleStart);
  const ly1=(outerR*1.15)*Math.sin(angleStart);
  ctx.fillText(`1/${sectorFrom}`,lx1,-ly1);
  const lx2=(outerR*1.15)*Math.cos(angleEnd);
  const ly2=(outerR*1.15)*Math.sin(angleEnd);
  ctx.fillText(`1/${sectorTo}`,lx2,-ly2);
  
  // Root mediant label - positioned outside the circle
  const rootAngle=(angleStart+angleEnd)/2; // midpoint of sector
  const rx=(outerR*1.25)*Math.cos(rootAngle);
  const ry=(outerR*1.25)*Math.sin(rootAngle);
  ctx.fillStyle='rgba(255,215,0,0.9)';
  ctx.font='bold 10px Segoe UI';
  ctx.fillText(`S${sectorFrom}: 2/${sectorFrom+sectorTo}`,rx,-ry);
  
  ctx.restore();
}

// Draw Farey sector boundaries (1/n lines)
if(showFareySectors&&!smithEnabled){
  ctx.save();
  for(let n=2;n<=sectorDepth;n++){
    const angle=2*Math.PI/n;
    const hue=(n*60)%360;
    ctx.strokeStyle=`hsla(${hue},80%,60%,${0.4})`;
    ctx.lineWidth=1.5;
    ctx.setLineDash([4,4]);
    ctx.beginPath();
    ctx.moveTo(0,0);
    ctx.lineTo(outerR*1.1*Math.cos(angle),outerR*1.1*Math.sin(angle));
    ctx.stroke();
    // Label
    ctx.fillStyle=`hsla(${hue},80%,70%,0.8)`;
    ctx.font='9px Segoe UI';
    ctx.textAlign='center';
    const lx=(outerR*1.15)*Math.cos(angle);
    const ly=(outerR*1.15)*Math.sin(angle);
    ctx.fillText(`1/${n}`,lx,-ly);
  }
  ctx.setLineDash([]);
  ctx.restore();
}

// Draw sector boundaries (uniform angular divisions)
if(showSectors&&!smithEnabled){
  ctx.save();
  const numSectors=sectorDepth;
  for(let i=0;i<numSectors;i++){
    const angle=2*Math.PI*i/numSectors;
    ctx.strokeStyle=`rgba(255,215,0,0.2)`;
    ctx.lineWidth=1;
    ctx.beginPath();
    ctx.moveTo(0,0);
    ctx.lineTo(outerR*1.05*Math.cos(angle),outerR*1.05*Math.sin(angle));
    ctx.stroke();
  }
  ctx.restore();
}

// Draw mediant lines (connecting Farey neighbors on outer ring)
if(showMediants&&enhRingsData.length>0&&!smithEnabled){
  const outerRing=enhRingsData[enhRingsData.length-1];
  const M=outerRing.mod;
  const ringIdx=enhInvertRings?0:(numRings-1);
  const ringRotation=ringIdx*enhRingInc+enhPhase;
  ctx.save();
  ctx.strokeStyle=`rgba(0,255,200,0.3)`;
  ctx.lineWidth=1;
  // Find coprime pairs that are Farey neighbors
  for(let p1=1;p1<M;p1++){
    if(gcd(p1,M)!==1)continue;
    for(let p2=p1+1;p2<M;p2++){
      if(gcd(p2,M)!==1)continue;
      // Check if Farey neighbors: |p1*M - p2*M| = |p1-p2|*M... simplified check
      const diff=p2-p1;
      if(diff<=Math.floor(M/4)){ // Only close neighbors
        const ang1=2*Math.PI*(M-p1)/M+ringRotation;
        const ang2=2*Math.PI*(M-p2)/M+ringRotation;
        ctx.beginPath();
        ctx.moveTo(outerRing.radius*Math.cos(ang1),outerRing.radius*Math.sin(ang1));
        ctx.lineTo(outerRing.radius*Math.cos(ang2),outerRing.radius*Math.sin(ang2));
        ctx.stroke();
      }
    }
  }
  ctx.restore();
}

// Draw ring circles (non-Smith) with optional modulus labels
// Scale opacity based on ring count to prevent accumulation
const ringOpacity = Math.max(0.02, Math.min(0.2, 10 / enhRingsData.length));
if(!smithEnabled){
enhRingsData.forEach((ring,idx)=>{
if(ring.isUnit&&!showUnit)return;
// Skip ring circles for large datasets (>200 rings) to reduce visual clutter
if(enhRingsData.length > 200 && !ring.isUnit) return;
ctx.beginPath();ctx.arc(0,0,ring.radius,0,2*Math.PI);
if(ring.isUnit){ctx.strokeStyle='rgba(255,215,0,.8)';ctx.lineWidth=3;}
else{ctx.strokeStyle=`rgba(255,255,255,${ringOpacity})`;ctx.lineWidth=1;ctx.setLineDash([2,4]);}
ctx.stroke();ctx.setLineDash([]);
// Ring modulus label
if(enhShowLabels){
const ringIdx=enhInvertRings?(numRings-1-idx):idx;
const ringRotation=ringIdx*enhRingInc+enhPhase;
const labelAngle=-Math.PI/2+ringRotation; // Position at top, rotated
const lx=ring.radius*Math.cos(labelAngle);
const ly=ring.radius*Math.sin(labelAngle);
const lblSz=+document.getElementById('enhLblSz')?.value||9;
ctx.fillStyle='rgba(255,215,0,0.9)';
ctx.font=`bold ${lblSz}px Segoe UI`;
ctx.textAlign='center';
ctx.fillText(`M=${ring.mod}`,lx,ly-8);
}
});
}

// Draw gap connections (works in both modes now)
if(gaps.length>0&&(!smithEnabled||smithGaps)){
enhRingsData.forEach(ring=>{
if(ring.isUnit||ring.mod<2)return;
gaps.forEach((gap,gi)=>{
const hue=(gi*360/gaps.length)%360;
ctx.strokeStyle=`hsla(${hue},80%,60%,${smithEnabled?0.8:0.6})`;ctx.lineWidth=gapW*(smithEnabled?0.7:1);
ring.coprimes.forEach(r=>{
const r2=(r+gap)%ring.mod;
if(ring.coprimes.includes(r2)){
const p1=getPoint(ring,r);
const p2=getPoint(ring,r2);
ctx.beginPath();
ctx.moveTo(p1.x,p1.y);
ctx.lineTo(p2.x,p2.y);
ctx.stroke();
}});});});
}

// Draw lift lines with 4 modes like Og.html
const showDirectLifts=document.getElementById('enhDirectLifts')?.checked;
const showModLifts=document.getElementById('enhModLifts')?.checked;
const showSkipLifts=document.getElementById('enhSkipLifts')?.checked;
const showAllLifts=document.getElementById('enhAllLifts')?.checked;
const liftW=+(document.getElementById('enhLiftW')?.value||1);
const liftCol=document.getElementById('enhLiftCol')?.value||'#00d9ff';
const modLiftCol=document.getElementById('enhModLiftCol')?.value||'#ff6496';

if((showDirectLifts||showModLifts||showSkipLifts||showAllLifts)&&enhRingsData.length>1&&(!smithEnabled||smithLifts)){
const baseLiftThickness=(0.5+liftW*2)*(smithEnabled?0.6:1);

for(let i=0;i<enhRingsData.length;i++){
for(let j=i+1;j<enhRingsData.length;j++){
const ring1=enhRingsData[i],ring2=enhRingsData[j];
const isConsecutive=(j===i+1);

// Skip unit circle for modular lifts
if(ring1.isUnit&&!showDirectLifts)continue;

ring1.coprimes.forEach(r=>{
// 1. Direct lifts (r→r) - consecutive only unless showAllLifts
if(showDirectLifts&&(isConsecutive||showAllLifts)){
if(ring2.coprimes.includes(r%ring2.mod)){
const p1=getPoint(ring1,r);
const p2=getPoint(ring2,r%ring2.mod);
ctx.beginPath();ctx.moveTo(p1.x,p1.y);ctx.lineTo(p2.x,p2.y);
ctx.strokeStyle=ring1.isUnit?'rgba(255,215,0,0.7)':liftCol;
ctx.lineWidth=isConsecutive?baseLiftThickness:baseLiftThickness*0.5;
ctx.globalAlpha=isConsecutive?0.6:0.25;
ctx.stroke();ctx.globalAlpha=1;
}}

// 2. Modular lifts (r→r+M) - like Og.html cardioid pattern for a^b
if(showModLifts&&!ring1.isUnit&&!ring2.isUnit){
const shouldDraw=isConsecutive||(showSkipLifts&&!isConsecutive);
if(shouldDraw){
// For power families a^b: shift = M₁ creates cardioid when b=2
const shift=ring1.mod;
const liftedR=(r+shift)%ring2.mod;
if(ring2.coprimes.includes(liftedR)){
const p1=getPoint(ring1,r);
const p2=getPoint(ring2,liftedR);
ctx.beginPath();ctx.moveTo(p1.x,p1.y);ctx.lineTo(p2.x,p2.y);
ctx.strokeStyle=modLiftCol;
ctx.lineWidth=isConsecutive?baseLiftThickness*0.9:baseLiftThickness*0.4;
ctx.globalAlpha=isConsecutive?0.5:0.2;
ctx.stroke();ctx.globalAlpha=1;
}}}

// 3. Skip-level modular lifts with power-adjusted shift
if(showSkipLifts&&!isConsecutive&&!ring1.isUnit&&!ring2.isUnit){
// For a^n families: compute proper shift based on exponent difference
const mode=document.getElementById('enhMode').value;
if(mode==='power'){
const base=+document.getElementById('enhBase').value||2;
// ring1.mod = base^e1, ring2.mod = base^e2
// Proper modular shift: base^e1 * base^(e2-e1-1) = base^(e2-1)
const e1=Math.round(Math.log(ring1.mod)/Math.log(base));
const e2=Math.round(Math.log(ring2.mod)/Math.log(base));
const nDiff=e2-e1;
if(nDiff>1){
const shift=ring1.mod*Math.pow(base,nDiff-1);
const liftedR=(r+shift)%ring2.mod;
if(ring2.coprimes.includes(liftedR)){
const p1=getPoint(ring1,r);
const p2=getPoint(ring2,liftedR);
ctx.beginPath();ctx.moveTo(p1.x,p1.y);ctx.lineTo(p2.x,p2.y);
ctx.strokeStyle='rgba(150,100,255,0.4)';
ctx.lineWidth=baseLiftThickness*0.35;
ctx.stroke();
}}}}
});}}}

// ===== SAME-MOD CONNECTIONS (within same ring) =====
const showSameModConn = document.getElementById('enhSameModConn')?.checked;
const showSameModAdj = document.getElementById('enhSameModAdj')?.checked;
const showSameModGap = document.getElementById('enhSameModGap')?.checked;
const sameModPattern = document.getElementById('enhSameModPattern')?.value || 'all';
const sameModCol = document.getElementById('enhSameModCol')?.value || '#00ff88';

if((showSameModConn || showSameModAdj || showSameModGap) && !smithEnabled) {
  const sameModThickness = (0.5 + liftW * 1.5);
  const activeGaps = enhGetGaps();
  
  enhRingsData.forEach((ring, ringIdx) => {
    if(ring.isUnit || ring.mod < 3) return;
    const rIdx = enhInvertRings ? (numRings - 1 - ringIdx) : ringIdx;
    const ringRotation = rIdx * enhRingInc + enhPhase;
    
    // Get eligible residues based on pattern
    let eligibleResidues = [...ring.coprimes];
    if(sameModPattern === 'quadratic') {
      eligibleResidues = ring.coprimes.filter(r => {
        for(let x = 1; x < ring.mod; x++) {
          if((x * x) % ring.mod === r) return true;
        }
        return false;
      });
    } else if(sameModPattern === 'primitive') {
      // Primitive roots: elements of order φ(M)
      const phi = ring.coprimes.length;
      eligibleResidues = ring.coprimes.filter(r => {
        let curr = r;
        for(let k = 1; k < phi; k++) {
          curr = (curr * r) % ring.mod;
          if(curr === 1) return false;
        }
        return (curr * r) % ring.mod === 1;
      });
    }
    
    for(let i = 0; i < eligibleResidues.length; i++) {
      const r1 = eligibleResidues[i];
      
      for(let j = i + 1; j < eligibleResidues.length; j++) {
        const r2 = eligibleResidues[j];
        let shouldDraw = false;
        let lineAlpha = 0.4;
        
        // Adjacent only mode
        if(showSameModAdj) {
          const diff = Math.abs(r2 - r1);
          if(diff === 1 || diff === ring.mod - 1) {
            shouldDraw = true;
            lineAlpha = 0.7;
          }
        }
        
        // Gap class mode
        if(showSameModGap && activeGaps.length > 0) {
          const diff = Math.min(Math.abs(r2 - r1), ring.mod - Math.abs(r2 - r1));
          if(activeGaps.includes(diff)) {
            shouldDraw = true;
            lineAlpha = 0.6;
          }
        }
        
        // All coprimes mode (Farey neighbors check for that pattern)
        if(showSameModConn && !showSameModAdj && !showSameModGap) {
          if(sameModPattern === 'neighbors') {
            // Farey neighbor: |r1*q2 - r2*q1| = 1 where both are p/M fractions
            // Simplified: |r1 - r2| divides M or gcd condition
            const g = gcd(Math.abs(r1 - r2), ring.mod);
            if(g === 1 || g === ring.mod) shouldDraw = true;
          } else {
            shouldDraw = true;
            lineAlpha = 0.25;
          }
        }
        
        if(shouldDraw) {
          const ang1 = 2 * Math.PI * (ring.mod - r1) / ring.mod + ringRotation;
          const ang2 = 2 * Math.PI * (ring.mod - r2) / ring.mod + ringRotation;
          const p1 = { x: ring.radius * Math.cos(ang1), y: ring.radius * Math.sin(ang1) };
          const p2 = { x: ring.radius * Math.cos(ang2), y: ring.radius * Math.sin(ang2) };
          
          ctx.beginPath();
          ctx.moveTo(p1.x, p1.y);
          ctx.lineTo(p2.x, p2.y);
          ctx.strokeStyle = sameModCol;
          ctx.lineWidth = sameModThickness * 0.6;
          ctx.globalAlpha = lineAlpha;
          ctx.stroke();
          ctx.globalAlpha = 1;
        }
      }
    }
  });
}

// ===== CUSTOM CONNECTIONS =====
const showCustomConn = document.getElementById('enhCustomConn')?.checked;
const customConnExpr = document.getElementById('enhCustomConnExpr')?.value || '';

if(showCustomConn && customConnExpr && !smithEnabled) {
  const customThickness = (0.5 + liftW * 1.5);
  
  enhRingsData.forEach((ring, ringIdx) => {
    if(ring.isUnit) return;
    const rIdx = enhInvertRings ? (numRings - 1 - ringIdx) : ringIdx;
    const ringRotation = rIdx * enhRingInc + enhPhase;
    const M = ring.mod;
    
    ring.coprimes.forEach(r => {
      try {
        // Evaluate custom expression
        let r2;
        const expr = customConnExpr.replace(/modInverse\((\w+),(\w+)\)/g, (_, a, b) => {
          const av = a === 'r' ? r : (a === 'M' ? M : parseInt(a));
          const bv = b === 'r' ? r : (b === 'M' ? M : parseInt(b));
          return modInverse(av, bv);
        });
        r2 = eval(expr.replace(/r/g, r).replace(/M/g, M));
        r2 = ((r2 % M) + M) % M;
        
        if(r2 !== r && ring.coprimes.includes(r2)) {
          const ang1 = 2 * Math.PI * (M - r) / M + ringRotation;
          const ang2 = 2 * Math.PI * (M - r2) / M + ringRotation;
          const p1 = { x: ring.radius * Math.cos(ang1), y: ring.radius * Math.sin(ang1) };
          const p2 = { x: ring.radius * Math.cos(ang2), y: ring.radius * Math.sin(ang2) };
          
          ctx.beginPath();
          ctx.moveTo(p1.x, p1.y);
          ctx.lineTo(p2.x, p2.y);
          ctx.strokeStyle = '#9664ff';
          ctx.lineWidth = customThickness * 0.7;
          ctx.globalAlpha = 0.5;
          ctx.stroke();
          ctx.globalAlpha = 1;
        }
      } catch(e) { /* ignore eval errors */ }
    });
  });
}

// ===== SECTOR DYNAMICS =====
const showSectorDynamics = document.getElementById('enhSectorDynamics')?.checked;
const sectorCrossOnly = document.getElementById('enhSectorCrossOnly')?.checked;
const sectorDynMode = document.getElementById('enhSectorDynMode')?.value || 'within';

if(showSectorDynamics && highlightSector && !smithEnabled) {
  const sectorThickness = (0.5 + liftW * 1.8);
  const sFrom = +document.getElementById('enhSectorFrom')?.value || 3;
  const sTo = +document.getElementById('enhSectorTo')?.value || 2;
  const sectorMinAngle = Math.atan2(1, sFrom);
  const sectorMaxAngle = Math.atan2(1, sTo);
  
  // Helper to check if residue is in sector
  const inSector = (r, M, rotation) => {
    const angle = 2 * Math.PI * (M - r) / M + rotation;
    const normAngle = ((angle % (2 * Math.PI)) + 2 * Math.PI) % (2 * Math.PI);
    return normAngle >= sectorMinAngle && normAngle <= sectorMaxAngle;
  };
  
  // Draw sector-filtered connections between rings
  for(let i = 0; i < enhRingsData.length; i++) {
    const ring1 = enhRingsData[i];
    if(ring1.isUnit) continue;
    const rIdx1 = enhInvertRings ? (numRings - 1 - i) : i;
    const rot1 = rIdx1 * enhRingInc + enhPhase;
    
    for(let j = i + 1; j < enhRingsData.length; j++) {
      const ring2 = enhRingsData[j];
      if(ring2.isUnit) continue;
      const rIdx2 = enhInvertRings ? (numRings - 1 - j) : j;
      const rot2 = rIdx2 * enhRingInc + enhPhase;
      
      ring1.coprimes.forEach(r1 => {
        const in1 = inSector(r1, ring1.mod, rot1);
        
        ring2.coprimes.forEach(r2 => {
          const in2 = inSector(r2, ring2.mod, rot2);
          
          let shouldDraw = false;
          
          if(sectorDynMode === 'within') {
            // Both must be in sector
            shouldDraw = in1 && in2;
          } else if(sectorDynMode === 'boundary') {
            // One in, one out (crossing boundary)
            shouldDraw = (in1 !== in2);
          } else if(sectorDynMode === 'mediant') {
            // Connect if r2/M2 is mediant of r1/M1 with sector bounds
            if(in1 && in2) {
              const ratio1 = r1 / ring1.mod;
              const ratio2 = r2 / ring2.mod;
              const diff = Math.abs(ratio1 - ratio2);
              shouldDraw = diff < 0.1;
            }
          } else if(sectorDynMode === 'farey') {
            // Farey sequence order within sector
            if(in1 && in2) {
              // Check if Farey neighbors
              const det = Math.abs(r1 * ring2.mod - r2 * ring1.mod);
              shouldDraw = (det === 1 || det === ring1.mod || det === ring2.mod);
            }
          }
          
          if(sectorCrossOnly && in1 === in2) shouldDraw = false;
          
          if(shouldDraw) {
            const ang1 = 2 * Math.PI * (ring1.mod - r1) / ring1.mod + rot1;
            const ang2 = 2 * Math.PI * (ring2.mod - r2) / ring2.mod + rot2;
            const p1 = { x: ring1.radius * Math.cos(ang1), y: ring1.radius * Math.sin(ang1) };
            const p2 = { x: ring2.radius * Math.cos(ang2), y: ring2.radius * Math.sin(ang2) };
            
            ctx.beginPath();
            ctx.moveTo(p1.x, p1.y);
            ctx.lineTo(p2.x, p2.y);
            ctx.strokeStyle = '#ff8c00';
            ctx.lineWidth = sectorThickness * 0.5;
            ctx.globalAlpha = 0.4;
            ctx.stroke();
            ctx.globalAlpha = 1;
          }
        });
      });
    }
  }
}

// ===== DRAW LIGHT RAYS FROM ORIGIN =====
if(showRays&&!smithEnabled){
  ctx.save();
  enhRingsData.forEach((ring,idx)=>{
    if(ring.isUnit&&!showUnit)return;
    const isOuter=(idx===enhRingsData.length-1);
    const rayResidues=[];
    if(rayMode==='all'||rayMode==='coprime'){rayResidues.push(...ring.coprimes.map(r=>({r,gcd1:true})));}
    if(rayMode==='all'&&showNonGcd1&&!ring.isUnit){const non=ring.allRes.filter(r=>!ring.coprimes.includes(r));rayResidues.push(...non.map(r=>({r,gcd1:false})));}
    if(rayMode==='outer'&&!isOuter)return;
    const rIdx=enhInvertRings?(numRings-1-ring.idx):ring.idx;
    const rRot=rIdx*enhRingInc+enhPhase;
    rayResidues.forEach(({r,gcd1})=>{
      const angle=2*Math.PI*(ring.mod-r)/ring.mod+rRot;
      const px=ring.radius*Math.cos(angle);
      const py=ring.radius*Math.sin(angle);
      const hue=(r/ring.mod)*360;
      ctx.strokeStyle=gcd1?`hsla(${hue},80%,70%,${rayOp})`:`rgba(100,100,100,${rayOp*0.5})`;
      ctx.lineWidth=gcd1?1:0.5;
      ctx.beginPath();ctx.moveTo(0,0);ctx.lineTo(px,py);ctx.stroke();
    });
  });
  ctx.restore();
}

// Draw points
enhRingsData.forEach((ring,idx)=>{
if(ring.isUnit&&!showUnit)return;
const residues=[];
if(showGcd1)residues.push(...ring.coprimes.map(r=>({r,gcd1:true})));
if(showNonGcd1&&!ring.isUnit){
const non=ring.allRes.filter(r=>!ring.coprimes.includes(r));
residues.push(...non.map(r=>({r,gcd1:false})));
}

// Calculate per-ring rotation for THIS ring
const ringIdx=enhInvertRings?(numRings-1-ring.idx):ring.idx;
const ringRotation=ringIdx*enhRingInc+enhPhase;

residues.forEach(({r,gcd1})=>{
let px,py;
if(smithEnabled){
let theta=2*Math.PI*(ring.mod-r)/ring.mod+ringRotation;
if(smithReflect)theta=-theta;
const dist=ring.radius/320;
let sm=smithTransform(0.5+dist*1.5,theta,smithAlpha);
if(smithInvert){sm.x=-sm.x;sm.y=-sm.y;}
const scaledRad=smithRad*smithZoom;
px=sm.x*scaledRad+smithOffX;py=-sm.y*scaledRad+smithOffY;
}else{
const angle=2*Math.PI*(ring.mod-r)/ring.mod+ringRotation;
px=ring.radius*Math.cos(angle);py=ring.radius*Math.sin(angle);
}

// Check if point is in highlighted sector
const highlightSector=document.getElementById('enhHighlightSector')?.checked;
const sectorFrom=+document.getElementById('enhSectorFrom')?.value||3;
const sectorTo=+document.getElementById('enhSectorTo')?.value||2;
const sectorColorMode=document.getElementById('enhSectorColorMode')?.value||'preserve';
const frac=r/ring.mod;
const inSector=frac>1/sectorFrom&&frac<1/sectorTo;

const baseSize=ring.isUnit?7:(ring.radius>200?5:4);
let ptSz=baseSize*ptScale*(smithEnabled?0.7*smithPtScale:1);
// Make points in sector larger
if(highlightSector&&inSector&&gcd1)ptSz*=1.3;

let clr;
if(colMode==='angular'){const h=(r/ring.mod)*360;clr=`hsl(${h},80%,60%)`;}
else if(colMode==='gcd'){clr=gcd1?'#ffd700':'#555';}
else if(colMode==='ring'){const h=(ringIdx/enhRingsData.length)*300;clr=`hsl(${h},70%,55%)`;}
else if(colMode==='coprime'){clr=gcd1?'#00ff88':'#ff4040';}
else if(colMode==='harmonic'){
  // Harmonic/musical coloring based on denominator q
  if(gcd1){
    const[p,q]=reduceFrac(r,ring.mod);
    clr=getEnhHarmonicColor(q,isDark());
  }else{clr=isDark()?'#333':'#bbb';}
}
else if(colMode==='primelimit'){
  // Color by prime limit of reduced fraction
  if(gcd1){
    const[p,q]=reduceFrac(r,ring.mod);
    clr=getEnhPrimeLimitColor(p,q,isDark());
  }else{clr=isDark()?'#333':'#bbb';}
}
else if(colMode==='tenney'){
  // Color by Tenney height (complexity)
  if(gcd1){
    const[p,q]=reduceFrac(r,ring.mod);
    clr=getEnhTenneyColor(p,q,isDark());
  }else{clr=isDark()?'#333':'#bbb';}
}
else if(colMode==='consonance'){
  // Color by consonance category
  if(gcd1){
    const[p,q]=reduceFrac(r,ring.mod);
    clr=getEnhConsonanceColor(p,q,isDark());
  }else{clr=isDark()?'#333':'#bbb';}
}
else if(colMode==='spectrum'){if(gcd1){const phi=ring.coprimes.length/ring.mod;clr=`hsl(${phi*240},80%,60%)`;}else clr='#333';}
else if(colMode==='sector'){
  // Stern-Brocot sector coloring: S_n = (1/(n+1), 1/n)
  const frac=r/ring.mod;
  let sec=0;
  for(let n=1;n<=20;n++){if(frac>1/(n+1)&&frac<=1/n){sec=n;break;}}
  clr=sec>0?`hsl(${sec*40},75%,${gcd1?55:35}%)`:'#444';
}
else if(colMode==='depth'){
  // Stern-Brocot tree depth approximation
  const d=Math.floor(Math.log2(ring.mod+1));
  clr=`hsl(${d*25+120},${gcd1?70:40}%,${gcd1?55:35}%)`;
}
else if(colMode==='primality'){
  // Color by whether r*gcd is prime-like
  const prod=r*gcd(r,ring.mod);
  const isPrimeish=(prod>1&&prod<100)?!Array.from({length:Math.floor(Math.sqrt(prod))-1},(_,i)=>i+2).some(d=>prod%d===0):false;
  clr=isPrimeish?'#00ff88':gcd1?'#ffd700':'#666';
}
else if(colMode==='quadres'){
  // Quadratic residue coloring
  const isQR=ring.coprimes.some(c=>(c*c)%ring.mod===r%ring.mod);
  clr=isQR?'#00d9ff':'#ff6496';
}
else if(colMode==='discrete'){
  const cols=['#e6194b','#3cb44b','#ffe119','#4363d8','#f58231','#911eb4','#46f0f0','#f032e6','#bcf60c','#fabebe','#008080','#e6beff','#9a6324','#fffac8','#800000','#aaffc3','#808000','#ffd8b1','#000075','#808080'];
  const g=gcd(r,ring.mod);
  clr=cols[(g-1)%cols.length];
}
else if(colMode==='multtable'){
  const prod=(r*ring.mod)%ring.mod;
  const h=(prod/ring.mod)*360;
  clr=`hsl(${h},${gcd1?80:50}%,${gcd1?55:35}%)`;
}
else if(colMode==='zerodiv'){
  clr=gcd1?'#4488ff':'#ff4040';
}
else if(colMode==='idempotent'){
  const isIdem=(r*r)%ring.mod===r;
  clr=isIdem?'#ffd700':gcd1?'#4488ff':'#666';
}
else if(colMode==='fire'){
  const t=r/ring.mod;
  if(t<0.25)clr=`rgb(${Math.floor(t*4*255)},0,0)`;
  else if(t<0.5)clr=`rgb(255,${Math.floor((t-0.25)*4*255)},0)`;
  else if(t<0.75)clr=`rgb(255,255,${Math.floor((t-0.5)*4*255)})`;
  else clr=`rgb(255,255,255)`;
}
else if(colMode==='plasma'){
  const t=r/ring.mod;
  const r_=Math.floor(13+t*242);
  const g_=Math.floor(8+Math.sin(t*Math.PI)*200);
  const b_=Math.floor(135+t*120);
  clr=`rgb(${r_},${g_},${b_})`;
}
else if(colMode==='viridis'){
  const t=r/ring.mod;
  const r_=Math.floor(68+t*187);
  const g_=Math.floor(1+t*208);
  const b_=Math.floor(84+t*(-60+Math.sin(t*Math.PI)*100));
  clr=`rgb(${Math.min(255,r_)},${Math.min(255,g_)},${Math.min(255,Math.max(0,b_))})`;
}
else if(colMode==='ocean'){
  const t=r/ring.mod;
  clr=`hsl(${200+t*60},${70+t*20}%,${30+t*40}%)`;
}
else if(colMode==='totient'){
  const phi=ring.coprimes.length;
  const h=(phi/ring.mod)*360;
  clr=`hsl(${h},75%,${gcd1?55:35}%)`;
}
else if(colMode==='numerator'){
  // Color by numerator family (all r/M with same r share color)
  const h=(r*137.5)%360;
  clr=`hsl(${h},${gcd1?80:50}%,${gcd1?55:35}%)`;
}
else clr=gcd1?'#00d9ff':'#666';

// Sector highlight: apply based on sectorColorMode
let finalAlpha=gcd1?1:nonGcdOp;
if(highlightSector){
  if(sectorColorMode==='preserve'){
    // Keep original colors, no alpha changes
    finalAlpha=gcd1?1:nonGcdOp;
  }else if(sectorColorMode==='dim'){
    // Dim points outside sector
    if(inSector&&gcd1){
      finalAlpha=1;
    }else{
      finalAlpha=gcd1?0.25:nonGcdOp*0.3;
    }
  }else if(sectorColorMode==='inout'){
    // Override colors: gold inside, gray outside
    clr=inSector?'#ffd700':'#555';
    finalAlpha=gcd1?1:nonGcdOp;
  }else if(sectorColorMode==='enhance'){
    // Enhance inside: brighter, larger
    if(inSector&&gcd1){
      finalAlpha=1;
      ptSz*=1.3;
    }else{
      finalAlpha=gcd1?0.5:nonGcdOp*0.5;
    }
  }
}

ctx.globalAlpha=finalAlpha;
ctx.fillStyle=clr;ctx.beginPath();ctx.arc(px,py,ptSz,0,2*Math.PI);ctx.fill();
ctx.strokeStyle=ring.isUnit?'rgba(255,255,255,.9)':'rgba(255,255,255,.5)';
ctx.lineWidth=ring.isUnit?2:1;ctx.stroke();

// Add glow effect for highlighted sector points (only in dim/enhance modes)
if(highlightSector&&inSector&&gcd1&&(sectorColorMode==='dim'||sectorColorMode==='enhance')){
  ctx.globalAlpha=0.4;
  ctx.fillStyle='#fff';
  ctx.beginPath();ctx.arc(px,py,ptSz*1.5,0,2*Math.PI);ctx.fill();
  ctx.globalAlpha=1;
  ctx.fillStyle=clr;ctx.beginPath();ctx.arc(px,py,ptSz,0,2*Math.PI);ctx.fill();
}
ctx.globalAlpha=1;

// Labels
const lblSz=+document.getElementById('enhLblSz')?.value||9;
const shouldLabel=(lblFmt!=='none')&&(
(lblWhich==='all')||
(lblWhich==='gcd1'&&gcd1)||
(lblWhich==='outer'&&ringIdx===enhRingsData.length-1)||
(lblWhich==='unit'&&ring.isUnit)
);
if(shouldLabel){
let txt='';
if(lblFmt==='number')txt=r;
else if(lblFmt==='fraction')txt=`${r}/${ring.mod}`;
else if(lblFmt==='decimal')txt=(r/ring.mod).toFixed(3);
else if(lblFmt==='farey'){const g=gcd(r,ring.mod);txt=g>0?`${r/g}/${ring.mod/g}`:`${r}/${ring.mod}`;}
else if(lblFmt==='angle')txt=Math.round(360*r/ring.mod)+'°';
else if(lblFmt==='gcd')txt=gcd(r,ring.mod);
else if(lblFmt==='coprime')txt=gcd1?'OK':'X';
ctx.fillStyle='rgba(255,255,255,.9)';ctx.font=`bold ${lblSz}px Segoe UI`;ctx.textAlign='center';
ctx.fillText(txt,px,py-ptSz-3);
}});});

// Draw selected point highlight
if(enhSelectedPoint){
  const sp=enhSelectedPoint;
  const ring=enhRingsData.find(r=>r.mod===sp.mod);
  if(ring){
    const ringIdx=enhInvertRings?(numRings-1-ring.idx):ring.idx;
    const ringRotation=ringIdx*enhRingInc+enhPhase;
    let spx,spy;
    if(smithEnabled){
      const theta=2*Math.PI*(ring.mod-sp.residue)/ring.mod+ringRotation;
      const dist=ring.radius/320;
      const sm=smithTransform(0.5+dist*1.5,theta,smithAlpha);
      spx=sm.x*smithRad;spy=-sm.y*smithRad;
    }else{
      const angle=2*Math.PI*(ring.mod-sp.residue)/ring.mod+ringRotation;
      spx=ring.radius*Math.cos(angle);spy=ring.radius*Math.sin(angle);
    }
    // Pulsing selection ring
    ctx.save();
    ctx.strokeStyle='#00ffff';ctx.lineWidth=3;
    ctx.shadowColor='#00ffff';ctx.shadowBlur=15;
    ctx.beginPath();ctx.arc(spx,spy,12,0,2*Math.PI);ctx.stroke();
    ctx.strokeStyle='#fff';ctx.lineWidth=1.5;
    ctx.beginPath();ctx.arc(spx,spy,15,0,2*Math.PI);ctx.stroke();
    ctx.restore();
  }
}

// Draw tracked residues on top
drawEnhTrackedResidues(ctx, enhRingsData, 0, 0, getPoint);

ctx.restore();
if(smithEnabled){
ctx.fillStyle=isDark()?'#ffd700':'#cc8800';ctx.font='11px Segoe UI';
ctx.fillText(`Smith Chart: α=${smithAlpha}°`,10,20);
}
const colorMode=document.getElementById('enhCol')?.value||'angular';
let legendItems=[
['Rings',enhRingsData.length,'#ffd700'],
['Coprime (φ)',enhRingsData.reduce((s,r)=>s+r.coprimes.length,0),'#00ff88'],
['Gaps',gaps.length>0?gaps.join(','):'None','#ff6496']
];
if(colorMode==='harmonic'){
legendItems=[
['Rings',enhRingsData.length,'#ffd700'],
['Coprime (φ)',enhRingsData.reduce((s,r)=>s+r.coprimes.length,0),'#00ff88'],
['Unison (q=1)','','#ffd700'],
['Consonant (q≤4)','','#00ff88'],
['Complex (q≤8)','','#00d9ff'],
['Dissonant (q>16)','','#ff6496']
];
}
// Add selected point info to legend
if(enhSelectedPoint&&enhSelectedPoint.isCoprime){
  const[sp,sq]=enhSelectedPoint.reducedFrac?enhSelectedPoint.reducedFrac.split('/').map(Number):[enhSelectedPoint.residue,enhSelectedPoint.mod];
  const baseFreq=parseFloat(document.getElementById('enhBaseFreq')?.value||440);
  const freq=(baseFreq*sp/sq).toFixed(1);
  const neighborCount=enhSelectedPoint.fareyNeighbors?.length||0;
  legendItems.push(['Selected',`${sp}/${sq}`,'#fff']);
  legendItems.push(['Frequency',`${freq}Hz`,'#ffd700']);
  if(neighborCount>0)legendItems.push(['Neighbors',neighborCount,'#ff6496']);
}
legend('alenhanced',smithEnabled?'Smith Transform':(colorMode==='harmonic'?'Harmonic Rings':'Enhanced Rings'),legendItems);
updateEnhStats();
}

function updateEnhStats(){
const stats=document.getElementById('enhLiveStats');
if(enhRingsData.length===0){stats.innerHTML='<em>No rings</em>';return;}

// Apply font size setting
const fontSize=document.getElementById('enhStatsFont')?.value||'0.85rem';
stats.style.fontSize=fontSize;
const fontVEl=document.getElementById('enhStatsFontV');
if(fontVEl)fontVEl.textContent=fontSize;

const mode=document.getElementById('enhMode').value;
const vizMode=document.getElementById('enhVizMode')?.value||'rings';
const smithEnabled=document.getElementById('enhSmith')?.checked;
const colMode=document.getElementById('enhCol')?.value||'angular';
const moduli=enhRingsData.map(r=>r.mod);
const minM=Math.min(...moduli),maxM=Math.max(...moduli);
const totalPts=enhRingsData.reduce((s,r)=>s+r.allRes.length,0);
const totalCoprime=enhRingsData.reduce((s,r)=>s+r.coprimes.length,0);
const gaps=enhGetGaps();
const z2=zeta(2);
const primDensity=totalCoprime/totalPts;
const theoreticalDensity=1/z2;

// Sweep/ray overlay status
const showRays=document.getElementById('enhShowRays')?.checked;
const showSectors=document.getElementById('enhShowSectors')?.checked;
const showFareySectors=document.getElementById('enhShowFareySectors')?.checked;
const showMediants=document.getElementById('enhShowMediants')?.checked;
const sectorDepth=+document.getElementById('enhSectorDepth')?.value||6;

// Sector highlighting stats
const highlightSector=document.getElementById('enhHighlightSector')?.checked;
const sectorFrom=+document.getElementById('enhSectorFrom')?.value||3;
const sectorTo=+document.getElementById('enhSectorTo')?.value||2;
let sectorPts=0,sectorCoprime=0;
let hlSectorError={asymptotic:0,absError:0,relError:0,ci95:0,reliability:'—'};
if(highlightSector){
  enhRingsData.forEach(ring=>{
    ring.allRes.forEach(r=>{
      const frac=r/ring.mod;
      if(frac>1/sectorFrom&&frac<1/sectorTo){
        sectorPts++;
        if(gcd(r,ring.mod)===1)sectorCoprime++;
      }
    });
  });
  // Calculate error for highlighted sector (n = sectorFrom means S_n = 1/(n+1) to 1/n)
  // For sector from 1/sectorFrom to 1/sectorTo, use sectorFrom as n
  const hlN=sectorFrom;
  const hlAsymptotic=3*maxM*maxM/(Math.PI*Math.PI*hlN*(hlN+1));
  const hlAbsError=Math.abs(sectorCoprime-hlAsymptotic);
  const hlRelError=sectorCoprime>0?(hlAbsError/sectorCoprime)*100:0;
  const C1=0.3,C2=0.1;
  const hlErrorBound=C1*maxM*Math.log(maxM)/(hlN*hlN)+C2*Math.pow(maxM,1.5)/(hlN*hlN);
  let hlReliability='EXCELLENT';
  if(hlRelError>0.3)hlReliability='VERY GOOD';
  if(hlRelError>1)hlReliability='GOOD';
  if(hlRelError>3)hlReliability='FAIR';
  if(hlRelError>8)hlReliability='POOR';
  if(hlRelError>15)hlReliability='UNRELIABLE';
  const hlCi95=Math.ceil(1.96*Math.sqrt(sectorCoprime>0?sectorCoprime:1));
  hlSectorError={asymptotic:hlAsymptotic,absError:hlAbsError,relError:hlRelError,errorBound:hlErrorBound,reliability:hlReliability,ci95:hlCi95};
}

// Mode description
let modeDesc='Range M'+minM+'-M'+maxM;
let baseVal=2;
if(mode==='power'){
baseVal=+document.getElementById('enhBase').value||2;
modeDesc=baseVal+'^n family';
}else if(mode==='custom'){
modeDesc='Custom ('+enhRingsData.length+' moduli)';
}

// Get largest ring for modular sieve analysis
const largestRing=enhRingsData[enhRingsData.length-1];
const M=largestRing.mod;

// Sector analysis (Stern-Brocot sectors S_n = 1/(n+1) to 1/n)
// Expand to cover all sectors based on max modulus
const maxSectorN=Math.min(maxM,30);
const sectorCounts={};
const sectorErrors={};  // Error analysis per sector
for(let n=1;n<=maxSectorN;n++)sectorCounts[n]=0;
enhRingsData.forEach(ring=>{
  ring.coprimes.forEach(r=>{
    const frac=r/ring.mod;
    for(let n=1;n<=maxSectorN;n++){
      if(frac>1/(n+1)&&frac<=1/n){sectorCounts[n]++;break;}
    }
  });
});

// Calculate error bounds for each sector
// Formula: Count(n,N) ≈ 3N²/(π²·n(n+1))
// Error: O(N log N / n²)
const calcSectorError=(n,N,observed)=>{
  const asymptotic=3*N*N/(Math.PI*Math.PI*n*(n+1));
  const absError=Math.abs(observed-asymptotic);
  const relError=observed>0?(absError/observed)*100:0;
  // Error bound: C₁·N·log(N)/n² + C₂·N^1.5/n²
  const C1=0.3,C2=0.1;
  const errorBound=C1*N*Math.log(N)/(n*n)+C2*Math.pow(N,1.5)/(n*n);
  // Confidence: based on relative error
  let reliability='EXCELLENT';
  if(relError>0.3)reliability='VERY GOOD';
  if(relError>1)reliability='GOOD';
  if(relError>3)reliability='FAIR';
  if(relError>8)reliability='POOR';
  if(relError>15)reliability='UNRELIABLE';
  // 95% CI
  const ci95=Math.ceil(1.96*Math.sqrt(observed>0?observed:1));
  return{asymptotic,absError,relError,errorBound,reliability,ci95};
};

for(let n=1;n<=maxSectorN;n++){
  if(sectorCounts[n]>0||n<=10){
    sectorErrors[n]=calcSectorError(n,maxM,sectorCounts[n]);
  }
}

// Upper half (Real part: 0° to 180°, fractions 0 to 1/2) vs Lower half (Imaginary part: 180° to 360°, fractions 1/2 to 1)
let upperHalfCount=0,lowerHalfCount=0;
enhRingsData.forEach(ring=>{
  ring.coprimes.forEach(r=>{
    const frac=r/ring.mod;
    if(frac<=0.5)upperHalfCount++;
    else lowerHalfCount++;
  });
});

// Angular distribution (quadrants)
let q1=0,q2=0,q3=0,q4=0;
enhRingsData.forEach(ring=>{
  ring.coprimes.forEach(r=>{
    const ang=360*r/ring.mod;
    if(ang<=90)q1++;
    else if(ang<=180)q2++;
    else if(ang<=270)q3++;
    else q4++;
  });
});

// Gap pair counts (across all rings)
let gapStats='';
if(gaps.length>0){
const gapCounts=gaps.map(g=>{
let count=0;
enhRingsData.forEach(ring=>{
if(ring.mod<2)return;
ring.coprimes.forEach(r=>{
const r2=(r+g)%ring.mod;
if(ring.coprimes.includes(r2))count++;
});});
return{g,count};
});
gapStats=gapCounts.map(({g,count})=>`<span style="color:hsl(${gaps.indexOf(g)*60},80%,60%)">Gap ${g}: <strong>${count}</strong></span>`).join(' | ');
}

// Overlay status string
const overlays=[];
if(showRays)overlays.push('Rays');
if(showSectors)overlays.push('Sectors');
if(showFareySectors)overlays.push('Farey(N='+sectorDepth+')');
if(showMediants)overlays.push('Mediants');
const overlayStr=overlays.length>0?overlays.join('+'):'None';

// Color scheme names
const colNames={angular:'Angular',gcd:'GCD',ring:'Ring',coprime:'Coprime',spectrum:'Spectrum',sector:'Sector',depth:'Depth'};

stats.innerHTML=`
<div id="statsSectionMode" data-section="mode" style="background:linear-gradient(135deg,rgba(255,215,0,.15),rgba(0,217,255,.1));padding:10px;border-radius:8px;margin-bottom:12px;border:1px solid var(--acc)">
<div style="font-size:.7rem;color:var(--txt2);margin-bottom:4px">MODE: ${mode.toUpperCase()} | VIZ: ${vizMode.toUpperCase()}${smithEnabled?' + SMITH':''} | ${modeDesc}</div>
<div style="display:grid;grid-template-columns:repeat(4,1fr);gap:6px;font-size:.75rem">
<span>Rings: <strong style="color:#00ff88">${enhRingsData.length}</strong></span>
<span>Min M: <strong style="color:#00d9ff">${minM}</strong></span>
<span>Max M: <strong style="color:#ffd700">${maxM}</strong></span>
<span>Color: <strong style="color:#ff6496">${colNames[colMode]||colMode}</strong></span>
</div>
<div style="font-size:.7rem;color:var(--txt2);margin-top:4px">Overlays: <strong style="color:#00d9ff">${overlayStr}</strong> | Gaps: <strong style="color:#ff6496">${gaps.length>0?gaps.join(','):'—'}</strong></div>
</div>
<div id="statsSectionPrimary" data-section="primary" style="display:grid;grid-template-columns:repeat(2,1fr);gap:8px;margin-bottom:12px">
<div style="background:var(--bg1);padding:12px;border-radius:6px;text-align:center"><div style="font-size:1.6rem;font-weight:bold;color:#ffd700">${totalCoprime}</div><div style="font-size:.7rem;color:var(--txt2)">PRIMITIVE POINTS<br><span style="font-size:.65rem;opacity:.8">Σφ(M) coprime</span></div></div>
<div style="background:var(--bg1);padding:12px;border-radius:6px;text-align:center"><div style="font-size:1.6rem;font-weight:bold;color:#00d9ff">${totalPts}</div><div style="font-size:.7rem;color:var(--txt2)">TOTAL POINTS<br><span style="font-size:.65rem;opacity:.8">Σ M residues</span></div></div>
</div>
<div id="statsSectionDensity" data-section="density" style="display:grid;grid-template-columns:repeat(3,1fr);gap:6px;margin-bottom:12px">
<div style="background:var(--bg1);padding:8px;border-radius:6px;text-align:center"><div style="font-size:1.1rem;font-weight:bold;color:#00ff88">${fmt(100*primDensity)}%</div><div style="font-size:.65rem;color:var(--txt2)">DENSITY</div></div>
<div style="background:var(--bg1);padding:8px;border-radius:6px;text-align:center"><div style="font-size:1.1rem;font-weight:bold;color:#9664ff">${fmt(100*theoreticalDensity)}%</div><div style="font-size:.65rem;color:var(--txt2)">1/ζ(2)</div></div>
<div style="background:var(--bg1);padding:8px;border-radius:6px;text-align:center"><div style="font-size:1.1rem;font-weight:bold;color:${Math.abs(primDensity-theoreticalDensity)<0.05?'#00ff88':'#ff8c00'}">${fmt(primDensity/theoreticalDensity)}</div><div style="font-size:.65rem;color:var(--txt2)">RATIO</div></div>
</div>
${highlightSector?`<div id="statsSectionHighlight" data-section="highlight" style="background:rgba(150,100,255,.15);padding:10px;border-radius:6px;margin-bottom:10px;border:2px solid rgba(150,100,255,.5)">
<strong style="color:#9664ff;font-size:.85rem"> HIGHLIGHTED SECTOR: 1/${sectorFrom} → 1/${sectorTo} (S<sub>${sectorFrom}</sub>)</strong>
<div style="display:grid;grid-template-columns:repeat(3,1fr);gap:6px;font-size:.75rem;margin-top:8px">
<div style="background:var(--bg1);padding:6px;border-radius:4px;text-align:center"><div style="font-size:1.2rem;font-weight:bold;color:#ffd700">${sectorCoprime}</div><div style="font-size:.6rem;color:var(--txt2)">OBSERVED COPRIME</div></div>
<div style="background:var(--bg1);padding:6px;border-radius:4px;text-align:center"><div style="font-size:1.2rem;font-weight:bold;color:#888">${hlSectorError.asymptotic?.toFixed(1)||'—'}</div><div style="font-size:.6rem;color:var(--txt2)">ASYMPTOTIC EST</div></div>
<div style="background:var(--bg1);padding:6px;border-radius:4px;text-align:center"><div style="font-size:1.2rem;font-weight:bold;color:#00ff88">${fmt(100*sectorCoprime/totalCoprime)}%</div><div style="font-size:.6rem;color:var(--txt2)">% OF ALL COPRIME</div></div>
</div>
<div style="display:grid;grid-template-columns:repeat(4,1fr);gap:4px;font-size:.65rem;margin-top:6px">
<div style="background:var(--bg1);padding:4px;border-radius:3px;text-align:center"><span style="color:var(--txt2)">Abs Err:</span> <strong style="color:#00d9ff">${hlSectorError.absError?.toFixed(1)||'—'}</strong></div>
<div style="background:var(--bg1);padding:4px;border-radius:3px;text-align:center"><span style="color:var(--txt2)">Rel Err:</span> <strong style="color:${hlSectorError.relError<1?'#00ff88':hlSectorError.relError<5?'#ffd700':'#ff8c00'}">${hlSectorError.relError?.toFixed(2)||'—'}%</strong></div>
<div style="background:var(--bg1);padding:4px;border-radius:3px;text-align:center"><span style="color:var(--txt2)">95% CI:</span> <strong style="color:#9664ff">±${hlSectorError.ci95||'—'}</strong></div>
<div style="background:var(--bg1);padding:4px;border-radius:3px;text-align:center"><span style="color:var(--txt2)">Rating:</span> <strong style="color:${hlSectorError.reliability==='EXCELLENT'||hlSectorError.reliability==='VERY GOOD'?'#00ff88':hlSectorError.reliability==='GOOD'?'#ffd700':'#ff8c00'}">${hlSectorError.reliability||'—'}</strong></div>
</div>
<div style="font-size:.55rem;color:var(--txt2);margin-top:6px">Angular: ${fmt(360/sectorFrom)}°–${fmt(360/sectorTo)}° | Width: ${fmt((360/sectorTo)-(360/sectorFrom))}° | Total pts: ${sectorPts} | Formula: 3N²/(π²·${sectorFrom}·${sectorFrom+1})</div>
</div>`:''}
<div id="statsSectionSBSectors" data-section="sbsectors" style="background:rgba(150,100,255,.1);padding:8px;border-radius:6px;margin-bottom:10px;border:1px solid rgba(150,100,255,.3)">
<strong style="color:#9664ff;font-size:.8rem">Stern-Brocot Sectors S<sub>n</sub> = (1/(n+1), 1/n) — Counts with Error Analysis</strong>
<div style="display:flex;flex-wrap:wrap;gap:3px;font-size:.65rem;margin-top:6px">
${Array.from({length:Math.min(maxSectorN,15)},(_,i)=>i+1).filter(n=>sectorCounts[n]>0||n<=6).map(n=>{
  const e=sectorErrors[n]||{relError:0,reliability:'—'};
  const relCol=e.relError<0.5?'#00ff88':e.relError<2?'#ffd700':e.relError<5?'#ff8c00':'#ff4444';
  return `<span style="background:rgba(255,255,255,.05);padding:2px 5px;border-radius:3px;border:1px solid hsl(${n*18},60%,40%)" title="Asymp: ${e.asymptotic?.toFixed(1)||'—'} | Error: ${e.relError?.toFixed(2)||'—'}% | ${e.reliability||'—'}">S<sub>${n}</sub>: <strong style="color:hsl(${n*18},70%,60%)">${sectorCounts[n]||0}</strong><span style="font-size:.5rem;color:${relCol};margin-left:2px">±${e.relError?.toFixed(1)||'?'}%</span></span>`;
}).join('')}
</div>
<div style="font-size:.55rem;color:var(--txt2);margin-top:4px">Formula: C(n,N) ≈ 3N²/(π²·n(n+1)) | Error: O(N·log(N)/n²) | Hover for details</div>
</div>
<div id="statsSectionError" data-section="error" style="background:rgba(0,200,255,.08);padding:8px;border-radius:6px;margin-bottom:10px;border:1px solid rgba(0,200,255,.3)">
<strong style="color:#00d9ff;font-size:.8rem">Error Bounds & Reliability Analysis</strong>
<div style="overflow-x:auto;margin-top:6px">
<table style="width:100%;font-size:.6rem;border-collapse:collapse;text-align:center">
<tr style="background:rgba(255,255,255,.1)">
<th style="padding:3px;border:1px solid rgba(255,255,255,.2)">Sector</th>
<th style="padding:3px;border:1px solid rgba(255,255,255,.2)">Observed</th>
<th style="padding:3px;border:1px solid rgba(255,255,255,.2)">Asymptotic</th>
<th style="padding:3px;border:1px solid rgba(255,255,255,.2)">Abs Err</th>
<th style="padding:3px;border:1px solid rgba(255,255,255,.2)">Rel Err</th>
<th style="padding:3px;border:1px solid rgba(255,255,255,.2)">95% CI</th>
<th style="padding:3px;border:1px solid rgba(255,255,255,.2)">Reliability</th>
</tr>
${[1,2,3,4,5,6,10,15,20].filter(n=>sectorCounts[n]>0||n<=6).map(n=>{
  const e=sectorErrors[n]||{asymptotic:0,absError:0,relError:0,ci95:0,reliability:'—'};
  const relCol=e.relError<0.5?'#00ff88':e.relError<2?'#ffd700':e.relError<5?'#ff8c00':'#ff4444';
  const reliabCol=e.reliability==='EXCELLENT'?'#00ff88':e.reliability==='VERY GOOD'?'#7fff7f':e.reliability==='GOOD'?'#ffd700':e.reliability==='FAIR'?'#ff8c00':'#ff4444';
  return `<tr style="border-bottom:1px solid rgba(255,255,255,.1)">
<td style="padding:2px;color:#9664ff">S<sub>${n}</sub></td>
<td style="padding:2px;color:#ffd700;font-weight:bold">${sectorCounts[n]||0}</td>
<td style="padding:2px;color:#888">${e.asymptotic?.toFixed(1)||'—'}</td>
<td style="padding:2px;color:#00d9ff">${e.absError?.toFixed(1)||'—'}</td>
<td style="padding:2px;color:${relCol};font-weight:bold">${e.relError?.toFixed(2)||'—'}%</td>
<td style="padding:2px;color:#888">±${e.ci95||'—'}</td>
<td style="padding:2px;color:${reliabCol};font-weight:bold;font-size:.55rem">${e.reliability||'—'}</td>
</tr>`;
}).join('')}
</table>
</div>
<div style="display:flex;gap:8px;margin-top:6px;font-size:.55rem;flex-wrap:wrap">
<span style="color:#00ff88"> EXCELLENT (&lt;0.3%)</span>
<span style="color:#7fff7f"> V.GOOD (&lt;1%)</span>
<span style="color:#ffd700"> GOOD (&lt;3%)</span>
<span style="color:#ff8c00"> FAIR (&lt;8%)</span>
<span style="color:#ff4444"> POOR/UNRELIABLE</span>
</div>
<div style="font-size:.5rem;color:var(--txt2);margin-top:4px">
Error sources: Asymptotic Σφ(k) (~60%), Boundary discretization (~30%), Rounding (~10%) | For n&gt;30: enumerate explicitly
</div>
</div>
<div id="statsSectionCircle" data-section="circle" style="background:rgba(255,136,0,.1);padding:8px;border-radius:6px;margin-bottom:10px;border:1px solid rgba(255,136,0,.3)">
<strong style="color:#ff8c00;font-size:.8rem">Circle Halves — Real vs Imaginary Interpretation</strong>
<div style="display:grid;grid-template-columns:repeat(2,1fr);gap:8px;margin-top:6px">
<div style="background:var(--bg1);padding:8px;border-radius:4px;text-align:center">
<div style="font-size:1.3rem;font-weight:bold;color:#00d9ff">${upperHalfCount}</div>
<div style="font-size:.65rem;color:var(--txt2)">UPPER HALF (Real Part)</div>
<div style="font-size:.55rem;color:#888">0°–180° | fractions 0→½ | z<sup>i</sup> real axis</div>
<div style="font-size:.7rem;color:#00ff88;margin-top:2px">${fmt(100*upperHalfCount/totalCoprime)}%</div>
</div>
<div style="background:var(--bg1);padding:8px;border-radius:4px;text-align:center">
<div style="font-size:1.3rem;font-weight:bold;color:#ff6496">${lowerHalfCount}</div>
<div style="font-size:.65rem;color:var(--txt2)">LOWER HALF (Imaginary Part)</div>
<div style="font-size:.55rem;color:#888">180°–360° | fractions ½→1 | z<sup>i</sup> imag axis</div>
<div style="font-size:.7rem;color:#00ff88;margin-top:2px">${fmt(100*lowerHalfCount/totalCoprime)}%</div>
</div>
</div>
<div style="font-size:.55rem;color:var(--txt2);margin-top:4px;text-align:center">z<sup>i</sup> = e<sup>i·ln(z)</sup> maps p/q → e<sup>2πi·p/q</sup> — GCD multiplication table structure in lower half</div>
</div>
<div id="statsSectionQuadrant" data-section="quadrant" style="background:rgba(0,255,200,.08);padding:8px;border-radius:6px;margin-bottom:10px;border:1px solid rgba(0,255,200,.2)">
<strong style="color:#00ffc8;font-size:.8rem">Quadrant Distribution</strong>
<div style="display:grid;grid-template-columns:repeat(4,1fr);gap:4px;font-size:.7rem;margin-top:6px">
<span>Q1 (0-90°): <strong style="color:#ffd700">${q1}</strong></span>
<span>Q2 (90-180°): <strong style="color:#00ff88">${q2}</strong></span>
<span>Q3 (180-270°): <strong style="color:#00d9ff">${q3}</strong></span>
<span>Q4 (270-360°): <strong style="color:#ff6496">${q4}</strong></span>
</div>
</div>
<div id="statsSectionSieve" data-section="sieve">
${modularSieveHTML(M, gaps[0]||2, 'Modular Sieve (Max M)')}
</div>
${gaps.length>0?`<div id="statsSectionGaps" data-section="gaps" style="margin-bottom:10px;padding:8px;background:var(--bg1);border-radius:6px">
<strong style="color:var(--acc);font-size:.8rem">Gap Pair Counts:</strong>
<div style="font-size:.75rem;margin-top:4px">${gapStats}</div>
</div>`:''}
<div id="statsSectionPhi" data-section="phi" style="padding:8px;background:var(--bg1);border-radius:6px">
<strong style="color:var(--acc);font-size:.8rem">Ring φ(M):</strong>
<div style="font-size:.65rem;color:var(--txt2);margin-top:4px;line-height:1.5">
${enhRingsData.slice(0,8).map(r=>`<span style="display:inline-block;margin:1px;padding:2px 4px;background:rgba(255,215,0,.12);border-radius:3px">M${r.mod}:${r.coprimes.length}</span>`).join('')}
${enhRingsData.length>8?`<span style="opacity:.6">+${enhRingsData.length-8}</span>`:''}
</div></div>
`;

// Update frequency distribution chart when stats update
if(typeof drawFreqDistribution === 'function') {
  setTimeout(drawFreqDistribution, 50);
}

// Apply section visibility settings
setTimeout(applyStatSectionVisibility, 10);

// Update Smith Chart status
if(typeof updateSmithStatus === 'function') {
  updateSmithStatus();
}
}

function updateEnhStatsFont(){
const fontSize=document.getElementById('enhStatsFont')?.value||'0.85rem';
const stats=document.getElementById('enhLiveStats');
if(stats)stats.style.fontSize=fontSize;
const fontVEl=document.getElementById('enhStatsFontV');
if(fontVEl)fontVEl.textContent=fontSize;
}

// Enhanced Pick's Theorem Mode
let enhPicksVertices=[];
let enhPicksClosed=false;

function toggleEnhPicksMode(){
const enabled=document.getElementById('enhPicksEnable')?.checked;
const instructions=document.getElementById('enhPicksInstructions');
if(instructions)instructions.style.display=enabled?'block':'none';
if(!enabled){
  enhPicksVertices=[];
  enhPicksClosed=false;
  drawEnhanced();
}
const vertsEl=document.getElementById('enhPicksVerts');
if(vertsEl)vertsEl.textContent=enhPicksVertices.length;
}

function clearEnhPicksPolygon(){
enhPicksVertices=[];
enhPicksClosed=false;
const vertsEl=document.getElementById('enhPicksVerts');
if(vertsEl)vertsEl.textContent='0';
const statsEl=document.getElementById('enhPicksStats');
if(statsEl)statsEl.style.display='none';
drawEnhanced();
}

function closeEnhPicksPolygon(){
if(enhPicksVertices.length<3){alert('Need at least 3 vertices');return;}
enhPicksClosed=true;
calcEnhPicksTheorem();
drawEnhanced();
}

function addEnhPicksPreset(type){
enhPicksVertices=[];
if(type==='triangle'){
// Sample triangle using coprime points
enhPicksVertices=[{x:0,y:0},{x:3,y:0},{x:1,y:2}];
}
enhPicksClosed=true;
const vertsEl=document.getElementById('enhPicksVerts');
if(vertsEl)vertsEl.textContent=enhPicksVertices.length;
calcEnhPicksTheorem();
drawEnhanced();
}

function calcEnhPicksTheorem(){
if(enhPicksVertices.length<3||!enhPicksClosed)return;
const verts=enhPicksVertices;
// Shoelace formula for area
let area=0;
for(let i=0;i<verts.length;i++){
const j=(i+1)%verts.length;
area+=verts[i].x*verts[j].y;
area-=verts[j].x*verts[i].y;
}
area=Math.abs(area)/2;

// Count boundary points (using GCD for each edge)
let boundary=0;
for(let i=0;i<verts.length;i++){
const j=(i+1)%verts.length;
const dx=Math.abs(verts[j].x-verts[i].x);
const dy=Math.abs(verts[j].y-verts[i].y);
boundary+=gcd(dx,dy);
}

// Pick's theorem: A = i + b/2 - 1, so i = A - b/2 + 1
const interior=area-boundary/2+1;

// Update display (with null checks)
const statsEl=document.getElementById('enhPicksStats');
if(statsEl)statsEl.style.display='block';
const iEl=document.getElementById('enhPicksI');
if(iEl)iEl.textContent=Math.round(interior);
const bEl=document.getElementById('enhPicksB');
if(bEl)bEl.textContent=boundary;
const aEl=document.getElementById('enhPicksA');
if(aEl)aEl.textContent=area;

// Verify
const calcArea=interior+boundary/2-1;
const verify=document.getElementById('enhPicksVerify');
if(verify)verify.style.display='block';
const calcEl=document.getElementById('enhPicksCalc');
if(calcEl)calcEl.textContent=`i + b/2 - 1 = ${Math.round(interior)} + ${boundary}/2 - 1 = ${calcArea.toFixed(1)}`;
}

function toggleEnhRotation(){
const btn=document.getElementById('enhRotBtn');
const status=document.getElementById('enhStatus');
if(enhAnimating){
enhAnimating=false;
if(enhAnimTimer)clearInterval(enhAnimTimer);
btn.textContent='Animate';
if(status)status.style.display='none';
}else{
enhAnimating=true;
const speed=+document.getElementById('enhSpeed').value;
const varSpeeds=document.getElementById('enhDiffSpeeds')?.checked;
enhAnimTimer=setInterval(()=>{
enhAnimFrame+=speed*(varSpeeds?1.5:1);
drawEnhanced();
},50);
btn.textContent=' Pause';
if(status){status.style.display='block';status.textContent='Animating...';}
}}


async function screenshotEnhanced(){
  const mode = document.getElementById('enhMode')?.value || 'range';
  let title = 'Enhanced Modular Rings';
  if (mode === 'range') {
    const minM = document.getElementById('enhMin')?.value || '1';
    const maxM = document.getElementById('enhMax')?.value || '30';
    title = `Enhanced Modular Rings (M${minM}-M${maxM})`;
  } else if (mode === 'power') {
    const base = document.getElementById('enhBase')?.value || '2';
    title = `Enhanced Modular Rings (${base}^n family)`;
  }
  
  // Build pathInfo from current selection
  let pathInfo = null;
  if(window.enhSBHighlightPath && window.enhSBHighlightPath.length > 0 && window.enhSBSelectedNode){
    pathInfo = {
      path: window.enhSBHighlightPath,
      selected: window.enhSBSelectedNode
    };
  }
  
  await screenshotUnified('cenhanced', 'enhLiveStats', title, 'enhanced_modular.png', {
    scale: 2, 
    legendId: 'alenhanced',
    pathInfo: pathInfo,
    showLegend: true
  });
}

async function exportAllEnhanced(){
  try {
    const c = document.getElementById('cenhanced');
    const tree = document.getElementById('cSternBrocot');
    const arnold = document.getElementById('cArnoldTongues');
    const freqDist = document.getElementById('cFreqDist');
    if(!c) { alert('Canvas not found'); return; }
    
    // Get resolution from selector
    const scale = +(document.getElementById('ssEnhRes')?.value || 2);
    const pad = 30;
    const gap = 15;
    const isDk = isDark();
    
    // Get checkbox options (defaults to true if element doesn't exist)
    const getOpt = id => { const el = document.getElementById(id); return el ? el.checked : true; };
    
    // Canvas options
    const showMainCanvas = getOpt('ssEnhMainCanvas');
    const showLegend = getOpt('ssEnhLegend');
    const showTree = getOpt('ssEnhTree');
    const showArnold = getOpt('ssEnhIncludeArnold');
    const showFreqDist = getOpt('ssEnhFreqDist');
    
    // Live Stats section options
    const showModeHeader = getOpt('ssStatsModeHeader');
    const showPrimaryCounts = getOpt('ssStatsPrimaryCounts');
    const showDensity = getOpt('ssStatsDensity');
    const showHighlightSector = getOpt('ssStatsHighlightSector');
    const showSBSectors = getOpt('ssStatsSBSectors');
    const showErrorTable = getOpt('ssStatsErrorTable');
    const showCircleHalves = getOpt('ssStatsCircleHalves');
    const showQuadrants = getOpt('ssStatsQuadrants');
    const showModSieve = getOpt('ssStatsModSieve');
    const showGapCounts = getOpt('ssStatsGapCounts');
    const showRingPhi = getOpt('ssStatsRingPhi');
    
    // Point Details options
    const showPointBasic = getOpt('ssPointBasicInfo');
    const showPointHarmonics = getOpt('ssPointHarmonics');
    const showPointMusical = getOpt('ssPointMusical');
    const showPointFrequency = getOpt('ssPointFrequency');
    const showPointNeighbors = getOpt('ssPointNeighbors');
    
    // Tree & Analysis options
    const showTreeStats = getOpt('ssEnhTreeStats');
    const showTreePath = getOpt('ssEnhTreePath');
    const showFarey = getOpt('ssEnhFarey');
    const showFareyLegend = getOpt('ssEnhFareyLegend');
    
    // Additional panels
    const showTracker = getOpt('ssEnhTracker');
    const showTrajectory = getOpt('ssEnhTrajectory');
    const showMultTable = getOpt('ssEnhMultTable');
    const showTimestamp = getOpt('ssEnhTimestamp');
    const showAuthor = getOpt('ssEnhAuthor');
    
    // Map section IDs to checkbox states
    const sectionVisibility = {
      'statsSectionMode': showModeHeader,
      'statsSectionPrimary': showPrimaryCounts,
      'statsSectionDensity': showDensity,
      'statsSectionHighlight': showHighlightSector,
      'statsSectionSBSectors': showSBSectors,
      'statsSectionError': showErrorTable,
      'statsSectionCircle': showCircleHalves,
      'statsSectionQuadrant': showQuadrants,
      'statsSectionSieve': showModSieve,
      'statsSectionGaps': showGapCounts,
      'statsSectionPhi': showRingPhi
    };
    
    // Store original display states and hide unchecked sections
    const originalDisplay = {};
    Object.entries(sectionVisibility).forEach(([id, show]) => {
      const el = document.getElementById(id);
      if (el) {
        originalDisplay[id] = el.style.display;
        if (!show) el.style.display = 'none';
      }
    });
    
    // Canvas dimensions
    const canvW = c.width || 800;
    const canvH = c.height || 800;
    const treeW = (tree && tree.width && showTree) ? tree.width : 0;
    const treeH = (tree && tree.height && showTree) ? tree.height : 0;
    const arnoldW = (arnold && arnold.width && showArnold) ? arnold.width : 0;
    const arnoldH = (arnold && arnold.height && showArnold) ? arnold.height : 0;
    const freqW = (freqDist && freqDist.width && showFreqDist) ? freqDist.width : 0;
    const freqH = (freqDist && freqDist.height && showFreqDist) ? freqDist.height : 0;
    
    // Get parameters for title
    const mode = document.getElementById('enhMode')?.value || 'range';
    const minM = document.getElementById('enhMin')?.value || '1';
    const maxM = document.getElementById('enhMax')?.value || '30';
    const base = document.getElementById('enhBase')?.value || '2';
    const sectorFrom = document.getElementById('enhSectorFrom')?.value || '3';
    const sectorTo = document.getElementById('enhSectorTo')?.value || '2';
    let title = mode === 'range' ? `Enhanced Modular Rings (M${minM}-M${maxM})` : `Enhanced Modular Rings (${base}^n)`;
    
    // Import html2canvas
    const html2canvas = (await import('https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/+esm')).default;
    
    // Capture DOM panels with html2canvas
    const captureOpts = { scale: scale, backgroundColor: isDk ? '#151b2d' : '#f5f5f5', logging: false, useCORS: true };
    
    let liveStatsImg = null, pointDetailsImg = null, harmonicMetricsImg = null, treeStatsImg = null, fareyImg = null, fareyLegendImg = null;
    let rightPanelH = 0;
    const rightPanelW = 380;
    
    // Capture Live Statistics (with hidden sections already applied)
    const liveStatsEl = document.getElementById('enhLiveStats');
    if(liveStatsEl && liveStatsEl.innerHTML.trim()) {
      // Check if any stats section is visible
      const anyStatsVisible = Object.values(sectionVisibility).some(v => v);
      if (anyStatsVisible) {
        liveStatsImg = await html2canvas(liveStatsEl, captureOpts);
        rightPanelH += liveStatsImg.height / scale + 30;
      }
    }
    
    // Restore original display states
    Object.entries(originalDisplay).forEach(([id, display]) => {
      const el = document.getElementById(id);
      if (el) el.style.display = display;
    });
    
    // Capture Point Details (if visible and enabled)
    if(showPointBasic || showPointHarmonics || showPointMusical || showPointFrequency || showPointNeighbors) {
      const el = document.getElementById('enhPointDetails');
      if(el && el.style.display !== 'none' && el.innerHTML.trim()) {
        pointDetailsImg = await html2canvas(el, captureOpts);
        rightPanelH += pointDetailsImg.height / scale + 30;
      }
    }
    
    // Capture Tree Stats + Path
    if(showTreeStats || showTreePath) {
      const statsEl = document.getElementById('enhTreeStats');
      const pathEl = document.getElementById('enhTreePath');
      const tempDiv = document.createElement('div');
      tempDiv.style.cssText = 'background:' + (isDk ? '#151b2d' : '#f5f5f5') + ';padding:10px;border-radius:8px;';
      if(showTreeStats && statsEl) {
        const clone1 = statsEl.cloneNode(true);
        clone1.style.display = 'block';
        tempDiv.appendChild(clone1);
      }
      if(showTreePath && pathEl && pathEl.style.display !== 'none') {
        const clone2 = pathEl.cloneNode(true);
        clone2.style.display = 'block';
        tempDiv.appendChild(clone2);
      }
      if(tempDiv.children.length > 0) {
        document.body.appendChild(tempDiv);
        treeStatsImg = await html2canvas(tempDiv, captureOpts);
        document.body.removeChild(tempDiv);
        rightPanelH += treeStatsImg.height / scale + 30;
      }
    }
    
    // Capture Farey Legend
    if(showFareyLegend) {
      const el = document.getElementById('enhFareyNeighborLegend');
      if(el && el.style.display !== 'none') {
        fareyLegendImg = await html2canvas(el, captureOpts);
        rightPanelH += fareyLegendImg.height / scale + 15;
      }
    }
    
    // Capture Farey Neighbors
    if(showFarey) {
      const el = document.getElementById('enhFareyNeighbors');
      if(el && el.innerHTML.trim()) {
        fareyImg = await html2canvas(el, {...captureOpts, height: Math.min(el.scrollHeight, 400)});
        rightPanelH += Math.min(fareyImg.height / scale, 400) + 30;
      }
    }
    
    // Layout calculations
    const leftColW = showMainCanvas ? Math.max(canvW, treeW, arnoldW, freqW) : Math.max(treeW, arnoldW, freqW, 400);
    let leftColH = 0;
    if (showMainCanvas) leftColH += canvH + gap;
    if (treeH > 0) leftColH += treeH + gap + 25;
    if (arnoldH > 0) leftColH += arnoldH + gap + 25;
    if (freqH > 0) leftColH += freqH + gap + 25;
    
    const titleH = 55;
    const footerH = (showTimestamp || showAuthor) ? 35 : 10;
    const actualRightW = rightPanelH > 0 ? Math.max(rightPanelW, 380) : 0;
    
    const totalW = leftColW + actualRightW + pad * 3;
    const totalH = Math.max(leftColH, rightPanelH) + titleH + footerH + pad * 2;
    
    // Create output canvas
    const out = document.createElement('canvas');
    out.width = totalW * scale;
    out.height = totalH * scale;
    const ctx = out.getContext('2d');
    ctx.scale(scale, scale);
    
    // Background
    ctx.fillStyle = isDk ? '#0d1321' : '#fff';
    ctx.fillRect(0, 0, totalW, totalH);
    
    // Title bar
    const grad = ctx.createLinearGradient(0, 0, totalW, 0);
    grad.addColorStop(0, isDk ? '#151b2d' : '#e8e8e8');
    grad.addColorStop(1, isDk ? '#1a2540' : '#f5f5f5');
    ctx.fillStyle = grad;
    ctx.fillRect(0, 0, totalW, titleH);
    ctx.fillStyle = isDk ? '#ffd700' : '#cc8800';
    ctx.font = 'bold 20px Segoe UI';
    ctx.textAlign = 'center';
    ctx.fillText(title + ' — Complete Export', totalW / 2, 32);
    ctx.fillStyle = isDk ? '#00d9ff' : '#0066cc';
    ctx.font = '11px Segoe UI';
    const canvasCount = (showMainCanvas ? 1 : 0) + (showTree ? 1 : 0) + (showArnold ? 1 : 0) + (showFreqDist ? 1 : 0);
    ctx.fillText(`${canvasCount} Canvas${canvasCount !== 1 ? 'es' : ''} + Statistics`, totalW / 2, 48);
    
    // LEFT COLUMN: Canvases
    let y = titleH + pad;
    ctx.textAlign = 'left';
    
    // Main canvas
    if (showMainCanvas) {
      ctx.fillStyle = isDk ? '#00d9ff' : '#0066cc';
      ctx.font = 'bold 11px Segoe UI';
      ctx.fillText(' Enhanced Modular Rings', pad, y - 5);
      ctx.strokeStyle = isDk ? 'rgba(0,217,255,0.4)' : 'rgba(0,102,204,0.3)';
      ctx.lineWidth = 2;
      ctx.strokeRect(pad - 2, y - 2, canvW + 4, canvH + 4);
      ctx.drawImage(c, pad, y, canvW, canvH);
      
      // Legend overlay on main canvas
      if(showLegend) {
        const legW = 160, legH = 100;
        const legX = pad + canvW - legW - 15, legY = y + 15;
        ctx.fillStyle = isDk ? 'rgba(13,19,33,0.92)' : 'rgba(255,255,255,0.92)';
        ctx.fillRect(legX, legY, legW, legH);
        ctx.strokeStyle = isDk ? 'rgba(0,217,255,0.5)' : 'rgba(0,102,204,0.5)';
        ctx.lineWidth = 1;
        ctx.strokeRect(legX, legY, legW, legH);
        ctx.fillStyle = isDk ? '#00d9ff' : '#0066cc';
        ctx.font = 'bold 12px Segoe UI';
        ctx.textAlign = 'left';
        ctx.fillText('LEGEND', legX + 10, legY + 17);
        ctx.font = '12px Segoe UI';
        ctx.fillStyle = isDk ? '#ffd700' : '#cc8800';
        ctx.fillText(' Coprime (GCD=1)', legX + 10, legY + 34);
        ctx.fillStyle = isDk ? '#666' : '#999';
        ctx.fillText(' Non-coprime', legX + 10, legY + 50);
        ctx.fillStyle = isDk ? '#9664ff' : '#7744dd';
        ctx.fillText(' Highlighted sector', legX + 10, legY + 67);
        ctx.fillStyle = isDk ? '#00ff88' : '#00aa55';
        ctx.fillText(' Unit circle', legX + 10, legY + 84);
      }
      
      y += canvH + gap;
    }
    
    // Stern-Brocot Tree canvas
    if(treeW > 0 && treeH > 0) {
      ctx.fillStyle = isDk ? '#00ff88' : '#00aa55';
      ctx.font = 'bold 11px Segoe UI';
      ctx.textAlign = 'left';
      ctx.fillText(` Stern-Brocot Tree (Sector 1/${sectorFrom} → 1/${sectorTo})`, pad, y - 5);
      ctx.strokeStyle = isDk ? 'rgba(0,255,136,0.3)' : 'rgba(0,170,85,0.2)';
      ctx.lineWidth = 2;
      ctx.strokeRect(pad - 2, y - 2, treeW + 4, treeH + 4);
      ctx.drawImage(tree, pad, y, treeW, treeH);
      y += treeH + gap;
    }
    
    // Arnold Tongues canvas
    if(arnoldW > 0 && arnoldH > 0) {
      ctx.fillStyle = isDk ? '#ff8c00' : '#cc6600';
      ctx.font = 'bold 11px Segoe UI';
      ctx.textAlign = 'left';
      ctx.fillText(' Arnold Tongues — Phase-Locking Regions', pad, y - 5);
      ctx.strokeStyle = isDk ? 'rgba(255,140,0,0.3)' : 'rgba(204,102,0,0.2)';
      ctx.lineWidth = 2;
      ctx.strokeRect(pad - 2, y - 2, arnoldW + 4, arnoldH + 4);
      ctx.drawImage(arnold, pad, y, arnoldW, arnoldH);
      y += arnoldH + gap;
    }
    
    // Frequency Distribution canvas
    if(freqW > 0 && freqH > 0) {
      ctx.fillStyle = isDk ? '#9664ff' : '#7733cc';
      ctx.font = 'bold 11px Segoe UI';
      ctx.textAlign = 'left';
      ctx.fillText(' Frequency Ratio Distribution', pad, y - 5);
      ctx.strokeStyle = isDk ? 'rgba(150,100,255,0.3)' : 'rgba(119,51,204,0.2)';
      ctx.lineWidth = 2;
      ctx.strokeRect(pad - 2, y - 2, freqW + 4, freqH + 4);
      ctx.drawImage(freqDist, pad, y, freqW, freqH);
    }
    
    // RIGHT COLUMN: Captured DOM panels
    if (actualRightW > 0) {
      const rightX = leftColW + pad * 2;
      let rY = titleH + pad;
      
      // Panel background
      ctx.fillStyle = isDk ? '#151b2d' : '#f5f5f5';
      ctx.fillRect(rightX - 10, rY - 10, actualRightW + 10, Math.max(leftColH, rightPanelH) + 20);
      ctx.strokeStyle = isDk ? 'rgba(0,217,255,0.2)' : 'rgba(0,102,204,0.15)';
      ctx.lineWidth = 1;
      ctx.strokeRect(rightX - 10, rY - 10, actualRightW + 10, Math.max(leftColH, rightPanelH) + 20);
      
      // Live Statistics header
      if (liveStatsImg) {
        ctx.fillStyle = isDk ? '#ffd700' : '#cc8800';
        ctx.font = 'bold 14px Segoe UI';
        ctx.textAlign = 'left';
        ctx.fillText('Live Statistics', rightX, rY + 14);
        rY += 25;
        const drawW = Math.min(liveStatsImg.width / scale, actualRightW - 10);
        const drawH = (liveStatsImg.height / scale) * (drawW / (liveStatsImg.width / scale));
        ctx.drawImage(liveStatsImg, rightX, rY, drawW, drawH);
        rY += drawH + 15;
      }
      
      if(pointDetailsImg) {
        ctx.fillStyle = isDk ? '#ff6496' : '#d32f2f';
        ctx.font = 'bold 12px Segoe UI';
        ctx.fillText('Selected Point Details', rightX, rY + 12);
        rY += 18;
        const drawW = Math.min(pointDetailsImg.width / scale, actualRightW - 10);
        const drawH = (pointDetailsImg.height / scale) * (drawW / (pointDetailsImg.width / scale));
        ctx.drawImage(pointDetailsImg, rightX, rY, drawW, drawH);
        rY += drawH + 15;
      }
      
      if(treeStatsImg) {
        ctx.fillStyle = isDk ? '#00ff88' : '#00aa55';
        ctx.font = 'bold 12px Segoe UI';
        ctx.fillText('Stern-Brocot Tree', rightX, rY + 12);
        rY += 18;
        const drawW = Math.min(treeStatsImg.width / scale, actualRightW - 10);
        const drawH = (treeStatsImg.height / scale) * (drawW / (treeStatsImg.width / scale));
        ctx.drawImage(treeStatsImg, rightX, rY, drawW, drawH);
        rY += drawH + 15;
      }
      
      if(fareyLegendImg) {
        const drawW = Math.min(fareyLegendImg.width / scale, actualRightW - 10);
        const drawH = (fareyLegendImg.height / scale) * (drawW / (fareyLegendImg.width / scale));
        ctx.drawImage(fareyLegendImg, rightX, rY, drawW, drawH);
        rY += drawH + 10;
      }
      
      if(fareyImg) {
        ctx.fillStyle = isDk ? '#ffd700' : '#f57c00';
        ctx.font = 'bold 12px Segoe UI';
        ctx.fillText('Farey Neighbors in Sector', rightX, rY + 12);
        rY += 18;
        const drawW = Math.min(fareyImg.width / scale, actualRightW - 10);
        const maxH = 350;
        const drawH = Math.min((fareyImg.height / scale) * (drawW / (fareyImg.width / scale)), maxH);
        ctx.drawImage(fareyImg, rightX, rY, drawW, drawH);
      }
    }
    
    // Footer
    if (showTimestamp || showAuthor) {
      ctx.fillStyle = isDk ? '#506080' : '#888';
      ctx.font = '11px Segoe UI';
      ctx.textAlign = 'center';
      if (showAuthor) {
        ctx.fillText('Möbius Shell Sieve — @7dview — wessengetachew.github.io', totalW / 2, totalH - 15);
      }
      if (showTimestamp) {
        ctx.textAlign = 'right';
        ctx.font = '10px Segoe UI';
        ctx.fillText(new Date().toISOString().slice(0, 19).replace('T', ' '), totalW - pad, totalH - 15);
      }
    }
    
    // Export
    out.toBlob(b => {
      if(!b) { alert('Failed to create image'); return; }
      const a = document.createElement('a');
      a.href = URL.createObjectURL(b);
      a.download = 'enhanced_modular_complete.png';
      a.click();
      URL.revokeObjectURL(a.href);
    }, 'image/png', 1.0);
    
  } catch(err) {
    console.error('Export All error:', err);
    alert('Export failed: ' + err.message);
  }
}

// Manual path input for tree
function manualTreePath(){
  const p=+document.getElementById('enhTreeP')?.value||1;
  const q=+document.getElementById('enhTreeQ')?.value||5;
  if(q<=0)return;
  // Reduce fraction
  const g=gcd(p,q);
  highlightInSBTree(p/g,q/g);
}

// ========== ARNOLD TONGUES VISUALIZATION ==========
function drawArnoldTongues() {
  const c = document.getElementById('cArnoldTongues');
  if (!c) return;
  const ctx = c.getContext('2d');
  const maxQ = +document.getElementById('arnoldMaxQ')?.value || 8;
  const epsMax = +document.getElementById('arnoldEpsMax')?.value || 1;
  const colorMode = document.getElementById('arnoldColorMode')?.value || 'harmonic';
  const viewMode = document.getElementById('arnoldViewMode')?.value || 'tongues';
  const showLabels = document.getElementById('arnoldShowLabels')?.checked ?? true;
  const showGrid = document.getElementById('arnoldShowGrid')?.checked ?? true;
  const showPath = document.getElementById('arnoldShowPath')?.checked ?? false;
  const showEdges = document.getElementById('arnoldShowEdges')?.checked ?? false;
  const fill = document.getElementById('arnoldFill')?.checked ?? true;
  const sectorFrom = +document.getElementById('arnoldSectorFrom')?.value || 0;
  const isDk = isDark();
  
  const W = c.width, H = c.height;
  const margin = { left: 50, right: 20, top: 20, bottom: 40 };
  const plotW = W - margin.left - margin.right;
  const plotH = H - margin.top - margin.bottom;
  
  // Clear
  ctx.fillStyle = isDk ? '#0a0e27' : '#f5f7fa';
  ctx.fillRect(0, 0, W, H);
  
  // Determine sector bounds
  let minRatio = 0, maxRatio = 1;
  if (sectorFrom === 2) { minRatio = 0.5; maxRatio = 1; }
  else if (sectorFrom === 3) { minRatio = 1/3; maxRatio = 0.5; }
  else if (sectorFrom === 4) { minRatio = 0.25; maxRatio = 1/3; }
  else if (sectorFrom === 5) { minRatio = 0.2; maxRatio = 0.25; }
  
  // Grid
  if (showGrid) {
    ctx.strokeStyle = isDk ? 'rgba(255,255,255,.1)' : 'rgba(0,0,0,.1)';
    ctx.lineWidth = 1;
    for (let i = 0; i <= 10; i++) {
      const x = margin.left + (i / 10) * plotW;
      ctx.beginPath();
      ctx.moveTo(x, margin.top);
      ctx.lineTo(x, margin.top + plotH);
      ctx.stroke();
    }
    for (let i = 0; i <= 5; i++) {
      const y = margin.top + plotH - (i / 5) * plotH;
      ctx.beginPath();
      ctx.moveTo(margin.left, y);
      ctx.lineTo(margin.left + plotW, y);
      ctx.stroke();
    }
  }
  
  // Generate Farey sequence for tongues
  const tongues = [];
  for (let q = 1; q <= maxQ; q++) {
    for (let p = 0; p <= q; p++) {
      if (gcd(p, q) === 1) {
        const ratio = p / q;
        if (ratio >= minRatio && ratio <= maxRatio) {
          tongues.push({ p, q, ratio });
        }
      }
    }
  }
  tongues.sort((a, b) => a.ratio - b.ratio);
  
  // Get highlighted path for Arnold
  const highlightPath = window.enhSBHighlightPath || [];
  const isOnPath = (p, q) => highlightPath.some(h => h.p === p && h.q === q);
  
  // Draw based on view mode
  if (viewMode === 'circle') {
    // Polar/circle view
    const cx = W / 2, cy = H / 2;
    const r = Math.min(plotW, plotH) / 2 - 10;
    
    tongues.forEach((t, idx) => {
      const { p, q, ratio } = t;
      const normalizedRatio = (ratio - minRatio) / (maxRatio - minRatio);
      const angle = normalizedRatio * 2 * Math.PI - Math.PI / 2;
      const tongueR = r * (1 - 0.3 / q);
      const x = cx + tongueR * Math.cos(angle);
      const y = cy + tongueR * Math.sin(angle);
      
      const onPath = isOnPath(p, q);
      let color = getArnoldColor(p, q, idx, tongues.length, colorMode, isDk);
      
      ctx.beginPath();
      ctx.arc(x, y, Math.max(4, 12 - q), 0, 2 * Math.PI);
      ctx.fillStyle = onPath ? '#00ff88' : color;
      ctx.fill();
      if (onPath) {
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 2;
        ctx.stroke();
      }
      
      if (showLabels && q <= 4) {
        ctx.fillStyle = isDk ? '#fff' : '#000';
        ctx.font = '9px sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText(`${p}/${q}`, x, y - 10);
      }
    });
    
  } else if (viewMode === 'tree') {
    // Tree layout (like Stern-Brocot)
    tongues.forEach((t, idx) => {
      const { p, q, ratio } = t;
      const normalizedRatio = (ratio - minRatio) / (maxRatio - minRatio);
      const x = margin.left + normalizedRatio * plotW;
      const depth = Math.ceil(Math.log2(q + 1));
      const y = margin.top + depth * (plotH / Math.ceil(Math.log2(maxQ + 1)));
      
      const onPath = isOnPath(p, q);
      let color = getArnoldColor(p, q, idx, tongues.length, colorMode, isDk);
      
      // Draw connecting edges
      if (showEdges && q > 1) {
        ctx.strokeStyle = isDk ? 'rgba(0,217,255,.2)' : 'rgba(0,102,204,.15)';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(x, y);
        ctx.lineTo(margin.left + plotW / 2, margin.top);
        ctx.stroke();
      }
      
      ctx.beginPath();
      ctx.arc(x, y, Math.max(4, 12 - q), 0, 2 * Math.PI);
      ctx.fillStyle = onPath ? '#00ff88' : color;
      ctx.fill();
      if (onPath) {
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 2;
        ctx.stroke();
      }
      
      if (showLabels && q <= 6) {
        ctx.fillStyle = isDk ? '#fff' : '#000';
        ctx.font = `${Math.max(8, 11 - q)}px sans-serif`;
        ctx.textAlign = 'center';
        ctx.fillText(`${p}/${q}`, x, y - 8);
      }
    });
    
  } else {
    // Standard tongues view (or inverted)
    const inverted = viewMode === 'inverted';
    
    tongues.forEach((t, idx) => {
      const { p, q, ratio } = t;
      const normalizedRatio = (ratio - minRatio) / (maxRatio - minRatio);
      const x = margin.left + normalizedRatio * plotW;
      
      const k = 0.5;
      const onPath = isOnPath(p, q);
      let color = getArnoldColor(p, q, idx, tongues.length, colorMode, isDk);
      
      ctx.fillStyle = onPath ? '#00ff88' : color;
      ctx.strokeStyle = onPath ? '#00ff88' : color;
      ctx.lineWidth = onPath ? 2 : 1;
      
      ctx.beginPath();
      const topWidth = (k * epsMax / (q * q)) * plotW;
      
      if (inverted) {
        ctx.moveTo(x, margin.top);
        ctx.lineTo(x - topWidth / 2, margin.top + plotH);
        ctx.lineTo(x + topWidth / 2, margin.top + plotH);
      } else {
        ctx.moveTo(x, margin.top + plotH);
        ctx.lineTo(x - topWidth / 2, margin.top);
        ctx.lineTo(x + topWidth / 2, margin.top);
      }
      ctx.closePath();
      
      if (fill) {
        ctx.globalAlpha = onPath ? 0.9 : 0.6;
        ctx.fill();
        ctx.globalAlpha = 1;
      }
      ctx.stroke();
      
      if (showLabels && q <= 6) {
        ctx.fillStyle = isDk ? '#fff' : '#000';
        ctx.font = `${Math.max(8, 12 - q)}px sans-serif`;
        ctx.textAlign = 'center';
        ctx.fillText(`${p}/${q}`, x, inverted ? margin.top - 5 : margin.top + plotH + 15);
      }
    });
  }
  
  // Draw path connections
  if (showPath && highlightPath.length > 1) {
    ctx.strokeStyle = '#00ff88';
    ctx.lineWidth = 2;
    ctx.beginPath();
    let first = true;
    highlightPath.forEach(node => {
      const t = tongues.find(t => t.p === node.p && t.q === node.q);
      if (t) {
        const normalizedRatio = (t.ratio - minRatio) / (maxRatio - minRatio);
        const x = margin.left + normalizedRatio * plotW;
        const y = viewMode === 'tree' 
          ? margin.top + Math.ceil(Math.log2(t.q + 1)) * (plotH / Math.ceil(Math.log2(maxQ + 1)))
          : margin.top + plotH / 2;
        if (first) { ctx.moveTo(x, y); first = false; }
        else ctx.lineTo(x, y);
      }
    });
    ctx.stroke();
  }
  
  // Axes
  ctx.strokeStyle = isDk ? '#888' : '#333';
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(margin.left, margin.top);
  ctx.lineTo(margin.left, margin.top + plotH);
  ctx.lineTo(margin.left + plotW, margin.top + plotH);
  ctx.stroke();
  
  // Axis labels
  ctx.fillStyle = isDk ? '#aaa' : '#333';
  ctx.font = '12px sans-serif';
  ctx.textAlign = 'center';
  ctx.fillText('Rotation Number (ω)', margin.left + plotW / 2, H - 5);
  ctx.save();
  ctx.translate(15, margin.top + plotH / 2);
  ctx.rotate(-Math.PI / 2);
  ctx.fillText(viewMode === 'tree' ? 'Depth' : 'Coupling (ε)', 0, 0);
  ctx.restore();
  
  // Axis tick labels
  ctx.font = '10px sans-serif';
  ctx.fillText(minRatio.toFixed(2), margin.left, margin.top + plotH + 12);
  ctx.fillText(maxRatio.toFixed(2), margin.left + plotW, margin.top + plotH + 12);
  ctx.textAlign = 'right';
  ctx.fillText('0', margin.left - 5, margin.top + plotH);
  ctx.fillText(epsMax.toFixed(1), margin.left - 5, margin.top + 10);
  
  // Update stats
  const sectorStr = sectorFrom > 0 ? ` | Sector: 1/${sectorFrom+1}-1/${sectorFrom}` : '';
  const stats = document.getElementById('arnoldStats');
  if (stats) stats.textContent = `Tongues: ${tongues.length} | Max q: ${maxQ} | ε max: ${epsMax} | View: ${viewMode}${sectorStr}`;
  
  // Update path display
  if (highlightPath.length > 0) {
    const pathEl = document.getElementById('arnoldPath');
    if (pathEl) {
      pathEl.style.display = 'block';
      pathEl.innerHTML = `Path: ${highlightPath.map(n => `<span style="color:#ffd700">${n.p}/${n.q}</span>`).join(' → ')}`;
    }
  }
  
  // Store for click handling
  window.arnoldTongues = tongues;
}

function getArnoldColor(p, q, idx, total, colorMode, isDk) {
  if (colorMode === 'harmonic') {
    if (q === 1) return isDk ? '#ffd700' : '#cc8800';
    else if (q <= 2) return isDk ? '#00ff88' : '#00aa55';
    else if (q <= 4) return isDk ? '#00d9ff' : '#0088cc';
    else if (q <= 8) return isDk ? '#9664ff' : '#6644cc';
    else return isDk ? '#ff6496' : '#cc3366';
  } else if (colorMode === 'hue') {
    return `hsl(${(p / q * 360) % 360}, 70%, ${isDk ? 60 : 40}%)`;
  } else if (colorMode === 'depth') {
    const depth = Math.floor(Math.log2(q + 1));
    return `hsl(${depth * 40}, 70%, ${isDk ? 60 : 40}%)`;
  } else {
    return `hsl(${idx * 7}, 70%, ${isDk ? 60 : 40}%)`;
  }
}

// Stats section toggle functions
function toggleStatSection(section) {
  const el = document.querySelector(`[data-section="${section}"]`);
  const checkbox = document.getElementById(`showStat${section.charAt(0).toUpperCase() + section.slice(1)}`);
  if (el) {
    el.style.display = checkbox?.checked ? '' : 'none';
  }
}

function toggleAllStats(show) {
  const sections = ['mode', 'primary', 'density', 'highlight', 'sbsectors', 'error', 'circle', 'quadrant', 'sieve', 'gaps', 'phi'];
  sections.forEach(s => {
    const checkbox = document.getElementById(`showStat${s.charAt(0).toUpperCase() + s.slice(1)}`);
    if (checkbox) checkbox.checked = show;
    toggleStatSection(s);
  });
}

// Apply section visibility after stats update
function applyStatSectionVisibility() {
  const sections = ['mode', 'primary', 'density', 'highlight', 'sbsectors', 'error', 'circle', 'quadrant', 'sieve', 'gaps', 'phi'];
  sections.forEach(s => {
    toggleStatSection(s);
  });
}

// ========== Smith Chart Control Functions ==========
let smithRotationInterval = null;

function startSmithRotation() {
  stopSmithRotation();
  const speed = +document.getElementById('enhSmithRotSpeed')?.value || 1;
  const phaseEl = document.getElementById('enhSmithA');
  const phaseNumEl = document.getElementById('enhSmithANum');
  const phaseVEl = document.getElementById('enhSmithAV');
  
  smithRotationInterval = setInterval(() => {
    let phase = (+phaseEl.value + speed) % 360;
    phaseEl.value = phase;
    if (phaseNumEl) phaseNumEl.value = Math.round(phase);
    if (phaseVEl) phaseVEl.textContent = Math.round(phase) + '°';
    drawEnhanced();
    updateSmithStatus();
  }, 50);
  
  updateSmithStatus();
}

function stopSmithRotation() {
  if (smithRotationInterval) {
    clearInterval(smithRotationInterval);
    smithRotationInterval = null;
  }
  updateSmithStatus();
}

function resetSmithPhase() {
  stopSmithRotation();
  const phaseEl = document.getElementById('enhSmithA');
  const phaseNumEl = document.getElementById('enhSmithANum');
  const phaseVEl = document.getElementById('enhSmithAV');
  if (phaseEl) phaseEl.value = 90;
  if (phaseNumEl) phaseNumEl.value = 90;
  if (phaseVEl) phaseVEl.textContent = '90°';
  drawEnhanced();
  updateSmithStatus();
}

function smithZoomIn() {
  const zoomEl = document.getElementById('enhSmithZoom');
  const zoomNumEl = document.getElementById('enhSmithZoomNum');
  const zoomVEl = document.getElementById('enhSmithZoomV');
  if (zoomEl) {
    let z = Math.min(5, +zoomEl.value + 0.2);
    zoomEl.value = z;
    if (zoomNumEl) zoomNumEl.value = z.toFixed(1);
    if (zoomVEl) zoomVEl.textContent = z.toFixed(1) + '×';
    drawEnhanced();
  }
}

function smithZoomOut() {
  const zoomEl = document.getElementById('enhSmithZoom');
  const zoomNumEl = document.getElementById('enhSmithZoomNum');
  const zoomVEl = document.getElementById('enhSmithZoomV');
  if (zoomEl) {
    let z = Math.max(0.2, +zoomEl.value - 0.2);
    zoomEl.value = z;
    if (zoomNumEl) zoomNumEl.value = z.toFixed(1);
    if (zoomVEl) zoomVEl.textContent = z.toFixed(1) + '×';
    drawEnhanced();
  }
}

function smithZoomReset() {
  const zoomEl = document.getElementById('enhSmithZoom');
  const zoomNumEl = document.getElementById('enhSmithZoomNum');
  const zoomVEl = document.getElementById('enhSmithZoomV');
  if (zoomEl) {
    zoomEl.value = 1;
    if (zoomNumEl) zoomNumEl.value = 1;
    if (zoomVEl) zoomVEl.textContent = '1.0×';
    drawEnhanced();
  }
}

function smithZoomFit() {
  // Fit to show all points - calculate based on data
  const maxRad = enhRingsData.length > 0 ? Math.max(...enhRingsData.map(r => r.mod)) : 30;
  const fitZoom = Math.min(2, 300 / maxRad);
  
  const zoomEl = document.getElementById('enhSmithZoom');
  const zoomNumEl = document.getElementById('enhSmithZoomNum');
  const zoomVEl = document.getElementById('enhSmithZoomV');
  if (zoomEl) {
    zoomEl.value = fitZoom.toFixed(1);
    if (zoomNumEl) zoomNumEl.value = fitZoom.toFixed(1);
    if (zoomVEl) zoomVEl.textContent = fitZoom.toFixed(1) + '×';
    drawEnhanced();
  }
}

function setSmithPreset(preset) {
  const phaseEl = document.getElementById('enhSmithA');
  const phaseNumEl = document.getElementById('enhSmithANum');
  const phaseVEl = document.getElementById('enhSmithAV');
  const zoomEl = document.getElementById('enhSmithZoom');
  const zoomNumEl = document.getElementById('enhSmithZoomNum');
  const zoomVEl = document.getElementById('enhSmithZoomV');
  const invertEl = document.getElementById('enhSmithInvert');
  const enableEl = document.getElementById('enhSmith');
  const offXEl = document.getElementById('enhSmithOffX');
  const offYEl = document.getElementById('enhSmithOffY');
  const offXVEl = document.getElementById('enhSmithOffXV');
  const offYVEl = document.getElementById('enhSmithOffYV');
  
  // Enable Smith Chart if not already
  if (enableEl && !enableEl.checked) enableEl.checked = true;
  
  // Reset offsets
  if (offXEl) { offXEl.value = 0; if (offXVEl) offXVEl.textContent = '0'; }
  if (offYEl) { offYEl.value = 0; if (offYVEl) offYVEl.textContent = '0'; }
  
  let phase = 90, zoom = 1, invert = false;
  
  switch (preset) {
    case 'standard':
      phase = 90; zoom = 1; invert = false;
      break;
    case 'quarter':
      phase = 90; zoom = 1; invert = false;
      break;
    case 'half':
      phase = 180; zoom = 1; invert = false;
      break;
    case 'golden':
      phase = 137.5; zoom = 1; invert = false;
      break;
    case 'inverted':
      phase = 90; zoom = 1; invert = true;
      break;
    case 'zoom2x':
      phase = 90; zoom = 2; invert = false;
      break;
  }
  
  if (phaseEl) { phaseEl.value = phase; if (phaseNumEl) phaseNumEl.value = phase; if (phaseVEl) phaseVEl.textContent = phase + '°'; }
  if (zoomEl) { zoomEl.value = zoom; if (zoomNumEl) zoomNumEl.value = zoom; if (zoomVEl) zoomVEl.textContent = zoom + '×'; }
  if (invertEl) invertEl.checked = invert;
  
  drawEnhanced();
  updateSmithStatus();
}

function updateSmithStatus() {
  const statusEl = document.getElementById('enhSmithStatus');
  if (!statusEl) return;
  
  const enabled = document.getElementById('enhSmith')?.checked;
  const phase = document.getElementById('enhSmithA')?.value || 90;
  const zoom = document.getElementById('enhSmithZoom')?.value || 1;
  const invert = document.getElementById('enhSmithInvert')?.checked;
  const rotating = smithRotationInterval !== null;
  
  if (!enabled) {
    statusEl.innerHTML = '<span style="color:#ff6496">Smith Chart: OFF</span>';
  } else {
    let status = `<span style="color:#00ff88">ON</span> | α=${phase}° | ${zoom}×`;
    if (invert) status += ' | <span style="color:#ff6496">INV</span>';
    if (rotating) status += ' | <span style="color:#ffd700"> Rotating</span>';
    statusEl.innerHTML = `Smith: ${status}`;
  }
}

// ========== FAREY EXPLORER FUNCTIONS ==========
window.fareyExpPoints = [];
let fareyExpRotationInterval = null;

function generateFareyExp(n) {
  if (n === undefined) n = +document.getElementById('fareyExpN')?.value || 5;
  
  // RESET
  window.fareyExpPoints = [];
  
  // Generate Farey sequence F_n
  for (let q = 1; q <= n; q++) {
    for (let p = 0; p <= q; p++) {
      // Use inline gcd to ensure it works
      let a = p, b = q;
      while(b) { [a, b] = [b, a % b]; }
      
      if (a === 1) {
        window.fareyExpPoints.push({ p: p, q: q, value: p / q });
      }
    }
  }
  
  // Sort by value
  window.fareyExpPoints.sort((a, b) => a.value - b.value);
  
  // Update display
  updateFareyExpDisplay();
  drawFareyExplorer();
  
  // Debug: Log to console
  console.log(' Farey F_' + n + ' generated:', window.fareyExpPoints.length, 'points');
}


function addFareyExpResidues(m) {
  if (m === undefined) m = +document.getElementById('fareyExpMod')?.value || 12;
  
  // Add all k/m for k = 0 to m-1
  for (let k = 0; k < m; k++) {
    const g = gcd(k, m);
    const p = k / g;
    const q = m / g;
    // Check if already exists
    const exists = window.fareyExpPoints.some(pt => pt.p === p && pt.q === q);
    if (!exists) {
      window.fareyExpPoints.push({ p, q, value: p / q });
    }
  }
  
  window.fareyExpPoints.sort((a, b) => a.value - b.value);
  updateFareyExpDisplay();
  drawFareyExplorer();
}

function loadFareyExpPreset(preset) {
  if (preset === 'primes') {
    // Add p/q where p is prime and q is small
    const primes = [2, 3, 5, 7, 11, 13];
    window.fareyExpPoints = [];
    for (let q = 2; q <= 12; q++) {
      for (const p of primes) {
        if (p < q && gcd(p, q) === 1) {
          window.fareyExpPoints.push({ p, q, value: p / q });
        }
      }
    }
  } else if (preset === 'golden') {
    // Golden ratio related fractions (Fibonacci)
    const fibs = [1, 1, 2, 3, 5, 8, 13, 21, 34, 55];
    window.fareyExpPoints = [];
    for (let i = 1; i < fibs.length; i++) {
      window.fareyExpPoints.push({ p: fibs[i - 1], q: fibs[i], value: fibs[i - 1] / fibs[i] });
    }
  }
  
  window.fareyExpPoints.sort((a, b) => a.value - b.value);
  updateFareyExpDisplay();
  drawFareyExplorer();
}

function addFareyExpPoint() {
  const input = prompt('Enter fraction p/q (e.g., 2/5):', '1/3');
  if (!input) return;
  
  const match = input.match(/(\d+)\s*\/\s*(\d+)/);
  if (match) {
    const p = +match[1];
    const q = +match[2];
    if (q > 0) {
      const g = gcd(p, q);
      const rp = p / g;
      const rq = q / g;
      const exists = window.fareyExpPoints.some(pt => pt.p === rp && pt.q === rq);
      if (!exists) {
        window.fareyExpPoints.push({ p: rp, q: rq, value: rp / rq });
        window.fareyExpPoints.sort((a, b) => a.value - b.value);
        updateFareyExpDisplay();
        drawFareyExplorer();
      }
    }
  }
}

function removeFareyExpPoint(p, q) {
  window.fareyExpPoints = window.fareyExpPoints.filter(pt => !(pt.p === p && pt.q === q));
  updateFareyExpDisplay();
  drawFareyExplorer();
}

function clearFareyExpPoints() {
  window.fareyExpPoints = [];
  updateFareyExpDisplay();
  drawFareyExplorer();
}

function updateFareyExpDisplay() {
  const list = document.getElementById('fareyExpPointsList');
  const count = document.getElementById('fareyExpCount');
  if (!list) return;
  
  if (window.fareyExpPoints.length === 0) {
    list.innerHTML = '<span style="color:var(--txt2);font-size:.7rem;font-style:italic">No points added yet</span>';
  } else {
    list.innerHTML = window.fareyExpPoints.slice(0, 50).map(pt => 
      `<span style="display:inline-flex;align-items:center;gap:2px;background:rgba(0,217,255,.15);padding:2px 6px;border-radius:3px;font-size:.7rem;color:#00d9ff">${pt.p}/${pt.q}<button onclick="removeFareyExpPoint(${pt.p},${pt.q})" style="background:none;border:none;color:#ff6496;cursor:pointer;font-size:.8rem;padding:0 2px">×</button></span>`
    ).join('') + (window.fareyExpPoints.length > 50 ? `<span style="color:var(--txt2);font-size:.65rem">+${window.fareyExpPoints.length - 50} more</span>` : '');
  }
  
  if (count) count.textContent = `${window.fareyExpPoints.length} POINTS`;
}

function resizeFareyExpCanvases() {
  const size = +document.getElementById('fareyExpSize')?.value || 500;
  const c = document.getElementById('cFareyDisk');
  if (c) { c.width = size; c.height = size; }
  drawFareyDisk();
}

function startFareyExpRotation() {
  stopFareyExpRotation();
  fareyExpRotationInterval = setInterval(() => {
    const phaseEl = document.getElementById('fareyExpPhase');
    if (phaseEl) {
      phaseEl.value = (+phaseEl.value + 1) % 360;
      document.getElementById('fareyExpPhaseV').textContent = phaseEl.value + '°';
      drawFareyExplorer();
    }
  }, 50);
}

function stopFareyExpRotation() {
  if (fareyExpRotationInterval) {
    clearInterval(fareyExpRotationInterval);
    fareyExpRotationInterval = null;
  }
}

function resetFareyExpView() {
  stopFareyExpRotation();
  document.getElementById('fareyExpZoom').value = 1;
  document.getElementById('fareyExpZoomV').textContent = '1.0×';
  document.getElementById('fareyExpPhase').value = 0;
  document.getElementById('fareyExpPhaseV').textContent = '0°';
  drawFareyExplorer();
}

function drawFareyExplorer() {
  try { drawFareyDisk(); } catch(e) { console.warn('drawFareyDisk error:', e); }
  try { drawFareyHalfPlane(); } catch(e) { console.warn('drawFareyHalfPlane error:', e); }
  try { drawFareyGrid(); } catch(e) { console.warn('drawFareyGrid error:', e); }
  try { drawFareyPhi(); } catch(e) { console.warn('drawFareyPhi error:', e); }
  try { updateFareyExpStats(); } catch(e) { console.warn('updateFareyExpStats error:', e); }
  updateFareyStats();
  console.log(' drawFareyExplorer completed');
}


function drawFareyDisk() {
  const c = document.getElementById('cFareyDisk');
  if (!c) return;
  const ctx = c.getContext('2d');
  const W = c.width, H = c.height;
  const cx = W / 2, cy = H / 2;
  const zoom = +document.getElementById('fareyExpZoom')?.value || 1;
  const phase = (+document.getElementById('fareyExpPhase')?.value || 0) * Math.PI / 180;
  const R = Math.min(W, H) * 0.42 * zoom;
  const showGrid = document.getElementById('fareyExpShowGrid')?.checked;
  const showAxes = document.getElementById('fareyExpShowAxes')?.checked;
  const showCircle = document.getElementById('fareyExpShowCircle')?.checked;
  const showLabels = document.getElementById('fareyExpShowLabels')?.checked;
  const coprimeOnly = document.getElementById('fareyExpCoprime')?.checked;
  const ptSize = +document.getElementById('fareyExpPtSize')?.value || 5;
  const lineW = +document.getElementById('fareyExpLineW')?.value || 1;
  const opacity = +document.getElementById('fareyExpOpacity')?.value || 0.5;
  const connectMode = document.getElementById('fareyExpConnect')?.value || 'none';
  const isDk = isDark();
  
  ctx.fillStyle = isDk ? '#0a0e27' : '#f8f9fa';
  ctx.fillRect(0, 0, W, H);
  
  // Grid (polar)
  if (showGrid) {
    ctx.strokeStyle = isDk ? 'rgba(255,255,255,.08)' : 'rgba(0,0,0,.08)';
    ctx.lineWidth = 0.5;
    // Radial lines
    for (let i = 0; i < 12; i++) {
      const angle = i * Math.PI / 6;
      ctx.beginPath();
      ctx.moveTo(cx, cy);
      ctx.lineTo(cx + R * 1.1 * Math.cos(angle), cy - R * 1.1 * Math.sin(angle));
      ctx.stroke();
    }
    // Concentric circles
    for (let r = 0.25; r <= 1; r += 0.25) {
      ctx.beginPath();
      ctx.arc(cx, cy, R * r, 0, 2 * Math.PI);
      ctx.stroke();
    }
  }
  
  // Axes
  if (showAxes) {
    ctx.strokeStyle = isDk ? 'rgba(255,255,255,.2)' : 'rgba(0,0,0,.2)';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(cx - R * 1.1, cy);
    ctx.lineTo(cx + R * 1.1, cy);
    ctx.moveTo(cx, cy - R * 1.1);
    ctx.lineTo(cx, cy + R * 1.1);
    ctx.stroke();
  }
  
  // Unit circle
  if (showCircle) {
    ctx.strokeStyle = isDk ? '#ff4444' : '#cc0000';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(cx, cy, R, 0, 2 * Math.PI);
    ctx.stroke();
  }
  
  // Get filtered points
  const pts = coprimeOnly ? window.fareyExpPoints.filter(pt => gcd(pt.p, pt.q) === 1) : fareyExpPoints;
  
  // Sort by value
  const sortedPts = [...pts].sort((a, b) => a.value - b.value);
  
  // Calculate screen positions
  const screenPts = sortedPts.map(pt => {
    const angle = 2 * Math.PI * pt.value + phase;
    return {
      ...pt,
      x: cx + R * Math.cos(angle),
      y: cy - R * Math.sin(angle),
      angle
    };
  });
  
  // Draw geodesic connections (chords through disk) - YELLOW like reference
  if ((connectMode === 'geodesic' || connectMode === 'farey') && screenPts.length > 1) {
    ctx.strokeStyle = isDk ? `rgba(255,215,0,${opacity})` : `rgba(204,170,0,${opacity})`;
    ctx.lineWidth = lineW * 1.5;
    
    for (let i = 0; i < screenPts.length; i++) {
      for (let j = i + 1; j < screenPts.length; j++) {
        const p1 = screenPts[i], p2 = screenPts[j];
        
        // For Farey mode, only connect neighbors (|ps - qr| = 1)
        if (connectMode === 'farey') {
          const det = Math.abs(p1.p * p2.q - p1.q * p2.p);
          if (det !== 1) continue;
        }
        
        // Draw chord (geodesic in disk model)
        ctx.beginPath();
        ctx.moveTo(p1.x, p1.y);
        ctx.lineTo(p2.x, p2.y);
        ctx.stroke();
      }
    }
  }
  
  // Same denominator connections
  if (connectMode === 'sameDen') {
    const groups = {};
    screenPts.forEach(pt => {
      if (!groups[pt.q]) groups[pt.q] = [];
      groups[pt.q].push(pt);
    });
    
    ctx.strokeStyle = isDk ? `rgba(0,217,255,${opacity})` : `rgba(0,136,204,${opacity})`;
    ctx.lineWidth = lineW;
    
    Object.values(groups).forEach(group => {
      if (group.length > 1) {
        for (let i = 0; i < group.length; i++) {
          for (let j = i + 1; j < group.length; j++) {
            ctx.beginPath();
            ctx.moveTo(group[i].x, group[i].y);
            ctx.lineTo(group[j].x, group[j].y);
            ctx.stroke();
          }
        }
      }
    });
  }
  
  // Draw points on circle
  screenPts.forEach(pt => {
    const hue = (pt.value * 360) % 360;
    
    // Outer glow
    ctx.shadowColor = `hsl(${hue}, 80%, 50%)`;
    ctx.shadowBlur = 8;
    
    // Point fill
    ctx.fillStyle = `hsl(${hue}, 80%, 55%)`;
    ctx.beginPath();
    ctx.arc(pt.x, pt.y, ptSize, 0, 2 * Math.PI);
    ctx.fill();
    
    // White border
    ctx.shadowBlur = 0;
    ctx.strokeStyle = '#fff';
    ctx.lineWidth = 1.5;
    ctx.stroke();
    
    // Labels outside circle
    if (showLabels && pt.q <= 10) {
      ctx.fillStyle = isDk ? '#fff' : '#000';
      ctx.font = `bold ${Math.max(9, 13 - pt.q)}px sans-serif`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      const labelR = R + 20;
      const lx = cx + labelR * Math.cos(pt.angle);
      const ly = cy - labelR * Math.sin(pt.angle);
      ctx.fillText(`${pt.p}/${pt.q}`, lx, ly);
    }
  });
  
  // Title
  ctx.shadowBlur = 0;
  ctx.fillStyle = isDk ? '#ffd700' : '#cc8800';
  ctx.font = 'bold 14px sans-serif';
  ctx.textAlign = 'left';
  ctx.textBaseline = 'top';
  ctx.fillText('Unit Disk 𝔻', 10, 10);
  ctx.font = '11px sans-serif';
  ctx.fillStyle = isDk ? '#888' : '#666';
  ctx.fillText('Custom Farey Configuration', 10, 27);
}

function drawFareyHalfPlane() {
  const c = document.getElementById('cFareyHalfPlane');
  if (!c) return;
  const ctx = c.getContext('2d');
  const W = c.width, H = c.height;
  const zoom = +document.getElementById('fareyExpZoom')?.value || 1;
  const phase = (+document.getElementById('fareyExpPhase')?.value || 0) * Math.PI / 180;
  const showGrid = document.getElementById('fareyExpShowGrid')?.checked;
  const showAxes = document.getElementById('fareyExpShowAxes')?.checked;
  const showLabels = document.getElementById('fareyExpShowLabels')?.checked;
  const coprimeOnly = document.getElementById('fareyExpCoprime')?.checked;
  const ptSize = +document.getElementById('fareyExpPtSize')?.value || 5;
  const lineW = +document.getElementById('fareyExpLineW')?.value || 1;
  const opacity = +document.getElementById('fareyExpOpacity')?.value || 0.5;
  const connectMode = document.getElementById('fareyExpConnect')?.value || 'none';
  const isDk = isDark();
  
  ctx.fillStyle = isDk ? '#0a0e27' : '#f8f9fa';
  ctx.fillRect(0, 0, W, H);
  
  // View parameters
  const margin = { left: 50, right: 20, top: 30, bottom: 70 };
  const plotW = W - margin.left - margin.right;
  const plotH = H - margin.top - margin.bottom;
  
  // Scale: map [0,1] on x-axis, and Ford circles fit in view
  // Largest Ford circle is at 0/1 and 1/1 with radius 1/2
  // We want to see circles for q up to ~8 clearly
  const xScale = plotW; // [0,1] maps to plotW pixels
  const yScale = plotH * 2.5 * zoom; // Imaginary axis scale - larger = bigger Ford circles
  
  const toX = (re) => margin.left + re * xScale;
  const toY = (im) => H - margin.bottom - im * yScale;
  const toR = (r) => r * yScale; // Radius in screen pixels
  
  // Rotate point on upper half plane (center at 0.5, 0)
  const rotatePoint = (x, y) => {
    const cx = 0.5; // Center of rotation
    const cy = 0;
    const cos_p = Math.cos(phase);
    const sin_p = Math.sin(phase);
    const px = x - cx;
    const py = y - cy;
    const rx = px * cos_p - py * sin_p + cx;
    const ry = px * sin_p + py * cos_p + cy;
    return { x: rx, y: ry };
  };
  
  // Grid
  if (showGrid) {
    ctx.strokeStyle = isDk ? 'rgba(255,255,255,.08)' : 'rgba(0,0,0,.08)';
    ctx.lineWidth = 0.5;
    for (let i = 0; i <= 10; i++) {
      const x = toX(i / 10);
      ctx.beginPath();
      ctx.moveTo(x, margin.top);
      ctx.lineTo(x, H - margin.bottom);
      ctx.stroke();
    }
    for (let i = 0; i <= 5; i++) {
      const y = toY(i * 0.1);
      if (y > margin.top) {
        ctx.beginPath();
        ctx.moveTo(margin.left, y);
        ctx.lineTo(W - margin.right, y);
        ctx.stroke();
      }
    }
  }
  
  // Get filtered points
  const pts = coprimeOnly ? window.fareyExpPoints.filter(pt => gcd(pt.p, pt.q) === 1) : fareyExpPoints;
  const sortedPts = [...pts].sort((a, b) => a.value - b.value);
  
  // Draw Ford circles - these are tangent to real axis (SEMICIRCLES above axis)
  // Ford circle for p/q: center at (p/q, 1/(2q²)), radius 1/(2q²)
  sortedPts.forEach(pt => {
    if (pt.q === 0) return;
    const re = pt.value;
    const r = 1 / (2 * pt.q * pt.q); // Ford circle radius
    
    // Apply rotation
    const rotated = rotatePoint(re, r);
    
    const cx = toX(rotated.x);
    const cy = toY(rotated.y); // Center is at height r above real axis
    const screenR = toR(r);
    
    if (screenR > 3) {
      // Fill semicircle
      const gradient = ctx.createRadialGradient(cx, cy, screenR * 0.3, cx, cy, screenR);
      gradient.addColorStop(0, isDk ? 'rgba(0,217,255,0.25)' : 'rgba(0,136,204,0.2)');
      gradient.addColorStop(1, isDk ? 'rgba(0,217,255,0.05)' : 'rgba(0,136,204,0.02)');
      ctx.fillStyle = gradient;
      ctx.beginPath();
      ctx.arc(cx, cy, screenR, Math.PI, 0); // UPPER SEMICIRCLE only
      ctx.fill();
      
      // Stroke semicircle - thicker for smaller q
      ctx.strokeStyle = isDk ? `rgba(0,217,255,${Math.min(0.95, 0.4 + 0.8/pt.q)})` : `rgba(0,136,204,${Math.min(0.85, 0.4 + 0.6/pt.q)})`;
      ctx.lineWidth = Math.max(2, 5 - pt.q * 0.5);
      ctx.beginPath();
      ctx.arc(cx, cy, screenR, Math.PI, 0); // UPPER SEMICIRCLE only
      ctx.stroke();
    }
  });
  
  // Draw geodesic arcs (semicircles between Farey neighbors)
  if (connectMode === 'geodesic' || connectMode === 'farey') {
    ctx.strokeStyle = isDk ? `rgba(255,215,0,${opacity})` : `rgba(204,170,0,${opacity})`;
    ctx.lineWidth = lineW * 1.5;
    
    for (let i = 0; i < sortedPts.length - 1; i++) {
      const p1 = sortedPts[i], p2 = sortedPts[i + 1];
      
      // For Farey mode, only connect neighbors
      if (connectMode === 'farey') {
        const det = Math.abs(p1.p * p2.q - p1.q * p2.p);
        if (det !== 1) continue;
      }
      
      // Rotate both endpoints
      const rot1 = rotatePoint(p1.value, 0);
      const rot2 = rotatePoint(p2.value, 0);
      
      // Geodesic is a semicircle with diameter from x1 to x2 on real axis
      const x1 = toX(rot1.x);
      const x2 = toX(rot2.x);
      const midX = (x1 + x2) / 2;
      const radius = Math.abs(x2 - x1) / 2;
      const baseY = toY(0);
      
      ctx.beginPath();
      ctx.arc(midX, baseY, radius, Math.PI, 0); // Upper semicircle
      ctx.stroke();
    }
  }
  
  // Real axis (golden line)
  ctx.strokeStyle = isDk ? '#ffd700' : '#cc8800';
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(margin.left, toY(0));
  ctx.lineTo(W - margin.right, toY(0));
  ctx.stroke();
  
  // Draw points on real axis
  sortedPts.forEach(pt => {
    // Rotate point on real axis
    const rotated = rotatePoint(pt.value, 0);
    const x = toX(rotated.x);
    const y = toY(rotated.y);
    
    const hue = (pt.value * 360) % 360;
    ctx.fillStyle = `hsl(${hue}, 80%, 55%)`;
    ctx.beginPath();
    ctx.arc(x, y, ptSize, 0, 2 * Math.PI);
    ctx.fill();
    
    ctx.strokeStyle = '#fff';
    ctx.lineWidth = 1;
    ctx.stroke();
    
    // Labels
    if (showLabels && pt.q <= 12) {
      ctx.fillStyle = isDk ? '#fff' : '#000';
      ctx.font = `${Math.max(8, 11 - Math.floor(pt.q/2))}px sans-serif`;
      ctx.textAlign = 'center';
      ctx.fillText(`${pt.p}/${pt.q}`, x, y + ptSize + 12);
    }
  });
  
  // Axis labels
  ctx.fillStyle = isDk ? '#888' : '#666';
  ctx.font = '10px sans-serif';
  ctx.textAlign = 'center';
  for (let i = 0; i <= 10; i += 2) {
    ctx.fillText((i/10).toFixed(1), toX(i/10), H - margin.bottom + 45);
  }
  
  // Title
  ctx.fillStyle = isDk ? '#00d9ff' : '#0088cc';
  ctx.font = 'bold 12px sans-serif';
  ctx.textAlign = 'left';
  ctx.fillText('Upper Half-Plane (Hyperbolic Space)', 8, 16);
  ctx.font = '10px sans-serif';
  ctx.fillStyle = isDk ? '#888' : '#666';
  ctx.fillText('Ford Circles & Geodesics (Rotating)', 8, 28);
  ctx.fillText('Im', margin.left - 15, margin.top + 10);
}

function drawFareyGrid() {
  const c = document.getElementById('cFareyGrid');
  if (!c) return;
  const ctx = c.getContext('2d');
  const W = c.width, H = c.height;
  const maxN = +document.getElementById('fareyExpGridMax')?.value || 20;
  const isDk = isDark();
  
  ctx.fillStyle = isDk ? '#0a0e27' : '#f8f9fa';
  ctx.fillRect(0, 0, W, H);
  
  const margin = { left: 45, right: 15, top: 45, bottom: 25 };
  const gridW = W - margin.left - margin.right;
  const gridH = H - margin.top - margin.bottom;
  const cellW = gridW / maxN;
  const cellH = gridH / maxN;
  
  // Count coprimes
  let coprimeCount = 0;
  let totalCount = 0;
  
  // Draw lattice points
  for (let p = 1; p <= maxN; p++) {
    for (let q = 1; q <= maxN; q++) {
      const x = margin.left + (p - 0.5) * cellW;
      const y = H - margin.bottom - (q - 0.5) * cellH;
      const g = gcd(p, q);
      const isCoprime = g === 1;
      
      totalCount++;
      if (isCoprime) coprimeCount++;
      
      if (isCoprime) {
        // Color by fraction p/q value
        const frac = p / q;
        const hue = (frac * 360) % 360;
        ctx.fillStyle = `hsl(${hue}, 75%, 55%)`;
        ctx.beginPath();
        ctx.arc(x, y, Math.min(cellW, cellH) * 0.35, 0, 2 * Math.PI);
        ctx.fill();
      } else {
        // Non-coprime: small gray dot
        ctx.fillStyle = isDk ? 'rgba(255,255,255,.12)' : 'rgba(0,0,0,.08)';
        ctx.beginPath();
        ctx.arc(x, y, 1.5, 0, 2 * Math.PI);
        ctx.fill();
      }
    }
  }
  
  // Border
  ctx.strokeStyle = isDk ? 'rgba(0,255,136,.3)' : 'rgba(0,170,85,.2)';
  ctx.lineWidth = 1;
  ctx.strokeRect(margin.left, margin.top, gridW, gridH);
  
  // Axis labels
  ctx.fillStyle = isDk ? '#888' : '#666';
  ctx.font = '9px sans-serif';
  ctx.textAlign = 'center';
  // X axis (p)
  for (let i = 5; i <= maxN; i += 5) {
    ctx.fillText(i, margin.left + (i - 0.5) * cellW, H - margin.bottom + 15);
  }
  // Y axis (q)
  ctx.textAlign = 'right';
  for (let i = 5; i <= maxN; i += 5) {
    ctx.fillText(i, margin.left - 5, H - margin.bottom - (i - 0.5) * cellH + 3);
  }
  
  // Axis titles
  ctx.fillStyle = isDk ? '#666' : '#888';
  ctx.font = '10px sans-serif';
  ctx.save();
  ctx.translate(12, H / 2);
  ctx.rotate(-Math.PI / 2);
  ctx.textAlign = 'center';
  ctx.fillText('q (denominator)', 0, 0);
  ctx.restore();
  ctx.textAlign = 'center';
  ctx.fillText('p (numerator)', W / 2, H - 5);
  
  // Title and density stats
  ctx.fillStyle = isDk ? '#00ff88' : '#00aa55';
  ctx.font = 'bold 12px sans-serif';
  ctx.textAlign = 'left';
  ctx.fillText('Coprime Grid', 8, 16);
  
  const density = (coprimeCount / totalCount * 100).toFixed(1);
  const theoretical = (6 / (Math.PI * Math.PI) * 100).toFixed(1);
  ctx.font = '10px sans-serif';
  ctx.fillStyle = isDk ? '#ffd700' : '#cc8800';
  ctx.fillText(`Density: ${coprimeCount}/${totalCount} = ${density}% (6/π² = ${theoretical}%)`, 8, 30);
}

function drawFareyPhi() {
  const c = document.getElementById('cFareyPhi');
  if (!c) return;
  const ctx = c.getContext('2d');
  const W = c.width, H = c.height;
  const view = document.getElementById('fareyExpPhiView')?.value || 'ratio';
  const isDk = isDark();
  
  ctx.fillStyle = isDk ? '#0a0e27' : '#f8f9fa';
  ctx.fillRect(0, 0, W, H);
  
  const margin = { left: 50, right: 20, top: 45, bottom: 35 };
  const plotW = W - margin.left - margin.right;
  const plotH = H - margin.top - margin.bottom;
  
  // Calculate phi values
  const maxN = 100;
  const data = [];
  let cumulative = 0;
  
  for (let n = 1; n <= maxN; n++) {
    const phi = eulerPhi(n);
    cumulative += phi;
    data.push({
      n,
      phi,
      ratio: phi / n,
      cumulative,
      cumRatio: cumulative / (n * n)
    });
  }
  
  // Title
  ctx.fillStyle = isDk ? '#9664ff' : '#6644cc';
  ctx.font = 'bold 12px sans-serif';
  ctx.textAlign = 'left';
  const titles = { ratio: 'φ(n)/n Ratio', cumulative: 'Cumulative Σφ(k)', sternbrocot: 'Stern-Brocot Tree' };
  ctx.fillText(titles[view] || 'Phi Analysis', 8, 16);
  
  // Border
  ctx.strokeStyle = isDk ? 'rgba(150,100,255,.3)' : 'rgba(100,68,204,.2)';
  ctx.lineWidth = 1;
  ctx.strokeRect(margin.left, margin.top, plotW, plotH);
  
  if (view === 'ratio') {
    // φ(n)/n scatter plot
    const theoretical = 6 / (Math.PI * Math.PI);
    
    // Y-axis from 0 to 1
    const toX = (n) => margin.left + (n / maxN) * plotW;
    const toY = (r) => margin.top + plotH * (1 - r);
    
    // Theoretical line 6/π²
    ctx.strokeStyle = isDk ? 'rgba(255,100,150,.6)' : 'rgba(204,51,102,.5)';
    ctx.lineWidth = 1.5;
    ctx.setLineDash([5, 3]);
    const thY = toY(theoretical);
    ctx.beginPath();
    ctx.moveTo(margin.left, thY);
    ctx.lineTo(margin.left + plotW, thY);
    ctx.stroke();
    ctx.setLineDash([]);
    
    // Label for theoretical line
    ctx.fillStyle = isDk ? '#ff6496' : '#cc3366';
    ctx.font = '9px sans-serif';
    ctx.textAlign = 'left';
    ctx.fillText(`6/π² ≈ ${theoretical.toFixed(4)}`, margin.left + 5, thY - 5);
    
    // Data points - color by primality
    data.forEach((d, i) => {
      const x = toX(d.n);
      const y = toY(d.ratio);
      
      // Color: primes are magenta, others by ratio
      const isPrime = d.phi === d.n - 1 && d.n > 1;
      if (isPrime) {
        ctx.fillStyle = '#ff6496'; // Magenta for primes
      } else {
        // Color by phi(n)/n value - rainbow
        const hue = d.ratio * 300; // 0 to 300 (red to magenta)
        ctx.fillStyle = `hsl(${hue}, 70%, 55%)`;
      }
      
      ctx.beginPath();
      ctx.arc(x, y, isPrime ? 4 : 3, 0, 2 * Math.PI);
      ctx.fill();
    });
    
    // Y-axis labels
    ctx.fillStyle = isDk ? '#888' : '#666';
    ctx.font = '9px sans-serif';
    ctx.textAlign = 'right';
    ctx.fillText('1.0', margin.left - 5, toY(1) + 3);
    ctx.fillText('0.5', margin.left - 5, toY(0.5) + 3);
    ctx.fillText('0', margin.left - 5, toY(0) + 3);
    
    // X-axis labels
    ctx.textAlign = 'center';
    for (let n = 20; n <= maxN; n += 20) {
      ctx.fillText(n, toX(n), H - margin.bottom + 15);
    }
    ctx.fillText('n', W - 15, H - margin.bottom + 15);
    
  } else if (view === 'cumulative') {
    const maxCum = data[data.length - 1].cumulative;
    const toX = (n) => margin.left + (n / maxN) * plotW;
    const toY = (v) => margin.top + plotH * (1 - v / maxCum);
    
    // Theoretical curve 3n²/π²
    ctx.strokeStyle = isDk ? 'rgba(255,100,150,.5)' : 'rgba(204,51,102,.5)';
    ctx.lineWidth = 2;
    ctx.setLineDash([5, 3]);
    ctx.beginPath();
    for (let i = 0; i < data.length; i++) {
      const x = toX(data[i].n);
      const theoretical = 3 * data[i].n * data[i].n / (Math.PI * Math.PI);
      const y = toY(theoretical);
      if (i === 0) ctx.moveTo(x, y);
      else ctx.lineTo(x, y);
    }
    ctx.stroke();
    ctx.setLineDash([]);
    
    // Actual cumulative
    ctx.strokeStyle = isDk ? '#00ff88' : '#00aa55';
    ctx.lineWidth = 2;
    ctx.beginPath();
    data.forEach((d, i) => {
      const x = toX(d.n);
      const y = toY(d.cumulative);
      if (i === 0) ctx.moveTo(x, y);
      else ctx.lineTo(x, y);
    });
    ctx.stroke();
    
    // Legend
    ctx.font = '9px sans-serif';
    ctx.fillStyle = isDk ? '#00ff88' : '#00aa55';
    ctx.fillText('Σφ(k)', margin.left + 10, margin.top + 15);
    ctx.fillStyle = isDk ? '#ff6496' : '#cc3366';
    ctx.fillText('3n²/π²', margin.left + 10, margin.top + 28);
    
  } else if (view === 'sternbrocot') {
    // Stern-Brocot tree
    const maxDepth = 5;
    const nodeRadius = 6;
    
    const drawNode = (p, q, x, y, depth) => {
      const hue = ((p / q) * 360) % 360;
      ctx.fillStyle = `hsl(${hue}, 70%, 55%)`;
      ctx.beginPath();
      ctx.arc(x, y, Math.max(3, nodeRadius - depth), 0, 2 * Math.PI);
      ctx.fill();
      
      if (depth <= 3) {
        ctx.fillStyle = isDk ? '#fff' : '#000';
        ctx.font = `${Math.max(8, 11 - depth)}px sans-serif`;
        ctx.textAlign = 'center';
        ctx.fillText(`${p}/${q}`, x, y - nodeRadius - 3);
      }
    };
    
    // Draw tree recursively
    const drawTree = (pL, qL, pR, qR, depth, x, y, spread) => {
      if (depth > maxDepth) return;
      
      const p = pL + pR;
      const q = qL + qR;
      
      drawNode(p, q, x, y, depth);
      
      const nextY = y + (plotH - 20) / (maxDepth + 1);
      const nextSpread = spread / 2;
      
      // Draw edges
      if (depth < maxDepth) {
        ctx.strokeStyle = isDk ? 'rgba(255,255,255,.15)' : 'rgba(0,0,0,.1)';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(x, y + nodeRadius);
        ctx.lineTo(x - nextSpread, nextY - nodeRadius);
        ctx.moveTo(x, y + nodeRadius);
        ctx.lineTo(x + nextSpread, nextY - nodeRadius);
        ctx.stroke();
        
        // Left child: mediant of (pL/qL, p/q)
        drawTree(pL, qL, p, q, depth + 1, x - nextSpread, nextY, nextSpread);
        // Right child: mediant of (p/q, pR/qR)
        drawTree(p, q, pR, qR, depth + 1, x + nextSpread, nextY, nextSpread);
      }
    };
    
    // Start with 1/2 as root (between 0/1 and 1/1)
    drawTree(0, 1, 1, 1, 0, margin.left + plotW / 2, margin.top + 25, plotW / 4);
  }
}

function eulerPhi(n) {
  let result = n;
  for (let p = 2; p * p <= n; p++) {
    if (n % p === 0) {
      while (n % p === 0) n = Math.floor(n / p);
      result -= Math.floor(result / p);
    }
  }
  if (n > 1) result -= Math.floor(result / n);
  return result;
}

function updateFareyExpStats() {
  const pts = fareyExpPoints;
  const coprimeOnly = document.getElementById('fareyExpCoprime')?.checked;
  const filtered = coprimeOnly ? pts.filter(pt => gcd(pt.p, pt.q) === 1) : pts;
  const maxQ = filtered.length > 0 ? Math.max(...filtered.map(pt => pt.q)) : 0;
  const coprimeCount = pts.filter(pt => gcd(pt.p, pt.q) === 1).length;
  
  document.getElementById('fareyExpStatPts').textContent = filtered.length;
  document.getElementById('fareyExpStatCoprime').textContent = coprimeCount;
  document.getElementById('fareyExpStatMaxQ').textContent = maxQ;
  document.getElementById('fareyExpStatDensity').textContent = pts.length > 0 ? (coprimeCount / pts.length * 100).toFixed(1) + '%' : '—';
}

function handleFareyDiskClick(event) {
  const c = event.target;
  const rect = c.getBoundingClientRect();
  const x = (event.clientX - rect.left) * (c.width / rect.width);
  const y = (event.clientY - rect.top) * (c.height / rect.height);
  const cx = c.width / 2, cy = c.height / 2;
  const zoom = +document.getElementById('fareyExpZoom')?.value || 1;
  const R = Math.min(c.width, c.height) * 0.4 * zoom;
  
  // Find closest point
  const phase = (+document.getElementById('fareyExpPhase')?.value || 0) * Math.PI / 180;
  let closest = null, minDist = Infinity;
  
  window.fareyExpPoints.forEach(pt => {
    const angle = 2 * Math.PI * pt.value + phase;
    const px = cx + R * Math.cos(angle);
    const py = cy - R * Math.sin(angle);
    const dist = Math.hypot(x - px, y - py);
    if (dist < minDist) { minDist = dist; closest = pt; }
  });
  
  if (closest && minDist < 20) {
    document.getElementById('fareyDiskInfo').innerHTML = 
      `Selected: <strong style="color:#ffd700">${closest.p}/${closest.q}</strong> = ${closest.value.toFixed(6)} | θ = ${(closest.value * 360).toFixed(1)}°`;
    if (typeof playEnhFreq === 'function') playEnhFreq(closest.p, closest.q);
  }
}

function handleFareyHalfPlaneClick(event) {
  // Similar to disk click handler
  document.getElementById('fareyHalfPlaneInfo').textContent = 'Click to select a point';
}

function handleFareyGridClick(event) {
  // Grid click handler
}

function screenshotFareyExplorer() {
  // Combine all 4 canvases into one screenshot
  const disk = document.getElementById('cFareyDisk');
  const halfPlane = document.getElementById('cFareyHalfPlane');
  const grid = document.getElementById('cFareyGrid');
  const phi = document.getElementById('cFareyPhi');
  
  if (!disk) return;
  
  const W = disk.width * 2 + 20;
  const H = disk.height * 2 + 40;
  
  const canvas = document.createElement('canvas');
  canvas.width = W;
  canvas.height = H;
  const ctx = canvas.getContext('2d');
  
  ctx.fillStyle = isDark() ? '#0a0e27' : '#f8f9fa';
  ctx.fillRect(0, 0, W, H);
  
  // Title
  ctx.fillStyle = isDark() ? '#00d9ff' : '#0088cc';
  ctx.font = 'bold 16px sans-serif';
  ctx.textAlign = 'center';
  ctx.fillText('Farey Explorer — Unit Disk & Upper Half-Plane', W / 2, 20);
  
  // Draw canvases
  ctx.drawImage(disk, 5, 30);
  ctx.drawImage(halfPlane, disk.width + 15, 30);
  ctx.drawImage(grid, 5, disk.height + 35);
  ctx.drawImage(phi, disk.width + 15, disk.height + 35);
  
  // Download
  const link = document.createElement('a');
  link.download = 'farey_explorer.png';
  link.href = canvas.toDataURL('image/png');
  link.click();
}

function exportFareyCanvas(canvasId, format) {
  const canvas = document.getElementById(canvasId);
  if (!canvas) return;
  
  if (format === 'png') {
    const link = document.createElement('a');
    const names = {
      'cFareyDisk': 'unit_disk',
      'cFareyHalfPlane': 'upper_half_plane',
      'cFareyGrid': 'coprime_grid',
      'cFareyPhi': 'phi_ratio'
    };
    link.download = (names[canvasId] || 'farey') + '.png';
    link.href = canvas.toDataURL('image/png');
    link.click();
  }
}

function exportFareyCSV() {
  if (window.fareyExpPoints.length === 0) {
    alert('No points to export');
    return;
  }
  
  let csv = 'p,q,value,angle_degrees,gcd,coprime\n';
  window.fareyExpPoints.forEach(pt => {
    const g = gcd(pt.p, pt.q);
    csv += `${pt.p},${pt.q},${pt.value.toFixed(8)},${(pt.value * 360).toFixed(4)},${g},${g === 1 ? 'yes' : 'no'}\n`;
  });
  
  const blob = new Blob([csv], { type: 'text/csv' });
  const url = URL.createObjectURL(blob);
  const link = document.createElement('a');
  link.download = 'farey_points.csv';
  link.href = url;
  link.click();
  URL.revokeObjectURL(url);
}

// Initialize Farey Explorer on load

// Update Farey stat cards
function updateFareyStats() {
  console.log("updateFareyStats called with", window.fareyExpPoints?.length || 0, "points");
  const pts = window.fareyExpPoints || [];
  
  // Clear/initialize all stat elements
  const statIds = ['farey-total', 'farey-coprime', 'farey-coprime-pct', 'farey-maxq', 
                   'farey-minq', 'farey-avgq', 'farey-minval', 'farey-maxval', 'farey-span',
                   'farey-maxp', 'farey-medianq', 'farey-stdq', 'farey-qrange',
                   'farey-noncoprime', 'farey-noncoprime-pct', 'farey-depth'];
  
  if(pts.length === 0) {
    statIds.forEach(id => {
      const el = document.getElementById(id);
      if(el) el.textContent = id.includes('pct') ? '0%' : (id.includes('depth') ? '—' : '0');
    });
    return;
  }
  
  // ===== BASIC STATS =====
  const total = pts.length;
  
  // ===== COPRIMALITY =====
  const coprime = pts.filter(p => {
    let a = p.p, b = p.q;
    while(b) { let t = b; b = a % b; a = t; }
    return a === 1;
  }).length;
  const noncoprime = total - coprime;
  const coprimePct = ((coprime / total) * 100).toFixed(1);
  const noncoprimePct = ((noncoprime / total) * 100).toFixed(1);
  
  // ===== DENOMINATOR STATS =====
  const qs = pts.map(p => p.q);
  const maxQ = Math.max(...qs);
  const minQ = Math.min(...qs);
  const avgQ = (qs.reduce((a, b) => a + b, 0) / qs.length).toFixed(3);
  
  // Median Q
  const sortedQs = [...qs].sort((a,b) => a-b);
  const medianQ = sortedQs.length % 2 === 0 
    ? ((sortedQs[sortedQs.length/2-1] + sortedQs[sortedQs.length/2]) / 2).toFixed(1)
    : sortedQs[Math.floor(sortedQs.length/2)];
  
  // Std Dev Q
  const meanQ = qs.reduce((a,b) => a+b, 0) / qs.length;
  const varianceQ = qs.reduce((sum, q) => sum + Math.pow(q - meanQ, 2), 0) / qs.length;
  const stdQ = Math.sqrt(varianceQ).toFixed(3);
  const qRange = maxQ - minQ;
  
  // ===== NUMERATOR STATS =====
  const ps = pts.map(p => p.p);
  const maxP = Math.max(...ps);
  
  // ===== FRACTION VALUE STATS =====
  const vals = pts.map(p => p.value);
  const minVal = Math.min(...vals);
  const maxVal = Math.max(...vals);
  const span = (maxVal - minVal).toFixed(6);
  
  // ===== FAREY DEPTH =====
  // The depth is the maximum q value that captures all points
  const depth = maxQ;
  
  // ===== UPDATE DOM =====
  const updates = {
    'farey-total': total,
    'farey-coprime': coprime,
    'farey-coprime-pct': coprimePct + '%',
    'farey-noncoprime': noncoprime,
    'farey-noncoprime-pct': noncoprimePct + '%',
    'farey-maxq': maxQ,
    'farey-minq': minQ,
    'farey-avgq': avgQ,
    'farey-medianq': medianQ,
    'farey-stdq': stdQ,
    'farey-qrange': qRange,
    'farey-maxp': maxP,
    'farey-minval': minVal.toFixed(6),
    'farey-maxval': maxVal.toFixed(6),
    'farey-span': span,
    'farey-depth': 'F_' + depth
  };
  
  for(const [id, val] of Object.entries(updates)) {
    const el = document.getElementById(id);
    if(el) el.textContent = val;
  }
}



document.addEventListener('DOMContentLoaded', () => {
  console.log(' Initializing Farey Explorer...');
  window.fareyExpPoints = [];
  setTimeout(() => {
    try {
      generateFareyExp(5);
      console.log(' Farey Explorer initialized');
    } catch(e) {
      console.error(' Error initializing Farey:', e);
      updateFareyStats();
    }
  }, 100);
});


// Arnold canvas resize
function resizeArnoldCanvas() {
  const size = +document.getElementById('arnoldCanvasSize')?.value || 800;
  const c = document.getElementById('cArnoldTongues');
  if (c) {
    c.width = size;
    c.height = size / 2;
    drawArnoldTongues();
  }
}

function handleArnoldClick(event) {
  const c = document.getElementById('cArnoldTongues');
  if (!c || !window.arnoldTongues) return;
  
  const rect = c.getBoundingClientRect();
  const x = (event.clientX - rect.left) * (c.width / rect.width);
  const y = (event.clientY - rect.top) * (c.height / rect.height);
  
  const margin = { left: 50, right: 20, top: 20, bottom: 40 };
  const plotW = c.width - margin.left - margin.right;
  const plotH = c.height - margin.top - margin.bottom;
  
  const ratio = (x - margin.left) / plotW;
  if (ratio < 0 || ratio > 1) return;
  
  // Find closest tongue
  let closest = null;
  let minDist = Infinity;
  window.arnoldTongues.forEach(t => {
    const dist = Math.abs(t.ratio - ratio);
    if (dist < minDist) {
      minDist = dist;
      closest = t;
    }
  });
  
  if (closest && minDist < 0.05) {
    const sel = document.getElementById('arnoldSelected');
    if (sel) {
      sel.style.display = 'block';
      const cents = Math.round(1200 * Math.log2(closest.p / closest.q || 1));
      sel.innerHTML = `Selected: <strong style="color:#ffd700">${closest.p}/${closest.q}</strong> = ${closest.ratio.toFixed(6)} | ${cents} cents`;
    }
    // Play the interval
    if (typeof playEnhFreq === 'function') {
      playEnhFreq(closest.p || 1, closest.q);
    }
  }
}

// Arnold Tongues play controls
let arnoldPlayInterval = null;
let arnoldPlayIndex = 0;

function playArnoldSequence(mode) {
  stopArnoldPlay();
  
  // Handle path mode specially
  if (mode === 'path') {
    const path = window.enhSBHighlightPath || [];
    if (path.length === 0) {
      const pathEl = document.getElementById('arnoldPath');
      if (pathEl) {
        pathEl.style.display = 'block';
        pathEl.innerHTML = '<span style="color:#ff6496">No path selected. Click a coprime point on the main canvas first.</span>';
      }
      return;
    }
    
    const speed = +(document.getElementById('arnoldPlaySpeed')?.value || 120);
    arnoldPlayIndex = 0;
    const sel = document.getElementById('arnoldSelected');
    if (sel) sel.style.display = 'block';
    
    function playPathNext() {
      if (arnoldPlayIndex >= path.length) {
        stopArnoldPlay();
        return;
      }
      
      const node = path[arnoldPlayIndex];
      if (typeof playEnhFreq === 'function') {
        playEnhFreq(node.p, node.q);
      }
      
      if (sel) {
        const cents = Math.round(1200 * Math.log2(node.p / node.q));
        sel.innerHTML = `Path: <strong style="color:#00ff88">${node.p}/${node.q}</strong> [${arnoldPlayIndex + 1}/${path.length}] | ${cents} cents`;
      }
      
      highlightArnoldTongue(node.p, node.q);
      arnoldPlayIndex++;
    }
    
    playPathNext();
    arnoldPlayInterval = setInterval(playPathNext, speed);
    return;
  }
  
  if (!window.arnoldTongues || window.arnoldTongues.length === 0) {
    drawArnoldTongues();
  }
  
  let tongues = [...(window.arnoldTongues || [])];
  if (tongues.length === 0) return;
  
  // Sort based on mode
  if (mode === 'ltr') {
    tongues.sort((a, b) => a.ratio - b.ratio); // ascending by ratio (left to right)
  } else if (mode === 'rtl') {
    tongues.sort((a, b) => b.ratio - a.ratio); // descending by ratio (right to left)
  } else if (mode === 'farey') {
    // Farey order: sort by denominator, then numerator
    tongues.sort((a, b) => a.q - b.q || a.p - b.p);
  } else if (mode === 'random') {
    // Shuffle
    for (let i = tongues.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [tongues[i], tongues[j]] = [tongues[j], tongues[i]];
    }
  }
  
  const speed = +(document.getElementById('arnoldPlaySpeed')?.value || 120);
  arnoldPlayIndex = 0;
  
  // Update selected display
  const sel = document.getElementById('arnoldSelected');
  if (sel) sel.style.display = 'block';
  
  function playNext() {
    if (arnoldPlayIndex >= tongues.length) {
      stopArnoldPlay();
      return;
    }
    
    const t = tongues[arnoldPlayIndex];
    if (typeof playEnhFreq === 'function') {
      playEnhFreq(t.p || 1, t.q);
    }
    
    // Update display
    if (sel) {
      const cents = Math.round(1200 * Math.log2((t.p || 1) / t.q));
      sel.innerHTML = `Playing: <strong style="color:#ffd700">${t.p}/${t.q}</strong> [${arnoldPlayIndex + 1}/${tongues.length}] | ${cents} cents`;
    }
    
    // Highlight on canvas
    highlightArnoldTongue(t.p, t.q);
    
    arnoldPlayIndex++;
  }
  
  playNext(); // Play first immediately
  arnoldPlayInterval = setInterval(playNext, speed);
}

function stopArnoldPlay() {
  if (arnoldPlayInterval) {
    clearInterval(arnoldPlayInterval);
    arnoldPlayInterval = null;
  }
  arnoldPlayIndex = 0;
  // Redraw to clear highlight
  drawArnoldTongues();
}

function highlightArnoldTongue(p, q) {
  const c = document.getElementById('cArnoldTongues');
  if (!c || !window.arnoldTongues) return;
  
  // Redraw base
  drawArnoldTongues();
  
  const ctx = c.getContext('2d');
  const margin = { left: 50, right: 20, top: 20, bottom: 40 };
  const plotW = c.width - margin.left - margin.right;
  
  // Find and highlight the tongue
  const t = window.arnoldTongues.find(x => x.p === p && x.q === q);
  if (!t) return;
  
  const x = margin.left + t.ratio * plotW;
  const epsMax = +document.getElementById('arnoldEpsMax')?.value || 1;
  const k = 0.5;
  const topWidth = (k * epsMax / (t.q * t.q)) * plotW;
  
  // Draw highlight
  ctx.strokeStyle = '#fff';
  ctx.lineWidth = 3;
  ctx.beginPath();
  ctx.moveTo(x, margin.top + (c.height - margin.top - margin.bottom)); // Tip at epsilon=0
  ctx.lineTo(x - topWidth / 2, margin.top);
  ctx.lineTo(x + topWidth / 2, margin.top);
  ctx.closePath();
  ctx.stroke();
  
  // Draw marker at tip
  ctx.fillStyle = '#ffd700';
  ctx.beginPath();
  ctx.arc(x, margin.top + (c.height - margin.top - margin.bottom), 6, 0, 2 * Math.PI);
  ctx.fill();
}

async function screenshotArnoldTongues() {
  const c = document.getElementById('cArnoldTongues');
  if (!c) return;
  
  const scale = 2;
  const out = document.createElement('canvas');
  out.width = c.width * scale;
  out.height = c.height * scale + 60;
  const ctx = out.getContext('2d');
  
  const isDk = isDark();
  ctx.fillStyle = isDk ? '#0d1117' : '#fff';
  ctx.fillRect(0, 0, out.width, out.height);
  
  // Title
  ctx.fillStyle = isDk ? '#ff8c00' : '#cc6600';
  ctx.font = `bold ${16 * scale}px sans-serif`;
  ctx.textAlign = 'center';
  ctx.fillText('Arnold Tongues — Phase-Locking Regions', out.width / 2, 25 * scale);
  
  // Canvas
  ctx.drawImage(c, 0, 40 * scale, c.width * scale, c.height * scale);
  
  out.toBlob(b => {
    const a = document.createElement('a');
    a.href = URL.createObjectURL(b);
    a.download = 'arnold_tongues.png';
    a.click();
  });
}

// ========== FREQUENCY DISTRIBUTION HISTOGRAM ==========
function drawFreqDistribution() {
  const c = document.getElementById('cFreqDist');
  if (!c || !enhRingsData || enhRingsData.length === 0) return;
  const ctx = c.getContext('2d');
  
  const bins = +document.getElementById('freqHistBins')?.value || 50;
  const logScale = document.getElementById('freqHistLog')?.checked ?? false;
  const showPeaks = document.getElementById('freqHistShowPeaks')?.checked ?? true;
  const isDk = isDark();
  
  const W = c.width, H = c.height;
  const margin = { left: 50, right: 20, top: 20, bottom: 40 };
  const plotW = W - margin.left - margin.right;
  const plotH = H - margin.top - margin.bottom;
  
  // Collect all coprime ratios
  const ratios = [];
  enhRingsData.forEach(ring => {
    ring.coprimes.forEach(r => {
      const ratio = r / ring.mod;
      if (ratio > 0 && ratio <= 1) ratios.push(ratio);
    });
  });
  
  if (ratios.length === 0) {
    ctx.fillStyle = isDk ? '#0a0e27' : '#f5f7fa';
    ctx.fillRect(0, 0, W, H);
    ctx.fillStyle = isDk ? '#888' : '#666';
    ctx.font = '14px sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText('No data — draw rings first', W / 2, H / 2);
    return;
  }
  
  // Create histogram
  const hist = new Array(bins).fill(0);
  const binWidth = 1 / bins;
  ratios.forEach(r => {
    const idx = Math.min(bins - 1, Math.floor(r / binWidth));
    hist[idx]++;
  });
  
  const maxCount = Math.max(...hist);
  
  // Clear
  ctx.fillStyle = isDk ? '#0a0e27' : '#f5f7fa';
  ctx.fillRect(0, 0, W, H);
  
  // Draw bars
  const barW = plotW / bins;
  hist.forEach((count, i) => {
    if (count === 0) return;
    const h = logScale ? 
      (Math.log(count + 1) / Math.log(maxCount + 1)) * plotH :
      (count / maxCount) * plotH;
    const x = margin.left + i * barW;
    const y = margin.top + plotH - h;
    
    // Color by position (hue cycle)
    const ratio = (i + 0.5) / bins;
    ctx.fillStyle = `hsl(${ratio * 270}, 70%, ${isDk ? 55 : 45}%)`;
    ctx.fillRect(x, y, barW - 1, h);
  });
  
  // Mark peaks (simple ratios)
  if (showPeaks) {
    const simpleRatios = [
      { p: 1, q: 2, name: '1/2' },
      { p: 1, q: 3, name: '1/3' },
      { p: 2, q: 3, name: '2/3' },
      { p: 1, q: 4, name: '1/4' },
      { p: 3, q: 4, name: '3/4' },
      { p: 1, q: 5, name: '1/5' },
      { p: 2, q: 5, name: '2/5' },
      { p: 3, q: 5, name: '3/5' },
      { p: 4, q: 5, name: '4/5' }
    ];
    
    ctx.strokeStyle = '#ffd700';
    ctx.fillStyle = '#ffd700';
    ctx.lineWidth = 1;
    ctx.font = '9px sans-serif';
    ctx.textAlign = 'center';
    
    simpleRatios.forEach(sr => {
      const ratio = sr.p / sr.q;
      const x = margin.left + ratio * plotW;
      ctx.beginPath();
      ctx.setLineDash([3, 3]);
      ctx.moveTo(x, margin.top);
      ctx.lineTo(x, margin.top + plotH);
      ctx.stroke();
      ctx.setLineDash([]);
      ctx.fillText(sr.name, x, margin.top - 5);
    });
  }
  
  // Axes
  ctx.strokeStyle = isDk ? '#888' : '#333';
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(margin.left, margin.top);
  ctx.lineTo(margin.left, margin.top + plotH);
  ctx.lineTo(margin.left + plotW, margin.top + plotH);
  ctx.stroke();
  
  // Labels
  ctx.fillStyle = isDk ? '#aaa' : '#333';
  ctx.font = '12px sans-serif';
  ctx.textAlign = 'center';
  ctx.fillText('Ratio (r/M)', margin.left + plotW / 2, H - 5);
  ctx.save();
  ctx.translate(15, margin.top + plotH / 2);
  ctx.rotate(-Math.PI / 2);
  ctx.fillText('Count', 0, 0);
  ctx.restore();
  
  // Tick labels
  ctx.font = '10px sans-serif';
  ctx.fillText('0', margin.left, margin.top + plotH + 12);
  ctx.fillText('1', margin.left + plotW, margin.top + plotH + 12);
  ctx.textAlign = 'right';
  ctx.fillText('0', margin.left - 5, margin.top + plotH);
  ctx.fillText(logScale ? 'log' : maxCount.toString(), margin.left - 5, margin.top + 10);
  
  // Stats
  const stats = document.getElementById('freqDistStats');
  if (stats) stats.textContent = `Points: ${ratios.length} | Bins: ${bins} | Max count: ${maxCount}`;
}

async function screenshotFreqDist() {
  const c = document.getElementById('cFreqDist');
  if (!c) return;
  
  const scale = 2;
  const out = document.createElement('canvas');
  out.width = c.width * scale;
  out.height = c.height * scale + 60;
  const ctx = out.getContext('2d');
  
  const isDk = isDark();
  ctx.fillStyle = isDk ? '#0d1117' : '#fff';
  ctx.fillRect(0, 0, out.width, out.height);
  
  ctx.fillStyle = isDk ? '#9664ff' : '#6644cc';
  ctx.font = `bold ${16 * scale}px sans-serif`;
  ctx.textAlign = 'center';
  ctx.fillText('Frequency Ratio Distribution', out.width / 2, 25 * scale);
  
  ctx.drawImage(c, 0, 40 * scale, c.width * scale, c.height * scale);
  
  out.toBlob(b => {
    const a = document.createElement('a');
    a.href = URL.createObjectURL(b);
    a.download = 'freq_distribution.png';
    a.click();
  });
}

function clearTreePath(){
  window.enhSBHighlightPath=[];
  window.enhSBSelectedNode=null;
  const pathEl=document.getElementById('enhTreePath');
  if(pathEl)pathEl.style.display='none';
  const bounds=window.enhSBTreeBounds;
  if(bounds)drawSternBrocotTree(bounds.fromN,bounds.toN);
}

// Tree play controls
let treePlayInterval = null;
let treePlayIndex = 0;

function playTreePath() {
  stopTreePlay();
  
  const path = window.enhSBHighlightPath || [];
  if (path.length === 0) {
    const pathEl = document.getElementById('enhTreePath');
    if (pathEl) {
      pathEl.style.display = 'block';
      pathEl.innerHTML = '<span style="color:#ff6496">No path selected. Click a point on the main canvas first.</span>';
    }
    return;
  }
  
  treePlayIndex = 0;
  const pathEl = document.getElementById('enhTreePath');
  
  function playNext() {
    if (treePlayIndex >= path.length) {
      stopTreePlay();
      return;
    }
    
    const node = path[treePlayIndex];
    if (typeof playEnhFreq === 'function') {
      playEnhFreq(node.p, node.q);
    }
    
    // Update display
    if (pathEl) {
      pathEl.style.display = 'block';
      pathEl.innerHTML = `Playing path: <strong style="color:#ffd700">${node.p}/${node.q}</strong> [${treePlayIndex + 1}/${path.length}]`;
    }
    
    treePlayIndex++;
  }
  
  playNext();
  treePlayInterval = setInterval(playNext, 200);
}

function playTreeAll(direction) {
  stopTreePlay();
  
  const nodes = window.enhSBTreeNodes || [];
  if (nodes.length === 0) return;
  
  // Sort by x position (left to right or right to left)
  let sorted = [...nodes].sort((a, b) => direction === 'ltr' ? a.x - b.x : b.x - a.x);
  
  // Limit to reasonable number
  if (sorted.length > 100) sorted = sorted.slice(0, 100);
  
  treePlayIndex = 0;
  const pathEl = document.getElementById('enhTreePath');
  
  function playNext() {
    if (treePlayIndex >= sorted.length) {
      stopTreePlay();
      return;
    }
    
    const node = sorted[treePlayIndex];
    if (typeof playEnhFreq === 'function') {
      playEnhFreq(node.p, node.q);
    }
    
    // Temporarily highlight this node
    window.enhSBHighlightPath = [{ p: node.p, q: node.q }];
    const bounds = window.enhSBTreeBounds;
    if (bounds) drawSternBrocotTree(bounds.fromN, bounds.toN);
    
    if (pathEl) {
      pathEl.style.display = 'block';
      pathEl.innerHTML = `Playing ${direction === 'ltr' ? 'L→R' : 'R→L'}: <strong style="color:#ffd700">${node.p}/${node.q}</strong> [${treePlayIndex + 1}/${sorted.length}]`;
    }
    
    treePlayIndex++;
  }
  
  playNext();
  treePlayInterval = setInterval(playNext, 150);
}

function stopTreePlay() {
  if (treePlayInterval) {
    clearInterval(treePlayInterval);
    treePlayInterval = null;
  }
  treePlayIndex = 0;
}

// Screenshot just the tree
async function screenshotSternBrocotTree(){
  try {
  const c=document.getElementById('cSternBrocot');
  if(!c){ alert('Tree canvas not found'); return; }
  
  const scale=2;
  const padding=30*scale;
  const isDk = isDark();
  const lblFmt=document.getElementById('enhTreeLblFmt')?.value||'fraction';
  const fmtNode=(p,q)=>{
    switch(lblFmt){
      case 'decimal': return (p/q).toFixed(3);
      case 'angle': return ((p/q)*360).toFixed(1)+'°';
      default: return `${p}/${q}`;
    }
  };
  
  // Get tree stats, path, and Farey info
  const treeStatsEl=document.getElementById('enhTreeStats');
  const treePathEl=document.getElementById('enhTreePath');
  const fareyEl=document.getElementById('enhFareyNeighbors');
  
  const treeStatsText = treeStatsEl?.innerText?.trim() || '';
  const treePathText = treePathEl && treePathEl.style.display !== 'none' ? treePathEl.innerText?.trim() : '';
  const fareyLines = fareyEl?.innerText ? fareyEl.innerText.split('\n').filter(l => l.trim()).slice(0, 6) : [];
  
  // Calculate extra height needed for text
  let extraH = 80 * scale; // base for stats
  if(treePathText) extraH += Math.ceil(treePathText.length / 70) * 14 * scale;
  if(fareyLines.length > 0) extraH += (fareyLines.length + 1) * 12 * scale + 20 * scale;
  
  const outCanvas=document.createElement('canvas');
  outCanvas.width=c.width*scale+padding*2;
  outCanvas.height=c.height*scale+padding*2+extraH;
  const ctx=outCanvas.getContext('2d');
  
  ctx.fillStyle = isDk ? '#0a0e27' : '#fff';
  ctx.fillRect(0,0,outCanvas.width,outCanvas.height);
  
  // Title
  const bounds=window.enhSBTreeBounds||{fromN:3,toN:2};
  ctx.fillStyle='#ffd700';
  ctx.font=`bold ${18*scale}px Segoe UI`;
  ctx.textAlign='center';
  ctx.fillText(`Stern-Brocot Tree: Sector ${fmtNode(1,bounds.fromN)} → ${fmtNode(1,bounds.toN)}`,outCanvas.width/2,padding);
  
  // Canvas
  ctx.drawImage(c,padding,padding+20*scale,c.width*scale,c.height*scale);
  
  let y = padding + 20*scale + c.height*scale + 20*scale;
  
  // Stats line
  if(treeStatsText) {
    ctx.fillStyle = isDk ? '#9664ff' : '#6633cc';
    ctx.font=`bold ${11*scale}px Segoe UI`;
    ctx.textAlign='center';
    ctx.fillText(treeStatsText, outCanvas.width/2, y);
    y += 18*scale;
  }
  
  // Path with word wrap
  if(treePathText){
    ctx.fillStyle='#00ff88';
    ctx.font=`${10*scale}px Segoe UI`;
    ctx.textAlign='left';
    // Word wrap
    const maxW = outCanvas.width - padding*2;
    const words = treePathText.split(' ');
    let line = '';
    words.forEach(w => {
      const test = line + (line ? ' ' : '') + w;
      if(ctx.measureText(test).width > maxW && line) {
        ctx.fillText(line, padding, y);
        y += 14*scale;
        line = w;
      } else {
        line = test;
      }
    });
    if(line) { ctx.fillText(line, padding, y); y += 18*scale; }
  }
  
  // Farey Neighbors
  if(fareyLines.length > 0) {
    ctx.fillStyle = '#ffd700';
    ctx.font=`bold ${10*scale}px Segoe UI`;
    ctx.textAlign='left';
    ctx.fillText('FAREY NEIGHBORS', padding, y);
    y += 14*scale;
    
    ctx.font=`${9*scale}px Segoe UI`;
    fareyLines.forEach(line => {
      if(line.includes('Sequence')) ctx.fillStyle = '#00d9ff';
      else if(line.includes('pairs') || line.includes('fractions')) ctx.fillStyle = '#00ff88';
      else ctx.fillStyle = isDk ? '#aaa' : '#555';
      
      // Truncate long lines
      if(ctx.measureText(line).width > outCanvas.width - padding*2) {
        line = line.substring(0, 80) + '...';
      }
      ctx.fillText(line, padding, y);
      y += 12*scale;
    });
  }
  
  // Attribution
  ctx.fillStyle='#666';
  ctx.font=`${10*scale}px Segoe UI`;
  ctx.textAlign='right';
  ctx.fillText('@7dview',outCanvas.width-padding,outCanvas.height-10*scale);
  
  outCanvas.toBlob(blob=>{
    if(!blob) { alert('Failed to create blob'); return; }
    const url=URL.createObjectURL(blob);
    const a=document.createElement('a');
    a.href=url;
    a.download=`stern_brocot_tree_${bounds.fromN}_${bounds.toN}.png`;
    a.click();
    URL.revokeObjectURL(url);
  },'image/png');
  } catch(err) { console.error('Tree screenshot error:', err); alert('Tree screenshot failed: ' + err.message); }
}

function csvEnhanced(){
let csv='modulus,residue,angle_deg,is_coprime,gcd,phi_M\n';
enhRingsData.forEach(ring=>{
const phi=ring.coprimes.length;
for(let r=0;r<ring.mod;r++){
const g=gcd(r,ring.mod);
csv+=`${ring.mod},${r},${(360*r/ring.mod).toFixed(2)},${g===1},${g},${phi}\n`;
}});
dl(csv,'enhanced_rings.csv');
}

// ===== TRAJECTORY COHERENCE ANALYSIS =====
let trajCache = {};
let trajData = [];
let trajSortColumn = 'drift';
let trajSortAsc = true;

// Core metric functions
function computeDrift(r, M) {
  const key = `drift_${r}_${M}`;
  if (trajCache[key] !== undefined) return trajCache[key];
  
  let phases = [];
  for (let m = 2; m <= M; m++) {
    const residue_mod_m = r % m;
    if (gcd(residue_mod_m, m) === 1) {
      let phi = ((r / m) % 1.0 + 1.0) % 1.0;
      phases.push(phi);
    }
  }
  
  let drift = 0;
  for (let i = 0; i < phases.length - 1; i++) {
    let diff = Math.abs(phases[i+1] - phases[i]);
    diff = Math.min(diff, 1.0 - diff); // Wraparound
    drift += diff;
  }
  
  trajCache[key] = drift;
  return drift;
}

function computeVariance(r, M) {
  const key = `var_${r}_${M}`;
  if (trajCache[key] !== undefined) return trajCache[key];
  
  let phases = [];
  for (let m = 2; m <= M; m++) {
    if (gcd(r % m, m) === 1) {
      let phi = ((r / m) % 1.0 + 1.0) % 1.0;
      phases.push(phi);
    }
  }
  
  if (phases.length === 0) { trajCache[key] = 0; return 0; }
  
  const mean = phases.reduce((a, b) => a + b) / phases.length;
  const variance = phases.reduce((sum, p) => sum + Math.pow(p - mean, 2), 0) / phases.length;
  
  trajCache[key] = variance;
  return variance;
}

function computeSurvival(r, M) {
  const key = `surv_${r}_${M}`;
  if (trajCache[key] !== undefined) return trajCache[key];
  
  let count = 0;
  for (let m = 2; m <= M; m++) {
    if (gcd(r % m, m) === 1) count++;
  }
  
  trajCache[key] = count;
  return count;
}

function computeMeanPhase(r, M) {
  const key = `mean_${r}_${M}`;
  if (trajCache[key] !== undefined) return trajCache[key];
  
  let phases = [];
  for (let m = 2; m <= M; m++) {
    if (gcd(r % m, m) === 1) {
      let phi = ((r / m) % 1.0 + 1.0) % 1.0;
      phases.push(phi);
    }
  }
  
  if (phases.length === 0) { trajCache[key] = 0; return 0; }
  const mean = phases.reduce((a, b) => a + b) / phases.length;
  
  trajCache[key] = mean;
  return mean;
}

function getPhaseTrajectory(r, M) {
  let trajectory = [];
  for (let m = 2; m <= M; m++) {
    if (gcd(r % m, m) === 1) {
      let phi = ((r / m) % 1.0 + 1.0) % 1.0;
      trajectory.push({ m, phi, angle: phi * 360 });
    }
  }
  return trajectory;
}

function classifyResidue(drift) {
  if (drift < 0.3) return "shell_core";
  if (drift < 1.0) return "shell_halo";
  if (drift < 3.0) return "shell_periphery";
  return "dispersed";
}

function getResidueType(r) {
  if (isPrime(r)) return "prime";
  if (isPrime(r + 1)) return "prime_minus_one";
  if (isPrime(r - 1)) return "prime_plus_one";
  return "other";
}

function getDriftColor(drift, maxDrift) {
  const norm = drift / maxDrift;
  if (norm < 0.1) return '#0a7e8c';
  if (norm < 0.2) return '#10a3a8';
  if (norm < 0.35) return '#3fbfcc';
  if (norm < 0.5) return '#6dd3d3';
  if (norm < 0.7) return '#e8d94d';
  return '#ff6b35';
}

function computeAllTrajectoryData() {
  const M = +document.getElementById('enhMax')?.value || 30;
  const maxR = +document.getElementById('trajMaxR')?.value || 200;
  
  trajData = [];
  for (let r = 1; r <= maxR; r++) {
    const drift = computeDrift(r, M);
    const variance = computeVariance(r, M);
    const survival = computeSurvival(r, M);
    const meanPhase = computeMeanPhase(r, M);
    const type = getResidueType(r);
    const classification = classifyResidue(drift);
    
    trajData.push({ r, drift, variance, survival, meanPhase, type, classification, M });
  }
  
  return trajData;
}

function computeTrajectoryStats() {
  const data = computeAllTrajectoryData();
  if (data.length === 0) return;
  
  const M = data[0].M;
  
  // Separate by type
  const primes = data.filter(d => d.type === 'prime');
  const pm1 = data.filter(d => d.type === 'prime_minus_one');
  const others = data.filter(d => d.type === 'other');
  
  const mean = arr => arr.length > 0 ? arr.reduce((a,b) => a + b, 0) / arr.length : 0;
  const std = arr => {
    if (arr.length < 2) return 0;
    const m = mean(arr);
    return Math.sqrt(arr.reduce((s, x) => s + Math.pow(x - m, 2), 0) / arr.length);
  };
  const median = arr => {
    if (arr.length === 0) return 0;
    const sorted = [...arr].sort((a,b) => a - b);
    const mid = Math.floor(sorted.length / 2);
    return sorted.length % 2 ? sorted[mid] : (sorted[mid-1] + sorted[mid]) / 2;
  };
  
  const primeDrifts = primes.map(d => d.drift);
  const pm1Drifts = pm1.map(d => d.drift);
  const allDrifts = data.map(d => d.drift);
  
  // T-test calculation
  function tTest(a, b) {
    if (a.length < 2 || b.length < 2) return { t: 0, p: 1 };
    const m1 = mean(a), m2 = mean(b);
    const s1 = std(a), s2 = std(b);
    const se = Math.sqrt(s1*s1/a.length + s2*s2/b.length);
    if (se === 0) return { t: 0, p: 1 };
    const t = (m1 - m2) / se;
    // Approximate p-value using normal distribution
    const p = 2 * (1 - normalCDF(Math.abs(t)));
    return { t, p };
  }
  
  function normalCDF(x) {
    const a1 = 0.254829592, a2 = -0.284496736, a3 = 1.421413741;
    const a4 = -1.453152027, a5 = 1.061405429, p = 0.3275911;
    const sign = x < 0 ? -1 : 1;
    x = Math.abs(x) / Math.sqrt(2);
    const t = 1.0 / (1.0 + p * x);
    const y = 1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*Math.exp(-x*x);
    return 0.5 * (1.0 + sign * y);
  }
  
  const tTestPM1vsPrime = tTest(pm1Drifts, primeDrifts);
  const tTestPM1vsOther = tTest(pm1Drifts, others.map(d => d.drift));
  
  // Classification counts
  const classes = { shell_core: 0, shell_halo: 0, shell_periphery: 0, dispersed: 0 };
  data.forEach(d => classes[d.classification]++);
  
  // Percentiles
  const sortedDrifts = [...allDrifts].sort((a,b) => a - b);
  const p25 = sortedDrifts[Math.floor(sortedDrifts.length * 0.25)];
  const p75 = sortedDrifts[Math.floor(sortedDrifts.length * 0.75)];
  
  // Update stats panel
  const statsDiv = document.getElementById('trajCoherenceStats');
  statsDiv.innerHTML = `
    <div style="margin-bottom:12px;padding:8px;background:rgba(0,217,255,.1);border-radius:6px;border-left:3px solid #00d9ff">
      <strong style="color:#00d9ff">Analysis Parameters</strong><br>
      <span style="color:var(--txt2)">Max Modulus M = ${M} | Residues r ∈ [1, ${data.length}]</span>
    </div>
    
    <div style="margin-bottom:12px;padding:8px;background:rgba(255,215,0,.1);border-radius:6px;border-left:3px solid #ffd700">
      <strong style="color:#ffd700">Drift Statistics by Type</strong>
      <table style="width:100%;font-size:.75rem;margin-top:6px;border-collapse:collapse">
        <tr style="border-bottom:1px solid var(--bord)">
          <th style="text-align:left;padding:3px">Type</th>
          <th style="text-align:right;padding:3px">Count</th>
          <th style="text-align:right;padding:3px">Mean D(r)</th>
          <th style="text-align:right;padding:3px">Median</th>
          <th style="text-align:right;padding:3px">Std</th>
        </tr>
        <tr><td style="padding:3px;color:#ff6496">Primes (p)</td><td style="text-align:right">${primes.length}</td><td style="text-align:right">${mean(primeDrifts).toFixed(2)}</td><td style="text-align:right">${median(primeDrifts).toFixed(2)}</td><td style="text-align:right">${std(primeDrifts).toFixed(2)}</td></tr>
        <tr style="background:rgba(0,255,136,.1)"><td style="padding:3px;color:#00ff88;font-weight:bold">p-1</td><td style="text-align:right;font-weight:bold">${pm1.length}</td><td style="text-align:right;font-weight:bold">${mean(pm1Drifts).toFixed(2)}</td><td style="text-align:right;font-weight:bold">${median(pm1Drifts).toFixed(2)}</td><td style="text-align:right">${std(pm1Drifts).toFixed(2)}</td></tr>
        <tr><td style="padding:3px">Other</td><td style="text-align:right">${others.length}</td><td style="text-align:right">${mean(others.map(d=>d.drift)).toFixed(2)}</td><td style="text-align:right">${median(others.map(d=>d.drift)).toFixed(2)}</td><td style="text-align:right">${std(others.map(d=>d.drift)).toFixed(2)}</td></tr>
      </table>
    </div>
    
    <div style="margin-bottom:12px;padding:8px;background:rgba(0,255,136,.1);border-radius:6px;border-left:3px solid #00ff88">
      <strong style="color:#00ff88">Statistical Significance</strong><br>
      <div style="font-size:.75rem;margin-top:4px">
        <div>(p-1) vs Primes: <strong>t = ${tTestPM1vsPrime.t.toFixed(3)}</strong>, p = ${tTestPM1vsPrime.p < 0.001 ? '<0.001 ' : tTestPM1vsPrime.p.toFixed(4)}</div>
        <div>(p-1) vs Other: <strong>t = ${tTestPM1vsOther.t.toFixed(3)}</strong>, p = ${tTestPM1vsOther.p < 0.001 ? '<0.001 ' : tTestPM1vsOther.p.toFixed(4)}</div>
        <div style="margin-top:4px;color:#ffd700">Enrichment: Primes/p-1 = <strong>${(mean(primeDrifts)/mean(pm1Drifts)).toFixed(2)}x</strong></div>
      </div>
    </div>
    
    <div style="margin-bottom:12px;padding:8px;background:rgba(150,100,255,.1);border-radius:6px;border-left:3px solid #9664ff">
      <strong style="color:#9664ff">Percentile Distribution</strong>
      <div style="font-size:.75rem;margin-top:4px;font-family:monospace">
        Min: ${Math.min(...allDrifts).toFixed(2)} | 25%: ${p25.toFixed(2)} | Median: ${median(allDrifts).toFixed(2)} | 75%: ${p75.toFixed(2)} | Max: ${Math.max(...allDrifts).toFixed(2)}
      </div>
    </div>
    
    <div style="padding:8px;background:rgba(255,100,150,.1);border-radius:6px;border-left:3px solid #ff6496">
      <strong style="color:#ff6496">Shell Classification</strong>
      <div style="display:grid;grid-template-columns:1fr 1fr;gap:4px;font-size:.75rem;margin-top:4px">
        <div>Core (D<0.3): <strong style="color:#0a7e8c">${classes.shell_core}</strong></div>
        <div>Halo (0.3-1): <strong style="color:#10a3a8">${classes.shell_halo}</strong></div>
        <div>Periphery (1-3): <strong style="color:#6dd3d3">${classes.shell_periphery}</strong></div>
        <div>Dispersed (>3): <strong style="color:#ff6b35">${classes.dispersed}</strong></div>
      </div>
    </div>
  `;
  
  // Update twin shell comparison
  updateTwinShellPanel(primes, pm1, tTestPM1vsPrime, mean, std);
  
  // Draw histogram
  drawTrajectoryHistogram(allDrifts, primeDrifts, pm1Drifts);
  
  // Update data table
  updateTrajectoryTable();
  
  // Draw main coherence plot
  drawTrajectoryCoherencePlot();
}

function updateTwinShellPanel(primes, pm1, tTest, mean, std) {
  const div = document.getElementById('trajTwinShell');
  const primeDrifts = primes.map(d => d.drift);
  const pm1Drifts = pm1.map(d => d.drift);
  
  div.innerHTML = `
    <div style="text-align:center;padding:10px;background:var(--bg1);border-radius:6px;margin-bottom:10px;border:2px solid ${tTest.p < 0.001 ? '#00ff88' : '#ffd700'}">
      <div style="font-size:1.2rem;color:${tTest.p < 0.001 ? '#00ff88' : '#ffd700'};font-weight:bold">
        ${tTest.p < 0.001 ? ' SIGNIFICANT' : tTest.p < 0.05 ? ' Significant' : ' Not Significant'}
      </div>
      <div style="font-size:.8rem;color:var(--txt2)">p-value ${tTest.p < 0.001 ? '< 0.001' : '= ' + tTest.p.toFixed(4)}</div>
    </div>
    
    <table style="width:100%;border-collapse:collapse;font-size:.8rem">
      <tr style="border-bottom:2px solid var(--bord)">
        <th style="text-align:left;padding:6px">Metric</th>
        <th style="text-align:right;padding:6px;color:#ff6496">Primes (p)</th>
        <th style="text-align:right;padding:6px;color:#00ff88">p-1</th>
        <th style="text-align:right;padding:6px;color:#ffd700">Ratio</th>
      </tr>
      <tr><td style="padding:4px">Mean Drift</td><td style="text-align:right">${mean(primeDrifts).toFixed(2)}</td><td style="text-align:right;font-weight:bold">${mean(pm1Drifts).toFixed(2)}</td><td style="text-align:right;color:#ffd700">${(mean(primeDrifts)/mean(pm1Drifts)).toFixed(2)}x</td></tr>
      <tr style="background:var(--bg1)"><td style="padding:4px">Std Dev</td><td style="text-align:right">${std(primeDrifts).toFixed(2)}</td><td style="text-align:right">${std(pm1Drifts).toFixed(2)}</td><td></td></tr>
      <tr><td style="padding:4px">Min Drift</td><td style="text-align:right">${Math.min(...primeDrifts).toFixed(2)}</td><td style="text-align:right">${Math.min(...pm1Drifts).toFixed(2)}</td><td></td></tr>
      <tr style="background:var(--bg1)"><td style="padding:4px">Max Drift</td><td style="text-align:right">${Math.max(...primeDrifts).toFixed(2)}</td><td style="text-align:right">${Math.max(...pm1Drifts).toFixed(2)}</td><td></td></tr>
    </table>
    
    <div style="margin-top:10px;padding:8px;background:rgba(0,217,255,.1);border-radius:6px;font-size:.75rem">
      <strong style="color:#00d9ff">Interpretation:</strong><br>
      Residues r = p-1 (where p is prime) exhibit ${(mean(primeDrifts)/mean(pm1Drifts)).toFixed(2)}x LESS trajectory drift than primes themselves. This forms the "twin-prime shell" structure.
    </div>
  `;
}

function drawTrajectoryHistogram(allDrifts, primeDrifts, pm1Drifts) {
  const c = document.getElementById('cTrajHistogram');
  if (!c) return;
  const ctx = c.getContext('2d');
  ctx.fillStyle = canvBg();
  ctx.fillRect(0, 0, c.width, c.height);
  
  const margin = { t: 30, r: 20, b: 40, l: 50 };
  const w = c.width - margin.l - margin.r;
  const h = c.height - margin.t - margin.b;
  
  // Bin the data
  const bins = [0, 1, 2, 3, 5, 10, 20, 50];
  const counts = new Array(bins.length).fill(0);
  const primeCounts = new Array(bins.length).fill(0);
  const pm1Counts = new Array(bins.length).fill(0);
  
  allDrifts.forEach(d => {
    for (let i = 0; i < bins.length - 1; i++) {
      if (d >= bins[i] && d < bins[i+1]) { counts[i]++; break; }
    }
    if (d >= bins[bins.length-1]) counts[bins.length-1]++;
  });
  
  primeDrifts.forEach(d => {
    for (let i = 0; i < bins.length - 1; i++) {
      if (d >= bins[i] && d < bins[i+1]) { primeCounts[i]++; break; }
    }
    if (d >= bins[bins.length-1]) primeCounts[bins.length-1]++;
  });
  
  pm1Drifts.forEach(d => {
    for (let i = 0; i < bins.length - 1; i++) {
      if (d >= bins[i] && d < bins[i+1]) { pm1Counts[i]++; break; }
    }
    if (d >= bins[bins.length-1]) pm1Counts[bins.length-1]++;
  });
  
  const maxCount = Math.max(...counts, 1);
  const barW = w / bins.length;
  
  // Draw bars
  for (let i = 0; i < bins.length; i++) {
    const x = margin.l + i * barW;
    const barH = (counts[i] / maxCount) * h;
    
    // Main bar
    ctx.fillStyle = 'rgba(100, 150, 255, 0.6)';
    ctx.fillRect(x + 2, margin.t + h - barH, barW - 4, barH);
    
    // Overlay for primes
    const primeH = (primeCounts[i] / maxCount) * h;
    ctx.fillStyle = 'rgba(255, 100, 150, 0.7)';
    ctx.fillRect(x + 2, margin.t + h - primeH, (barW - 4) / 2, primeH);
    
    // Overlay for p-1
    const pm1H = (pm1Counts[i] / maxCount) * h;
    ctx.fillStyle = 'rgba(0, 255, 136, 0.7)';
    ctx.fillRect(x + (barW - 4) / 2 + 2, margin.t + h - pm1H, (barW - 4) / 2, pm1H);
    
    // Labels
    ctx.fillStyle = isDark() ? '#fff' : '#000';
    ctx.font = '9px Segoe UI';
    ctx.textAlign = 'center';
    const label = i < bins.length - 1 ? `${bins[i]}-${bins[i+1]}` : `${bins[i]}+`;
    ctx.fillText(label, x + barW / 2, c.height - margin.b + 15);
    
    if (counts[i] > 0) {
      ctx.fillText(counts[i], x + barW / 2, margin.t + h - barH - 5);
    }
  }
  
  // Axes
  ctx.strokeStyle = gridC();
  ctx.beginPath();
  ctx.moveTo(margin.l, margin.t);
  ctx.lineTo(margin.l, margin.t + h);
  ctx.lineTo(margin.l + w, margin.t + h);
  ctx.stroke();
  
  // Title
  ctx.fillStyle = isDark() ? '#ff6496' : '#cc4466';
  ctx.font = 'bold 11px Segoe UI';
  ctx.textAlign = 'center';
  ctx.fillText('Drift Distribution: All (blue) | Primes (pink) | p-1 (green)', c.width / 2, 15);
  
  // Y-axis label
  ctx.save();
  ctx.translate(12, margin.t + h / 2);
  ctx.rotate(-Math.PI / 2);
  ctx.fillStyle = isDark() ? '#fff' : '#000';
  ctx.font = '10px Segoe UI';
  ctx.fillText('Count', 0, 0);
  ctx.restore();
}

// Draw trajectory coherence on Enhanced Modular main canvas
function drawEnhancedTrajectory(ctx, c, moduli) {
  const M = Math.max(...moduli, 30);
  const maxR = +document.getElementById('trajMaxR')?.value || 200;
  
  // Compute data if needed
  if (trajData.length === 0 || trajData[0]?.M !== M) {
    trajData = [];
    for (let r = 1; r <= maxR; r++) {
      const drift = computeDrift(r, M);
      const variance = computeVariance(r, M);
      const survival = computeSurvival(r, M);
      const meanPhase = computeMeanPhase(r, M);
      const type = getResidueType(r);
      const classification = classifyResidue(drift);
      trajData.push({ r, drift, variance, survival, meanPhase, type, classification, M });
    }
  }
  
  if (trajData.length === 0) {
    ctx.fillStyle = 'rgba(255,255,255,0.5)';
    ctx.font = '18px Segoe UI';
    ctx.textAlign = 'center';
    ctx.fillText('Click "Compute Stats" to analyze trajectories', c.width / 2, c.height / 2);
    return;
  }
  
  const colorBy = document.getElementById('trajColorBy')?.value || 'drift';
  const sizeBy = document.getElementById('trajSizeBy')?.value || 'survival';
  const highlightPM1 = document.getElementById('trajHighlightPM1')?.checked ?? true;
  const highlightPrimes = document.getElementById('trajHighlightPrimes')?.checked;
  const showTop20 = document.getElementById('trajShowTop20')?.checked ?? true;
  const showLabels = document.getElementById('trajShowLabels')?.checked;
  const filterType = document.getElementById('trajFilterType')?.value || 'all';
  const driftMin = +document.getElementById('trajDriftMin')?.value || 0;
  const driftMax = +document.getElementById('trajDriftMax')?.value || 50;
  
  const cx = c.width / 2, cy = c.height / 2;
  const maxRad = Math.min(cx, cy) - 60;
  
  // Filter data
  let filtered = trajData.filter(d => d.drift >= driftMin && d.drift <= driftMax);
  if (filterType === 'primes') filtered = filtered.filter(d => d.type === 'prime');
  else if (filterType === 'pm1') filtered = filtered.filter(d => d.type === 'prime_minus_one');
  else if (filterType === 'pp1') filtered = filtered.filter(d => d.type === 'prime_plus_one');
  else if (filterType === 'other') filtered = filtered.filter(d => d.type === 'other');
  
  const maxDrift = Math.max(...trajData.map(d => d.drift), 1);
  const maxSurvival = Math.max(...trajData.map(d => d.survival), 1);
  
  const sortedByDrift = [...trajData].sort((a, b) => a.drift - b.drift);
  const top20 = new Set(sortedByDrift.slice(0, 20).map(d => d.r));
  
  // Draw polar grid
  ctx.strokeStyle = 'rgba(255,255,255,0.15)';
  ctx.lineWidth = 1;
  for (let i = 1; i <= 5; i++) {
    ctx.beginPath();
    ctx.arc(cx, cy, maxRad * i / 5, 0, 2 * Math.PI);
    ctx.stroke();
  }
  for (let i = 0; i < 12; i++) {
    const angle = (i / 12) * 2 * Math.PI;
    ctx.beginPath();
    ctx.moveTo(cx, cy);
    ctx.lineTo(cx + maxRad * Math.cos(angle), cy + maxRad * Math.sin(angle));
    ctx.stroke();
  }
  
  // Drift labels on grid
  ctx.fillStyle = 'rgba(255,255,255,0.4)';
  ctx.font = '10px Segoe UI';
  ctx.textAlign = 'left';
  for (let i = 1; i <= 5; i++) {
    const dVal = maxDrift * (1 - i / 5);
    ctx.fillText(`D≈${dVal.toFixed(0)}`, cx + maxRad * i / 5 + 5, cy - 5);
  }
  
  // Sort for layering (highlighted on top)
  const sortedFiltered = [...filtered].sort((a, b) => {
    const aH = (highlightPM1 && a.type === 'prime_minus_one') || (highlightPrimes && a.type === 'prime');
    const bH = (highlightPM1 && b.type === 'prime_minus_one') || (highlightPrimes && b.type === 'prime');
    return aH - bH;
  });
  
  // Draw points
  sortedFiltered.forEach(d => {
    const angle = d.meanPhase * 2 * Math.PI;
    const radius = maxRad * (1 - Math.min(d.drift / maxDrift, 0.95));
    const px = cx + radius * Math.cos(angle);
    const py = cy + radius * Math.sin(angle);
    
    // Size
    let ptSize;
    if (sizeBy === 'survival') ptSize = 3 + 6 * (d.survival / maxSurvival);
    else if (sizeBy === 'drift') ptSize = 3 + 6 * (1 - d.drift / maxDrift);
    else ptSize = 5;
    
    // Color
    let clr;
    if (colorBy === 'drift') clr = getDriftColor(d.drift, maxDrift);
    else if (colorBy === 'variance') clr = `hsl(${(1 - d.variance / 0.1) * 200}, 70%, 55%)`;
    else if (colorBy === 'survival') clr = `hsl(${(d.survival / maxSurvival) * 120}, 70%, 55%)`;
    else if (colorBy === 'meanphase') clr = `hsl(${d.meanPhase * 360}, 70%, 55%)`;
    else if (colorBy === 'type') {
      if (d.type === 'prime') clr = '#ff6496';
      else if (d.type === 'prime_minus_one') clr = '#00ffff';
      else if (d.type === 'prime_plus_one') clr = '#ffff00';
      else clr = '#888';
    }
    else if (colorBy === 'classification') {
      if (d.classification === 'shell_core') clr = '#0a7e8c';
      else if (d.classification === 'shell_halo') clr = '#10a3a8';
      else if (d.classification === 'shell_periphery') clr = '#6dd3d3';
      else clr = '#ff6b35';
    }
    else clr = '#00d9ff';
    
    const isPM1 = d.type === 'prime_minus_one';
    const isP = d.type === 'prime';
    const isTop = top20.has(d.r);
    
    if (highlightPM1 && isPM1) { clr = '#00ffff'; ptSize *= 1.4; }
    if (highlightPrimes && isP) { clr = '#ff6496'; }
    
    // Glow for special points
    if ((highlightPM1 && isPM1) || (showTop20 && isTop)) {
      ctx.globalAlpha = 0.35;
      ctx.fillStyle = clr;
      ctx.beginPath();
      ctx.arc(px, py, ptSize * 2.5, 0, 2 * Math.PI);
      ctx.fill();
      ctx.globalAlpha = 1;
    }
    
    // Draw point
    ctx.fillStyle = clr;
    ctx.beginPath();
    ctx.arc(px, py, ptSize, 0, 2 * Math.PI);
    ctx.fill();
    
    // Stroke
    ctx.strokeStyle = 'rgba(255,255,255,0.5)';
    ctx.lineWidth = 1;
    ctx.stroke();
    
    // Labels
    if ((showTop20 && isTop) || showLabels) {
      ctx.fillStyle = isTop ? '#ffd700' : 'rgba(255,255,255,0.8)';
      ctx.font = isTop ? 'bold 11px Segoe UI' : '9px Segoe UI';
      ctx.textAlign = 'center';
      ctx.fillText(d.r, px, py - ptSize - 5);
    }
  });
  
  // Title
  ctx.fillStyle = '#00d9ff';
  ctx.font = 'bold 14px Segoe UI';
  ctx.textAlign = 'center';
  ctx.fillText(`Trajectory Coherence: M=${M} | r ∈ [1, ${trajData.length}] | Color: ${colorBy}`, c.width / 2, 25);
  
  // Legend
  ctx.font = '11px Segoe UI';
  ctx.textAlign = 'left';
  const legendY = c.height - 50;
  ctx.fillStyle = '#00ffff'; ctx.fillText(' p-1 (low drift)', 20, legendY);
  ctx.fillStyle = '#ff6496'; ctx.fillText(' Primes', 140, legendY);
  ctx.fillStyle = '#888'; ctx.fillText(' Other', 220, legendY);
  ctx.fillStyle = '#ffd700'; ctx.fillText('Outer = Low Drift (Coherent) | Inner = High Drift (Dispersed)', 20, legendY + 18);
  
  // Stats summary in corner
  const primes = trajData.filter(d => d.type === 'prime');
  const pm1 = trajData.filter(d => d.type === 'prime_minus_one');
  const mean = arr => arr.length > 0 ? arr.reduce((a,b) => a + b, 0) / arr.length : 0;
  const primeMean = mean(primes.map(d => d.drift));
  const pm1Mean = mean(pm1.map(d => d.drift));
  const ratio = primeMean / pm1Mean;
  
  ctx.fillStyle = 'rgba(0,0,0,0.7)';
  ctx.fillRect(c.width - 200, 10, 190, 80);
  ctx.strokeStyle = '#00ff88';
  ctx.lineWidth = 2;
  ctx.strokeRect(c.width - 200, 10, 190, 80);
  
  ctx.fillStyle = '#ffd700';
  ctx.font = 'bold 11px Segoe UI';
  ctx.textAlign = 'left';
  ctx.fillText('Twin-Prime Shell', c.width - 190, 28);
  ctx.fillStyle = '#ff6496';
  ctx.font = '10px Segoe UI';
  ctx.fillText(`Primes: D̄ = ${primeMean.toFixed(2)}`, c.width - 190, 45);
  ctx.fillStyle = '#00ffff';
  ctx.fillText(`p-1: D̄ = ${pm1Mean.toFixed(2)}`, c.width - 190, 60);
  ctx.fillStyle = '#00ff88';
  ctx.font = 'bold 11px Segoe UI';
  ctx.fillText(`Ratio: ${ratio.toFixed(2)}x`, c.width - 190, 78);
  
  // Also update the secondary panels if visible
  drawTrajectoryHistogram(trajData.map(d => d.drift), primes.map(d => d.drift), pm1.map(d => d.drift));
  updateTrajectoryTable();
}

function drawTrajectoryCoherencePlot() {
  const c = document.getElementById('cTrajCoherence');
  if (!c) return;
  const ctx = c.getContext('2d');
  ctx.fillStyle = canvBg();
  ctx.fillRect(0, 0, c.width, c.height);
  
  if (trajData.length === 0) {
    ctx.fillStyle = 'rgba(255,255,255,0.5)';
    ctx.font = '16px Segoe UI';
    ctx.textAlign = 'center';
    ctx.fillText('Click "Compute Stats" to generate plot', c.width / 2, c.height / 2);
    return;
  }
  
  const colorBy = document.getElementById('trajColorBy')?.value || 'drift';
  const sizeBy = document.getElementById('trajSizeBy')?.value || 'survival';
  const highlightPM1 = document.getElementById('trajHighlightPM1')?.checked;
  const highlightPrimes = document.getElementById('trajHighlightPrimes')?.checked;
  const showTop20 = document.getElementById('trajShowTop20')?.checked;
  const showLabels = document.getElementById('trajShowLabels')?.checked;
  const filterType = document.getElementById('trajFilterType')?.value || 'all';
  const driftMin = +document.getElementById('trajDriftMin')?.value || 0;
  const driftMax = +document.getElementById('trajDriftMax')?.value || 50;
  
  const cx = c.width / 2, cy = c.height / 2;
  const maxR = Math.min(cx, cy) - 40;
  
  // Filter data
  let filtered = trajData.filter(d => d.drift >= driftMin && d.drift <= driftMax);
  if (filterType === 'primes') filtered = filtered.filter(d => d.type === 'prime');
  else if (filterType === 'pm1') filtered = filtered.filter(d => d.type === 'prime_minus_one');
  else if (filterType === 'pp1') filtered = filtered.filter(d => d.type === 'prime_plus_one');
  else if (filterType === 'other') filtered = filtered.filter(d => d.type === 'other');
  
  // Get max values for normalization
  const maxDrift = Math.max(...trajData.map(d => d.drift), 1);
  const maxSurvival = Math.max(...trajData.map(d => d.survival), 1);
  
  // Sort for top 20
  const sortedByDrift = [...trajData].sort((a, b) => a.drift - b.drift);
  const top20 = new Set(sortedByDrift.slice(0, 20).map(d => d.r));
  
  // Draw polar grid
  ctx.strokeStyle = 'rgba(255,255,255,0.1)';
  ctx.lineWidth = 1;
  for (let i = 1; i <= 4; i++) {
    ctx.beginPath();
    ctx.arc(cx, cy, maxR * i / 4, 0, 2 * Math.PI);
    ctx.stroke();
  }
  for (let i = 0; i < 12; i++) {
    const angle = (i / 12) * 2 * Math.PI;
    ctx.beginPath();
    ctx.moveTo(cx, cy);
    ctx.lineTo(cx + maxR * Math.cos(angle), cy + maxR * Math.sin(angle));
    ctx.stroke();
  }
  
  // Draw points (sorted so highlighted are on top)
  const sortedFiltered = [...filtered].sort((a, b) => {
    const aHighlight = (highlightPM1 && a.type === 'prime_minus_one') || (highlightPrimes && a.type === 'prime');
    const bHighlight = (highlightPM1 && b.type === 'prime_minus_one') || (highlightPrimes && b.type === 'prime');
    return aHighlight - bHighlight;
  });
  
  sortedFiltered.forEach(d => {
    // Position: angle from mean phase, radius from drift (low drift = outer)
    const angle = d.meanPhase * 2 * Math.PI;
    const radius = maxR * (1 - Math.min(d.drift / maxDrift, 0.95));
    const px = cx + radius * Math.cos(angle);
    const py = cy + radius * Math.sin(angle);
    
    // Size
    let ptSize;
    if (sizeBy === 'survival') ptSize = 2 + 6 * (d.survival / maxSurvival);
    else if (sizeBy === 'drift') ptSize = 2 + 6 * (1 - d.drift / maxDrift);
    else ptSize = 4;
    
    // Color
    let clr;
    if (colorBy === 'drift') clr = getDriftColor(d.drift, maxDrift);
    else if (colorBy === 'variance') clr = `hsl(${(1 - d.variance / 0.1) * 200}, 70%, 55%)`;
    else if (colorBy === 'survival') clr = `hsl(${(d.survival / maxSurvival) * 120}, 70%, 55%)`;
    else if (colorBy === 'meanphase') clr = `hsl(${d.meanPhase * 360}, 70%, 55%)`;
    else if (colorBy === 'type') {
      if (d.type === 'prime') clr = '#ff6496';
      else if (d.type === 'prime_minus_one') clr = '#00ffff';
      else if (d.type === 'prime_plus_one') clr = '#ffff00';
      else clr = '#888';
    }
    else if (colorBy === 'classification') {
      if (d.classification === 'shell_core') clr = '#0a7e8c';
      else if (d.classification === 'shell_halo') clr = '#10a3a8';
      else if (d.classification === 'shell_periphery') clr = '#6dd3d3';
      else clr = '#ff6b35';
    }
    else clr = '#00d9ff';
    
    // Override for highlights
    const isPM1 = d.type === 'prime_minus_one';
    const isP = d.type === 'prime';
    const isTop = top20.has(d.r);
    
    if (highlightPM1 && isPM1) {
      clr = '#00ffff';
      ptSize *= 1.3;
    }
    if (highlightPrimes && isP) {
      clr = '#ff6496';
    }
    
    // Draw glow for special points
    if ((highlightPM1 && isPM1) || (showTop20 && isTop)) {
      ctx.fillStyle = clr.replace(')', ', 0.3)').replace('rgb', 'rgba').replace('hsl', 'hsla');
      if (!clr.includes('rgba') && !clr.includes('hsla')) {
        ctx.globalAlpha = 0.3;
      }
      ctx.beginPath();
      ctx.arc(px, py, ptSize * 2, 0, 2 * Math.PI);
      ctx.fill();
      ctx.globalAlpha = 1;
    }
    
    // Draw point
    ctx.fillStyle = clr;
    ctx.beginPath();
    ctx.arc(px, py, ptSize, 0, 2 * Math.PI);
    ctx.fill();
    
    // Labels for top 20 or all if enabled
    if ((showTop20 && isTop) || showLabels) {
      ctx.fillStyle = isTop ? '#ffd700' : 'rgba(255,255,255,0.7)';
      ctx.font = isTop ? 'bold 9px Segoe UI' : '8px Segoe UI';
      ctx.textAlign = 'center';
      ctx.fillText(d.r, px, py - ptSize - 3);
    }
  });
  
  // Title
  ctx.fillStyle = isDark() ? '#00d9ff' : '#0088aa';
  ctx.font = 'bold 12px Segoe UI';
  ctx.textAlign = 'center';
  ctx.fillText(`Trajectory Coherence: r ∈ [1, ${trajData.length}] | Color: ${colorBy}`, c.width / 2, 15);
  
  // Legend
  ctx.font = '9px Segoe UI';
  ctx.textAlign = 'left';
  ctx.fillStyle = '#00ffff';
  ctx.fillText(' p-1', 10, c.height - 25);
  ctx.fillStyle = '#ff6496';
  ctx.fillText(' Primes', 60, c.height - 25);
  ctx.fillStyle = '#888';
  ctx.fillText(' Other', 120, c.height - 25);
  ctx.fillStyle = '#ffd700';
  ctx.fillText('Outer = Low Drift (Coherent)', 10, c.height - 10);
}

function updateTrajectoryTable() {
  const tbody = document.getElementById('trajTableBody');
  if (!tbody) return;
  
  // Sort data
  const sorted = [...trajData].sort((a, b) => {
    let va, vb;
    if (trajSortColumn === 'r') { va = a.r; vb = b.r; }
    else if (trajSortColumn === 'drift') { va = a.drift; vb = b.drift; }
    else if (trajSortColumn === 'survival') { va = a.survival; vb = b.survival; }
    else if (trajSortColumn === 'meanphase') { va = a.meanPhase; vb = b.meanPhase; }
    else if (trajSortColumn === 'type') { va = a.type; vb = b.type; }
    else if (trajSortColumn === 'class') { va = a.classification; vb = b.classification; }
    else { va = a.drift; vb = b.drift; }
    
    if (typeof va === 'string') return trajSortAsc ? va.localeCompare(vb) : vb.localeCompare(va);
    return trajSortAsc ? va - vb : vb - va;
  });
  
  const typeColors = {
    'prime': '#ff6496',
    'prime_minus_one': '#00ff88',
    'prime_plus_one': '#ffd700',
    'other': '#888'
  };
  
  tbody.innerHTML = sorted.slice(0, 100).map(d => `
    <tr style="border-bottom:1px solid rgba(255,255,255,0.1);cursor:pointer" onclick="showTrajectoryDetail(${d.r})">
      <td style="padding:3px">${d.r}</td>
      <td style="padding:3px;color:${typeColors[d.type]}">${d.type === 'prime_minus_one' ? 'p-1' : d.type === 'prime_plus_one' ? 'p+1' : d.type}</td>
      <td style="padding:3px;text-align:right">${d.drift.toFixed(2)}</td>
      <td style="padding:3px;text-align:right">${d.survival}</td>
      <td style="padding:3px;text-align:right">${d.meanPhase.toFixed(3)}</td>
      <td style="padding:3px;color:${d.classification === 'shell_core' ? '#0a7e8c' : d.classification === 'dispersed' ? '#ff6b35' : '#6dd3d3'}">${d.classification.replace('shell_', '')}</td>
    </tr>
  `).join('');
}

function sortTrajTable(col) {
  if (trajSortColumn === col) trajSortAsc = !trajSortAsc;
  else { trajSortColumn = col; trajSortAsc = true; }
  updateTrajectoryTable();
}

function showTrajectoryDetail(r) {
  const c = document.getElementById('cTrajDetail');
  if (!c) return;
  const ctx = c.getContext('2d');
  ctx.fillStyle = canvBg();
  ctx.fillRect(0, 0, c.width, c.height);
  
  const M = +document.getElementById('enhMax')?.value || 30;
  const trajectory = getPhaseTrajectory(r, M);
  
  if (trajectory.length === 0) {
    ctx.fillStyle = 'rgba(255,255,255,0.5)';
    ctx.font = '14px Segoe UI';
    ctx.textAlign = 'center';
    ctx.fillText(`No coprime occurrences for r = ${r}`, c.width / 2, c.height / 2);
    return;
  }
  
  const margin = { t: 35, r: 20, b: 35, l: 45 };
  const w = c.width - margin.l - margin.r;
  const h = c.height - margin.t - margin.b;
  
  // Draw axes
  ctx.strokeStyle = gridC();
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(margin.l, margin.t);
  ctx.lineTo(margin.l, margin.t + h);
  ctx.lineTo(margin.l + w, margin.t + h);
  ctx.stroke();
  
  // Draw trajectory
  ctx.strokeStyle = '#00d9ff';
  ctx.lineWidth = 1.5;
  ctx.beginPath();
  trajectory.forEach((pt, i) => {
    const x = margin.l + (pt.m / M) * w;
    const y = margin.t + h - pt.phi * h;
    if (i === 0) ctx.moveTo(x, y);
    else ctx.lineTo(x, y);
  });
  ctx.stroke();
  
  // Draw points
  trajectory.forEach(pt => {
    const x = margin.l + (pt.m / M) * w;
    const y = margin.t + h - pt.phi * h;
    ctx.fillStyle = '#00d9ff';
    ctx.beginPath();
    ctx.arc(x, y, 2, 0, 2 * Math.PI);
    ctx.fill();
  });
  
  // Title
  const d = trajData.find(d => d.r === r);
  ctx.fillStyle = '#00d9ff';
  ctx.font = 'bold 11px Segoe UI';
  ctx.textAlign = 'center';
  ctx.fillText(`Phase Trajectory: r = ${r} | D(r) = ${d ? d.drift.toFixed(2) : '?'} | Type: ${d ? d.type : '?'}`, c.width / 2, 15);
  
  // Axis labels
  ctx.fillStyle = isDark() ? '#fff' : '#000';
  ctx.font = '10px Segoe UI';
  ctx.textAlign = 'center';
  ctx.fillText('Modulus m', c.width / 2, c.height - 5);
  ctx.save();
  ctx.translate(12, margin.t + h / 2);
  ctx.rotate(-Math.PI / 2);
  ctx.fillText('Phase φ(r,m)', 0, 0);
  ctx.restore();
  
  document.getElementById('trajDetailInfo').textContent = `r = ${r} | Steps: ${trajectory.length} | Mean φ: ${d ? d.meanPhase.toFixed(3) : '?'}`;
}

function exportTrajectoryCSV() {
  if (trajData.length === 0) {
    computeAllTrajectoryData();
  }
  
  let csv = 'r,type,survival_L_r,drift_D_r,variance_Var_r,mean_phase,steps,classification\n';
  trajData.forEach(d => {
    csv += `${d.r},${d.type},${d.survival},${d.drift.toFixed(4)},${d.variance.toFixed(6)},${d.meanPhase.toFixed(4)},${d.survival},${d.classification}\n`;
  });
  
  dl(csv, 'trajectory_coherence_data.csv');
}

function exportTrajectoryFull() {
  if (trajData.length === 0) {
    computeTrajectoryStats();
  }
  
  const M = trajData[0]?.M || 30;
  const primes = trajData.filter(d => d.type === 'prime');
  const pm1 = trajData.filter(d => d.type === 'prime_minus_one');
  
  const mean = arr => arr.length > 0 ? arr.reduce((a,b) => a + b, 0) / arr.length : 0;
  const primeDrifts = primes.map(d => d.drift);
  const pm1Drifts = pm1.map(d => d.drift);
  
  let report = `NESTED MODULAR RESIDUE TRAJECTORY ANALYSIS
==========================================
Generated: ${new Date().toISOString()}
Parameters: M = ${M}, r ∈ [1, ${trajData.length}]

SUMMARY STATISTICS
------------------
Total Residues: ${trajData.length}
Primes: ${primes.length}
Prime-minus-one (p-1): ${pm1.length}

DRIFT COMPARISON
----------------
Mean Drift (Primes): ${mean(primeDrifts).toFixed(4)}
Mean Drift (p-1): ${mean(pm1Drifts).toFixed(4)}
Enrichment Ratio: ${(mean(primeDrifts)/mean(pm1Drifts)).toFixed(4)}x

CLASSIFICATION
--------------
Shell Core (D<0.3): ${trajData.filter(d => d.classification === 'shell_core').length}
Shell Halo (0.3-1): ${trajData.filter(d => d.classification === 'shell_halo').length}
Shell Periphery (1-3): ${trajData.filter(d => d.classification === 'shell_periphery').length}
Dispersed (>3): ${trajData.filter(d => d.classification === 'dispersed').length}

TOP 20 MOST COHERENT (Lowest Drift)
-----------------------------------
`;
  
  const top20 = [...trajData].sort((a,b) => a.drift - b.drift).slice(0, 20);
  top20.forEach((d, i) => {
    report += `${(i+1).toString().padStart(2)}. r=${d.r.toString().padStart(3)} | D(r)=${d.drift.toFixed(3).padStart(7)} | Type: ${d.type}\n`;
  });
  
  dl(report, 'trajectory_analysis_report.txt');
}

// Show/hide trajectory controls based on viz mode
function updateEnhancedVizControls() {
  const vizMode = document.getElementById('enhVizMode')?.value || 'rings';
  const trajControls = document.getElementById('enhTrajectoryControls');
  const trajPanels = document.getElementById('trajAnalysisPanels');
  
  if (trajControls) trajControls.style.display = vizMode === 'trajectory' ? 'block' : 'none';
  if (trajPanels) {
    trajPanels.style.display = vizMode === 'trajectory' ? 'block' : 'none';
    // Initialize canvases when shown
    if (vizMode === 'trajectory') {
      initEnhancedTrajectoryPanels();
    }
  }
}

function initEnhancedTrajectoryPanels() {
  const canvases = ['cTrajCoherence', 'cTrajHistogram', 'cTrajDetail'];
  const messages = ['Main plot on Enhanced canvas above', 'Drift histogram', 'Click a row to see trajectory'];
  
  canvases.forEach((id, i) => {
    const c = document.getElementById(id);
    if (!c) return;
    const ctx = c.getContext('2d');
    ctx.fillStyle = canvBg();
    ctx.fillRect(0, 0, c.width, c.height);
    ctx.fillStyle = 'rgba(255,255,255,0.4)';
    ctx.font = '12px Segoe UI';
    ctx.textAlign = 'center';
    ctx.fillText(messages[i], c.width / 2, c.height / 2);
  });
}

// ===== DEDICATED TRAJECTORY TAB (ttrajectory) =====
let traj2Data = [];
let traj2SortColumn = 'drift';
let traj2SortAsc = true;

function initTrajectoryTab() {
  // Draw initial placeholder on all canvases
  const canvases = ['cTraj2Polar', 'cTraj2Hist', 'cTraj2Compare', 'cTraj2Detail'];
  const messages = ['Click "Analyze" to generate coherence plot', 'Drift distribution will appear here', 'Comparison chart will appear here', 'Click a residue to see its trajectory'];
  
  canvases.forEach((id, i) => {
    const c = document.getElementById(id);
    if (!c) return;
    const ctx = c.getContext('2d');
    ctx.fillStyle = canvBg();
    ctx.fillRect(0, 0, c.width, c.height);
    ctx.fillStyle = 'rgba(255,255,255,0.5)';
    ctx.font = '14px Segoe UI';
    ctx.textAlign = 'center';
    ctx.fillText(messages[i], c.width / 2, c.height / 2);
  });
}

function setTrajPreset(maxR) {
  document.getElementById('traj2MaxR').value = maxR;
  computeTrajStats2();
}

function computeTrajStats2() {
  const M = +document.getElementById('traj2MaxM')?.value || 60;
  const maxR = +document.getElementById('traj2MaxR')?.value || 200;
  
  traj2Data = [];
  for (let r = 1; r <= maxR; r++) {
    const drift = computeDrift(r, M);
    const variance = computeVariance(r, M);
    const survival = computeSurvival(r, M);
    const meanPhase = computeMeanPhase(r, M);
    const type = getResidueType(r);
    const classification = classifyResidue(drift);
    
    traj2Data.push({ r, drift, variance, survival, meanPhase, type, classification, M });
  }
  
  updateTraj2Stats();
  drawTraj2Plot();
  drawTraj2Histogram();
  drawTraj2Compare();
  updateTraj2Table();
}

function updateTraj2Stats() {
  if (traj2Data.length === 0) return;
  
  const M = traj2Data[0].M;
  const primes = traj2Data.filter(d => d.type === 'prime');
  const pm1 = traj2Data.filter(d => d.type === 'prime_minus_one');
  const pp1 = traj2Data.filter(d => d.type === 'prime_plus_one');
  const others = traj2Data.filter(d => d.type === 'other');
  
  const mean = arr => arr.length > 0 ? arr.reduce((a,b) => a + b, 0) / arr.length : 0;
  const std = arr => {
    if (arr.length < 2) return 0;
    const m = mean(arr);
    return Math.sqrt(arr.reduce((s, x) => s + Math.pow(x - m, 2), 0) / arr.length);
  };
  const median = arr => {
    if (arr.length === 0) return 0;
    const sorted = [...arr].sort((a,b) => a - b);
    const mid = Math.floor(sorted.length / 2);
    return sorted.length % 2 ? sorted[mid] : (sorted[mid-1] + sorted[mid]) / 2;
  };
  
  const primeDrifts = primes.map(d => d.drift);
  const pm1Drifts = pm1.map(d => d.drift);
  const allDrifts = traj2Data.map(d => d.drift);
  
  // T-test
  function tTest(a, b) {
    if (a.length < 2 || b.length < 2) return { t: 0, p: 1 };
    const m1 = mean(a), m2 = mean(b);
    const s1 = std(a), s2 = std(b);
    const se = Math.sqrt(s1*s1/a.length + s2*s2/b.length);
    if (se === 0) return { t: 0, p: 1 };
    const t = (m1 - m2) / se;
    const p = 2 * (1 - normalCDF(Math.abs(t)));
    return { t, p };
  }
  
  function normalCDF(x) {
    const a1 = 0.254829592, a2 = -0.284496736, a3 = 1.421413741;
    const a4 = -1.453152027, a5 = 1.061405429, p = 0.3275911;
    const sign = x < 0 ? -1 : 1;
    x = Math.abs(x) / Math.sqrt(2);
    const t = 1.0 / (1.0 + p * x);
    const y = 1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*Math.exp(-x*x);
    return 0.5 * (1.0 + sign * y);
  }
  
  const tTestResult = tTest(pm1Drifts, primeDrifts);
  const enrichment = mean(primeDrifts) / mean(pm1Drifts);
  
  // Classification counts
  const classes = { shell_core: 0, shell_halo: 0, shell_periphery: 0, dispersed: 0 };
  traj2Data.forEach(d => classes[d.classification]++);
  
  // Percentiles
  const sorted = [...allDrifts].sort((a,b) => a - b);
  const p25 = sorted[Math.floor(sorted.length * 0.25)];
  const p75 = sorted[Math.floor(sorted.length * 0.75)];
  
  // Top 10 most coherent
  const top10 = [...traj2Data].sort((a,b) => a.drift - b.drift).slice(0, 10);
  
  const statsDiv = document.getElementById('traj2ShellStats');
  statsDiv.innerHTML = `
    <div style="text-align:center;padding:12px;background:${tTestResult.p < 0.001 ? 'rgba(0,255,136,.15)' : 'rgba(255,215,0,.15)'};border-radius:8px;margin-bottom:12px;border:2px solid ${tTestResult.p < 0.001 ? '#00ff88' : '#ffd700'}">
      <div style="font-size:1.5rem;color:${tTestResult.p < 0.001 ? '#00ff88' : '#ffd700'};font-weight:bold">
        ${tTestResult.p < 0.001 ? ' HIGHLY SIGNIFICANT' : tTestResult.p < 0.05 ? ' Significant' : ' Not Significant'}
      </div>
      <div style="font-size:.9rem;color:var(--txt2)">t = ${tTestResult.t.toFixed(3)} | p ${tTestResult.p < 0.001 ? '< 0.001' : '= ' + tTestResult.p.toFixed(4)}</div>
      <div style="font-size:1.1rem;color:#ffd700;margin-top:6px">Enrichment: <strong>${enrichment.toFixed(2)}x</strong></div>
    </div>
    
    <div style="margin-bottom:12px;padding:10px;background:var(--bg1);border-radius:8px">
      <strong style="color:#ffd700">Parameters</strong>
      <div style="display:grid;grid-template-columns:1fr 1fr;gap:4px;font-size:.8rem;margin-top:4px">
        <span>Max Modulus M: <strong>${M}</strong></span>
        <span>Residues: <strong>[1, ${traj2Data.length}]</strong></span>
        <span>Primes: <strong style="color:#ff6496">${primes.length}</strong></span>
        <span>p-1: <strong style="color:#00ff88">${pm1.length}</strong></span>
      </div>
    </div>
    
    <div style="margin-bottom:12px;padding:10px;background:var(--bg1);border-radius:8px">
      <strong style="color:#00d9ff">Drift by Type</strong>
      <table style="width:100%;font-size:.75rem;margin-top:6px;border-collapse:collapse">
        <tr style="border-bottom:1px solid var(--bord)">
          <th style="text-align:left;padding:4px">Type</th>
          <th style="text-align:right;padding:4px">n</th>
          <th style="text-align:right;padding:4px">Mean</th>
          <th style="text-align:right;padding:4px">Med</th>
          <th style="text-align:right;padding:4px">Std</th>
        </tr>
        <tr><td style="color:#ff6496">Primes</td><td style="text-align:right">${primes.length}</td><td style="text-align:right">${mean(primeDrifts).toFixed(2)}</td><td style="text-align:right">${median(primeDrifts).toFixed(2)}</td><td style="text-align:right">${std(primeDrifts).toFixed(2)}</td></tr>
        <tr style="background:rgba(0,255,136,.1)"><td style="color:#00ff88;font-weight:bold">p-1</td><td style="text-align:right;font-weight:bold">${pm1.length}</td><td style="text-align:right;font-weight:bold">${mean(pm1Drifts).toFixed(2)}</td><td style="text-align:right;font-weight:bold">${median(pm1Drifts).toFixed(2)}</td><td style="text-align:right">${std(pm1Drifts).toFixed(2)}</td></tr>
        <tr><td style="color:#ffd700">p+1</td><td style="text-align:right">${pp1.length}</td><td style="text-align:right">${mean(pp1.map(d=>d.drift)).toFixed(2)}</td><td style="text-align:right">${median(pp1.map(d=>d.drift)).toFixed(2)}</td><td style="text-align:right">${std(pp1.map(d=>d.drift)).toFixed(2)}</td></tr>
        <tr><td>Other</td><td style="text-align:right">${others.length}</td><td style="text-align:right">${mean(others.map(d=>d.drift)).toFixed(2)}</td><td style="text-align:right">${median(others.map(d=>d.drift)).toFixed(2)}</td><td style="text-align:right">${std(others.map(d=>d.drift)).toFixed(2)}</td></tr>
      </table>
    </div>
    
    <div style="margin-bottom:12px;padding:10px;background:var(--bg1);border-radius:8px">
      <strong style="color:#9664ff">Shell Classification</strong>
      <div style="display:grid;grid-template-columns:1fr 1fr;gap:6px;font-size:.8rem;margin-top:6px">
        <div style="padding:6px;background:rgba(10,126,140,.3);border-radius:4px;text-align:center">
          <div style="color:#0a7e8c;font-weight:bold">Core (D<0.3)</div>
          <div style="font-size:1.2rem">${classes.shell_core}</div>
        </div>
        <div style="padding:6px;background:rgba(16,163,168,.3);border-radius:4px;text-align:center">
          <div style="color:#10a3a8;font-weight:bold">Halo (0.3-1)</div>
          <div style="font-size:1.2rem">${classes.shell_halo}</div>
        </div>
        <div style="padding:6px;background:rgba(109,211,211,.3);border-radius:4px;text-align:center">
          <div style="color:#6dd3d3;font-weight:bold">Periphery (1-3)</div>
          <div style="font-size:1.2rem">${classes.shell_periphery}</div>
        </div>
        <div style="padding:6px;background:rgba(255,107,53,.3);border-radius:4px;text-align:center">
          <div style="color:#ff6b35;font-weight:bold">Dispersed (>3)</div>
          <div style="font-size:1.2rem">${classes.dispersed}</div>
        </div>
      </div>
    </div>
    
    <div style="margin-bottom:12px;padding:10px;background:var(--bg1);border-radius:8px">
      <strong style="color:#ffd700">Percentiles (All)</strong>
      <div style="font-size:.8rem;font-family:monospace;margin-top:4px">
        Min: ${Math.min(...allDrifts).toFixed(2)} | 25%: ${p25.toFixed(2)} | Med: ${median(allDrifts).toFixed(2)} | 75%: ${p75.toFixed(2)} | Max: ${Math.max(...allDrifts).toFixed(2)}
      </div>
    </div>
    
    <div style="padding:10px;background:var(--bg1);border-radius:8px">
      <strong style="color:#00ff88">Top 10 Most Coherent</strong>
      <div style="font-size:.75rem;margin-top:4px;font-family:monospace">
        ${top10.map((d,i) => `<div style="color:${d.type==='prime_minus_one'?'#00ffff':d.type==='prime'?'#ff6496':'#888'}">${(i+1).toString().padStart(2)}. r=${d.r.toString().padStart(3)} D=${d.drift.toFixed(2).padStart(5)} ${d.type}</div>`).join('')}
      </div>
    </div>
  `;
}

function drawTraj2Plot() {
  const c = document.getElementById('cTraj2Polar');
  if (!c) return;
  const ctx = c.getContext('2d');
  ctx.fillStyle = canvBg();
  ctx.fillRect(0, 0, c.width, c.height);
  
  if (traj2Data.length === 0) {
    ctx.fillStyle = 'rgba(255,255,255,0.5)';
    ctx.font = '16px Segoe UI';
    ctx.textAlign = 'center';
    ctx.fillText('Click "Analyze" to generate plot', c.width / 2, c.height / 2);
    return;
  }
  
  const colorBy = document.getElementById('traj2ColorBy')?.value || 'drift';
  const sizeBy = document.getElementById('traj2SizeBy')?.value || 'survival';
  const highlightPM1 = document.getElementById('traj2HighlightPM1')?.checked;
  const highlightPrimes = document.getElementById('traj2HighlightPrimes')?.checked;
  const showTop20 = document.getElementById('traj2ShowTop20')?.checked;
  const showLabels = document.getElementById('traj2ShowLabels')?.checked;
  const filterType = document.getElementById('traj2FilterType')?.value || 'all';
  const driftMin = +document.getElementById('traj2DriftMin')?.value || 0;
  const driftMax = +document.getElementById('traj2DriftMax')?.value || 50;
  
  const cx = c.width / 2, cy = c.height / 2;
  const maxR = Math.min(cx, cy) - 50;
  
  // Filter
  let filtered = traj2Data.filter(d => d.drift >= driftMin && d.drift <= driftMax);
  if (filterType === 'primes') filtered = filtered.filter(d => d.type === 'prime');
  else if (filterType === 'pm1') filtered = filtered.filter(d => d.type === 'prime_minus_one');
  else if (filterType === 'pp1') filtered = filtered.filter(d => d.type === 'prime_plus_one');
  else if (filterType === 'other') filtered = filtered.filter(d => d.type === 'other');
  else if (filterType === 'lowdrift') filtered = filtered.filter(d => d.drift < 3);
  
  const maxDrift = Math.max(...traj2Data.map(d => d.drift), 1);
  const maxSurvival = Math.max(...traj2Data.map(d => d.survival), 1);
  
  const sortedByDrift = [...traj2Data].sort((a, b) => a.drift - b.drift);
  const top20 = new Set(sortedByDrift.slice(0, 20).map(d => d.r));
  
  // Polar grid
  ctx.strokeStyle = 'rgba(255,255,255,0.1)';
  ctx.lineWidth = 1;
  for (let i = 1; i <= 5; i++) {
    ctx.beginPath();
    ctx.arc(cx, cy, maxR * i / 5, 0, 2 * Math.PI);
    ctx.stroke();
  }
  for (let i = 0; i < 12; i++) {
    const angle = (i / 12) * 2 * Math.PI;
    ctx.beginPath();
    ctx.moveTo(cx, cy);
    ctx.lineTo(cx + maxR * Math.cos(angle), cy + maxR * Math.sin(angle));
    ctx.stroke();
  }
  
  // Labels for rings
  ctx.fillStyle = 'rgba(255,255,255,0.4)';
  ctx.font = '9px Segoe UI';
  ctx.textAlign = 'center';
  for (let i = 1; i <= 5; i++) {
    const dVal = maxDrift * (1 - i / 5);
    ctx.fillText(`D=${dVal.toFixed(1)}`, cx + maxR * i / 5 + 20, cy - 5);
  }
  
  // Sort for layering
  const sortedFiltered = [...filtered].sort((a, b) => {
    const aH = (highlightPM1 && a.type === 'prime_minus_one') || (highlightPrimes && a.type === 'prime');
    const bH = (highlightPM1 && b.type === 'prime_minus_one') || (highlightPrimes && b.type === 'prime');
    return aH - bH;
  });
  
  sortedFiltered.forEach(d => {
    const angle = d.meanPhase * 2 * Math.PI;
    const radius = maxR * (1 - Math.min(d.drift / maxDrift, 0.95));
    const px = cx + radius * Math.cos(angle);
    const py = cy + radius * Math.sin(angle);
    
    let ptSize;
    if (sizeBy === 'survival') ptSize = 2 + 6 * (d.survival / maxSurvival);
    else if (sizeBy === 'drift') ptSize = 2 + 6 * (1 - d.drift / maxDrift);
    else ptSize = 4;
    
    let clr;
    if (colorBy === 'drift') clr = getDriftColor(d.drift, maxDrift);
    else if (colorBy === 'type') {
      if (d.type === 'prime') clr = '#ff6496';
      else if (d.type === 'prime_minus_one') clr = '#00ffff';
      else if (d.type === 'prime_plus_one') clr = '#ffff00';
      else clr = '#888';
    }
    else if (colorBy === 'classification') {
      if (d.classification === 'shell_core') clr = '#0a7e8c';
      else if (d.classification === 'shell_halo') clr = '#10a3a8';
      else if (d.classification === 'shell_periphery') clr = '#6dd3d3';
      else clr = '#ff6b35';
    }
    else if (colorBy === 'variance') clr = `hsl(${(1 - Math.min(d.variance / 0.1, 1)) * 180}, 70%, 55%)`;
    else if (colorBy === 'meanphase') clr = `hsl(${d.meanPhase * 360}, 70%, 55%)`;
    else clr = '#00d9ff';
    
    const isPM1 = d.type === 'prime_minus_one';
    const isP = d.type === 'prime';
    const isTop = top20.has(d.r);
    
    if (highlightPM1 && isPM1) { clr = '#00ffff'; ptSize *= 1.3; }
    if (highlightPrimes && isP) { clr = '#ff6496'; }
    
    // Glow
    if ((highlightPM1 && isPM1) || (showTop20 && isTop)) {
      ctx.globalAlpha = 0.3;
      ctx.fillStyle = clr;
      ctx.beginPath();
      ctx.arc(px, py, ptSize * 2.5, 0, 2 * Math.PI);
      ctx.fill();
      ctx.globalAlpha = 1;
    }
    
    ctx.fillStyle = clr;
    ctx.beginPath();
    ctx.arc(px, py, ptSize, 0, 2 * Math.PI);
    ctx.fill();
    
    if ((showTop20 && isTop) || showLabels) {
      ctx.fillStyle = isTop ? '#ffd700' : 'rgba(255,255,255,0.7)';
      ctx.font = isTop ? 'bold 10px Segoe UI' : '8px Segoe UI';
      ctx.textAlign = 'center';
      ctx.fillText(d.r, px, py - ptSize - 4);
    }
  });
  
  // Title
  ctx.fillStyle = '#00d9ff';
  ctx.font = 'bold 12px Segoe UI';
  ctx.textAlign = 'center';
  ctx.fillText(`Trajectory Coherence | M=${traj2Data[0]?.M} | r ∈ [1,${traj2Data.length}]`, c.width / 2, 18);
  
  // Legend
  ctx.font = '9px Segoe UI';
  ctx.textAlign = 'left';
  ctx.fillStyle = '#00ffff'; ctx.fillText(' p-1', 10, c.height - 30);
  ctx.fillStyle = '#ff6496'; ctx.fillText(' Primes', 55, c.height - 30);
  ctx.fillStyle = '#888'; ctx.fillText(' Other', 110, c.height - 30);
  ctx.fillStyle = '#ffd700'; ctx.fillText('Outer ring = Low Drift (More Coherent)', 10, c.height - 15);
}

function drawTraj2Histogram() {
  const c = document.getElementById('cTraj2Hist');
  if (!c || traj2Data.length === 0) return;
  const ctx = c.getContext('2d');
  ctx.fillStyle = canvBg();
  ctx.fillRect(0, 0, c.width, c.height);
  
  const allDrifts = traj2Data.map(d => d.drift);
  const primeDrifts = traj2Data.filter(d => d.type === 'prime').map(d => d.drift);
  const pm1Drifts = traj2Data.filter(d => d.type === 'prime_minus_one').map(d => d.drift);
  
  const margin = { t: 30, r: 20, b: 40, l: 45 };
  const w = c.width - margin.l - margin.r;
  const h = c.height - margin.t - margin.b;
  
  const bins = [0, 1, 2, 3, 5, 10, 20, 50];
  const counts = new Array(bins.length).fill(0);
  const primeCounts = new Array(bins.length).fill(0);
  const pm1Counts = new Array(bins.length).fill(0);
  
  allDrifts.forEach(d => { for (let i = 0; i < bins.length - 1; i++) { if (d >= bins[i] && d < bins[i+1]) { counts[i]++; break; } } if (d >= bins[bins.length-1]) counts[bins.length-1]++; });
  primeDrifts.forEach(d => { for (let i = 0; i < bins.length - 1; i++) { if (d >= bins[i] && d < bins[i+1]) { primeCounts[i]++; break; } } if (d >= bins[bins.length-1]) primeCounts[bins.length-1]++; });
  pm1Drifts.forEach(d => { for (let i = 0; i < bins.length - 1; i++) { if (d >= bins[i] && d < bins[i+1]) { pm1Counts[i]++; break; } } if (d >= bins[bins.length-1]) pm1Counts[bins.length-1]++; });
  
  const maxCount = Math.max(...counts, 1);
  const barW = w / bins.length;
  
  for (let i = 0; i < bins.length; i++) {
    const x = margin.l + i * barW;
    const barH = (counts[i] / maxCount) * h;
    
    ctx.fillStyle = 'rgba(100, 150, 255, 0.5)';
    ctx.fillRect(x + 2, margin.t + h - barH, barW - 4, barH);
    
    const primeH = (primeCounts[i] / maxCount) * h;
    ctx.fillStyle = 'rgba(255, 100, 150, 0.7)';
    ctx.fillRect(x + 3, margin.t + h - primeH, (barW - 6) / 2, primeH);
    
    const pm1H = (pm1Counts[i] / maxCount) * h;
    ctx.fillStyle = 'rgba(0, 255, 200, 0.7)';
    ctx.fillRect(x + 3 + (barW - 6) / 2, margin.t + h - pm1H, (barW - 6) / 2, pm1H);
    
    ctx.fillStyle = isDark() ? '#fff' : '#000';
    ctx.font = '8px Segoe UI';
    ctx.textAlign = 'center';
    const label = i < bins.length - 1 ? `${bins[i]}-${bins[i+1]}` : `${bins[i]}+`;
    ctx.fillText(label, x + barW / 2, c.height - margin.b + 12);
  }
  
  ctx.strokeStyle = gridC();
  ctx.beginPath();
  ctx.moveTo(margin.l, margin.t);
  ctx.lineTo(margin.l, margin.t + h);
  ctx.lineTo(margin.l + w, margin.t + h);
  ctx.stroke();
  
  ctx.fillStyle = '#ff6496';
  ctx.font = 'bold 11px Segoe UI';
  ctx.textAlign = 'center';
  ctx.fillText('Drift Distribution: All | Primes | p-1', c.width / 2, 15);
}

function drawTraj2Compare() {
  const c = document.getElementById('cTraj2Compare');
  if (!c || traj2Data.length === 0) return;
  const ctx = c.getContext('2d');
  ctx.fillStyle = canvBg();
  ctx.fillRect(0, 0, c.width, c.height);
  
  const primes = traj2Data.filter(d => d.type === 'prime');
  const pm1 = traj2Data.filter(d => d.type === 'prime_minus_one');
  
  const mean = arr => arr.length > 0 ? arr.reduce((a,b) => a + b, 0) / arr.length : 0;
  const std = arr => { if (arr.length < 2) return 0; const m = mean(arr); return Math.sqrt(arr.reduce((s, x) => s + Math.pow(x - m, 2), 0) / arr.length); };
  
  const primeMean = mean(primes.map(d => d.drift));
  const primeStd = std(primes.map(d => d.drift));
  const pm1Mean = mean(pm1.map(d => d.drift));
  const pm1Std = std(pm1.map(d => d.drift));
  
  const margin = { t: 40, r: 30, b: 50, l: 50 };
  const w = c.width - margin.l - margin.r;
  const h = c.height - margin.t - margin.b;
  
  const maxVal = Math.max(primeMean + primeStd, pm1Mean + pm1Std) * 1.2;
  const barW = w / 4;
  
  // Prime bar
  const primeH = (primeMean / maxVal) * h;
  const primeErrH = (primeStd / maxVal) * h;
  ctx.fillStyle = '#ff6496';
  ctx.fillRect(margin.l + barW * 0.5, margin.t + h - primeH, barW, primeH);
  ctx.strokeStyle = '#fff';
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(margin.l + barW, margin.t + h - primeH - primeErrH);
  ctx.lineTo(margin.l + barW, margin.t + h - primeH + primeErrH);
  ctx.moveTo(margin.l + barW - 5, margin.t + h - primeH - primeErrH);
  ctx.lineTo(margin.l + barW + 5, margin.t + h - primeH - primeErrH);
  ctx.moveTo(margin.l + barW - 5, margin.t + h - primeH + primeErrH);
  ctx.lineTo(margin.l + barW + 5, margin.t + h - primeH + primeErrH);
  ctx.stroke();
  
  // p-1 bar
  const pm1H = (pm1Mean / maxVal) * h;
  const pm1ErrH = (pm1Std / maxVal) * h;
  ctx.fillStyle = '#00ff88';
  ctx.fillRect(margin.l + barW * 2.5, margin.t + h - pm1H, barW, pm1H);
  ctx.beginPath();
  ctx.moveTo(margin.l + barW * 3, margin.t + h - pm1H - pm1ErrH);
  ctx.lineTo(margin.l + barW * 3, margin.t + h - pm1H + pm1ErrH);
  ctx.moveTo(margin.l + barW * 3 - 5, margin.t + h - pm1H - pm1ErrH);
  ctx.lineTo(margin.l + barW * 3 + 5, margin.t + h - pm1H - pm1ErrH);
  ctx.moveTo(margin.l + barW * 3 - 5, margin.t + h - pm1H + pm1ErrH);
  ctx.lineTo(margin.l + barW * 3 + 5, margin.t + h - pm1H + pm1ErrH);
  ctx.stroke();
  
  // Labels
  ctx.fillStyle = isDark() ? '#fff' : '#000';
  ctx.font = '11px Segoe UI';
  ctx.textAlign = 'center';
  ctx.fillText('Primes (p)', margin.l + barW, c.height - margin.b + 15);
  ctx.fillText('p-1', margin.l + barW * 3, c.height - margin.b + 15);
  ctx.fillText(primeMean.toFixed(1), margin.l + barW, margin.t + h - primeH - primeErrH - 10);
  ctx.fillText(pm1Mean.toFixed(1), margin.l + barW * 3, margin.t + h - pm1H - pm1ErrH - 10);
  
  // Axis
  ctx.strokeStyle = gridC();
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(margin.l, margin.t);
  ctx.lineTo(margin.l, margin.t + h);
  ctx.lineTo(margin.l + w, margin.t + h);
  ctx.stroke();
  
  ctx.save();
  ctx.translate(15, margin.t + h / 2);
  ctx.rotate(-Math.PI / 2);
  ctx.fillText('Mean Drift D(r)', 0, 0);
  ctx.restore();
  
  ctx.fillStyle = '#00ff88';
  ctx.font = 'bold 11px Segoe UI';
  ctx.fillText('Mean Drift Comparison (±1σ)', c.width / 2, 18);
  
  // Ratio annotation
  const ratio = primeMean / pm1Mean;
  ctx.fillStyle = '#ffd700';
  ctx.font = 'bold 12px Segoe UI';
  ctx.fillText(`${ratio.toFixed(2)}x difference`, c.width / 2, c.height - 5);
}

function updateTraj2Table() {
  const tbody = document.getElementById('traj2TableBody');
  if (!tbody || traj2Data.length === 0) return;
  
  const sorted = [...traj2Data].sort((a, b) => {
    let va, vb;
    if (traj2SortColumn === 'r') { va = a.r; vb = b.r; }
    else if (traj2SortColumn === 'drift') { va = a.drift; vb = b.drift; }
    else if (traj2SortColumn === 'survival') { va = a.survival; vb = b.survival; }
    else if (traj2SortColumn === 'variance') { va = a.variance; vb = b.variance; }
    else if (traj2SortColumn === 'meanphase') { va = a.meanPhase; vb = b.meanPhase; }
    else if (traj2SortColumn === 'type') { va = a.type; vb = b.type; }
    else if (traj2SortColumn === 'class') { va = a.classification; vb = b.classification; }
    else { va = a.drift; vb = b.drift; }
    
    if (typeof va === 'string') return traj2SortAsc ? va.localeCompare(vb) : vb.localeCompare(va);
    return traj2SortAsc ? va - vb : vb - va;
  });
  
  const typeColors = { 'prime': '#ff6496', 'prime_minus_one': '#00ff88', 'prime_plus_one': '#ffd700', 'other': '#888' };
  const classColors = { 'shell_core': '#0a7e8c', 'shell_halo': '#10a3a8', 'shell_periphery': '#6dd3d3', 'dispersed': '#ff6b35' };
  
  tbody.innerHTML = sorted.slice(0, 100).map(d => `
    <tr style="border-bottom:1px solid rgba(255,255,255,0.1);cursor:pointer" onclick="showTraj2Detail(${d.r})">
      <td style="padding:3px">${d.r}</td>
      <td style="padding:3px;color:${typeColors[d.type]}">${d.type === 'prime_minus_one' ? 'p-1' : d.type === 'prime_plus_one' ? 'p+1' : d.type}</td>
      <td style="padding:3px;text-align:right">${d.drift.toFixed(2)}</td>
      <td style="padding:3px;text-align:right">${d.survival}</td>
      <td style="padding:3px;text-align:right">${d.variance.toFixed(4)}</td>
      <td style="padding:3px;text-align:right">${d.meanPhase.toFixed(3)}</td>
      <td style="padding:3px;color:${classColors[d.classification]}">${d.classification.replace('shell_', '')}</td>
    </tr>
  `).join('');
}

function sortTraj2(col) {
  if (traj2SortColumn === col) traj2SortAsc = !traj2SortAsc;
  else { traj2SortColumn = col; traj2SortAsc = true; }
  updateTraj2Table();
}

function showTraj2Detail(r) {
  const c = document.getElementById('cTraj2Detail');
  if (!c) return;
  const ctx = c.getContext('2d');
  ctx.fillStyle = canvBg();
  ctx.fillRect(0, 0, c.width, c.height);
  
  const M = +document.getElementById('traj2MaxM')?.value || 60;
  const trajectory = getPhaseTrajectory(r, M);
  const d = traj2Data.find(d => d.r === r);
  
  if (trajectory.length === 0) {
    ctx.fillStyle = 'rgba(255,255,255,0.5)';
    ctx.font = '14px Segoe UI';
    ctx.textAlign = 'center';
    ctx.fillText(`No coprime occurrences for r = ${r}`, c.width / 2, c.height / 2);
    return;
  }
  
  const margin = { t: 35, r: 20, b: 35, l: 45 };
  const w = c.width - margin.l - margin.r;
  const h = c.height - margin.t - margin.b;
  
  ctx.strokeStyle = gridC();
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(margin.l, margin.t);
  ctx.lineTo(margin.l, margin.t + h);
  ctx.lineTo(margin.l + w, margin.t + h);
  ctx.stroke();
  
  // Grid lines
  ctx.strokeStyle = 'rgba(255,255,255,0.1)';
  for (let i = 0; i <= 4; i++) {
    const y = margin.t + (i / 4) * h;
    ctx.beginPath();
    ctx.moveTo(margin.l, y);
    ctx.lineTo(margin.l + w, y);
    ctx.stroke();
  }
  
  ctx.strokeStyle = '#00d9ff';
  ctx.lineWidth = 1.5;
  ctx.beginPath();
  trajectory.forEach((pt, i) => {
    const x = margin.l + (pt.m / M) * w;
    const y = margin.t + h - pt.phi * h;
    if (i === 0) ctx.moveTo(x, y);
    else ctx.lineTo(x, y);
  });
  ctx.stroke();
  
  trajectory.forEach(pt => {
    const x = margin.l + (pt.m / M) * w;
    const y = margin.t + h - pt.phi * h;
    ctx.fillStyle = '#00d9ff';
    ctx.beginPath();
    ctx.arc(x, y, 2.5, 0, 2 * Math.PI);
    ctx.fill();
  });
  
  ctx.fillStyle = '#00d9ff';
  ctx.font = 'bold 11px Segoe UI';
  ctx.textAlign = 'center';
  ctx.fillText(`r = ${r} | D(r) = ${d ? d.drift.toFixed(2) : '?'} | Type: ${d ? (d.type === 'prime_minus_one' ? 'p-1' : d.type) : '?'}`, c.width / 2, 15);
  
  ctx.fillStyle = isDark() ? '#fff' : '#000';
  ctx.font = '10px Segoe UI';
  ctx.fillText('Modulus m', c.width / 2, c.height - 5);
  ctx.save();
  ctx.translate(12, margin.t + h / 2);
  ctx.rotate(-Math.PI / 2);
  ctx.fillText('Phase φ(r,m)', 0, 0);
  ctx.restore();
  
  document.getElementById('traj2DetailInfo').textContent = `r = ${r} | Steps: ${trajectory.length} | Mean φ: ${d ? d.meanPhase.toFixed(3) : '?'} | Var: ${d ? d.variance.toFixed(4) : '?'}`;
}

function exportTraj2CSV() {
  if (traj2Data.length === 0) computeTrajStats2();
  
  let csv = 'r,type,survival_L_r,drift_D_r,variance_Var_r,mean_phase,classification,M\n';
  traj2Data.forEach(d => {
    csv += `${d.r},${d.type},${d.survival},${d.drift.toFixed(6)},${d.variance.toFixed(8)},${d.meanPhase.toFixed(6)},${d.classification},${d.M}\n`;
  });
  
  dl(csv, 'trajectory_coherence_analysis.csv');
}

function exportTraj2FullReport() {
  if (traj2Data.length === 0) computeTrajStats2();
  
  const M = traj2Data[0]?.M || 60;
  const primes = traj2Data.filter(d => d.type === 'prime');
  const pm1 = traj2Data.filter(d => d.type === 'prime_minus_one');
  
  const mean = arr => arr.length > 0 ? arr.reduce((a,b) => a + b, 0) / arr.length : 0;
  const std = arr => { if (arr.length < 2) return 0; const m = mean(arr); return Math.sqrt(arr.reduce((s, x) => s + Math.pow(x - m, 2), 0) / arr.length); };
  
  const primeDrifts = primes.map(d => d.drift);
  const pm1Drifts = pm1.map(d => d.drift);
  
  let report = `NESTED MODULAR RESIDUE TRAJECTORY ANALYSIS - FULL REPORT
========================================================
Generated: ${new Date().toISOString()}

PARAMETERS
----------
Max Modulus M: ${M}
Residue Range: [1, ${traj2Data.length}]

COUNTS
------
Total Residues: ${traj2Data.length}
Primes: ${primes.length}
Prime-minus-one (p-1): ${pm1.length}

DRIFT STATISTICS
----------------
                    Mean      Std       Min       Max
Primes (p):         ${mean(primeDrifts).toFixed(3).padStart(8)}  ${std(primeDrifts).toFixed(3).padStart(8)}  ${Math.min(...primeDrifts).toFixed(3).padStart(8)}  ${Math.max(...primeDrifts).toFixed(3).padStart(8)}
p-1:                ${mean(pm1Drifts).toFixed(3).padStart(8)}  ${std(pm1Drifts).toFixed(3).padStart(8)}  ${Math.min(...pm1Drifts).toFixed(3).padStart(8)}  ${Math.max(...pm1Drifts).toFixed(3).padStart(8)}

ENRICHMENT RATIO: ${(mean(primeDrifts) / mean(pm1Drifts)).toFixed(4)}x

SHELL CLASSIFICATION
--------------------
Core (D<0.3):       ${traj2Data.filter(d => d.classification === 'shell_core').length}
Halo (0.3-1):       ${traj2Data.filter(d => d.classification === 'shell_halo').length}
Periphery (1-3):    ${traj2Data.filter(d => d.classification === 'shell_periphery').length}
Dispersed (>3):     ${traj2Data.filter(d => d.classification === 'dispersed').length}

TOP 20 MOST COHERENT (Lowest Drift)
-----------------------------------
`;
  
  const top20 = [...traj2Data].sort((a,b) => a.drift - b.drift).slice(0, 20);
  top20.forEach((d, i) => {
    report += `${(i+1).toString().padStart(2)}. r=${d.r.toString().padStart(4)} | D(r)=${d.drift.toFixed(4).padStart(8)} | L(r)=${d.survival.toString().padStart(3)} | Type: ${d.type}\n`;
  });
  
  report += `
INTERPRETATION
--------------
Residues r = p-1 (where p is prime) form a statistically significant
"twin-prime shell" with ${(mean(primeDrifts) / mean(pm1Drifts)).toFixed(2)}x LESS drift than primes themselves.

This geometric coherence is NOT random fluctuation - it reflects deep
number-theoretic structure in how (p-1) residues traverse modular space.
`;
  
  dl(report, 'trajectory_analysis_full_report.txt');
}

async function screenshotTraj2() {
  const c = document.getElementById('cTraj2Polar');
  if (!c) return;
  const link = document.createElement('a');
  link.download = 'trajectory_coherence_plot.png';
  link.href = c.toDataURL('image/png');
  link.click();
}

// ===== PRIME SIEVE ANALYSIS =====
// ===== RESIDUE TRACKER =====
function updateEnhTrackerMode() {
  const mode = document.getElementById('enhTrackerMode')?.value || 'manual';
  document.getElementById('enhTrackerManual').style.display = mode === 'manual' ? 'block' : 'none';
  document.getElementById('enhTrackerSlider').style.display = mode === 'slider' ? 'block' : 'none';
}

function setEnhTrackerPreset(preset) {
  const presets = {
    'phi12': '1, 5, 7, 11',  // φ(12) = 4
    'phi30': '1, 7, 11, 13, 17, 19, 23, 29',  // φ(30) = 8
    'phi60': '1, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 49, 53, 59',  // φ(60) = 16
    'primes10': '2, 3, 5, 7',  // Primes ≤ 10
    'twins30': '11, 17, 29',  // Twin-prime admissible in mod 30
    'sexy30': '1, 7, 11, 13, 17, 23',  // Sexy prime admissible (gap 6) in mod 30
    'cousin30': '1, 7, 11, 13, 19, 23',  // Cousin prime admissible (gap 4) in mod 30
  };
  
  const val = presets[preset] || '1, 5, 7, 11';
  document.getElementById('enhTrackerList').value = val;
  document.getElementById('enhTrackerMode').value = 'manual';
  updateEnhTrackerMode();
  document.getElementById('enhTrackerEnable').checked = true;
  drawEnhanced();
}

function getTrackedResidues() {
  const mode = document.getElementById('enhTrackerMode')?.value || 'manual';
  if (mode === 'slider') {
    return [+document.getElementById('enhTrackerR')?.value || 1];
  } else {
    const listStr = document.getElementById('enhTrackerList')?.value || '';
    return listStr.split(',').map(s => parseInt(s.trim())).filter(n => !isNaN(n) && n >= 0);
  }
}

function getTrackerModFilter() {
  const filterStr = document.getElementById('enhTrackerModFilter')?.value || '';
  if (!filterStr.trim()) return null;  // No filter
  return filterStr.split(',').map(s => parseInt(s.trim())).filter(n => !isNaN(n) && n > 0);
}

function updateEnhTrackerInfo(ringsData, trackedResidues, modFilter) {
  const infoDiv = document.getElementById('enhTrackerInfo');
  const dataDiv = document.getElementById('enhTrackerData');
  const panelDiv = document.getElementById('enhTrackerPanel');
  const vizDataDiv = document.getElementById('enhTrackerVizData');
  
  const enabled = document.getElementById('enhTrackerEnable')?.checked;
  if (infoDiv) infoDiv.style.display = enabled ? 'block' : 'none';
  if (panelDiv) panelDiv.style.display = enabled ? 'block' : 'none';
  
  if (!enabled) return;
  
  if (trackedResidues.length === 0) {
    if (dataDiv) dataDiv.innerHTML = '<div style="color:var(--txt2)">No residues being tracked</div>';
    if (vizDataDiv) vizDataDiv.innerHTML = '<div style="color:var(--txt2);text-align:center;padding:1rem">Enter residues to track</div>';
    return;
  }
  
  // Build info table
  let html = '<table style="width:100%;border-collapse:collapse;font-size:.7rem">';
  html += '<tr style="border-bottom:1px solid var(--bord);color:#ffd700"><th style="text-align:left;padding:2px">r</th><th style="text-align:right;padding:2px">Open</th><th style="text-align:right;padding:2px">Closed</th><th style="text-align:right;padding:2px">Open%</th><th style="text-align:left;padding:2px">Status</th></tr>';
  
  const trackerResults = [];
  
  trackedResidues.forEach(r => {
    let openCount = 0, closedCount = 0;
    const openMods = [], closedMods = [];
    
    ringsData.forEach(ring => {
      if (modFilter && !modFilter.includes(ring.mod)) return;
      const rMod = r % ring.mod;
      const g = gcd(rMod, ring.mod);
      if (g === 1) {
        openCount++;
        openMods.push(ring.mod);
      } else {
        closedCount++;
        closedMods.push(ring.mod);
      }
    });
    
    const total = openCount + closedCount;
    const pct = total > 0 ? (100 * openCount / total) : 0;
    const status = openCount > closedCount ? 'Mostly Open' : 
                   closedCount > openCount ? 'Mostly Closed' : 'Mixed';
    
    trackerResults.push({ r, openCount, closedCount, pct, status, openMods, closedMods });
    
    const statusHtml = status === 'Mostly Open' ? '<span style="color:#00ff88">Mostly Open</span>' : 
                       status === 'Mostly Closed' ? '<span style="color:#ff6496">Mostly Closed</span>' : 
                       '<span style="color:#ffd700">Mixed</span>';
    
    html += `<tr style="border-bottom:1px solid rgba(255,255,255,0.1)">`;
    html += `<td style="padding:2px;font-weight:bold">${r}</td>`;
    html += `<td style="padding:2px;text-align:right;color:#00ff88">${openCount}</td>`;
    html += `<td style="padding:2px;text-align:right;color:#ff6496">${closedCount}</td>`;
    html += `<td style="padding:2px;text-align:right">${pct.toFixed(1)}%</td>`;
    html += `<td style="padding:2px">${statusHtml}</td>`;
    html += '</tr>';
  });
  
  html += '</table>';
  
  // Summary
  const totalRings = modFilter ? ringsData.filter(r => modFilter.includes(r.mod)).length : ringsData.length;
  html += `<div style="margin-top:6px;color:var(--txt2);font-size:.65rem">Tracking ${trackedResidues.length} residue(s) across ${totalRings} ring(s)</div>`;
  
  // Factorization hint for single residue
  if (trackedResidues.length === 1) {
    const r = trackedResidues[0];
    const factors = [];
    let n = r;
    for (let p = 2; p * p <= n; p++) {
      while (n % p === 0) { factors.push(p); n /= p; }
    }
    if (n > 1) factors.push(n);
    
    if (r > 1) {
      html += `<div style="margin-top:4px;color:#9664ff;font-size:.65rem">r=${r} = ${factors.length > 0 ? factors.join(' × ') : '1'} — closed when m shares factor with ${factors.length > 0 ? factors.join(' or ') : 'none'}</div>`;
    }
  }
  
  if (dataDiv) dataDiv.innerHTML = html;
  
  // Build detailed panel view
  let vizHtml = '<div style="margin-bottom:12px;padding:8px;background:rgba(0,255,136,.1);border-radius:6px;border-left:3px solid #00ff88">';
  vizHtml += `<strong style="color:#00ff88">Tracking ${trackedResidues.length} Residue(s)</strong>`;
  vizHtml += `<div style="font-size:.75rem;color:var(--txt2)">Across ${totalRings} moduli | Filter: ${modFilter ? modFilter.join(', ') : 'All'}</div>`;
  vizHtml += '</div>';
  
  trackerResults.forEach(res => {
    const barWidth = Math.max(5, res.pct);
    vizHtml += `<div style="margin-bottom:10px;padding:8px;background:var(--bg1);border-radius:6px">`;
    vizHtml += `<div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:4px">`;
    vizHtml += `<strong style="color:#ffd700;font-size:1rem">r = ${res.r}</strong>`;
    vizHtml += `<span style="color:${res.status === 'Mostly Open' ? '#00ff88' : res.status === 'Mostly Closed' ? '#ff6496' : '#ffd700'};font-size:.8rem">${res.status}</span>`;
    vizHtml += `</div>`;
    
    // Progress bar
    vizHtml += `<div style="height:12px;background:#333;border-radius:6px;overflow:hidden;margin-bottom:4px">`;
    vizHtml += `<div style="height:100%;width:${barWidth}%;background:linear-gradient(90deg,#00ff88,#00d9ff);border-radius:6px"></div>`;
    vizHtml += `</div>`;
    
    vizHtml += `<div style="display:flex;justify-content:space-between;font-size:.7rem">`;
    vizHtml += `<span style="color:#00ff88">Open: ${res.openCount}</span>`;
    vizHtml += `<span style="color:#888">${res.pct.toFixed(1)}% open</span>`;
    vizHtml += `<span style="color:#ff6496">Closed: ${res.closedCount}</span>`;
    vizHtml += `</div>`;
    
    // Show first few open/closed moduli
    if (res.openMods.length > 0) {
      vizHtml += `<div style="font-size:.65rem;color:#00ff88;margin-top:4px">Open in: ${res.openMods.slice(0, 8).join(', ')}${res.openMods.length > 8 ? '...' : ''}</div>`;
    }
    if (res.closedMods.length > 0) {
      vizHtml += `<div style="font-size:.65rem;color:#ff6496">Closed in: ${res.closedMods.slice(0, 5).join(', ')}${res.closedMods.length > 5 ? '...' : ''}</div>`;
    }
    
    vizHtml += `</div>`;
  });
  
  // Theoretical density
  const avgOpenPct = trackerResults.reduce((s, r) => s + r.pct, 0) / trackerResults.length;
  vizHtml += `<div style="margin-top:12px;padding:8px;background:rgba(150,100,255,.1);border-radius:6px;font-size:.75rem">`;
  vizHtml += `<strong style="color:#9664ff">Theoretical Insight</strong><br>`;
  vizHtml += `Average open channel rate: <strong>${avgOpenPct.toFixed(1)}%</strong><br>`;
  vizHtml += `<span style="color:var(--txt2)">Asymptotic density of coprimes: 6/π² ≈ 60.79%</span>`;
  vizHtml += `</div>`;
  
  if (vizDataDiv) vizDataDiv.innerHTML = vizHtml;
  
  // Store for CSV export
  window.trackerResultsCache = { trackedResidues, trackerResults, ringsData, modFilter };
}

function exportTrackerCSV() {
  const cache = window.trackerResultsCache;
  if (!cache || !cache.trackerResults) {
    alert('No tracker data to export. Enable tracker first.');
    return;
  }
  
  let csv = 'residue,open_count,closed_count,open_percent,status,open_moduli,closed_moduli\n';
  cache.trackerResults.forEach(res => {
    csv += `${res.r},${res.openCount},${res.closedCount},${res.pct.toFixed(2)},${res.status},"${res.openMods.join(';')}","${res.closedMods.join(';')}"\n`;
  });
  
  dl(csv, 'residue_tracker_analysis.csv');
}

function drawEnhTrackedResidues(ctx, ringsData, cx, cy, getPoint) {
  const enabled = document.getElementById('enhTrackerEnable')?.checked;
  if (!enabled) return;
  
  const trackedResidues = getTrackedResidues();
  if (trackedResidues.length === 0) return;
  
  const modFilter = getTrackerModFilter();
  const trackerColor = document.getElementById('enhTrackerColor')?.value || '#00ffff';
  const trackerSize = +document.getElementById('enhTrackerSz')?.value || 8;
  const showLabels = document.getElementById('enhTrackerLabels')?.checked;
  const showGlow = document.getElementById('enhTrackerGlow')?.checked;
  const showLines = document.getElementById('enhTrackerLines')?.checked;
  
  // Update info panel
  updateEnhTrackerInfo(ringsData, trackedResidues, modFilter);
  
  // Collect points for connection lines
  const pointsByResidue = {};
  trackedResidues.forEach(r => pointsByResidue[r] = []);
  
  // Draw tracked residues
  ringsData.forEach((ring, ringIdx) => {
    if (modFilter && !modFilter.includes(ring.mod)) return;
    
    trackedResidues.forEach(r => {
      const rMod = r % ring.mod;
      const g = gcd(rMod, ring.mod);
      const isOpen = g === 1;
      
      const pt = getPoint(ring, rMod);
      if (!pt) return;
      
      pointsByResidue[r].push({ ...pt, mod: ring.mod, isOpen });
      
      // Glow effect
      if (showGlow) {
        ctx.globalAlpha = 0.4;
        ctx.fillStyle = trackerColor;
        ctx.beginPath();
        ctx.arc(pt.x, pt.y, trackerSize * 2, 0, 2 * Math.PI);
        ctx.fill();
        ctx.globalAlpha = 1;
      }
      
      // Main point
      ctx.fillStyle = trackerColor;
      ctx.beginPath();
      ctx.arc(pt.x, pt.y, trackerSize, 0, 2 * Math.PI);
      ctx.fill();
      
      // Border indicating open/closed
      ctx.strokeStyle = isOpen ? '#00ff88' : '#ff6496';
      ctx.lineWidth = 2;
      ctx.stroke();
      
      // Label
      if (showLabels) {
        const labelPos = document.getElementById('enhTrackerLabelPos')?.value || 'right';
        ctx.fillStyle = '#fff';
        ctx.font = `bold ${Math.max(8, trackerSize - 1)}px Segoe UI`;
        let lx = pt.x, ly = pt.y;
        const offset = trackerSize + 6;
        if (labelPos === 'above') { ctx.textAlign = 'center'; ly = pt.y - offset; }
        else if (labelPos === 'below') { ctx.textAlign = 'center'; ly = pt.y + offset + 4; }
        else if (labelPos === 'left') { ctx.textAlign = 'right'; lx = pt.x - offset; ly = pt.y + 3; }
        else if (labelPos === 'right') { ctx.textAlign = 'left'; lx = pt.x + offset; ly = pt.y + 3; }
        else if (labelPos === 'inside') { ctx.textAlign = 'center'; ly = pt.y + 3; ctx.fillStyle = '#000'; }
        ctx.fillText(r, lx, ly);
      }
    });
  });
  
  // Connection lines across rings
  if (showLines) {
    ctx.lineWidth = 1.5;
    ctx.setLineDash([4, 4]);
    
    trackedResidues.forEach(r => {
      const pts = pointsByResidue[r];
      if (pts.length < 2) return;
      
      ctx.strokeStyle = trackerColor;
      ctx.globalAlpha = 0.5;
      ctx.beginPath();
      ctx.moveTo(pts[0].x, pts[0].y);
      for (let i = 1; i < pts.length; i++) {
        ctx.lineTo(pts[i].x, pts[i].y);
      }
      ctx.stroke();
      ctx.globalAlpha = 1;
    });
    
    ctx.setLineDash([]);
  }
}

function setEnhSector(n){
  document.getElementById('enhSectorDepth').value=n;
  document.getElementById('enhShowFareySectors').checked=true;
  drawEnhanced();
}

function setEnhSectorRange(from,to){
  document.getElementById('enhSectorFrom').value=from;
  document.getElementById('enhSectorTo').value=to;
  document.getElementById('enhHighlightSector').checked=true;
  updateEnhSector();
}

function updateEnhSector(){
  let from=+document.getElementById('enhSectorFrom')?.value||3;
  let to=+document.getElementById('enhSectorTo')?.value||2;
  const consecutive=document.getElementById('enhConsecutiveOnly')?.checked;
  
  // Ensure from > to (smaller fraction to larger)
  if(from<=to){
    if(consecutive){
      to=from-1;
      const toEl=document.getElementById('enhSectorTo');
      if(toEl)toEl.value=to;
    }
  }
  if(consecutive&&from!==to+1){
    to=from-1;
    const toEl=document.getElementById('enhSectorTo');
    if(toEl)toEl.value=to;
  }
  
  // Calculate angles (θ = 360°/n for 1/n)
  const angleFrom=360/from;
  const angleTo=360/to;
  const angleRangeEl=document.getElementById('enhSectorAngleRange');
  if(angleRangeEl)angleRangeEl.textContent=`(${angleFrom.toFixed(1)}° – ${angleTo.toFixed(1)}°)`;
  
  // Calculate sector stats
  const width=angleTo-angleFrom;
  const widthEl=document.getElementById('enhSectorWidth');
  if(widthEl)widthEl.textContent=width.toFixed(1)+'°';
  
  // Root (mediant of boundaries)
  const rootP=1+1;
  const rootQ=from+to;
  const rootAngle=360*rootP/rootQ;
  const rootEl=document.getElementById('enhSectorRoot');
  if(rootEl)rootEl.textContent=`${rootP}/${rootQ} @ ${rootAngle.toFixed(1)}°`;
  
  // Estimated count formula: 3N²/π²n(n+1) where N=max mod
  const maxMod=enhRingsData.length>0?Math.max(...enhRingsData.map(r=>r.mod)):60;
  const estCount=Math.round(3*maxMod*maxMod/(Math.PI*Math.PI*from*to));
  
  // Update header
  const statsEl=document.getElementById('enhSectorStats');
  if(statsEl){
    const headerDiv=statsEl.querySelector('div');
    if(headerDiv)headerDiv.textContent=`Sector: 1/${from} → 1/${to} (${angleFrom.toFixed(1)}° – ${angleTo.toFixed(1)}°)`;
  }
  
  // Count points in sector
  let totalInSector=0,coprimeInSector=0;
  const fareyNeighbors=[];
  
  if(enhRingsData.length>0){
    enhRingsData.forEach(ring=>{
      ring.allRes.forEach(r=>{
        const frac=r/ring.mod;
        // Check if in sector: 1/from < frac < 1/to (or ≤ for boundaries)
        if(frac>1/from&&frac<1/to){
          totalInSector++;
          if(gcd(r,ring.mod)===1){
            coprimeInSector++;
            // Check for Farey neighbors within this ring
            ring.coprimes.forEach(r2=>{
              if(r2>r){
                const frac2=r2/ring.mod;
                if(frac2>1/from&&frac2<1/to){
                  // Check Farey neighbor condition: |r1*q2 - r2*q1| = 1
                  // Since same denominator: |r1 - r2| * q = q means not neighbors
                  // For true Farey neighbors we need cross-ring check
                }
              }
            });
          }
        }
      });
    });
  }
  
  const totalEl=document.getElementById('enhSectorTotal');
  if(totalEl)totalEl.textContent=totalInSector;
  const coprimeEl=document.getElementById('enhSectorCoprime');
  if(coprimeEl)coprimeEl.textContent=coprimeInSector;
  const nonCoprimeEl=document.getElementById('enhSectorNonCoprime');
  if(nonCoprimeEl)nonCoprimeEl.textContent=totalInSector-coprimeInSector;
  
  // Calculate density
  const density=totalInSector>0?coprimeInSector/totalInSector:0;
  const densityEl=document.getElementById('enhSectorDensity');
  if(densityEl)densityEl.textContent=(density*100).toFixed(1)+'%';
  const vsZetaEl=document.getElementById('enhSectorVsZeta');
  if(vsZetaEl)vsZetaEl.textContent=(density/(6/(Math.PI*Math.PI))).toFixed(3);
  
  // Calculate error bounds for this sector
  const asymptotic=3*maxMod*maxMod/(Math.PI*Math.PI*from*(from+1));
  const absError=Math.abs(coprimeInSector-asymptotic);
  const relError=coprimeInSector>0?(absError/coprimeInSector)*100:0;
  const ci95=Math.ceil(1.96*Math.sqrt(coprimeInSector>0?coprimeInSector:1));
  
  // Determine reliability rating
  let reliability='EXCELLENT',reliabColor='#00ff88';
  if(relError>0.3){reliability='V.GOOD';reliabColor='#7fff7f';}
  if(relError>1){reliability='GOOD';reliabColor='#ffd700';}
  if(relError>3){reliability='FAIR';reliabColor='#ff8c00';}
  if(relError>8){reliability='POOR';reliabColor='#ff6666';}
  if(relError>15){reliability='UNRELIABLE';reliabColor='#ff4444';}
  
  // Update display elements
  const asympEl=document.getElementById('enhSectorAsymp');
  if(asympEl)asympEl.textContent=asymptotic.toFixed(1);
  const absErrEl=document.getElementById('enhSectorAbsErr');
  if(absErrEl)absErrEl.textContent=absError.toFixed(1);
  const relErrEl=document.getElementById('enhSectorRelErr');
  if(relErrEl){
    relErrEl.textContent=relError.toFixed(2)+'%';
    relErrEl.style.color=relError<1?'#00ff88':relError<5?'#ffd700':'#ff8c00';
  }
  const ciEl=document.getElementById('enhSectorCI');
  if(ciEl)ciEl.textContent='±'+ci95;
  const ratingEl=document.getElementById('enhSectorRating');
  if(ratingEl){
    ratingEl.textContent=reliability;
    ratingEl.style.color=reliabColor;
  }
  
  // Modular Picks for sector triangle
  const showPicks=document.getElementById('enhSectorPicks')?.checked;
  const picksStats=document.getElementById('enhSectorPicksStats');
  if(picksStats){
    if(showPicks){
      picksStats.style.display='block';
      // Sector triangle: origin (0,0), point at 1/from, point at 1/to
      // In lattice coordinates, use the maxMod as scale
      const maxMod=enhRingsData.length>0?Math.max(...enhRingsData.map(r=>r.mod)):30;
      // Triangle vertices: (0,0), (maxMod/from, 0), (maxMod/to·cos, maxMod/to·sin)
      // Simplified: count lattice points in sector wedge
      // For Farey sector 1/n to 1/(n-1), use wedge formula
      // Pick's: A = i + b/2 - 1
      // For a wedge from origin to angle θ at radius R:
      // Approximate using the sector area = R²·θ/2
      const R=maxMod;
      const theta1=2*Math.PI/from;
      const theta2=2*Math.PI/to;
      const sectorArea=(theta2-theta1)*R*R/2;
      // Count boundary points on the two radii and arc
      const b1=gcd(R,Math.round(R*Math.cos(theta1)))+gcd(R,Math.round(R*Math.sin(theta1)));
      const b2=gcd(R,Math.round(R*Math.cos(theta2)))+gcd(R,Math.round(R*Math.sin(theta2)));
      const boundary=b1+b2+2; // Approximate
      // Interior from Pick's: i = A - b/2 + 1
      const interior=Math.round(sectorArea-boundary/2+1);
      const iEl=document.getElementById('enhSectorPicksI');
      if(iEl)iEl.textContent=Math.max(0,interior);
      const bEl=document.getElementById('enhSectorPicksB');
      if(bEl)bEl.textContent=boundary;
      const aEl=document.getElementById('enhSectorPicksA');
      if(aEl)aEl.textContent=sectorArea.toFixed(1);
      const verify=interior+boundary/2-1;
      const vEl=document.getElementById('enhSectorPicksV');
      if(vEl)vEl.textContent=verify.toFixed(1)+'≈'+sectorArea.toFixed(1);
    }else{
      picksStats.style.display='none';
    }
  }
  
  // Build Farey neighbors list
  buildFareyNeighborsList(from,to);
  
  // Draw Stern-Brocot tree
  drawSternBrocotTree(from,to);
  
  drawEnhanced();
}

function buildFareyNeighborsList(fromN,toN){
  const container=document.getElementById('enhFareyNeighbors');
  if(!container)return;
  
  // Build Farey sequence for this sector up to max denominator
  const maxQ=enhRingsData.length>0?Math.max(...enhRingsData.map(r=>r.mod)):30;
  const fareyPts=[];
  
  // Collect all primitive fractions in sector
  for(let q=1;q<=maxQ;q++){
    for(let p=1;p<q;p++){
      if(gcd(p,q)!==1)continue;
      const frac=p/q;
      if(frac>1/fromN&&frac<1/toN){
        fareyPts.push({p,q,frac,angle:360*frac});
      }
    }
  }
  
  // Sort by fraction value
  fareyPts.sort((a,b)=>a.frac-b.frac);
  
  // Find consecutive Farey neighbors
  const neighbors=[];
  for(let i=0;i<fareyPts.length-1;i++){
    const f1=fareyPts[i],f2=fareyPts[i+1];
    const det=Math.abs(f1.p*f2.q-f2.p*f1.q);
    if(det===1){
      neighbors.push({f1,f2,mediant:{p:f1.p+f2.p,q:f1.q+f2.q}});
    }
  }
  
  // Store for CSV export
  window.fareyNeighborsData = {fractions: fareyPts, neighbors: neighbors, fromN, toN};
  
  // Build HTML - show ALL items
  let html=`<div style="color:#00ff88;margin-bottom:6px">Found ${fareyPts.length} fractions, ${neighbors.length} Farey pairs</div>`;
  html+=`<div style="margin-bottom:8px;padding:4px;background:rgba(255,215,0,.1);border-radius:4px">`;
  html+=`<strong>Sequence:</strong> `;
  html+=fareyPts.slice(0,20).map(f=>`<span style="color:#ffd700">${f.p}/${f.q}</span>`).join(' ≺ ');
  if(fareyPts.length>20)html+=` ... (+${fareyPts.length-20})`;
  html+=`</div>`;
  
  html+=`<table style="width:100%;border-collapse:collapse;font-size:.65rem">`;
  html+=`<tr style="background:rgba(150,100,255,.2);position:sticky;top:0"><th style="padding:4px">Left p/q</th><th style="padding:4px">Right p/q</th><th style="padding:4px">|det|</th><th style="padding:4px">Mediant</th><th style="padding:4px">θ₁</th><th style="padding:4px">θ₂</th></tr>`;
  neighbors.forEach(({f1,f2,mediant})=>{
    html+=`<tr style="border-bottom:1px solid rgba(255,255,255,.1)">`;
    html+=`<td style="color:#00d9ff;padding:3px">${f1.p}/${f1.q}</td>`;
    html+=`<td style="color:#ff6496;padding:3px">${f2.p}/${f2.q}</td>`;
    html+=`<td style="color:#00ff88;padding:3px">1</td>`;
    html+=`<td style="color:#ffd700;padding:3px">${mediant.p}/${mediant.q}</td>`;
    html+=`<td style="padding:3px">${(f1.angle).toFixed(2)}°</td>`;
    html+=`<td style="padding:3px">${(f2.angle).toFixed(2)}°</td>`;
    html+=`</tr>`;
  });
  html+=`</table>`;
  
  container.innerHTML=html;
}

function exportFareyNeighborsCSV(){
  if(!window.fareyNeighborsData){alert('No Farey neighbors data. Run analysis first.');return;}
  const {fractions, neighbors, fromN, toN} = window.fareyNeighborsData;
  
  let csv = 'Farey Neighbors in Sector 1/' + fromN + ' to 1/' + toN + '\n\n';
  csv += 'FRACTIONS IN SECTOR\n';
  csv += 'p,q,fraction,angle_deg\n';
  fractions.forEach(f => {
    csv += `${f.p},${f.q},${f.frac.toFixed(8)},${f.angle.toFixed(4)}\n`;
  });
  
  csv += '\nFAREY NEIGHBOR PAIRS (|ad-bc|=1)\n';
  csv += 'left_p,left_q,right_p,right_q,det,mediant_p,mediant_q,left_angle,right_angle\n';
  neighbors.forEach(({f1, f2, mediant}) => {
    csv += `${f1.p},${f1.q},${f2.p},${f2.q},1,${mediant.p},${mediant.q},${f1.angle.toFixed(4)},${f2.angle.toFixed(4)}\n`;
  });
  
  dl(csv, `farey_neighbors_sector_${fromN}_${toN}.csv`);
}

// Tree zoom and pan state
let treeZoom=1, treePanX=0, treePanY=0;
let treeDragging=false, treeLastX=0, treeLastY=0;

function resetTreeView(){
  treeZoom=1;treePanX=0;treePanY=0;
  document.getElementById('enhTreeZoom').value=1;
  document.getElementById('enhTreeZoomV').textContent='1.0×';
  const bounds=window.enhSBTreeBounds;
  if(bounds)drawSternBrocotTree(bounds.fromN,bounds.toN);
}

// Safe tree draw with node limit to prevent freezing
function safeDrawTree(){
  const depth=+document.getElementById('enhTreeDepthNum')?.value||+document.getElementById('enhTreeDepth')?.value||20;
  const stats=document.getElementById('enhTreeStats');
  
  // For sector trees, actual node count is much smaller than full tree
  // Full tree would be 2^(depth+1)-1, but sector limits this significantly
  const sectorFrom=window.enhSBTreeBounds?.fromN||3;
  const sectorTo=window.enhSBTreeBounds?.toN||2;
  const sectorWidth=1/sectorTo-1/sectorFrom;
  const estimatedNodes=Math.min(Math.pow(2,depth+1)-1, Math.ceil(sectorWidth*Math.pow(2,depth)*10));
  
  if(depth>100){
    if(stats)stats.innerHTML=`<span style="color:#ff6496">Depth ${depth} is very high. Try ≤100 for better performance.</span>`;
    // Still draw but warn
  }
  if(estimatedNodes>100000){
    if(stats)stats.innerHTML=`<span style="color:#ffd700">Drawing ~${Math.min(estimatedNodes,100000).toLocaleString()}+ nodes (may take a moment)...</span>`;
  }
  
  setTimeout(()=>drawSternBrocotTree(window.enhSBTreeBounds?.fromN||3,window.enhSBTreeBounds?.toN||2),10);
}

function drawSternBrocotTree(fromN,toN){
  const c=document.getElementById('cSternBrocot');
  if(!c)return;
  const ctx=c.getContext('2d');
  
  ctx.fillStyle='#0a0e27';
  ctx.fillRect(0,0,c.width,c.height);
  
  // Get controls
  const nodeSz=+document.getElementById('enhTreeSzNum')?.value||+document.getElementById('enhTreeSz')?.value||12;
  const maxDepth=+document.getElementById('enhTreeDepthNum')?.value||+document.getElementById('enhTreeDepth')?.value||20;
  const showLabels=document.getElementById('enhTreeLabels')?.checked??true;
  const showEdges=document.getElementById('enhTreeEdges')?.checked??true;
  const showTongues=document.getElementById('enhTreeTongues')?.checked??true;
  const zoom=+document.getElementById('enhTreeZoom')?.value||1;
  const lblSz=+document.getElementById('enhTreeLblSz')?.value||10;
  const lblFmt=document.getElementById('enhTreeLblFmt')?.value||'fraction';
  const lblCol=document.getElementById('enhTreeLblCol')?.value||'auto';
  treeZoom=zoom;
  
  // Get label color
  function getLabelColor(node, isRoot, isHighlighted, onPath, isFareyNeighbor){
    if(lblCol==='white')return '#fff';
    if(lblCol==='black')return '#000';
    if(lblCol==='gold')return '#ffd700';
    if(lblCol==='cyan')return '#00d9ff';
    // Auto: contrast based on node color
    if(isHighlighted||onPath)return '#000';
    return '#fff';
  }
  
  // Helper to format node label based on format
  function formatNodeLabel(p,q){
    switch(lblFmt){
      case 'decimal': return (p/q).toFixed(3);
      case 'angle': return ((p/q)*360).toFixed(1)+'°';
      default: return `${p}/${q}`;
    }
  }
  
  // Boundaries
  const left={p:1,q:fromN};
  const right={p:1,q:toN};
  
  // Build tree recursively with node limit
  const maxQ=enhRingsData.length>0?Math.max(...enhRingsData.map(r=>r.mod),500):500;
  const nodes=[];
  const maxNodes=200000;
  
  function buildTree(l,r,depth,x,y,width,path){
    if(depth>maxDepth||nodes.length>=maxNodes)return;
    const medP=l.p+r.p;
    const medQ=l.q+r.q;
    if(medQ>maxQ)return;
    
    const node={p:medP,q:medQ,x,y,depth,path:path||'M',left:l,right:r};
    nodes.push(node);
    
    const childY=y+Math.min(60,c.height/(maxDepth+2));
    const childW=width/2;
    buildTree(l,{p:medP,q:medQ},depth+1,x-childW,childY,childW,node.path+'L');
    buildTree({p:medP,q:medQ},r,depth+1,x+childW,childY,childW,node.path+'R');
  }
  
  const rootX=c.width/2;
  const rootY=40;
  buildTree(left,right,0,rootX,rootY,c.width/4,'');
  
  // Store globally
  window.enhSBTreeNodes = nodes;
  window.enhSBTreeBounds = {left, right, fromN, toN};
  
  // Apply zoom and pan transform
  ctx.save();
  ctx.translate(c.width/2+treePanX,c.height/2+treePanY);
  ctx.scale(zoom,zoom);
  ctx.translate(-c.width/2,-c.height/2);
  
  // Get highlighted path nodes
  const highlightPath=window.enhSBHighlightPath||[];
  const isOnPath=(node)=>highlightPath.some(h=>h.p===node.p&&h.q===node.q);
  
  // Draw Arnold tongues first (behind everything)
  if(showTongues){
    nodes.forEach(node=>{
      // Draw tongue extending down from each node
      const tongueW = c.width * 0.9 / (node.q * node.q) * 1.5;
      ctx.fillStyle = 'rgba(255,100,150,0.06)';
      ctx.beginPath();
      ctx.moveTo(node.x, node.y);
      ctx.lineTo(node.x - tongueW / 2, c.height - 10);
      ctx.lineTo(node.x + tongueW / 2, c.height - 10);
      ctx.closePath();
      ctx.fill();
    });
  }
  
  // Draw edges first
  if(showEdges){
    nodes.forEach(node=>{
      const children=nodes.filter(n=>n.depth===node.depth+1&&Math.abs(n.x-node.x)<c.width/(Math.pow(2,node.depth+1)));
      children.forEach(child=>{
        const pathEdge=isOnPath(node)&&isOnPath(child);
        ctx.strokeStyle=pathEdge?'rgba(0,255,136,0.8)':'rgba(150,100,255,0.4)';
        ctx.lineWidth=pathEdge?2/zoom:1/zoom;
        ctx.beginPath();
        ctx.moveTo(node.x,node.y+nodeSz*0.6);
        ctx.lineTo(child.x,child.y-nodeSz*0.6);
        ctx.stroke();
      });
    });
  }
  
  // Draw nodes
  nodes.forEach(node=>{
    const isRoot=node.depth===0;
    const isHighlighted=window.enhSBSelectedNode && window.enhSBSelectedNode.p===node.p && window.enhSBSelectedNode.q===node.q;
    const onPath=isOnPath(node);
    
    // Check if this node is a Farey neighbor of the selected point
    const isFareyNeighbor=enhSelectedPoint?.fareyNeighbors?.some(n=>n.p===node.p&&n.q===node.q);
    
    const r=isRoot?nodeSz*1.2:isHighlighted?nodeSz*1.1:isFareyNeighbor?nodeSz*1.05:nodeSz-node.depth*0.5;
    
    ctx.fillStyle=isHighlighted?'#00ff88':isFareyNeighbor?'#ff6496':onPath?'#00d9ff':isRoot?'#ffd700':`hsl(${node.depth*50},70%,55%)`;
    ctx.beginPath();
    ctx.arc(node.x,node.y,Math.max(4,r),0,2*Math.PI);
    ctx.fill();
    
    if(isHighlighted||onPath||isFareyNeighbor){
      ctx.strokeStyle=isHighlighted?'#00ff88':isFareyNeighbor?'#ff6496':'#00d9ff';
      ctx.lineWidth=2/zoom;
      ctx.stroke();
    }
    
    if(showLabels&&r>5){
      ctx.fillStyle=getLabelColor(node,isRoot,isHighlighted,onPath,isFareyNeighbor);
      const fontSize=isRoot?lblSz+2:Math.max(6,Math.min(lblSz,r*0.8));
      ctx.font=`${isRoot?'bold ':''}${fontSize}px Segoe UI`;
      ctx.textAlign='center';
      ctx.textBaseline='middle';
      ctx.fillText(formatNodeLabel(node.p,node.q),node.x,node.y);
    }
  });
  
  ctx.restore();
  
  // Draw boundaries (outside transform)
  ctx.fillStyle='#9664ff';
  ctx.font='10px Segoe UI';
  ctx.textAlign='left';
  ctx.fillText(formatNodeLabel(1,fromN),5,20);
  ctx.textAlign='right';
  ctx.fillText(formatNodeLabel(1,toN),c.width-5,20);
  
  // Zoom indicator
  if(zoom!==1){
    ctx.fillStyle='rgba(0,217,255,0.7)';
    ctx.font='bold 11px Segoe UI';
    ctx.textAlign='left';
    ctx.fillText(`${zoom.toFixed(1)}×`,5,c.height-8);
  }
  
  // Stats
  const treeStats=document.getElementById('enhTreeStats');
  if(treeStats){
    const maxD=nodes.length>0?Math.max(...nodes.map(n=>n.depth)):0;
    treeStats.textContent=`Tree depth: ${maxD+1} | Nodes: ${nodes.length} | Max Q: ${maxQ}`;
  }
  
  // Setup event handlers
  setupTreeEvents(c);
}

function setupTreeEvents(c){
  // Mouse wheel zoom
  c.onwheel=(e)=>{
    e.preventDefault();
    const delta=e.deltaY>0?-0.1:0.1;
    let newZoom=treeZoom+delta;
    newZoom=Math.max(0.5,Math.min(4,newZoom));
    document.getElementById('enhTreeZoom').value=newZoom;
    document.getElementById('enhTreeZoomV').textContent=newZoom.toFixed(1)+'×';
    const bounds=window.enhSBTreeBounds;
    if(bounds)drawSternBrocotTree(bounds.fromN,bounds.toN);
  };
  
  // Mouse drag pan
  c.onmousedown=(e)=>{
    if(e.button===0){
      treeDragging=true;
      treeLastX=e.clientX;
      treeLastY=e.clientY;
      c.style.cursor='grabbing';
    }
  };
  c.onmousemove=(e)=>{
    if(treeDragging){
      treePanX+=e.clientX-treeLastX;
      treePanY+=e.clientY-treeLastY;
      treeLastX=e.clientX;
      treeLastY=e.clientY;
      const bounds=window.enhSBTreeBounds;
      if(bounds)drawSternBrocotTree(bounds.fromN,bounds.toN);
    }
  };
  c.onmouseup=(e)=>{
    if(treeDragging){
      treeDragging=false;
      c.style.cursor='grab';
      // Check if it was a click (not drag)
      if(Math.abs(e.clientX-treeLastX)<5&&Math.abs(e.clientY-treeLastY)<5){
        handleSBTreeClick(e);
      }
    }
  };
  c.onmouseleave=()=>{treeDragging=false;c.style.cursor='grab';};
  
  // Touch pinch zoom
  let touchStartDist=0;
  let touchStartZoom=1;
  c.ontouchstart=(e)=>{
    if(e.touches.length===2){
      const dx=e.touches[0].clientX-e.touches[1].clientX;
      const dy=e.touches[0].clientY-e.touches[1].clientY;
      touchStartDist=Math.sqrt(dx*dx+dy*dy);
      touchStartZoom=treeZoom;
    }else if(e.touches.length===1){
      treeDragging=true;
      treeLastX=e.touches[0].clientX;
      treeLastY=e.touches[0].clientY;
    }
  };
  c.ontouchmove=(e)=>{
    e.preventDefault();
    if(e.touches.length===2){
      const dx=e.touches[0].clientX-e.touches[1].clientX;
      const dy=e.touches[0].clientY-e.touches[1].clientY;
      const dist=Math.sqrt(dx*dx+dy*dy);
      let newZoom=touchStartZoom*(dist/touchStartDist);
      newZoom=Math.max(0.5,Math.min(4,newZoom));
      document.getElementById('enhTreeZoom').value=newZoom;
      document.getElementById('enhTreeZoomV').textContent=newZoom.toFixed(1)+'×';
      const bounds=window.enhSBTreeBounds;
      if(bounds)drawSternBrocotTree(bounds.fromN,bounds.toN);
    }else if(e.touches.length===1&&treeDragging){
      treePanX+=e.touches[0].clientX-treeLastX;
      treePanY+=e.touches[0].clientY-treeLastY;
      treeLastX=e.touches[0].clientX;
      treeLastY=e.touches[0].clientY;
      const bounds=window.enhSBTreeBounds;
      if(bounds)drawSternBrocotTree(bounds.fromN,bounds.toN);
    }
  };
  c.ontouchend=()=>{treeDragging=false;};
}

// Find path to a fraction in the Stern-Brocot tree
function findSBTreePath(p,q,fromN,toN){
  const path=[];
  let left={p:1,q:fromN};
  let right={p:1,q:toN};
  const maxIter=50;
  
  for(let i=0;i<maxIter;i++){
    const medP=left.p+right.p;
    const medQ=left.q+right.q;
    path.push({p:medP,q:medQ});
    
    if(medP===p&&medQ===q)break;
    
    // Compare p/q with medP/medQ
    // p/q < medP/medQ means go left
    if(p*medQ<medP*q){
      right={p:medP,q:medQ};
    }else{
      left={p:medP,q:medQ};
    }
  }
  return path;
}

// Highlight a point from main canvas in the tree
function highlightInSBTree(p,q){
  const pathEl=document.getElementById('enhTreePath');
  const lblFmt=document.getElementById('enhTreeLblFmt')?.value||'fraction';
  
  // Helper to format
  function fmt(p,q){
    switch(lblFmt){
      case 'decimal': return (p/q).toFixed(3);
      case 'angle': return ((p/q)*360).toFixed(1)+'°';
      default: return `${p}/${q}`;
    }
  }
  
  if(!window.enhSBTreeBounds){
    if(pathEl){
      pathEl.style.display='block';
      pathEl.innerHTML=`<span style="color:#888">Tree not initialized - select sector first</span>`;
    }
    return;
  }
  const{fromN,toN}=window.enhSBTreeBounds;
  
  // Check if fraction is in sector
  const frac=p/q;
  if(frac<=1/fromN||frac>=1/toN){
    // Point is outside sector - show message
    if(pathEl){
      pathEl.style.display='block';
      pathEl.innerHTML=`<span style="color:#ff8c00">${fmt(p,q)} = ${frac.toFixed(4)} is outside sector (${fmt(1,fromN)} to ${fmt(1,toN)})</span>`;
    }
    // Clear any previous highlight
    window.enhSBHighlightPath=[];
    window.enhSBSelectedNode=null;
    drawSternBrocotTree(fromN,toN);
    return;
  }
  
  // Find path
  window.enhSBHighlightPath=findSBTreePath(p,q,fromN,toN);
  window.enhSBSelectedNode={p,q};
  
  // Update enhSBPath for audio playback
  enhSBPath=window.enhSBHighlightPath.slice();
  
  // Update path display
  if(pathEl){
    pathEl.style.display='block';
    const pathStr=window.enhSBHighlightPath.map(n=>fmt(n.p,n.q)).join(' → ');
    pathEl.innerHTML=`<strong style="color:#00ff88">Path to ${fmt(p,q)}:</strong> ${pathStr} <button onclick="playEnhPath()" style="margin-left:8px;padding:2px 8px;font-size:.7rem;border:1px solid #00ff88;background:rgba(0,255,136,.15);color:#00ff88;border-radius:3px;cursor:pointer"> Play</button><button onclick="playEnhPath(true)" style="margin-left:4px;padding:2px 6px;font-size:.7rem;border:1px solid #ff6496;background:rgba(255,100,150,.15);color:#ff6496;border-radius:3px;cursor:pointer"> Rev</button>`;
  }
  
  // Redraw tree
  drawSternBrocotTree(fromN,toN);
}

// Click handler for Stern-Brocot tree
function handleSBTreeClick(e){
  const c=document.getElementById('cSternBrocot');
  if(!c || !window.enhSBTreeNodes)return;
  
  const rect=c.getBoundingClientRect();
  let mx=(e.clientX-rect.left)*(c.width/rect.width);
  let my=(e.clientY-rect.top)*(c.height/rect.height);
  
  // Account for zoom and pan
  const zoom=treeZoom||1;
  mx=(mx-c.width/2-treePanX)/zoom+c.width/2;
  my=(my-c.height/2-treePanY)/zoom+c.height/2;
  
  // Find closest node
  const nodeSz=+document.getElementById('enhTreeSz')?.value||12;
  let closest=null, minDist=nodeSz*2/zoom;
  window.enhSBTreeNodes.forEach(node=>{
    const dist=Math.sqrt((node.x-mx)**2+(node.y-my)**2);
    if(dist<minDist){
      minDist=dist;
      closest=node;
    }
  });
  
  if(closest){
    // Add to chord if chord mode active
    if(enhChordMode){
      addToEnhChord(closest.p, closest.q);
    }
    
    // Play the note
    const baseFreq = parseFloat(document.getElementById('enhBaseFreq')?.value || 440);
    const detuneRatio = getEnhDetuneRatio();
    playEnhFrequency(baseFreq * closest.p / closest.q * detuneRatio);
    
    // Highlight in tree
    highlightInSBTree(closest.p,closest.q);
    
    // Sync with main canvas - find matching point and update selection
    syncTreeToMainCanvas(closest.p, closest.q);
  }
}

// Sync tree click to main canvas selection
function syncTreeToMainCanvas(p, q) {
  if (!enhRingsData || enhRingsData.length === 0) return;
  
  const frac = p / q;
  
  // Find a ring that contains this fraction as a coprime residue
  // The fraction p/q corresponds to residue class r where r/m reduces to p/q
  let foundRing = null;
  let foundResidue = null;
  
  for (const ring of enhRingsData) {
    // Check if q divides m (then r = p * (m/q) would give us p/q)
    if (ring.mod % q === 0) {
      const scale = ring.mod / q;
      const r = p * scale;
      if (r < ring.mod && gcd(r, ring.mod) === 1) {
        // Verify it reduces to p/q
        const g = gcd(r, ring.mod);
        if (r/g === p && ring.mod/g === q) {
          foundRing = ring;
          foundResidue = r;
          break;
        }
      }
    }
    // Also check direct match
    for (const r of ring.coprimes) {
      const g = gcd(r, ring.mod);
      if (r/g === p && ring.mod/g === q) {
        foundRing = ring;
        foundResidue = r;
        break;
      }
    }
    if (foundRing) break;
  }
  
  // If found, create selection object
  if (foundRing && foundResidue !== null) {
    const ringIdx = enhRingsData.indexOf(foundRing);
    const numRings = enhRingsData.length;
    const c = document.getElementById('cenhanced');
    const cx = c ? c.width / 2 : 400;
    const cy = c ? c.height / 2 : 400;
    const outerR = Math.min(cx, cy) - 40;
    const innerR = 30;
    const radius = innerR + (outerR - innerR) * ringIdx / (numRings - 1 || 1);
    
    const ringInc = (+document.getElementById('enhRingInc')?.value || 0) * Math.PI / 180;
    const phase = (+document.getElementById('enhPhase')?.value || 0) * Math.PI / 180;
    const invertRings = document.getElementById('enhInvertRings')?.checked;
    const actualRingIdx = invertRings ? (numRings - 1 - ringIdx) : ringIdx;
    const ringRotation = actualRingIdx * ringInc + phase;
    
    const angle = 2 * Math.PI * (foundRing.mod - foundResidue) / foundRing.mod + ringRotation;
    
    enhSelectedPoint = {
      residue: foundResidue,
      mod: foundRing.mod,
      angle: angle,
      angleDeg: (angle * 180 / Math.PI) % 360,
      gcd: 1,
      isCoprime: true,
      fraction: `${foundResidue}/${foundRing.mod}`,
      reducedFrac: `${p}/${q}`,
      ringIdx: ringIdx,
      radius: radius,
      x: radius * Math.cos(angle),
      y: radius * Math.sin(angle)
    };
    
    // Show point details
    showEnhPointDetails(enhSelectedPoint);
    
    // Find and display Farey neighbors
    const neighbors = findEnhFareyNeighbors(p, q);
    updateEnhFareyNeighborLegend(p, q, neighbors);
    enhSelectedPoint.fareyNeighbors = neighbors;
    
    // Update manual input fields
    const manP = document.getElementById('enhManualP');
    const manQ = document.getElementById('enhManualQ');
    if (manP) manP.value = p;
    if (manQ) manQ.value = q;
    
    // Redraw canvas to show selection
    drawEnhanced();
  } else {
    // No exact match found, but still update manual inputs and show info
    enhSelectedPoint = {
      residue: p,
      mod: q,
      angle: 2 * Math.PI * p / q,
      angleDeg: (p / q * 360),
      gcd: 1,
      isCoprime: true,
      fraction: `${p}/${q}`,
      reducedFrac: `${p}/${q}`,
      ringIdx: -1,
      radius: 0
    };
    
    showEnhPointDetails(enhSelectedPoint);
    
    const neighbors = findEnhFareyNeighbors(p, q);
    updateEnhFareyNeighborLegend(p, q, neighbors);
    
    const manP = document.getElementById('enhManualP');
    const manQ = document.getElementById('enhManualQ');
    if (manP) manP.value = p;
    if (manQ) manQ.value = q;
    
    drawEnhanced();
  }
}

// Show path details for selected node
function showSBTreePath(node){
  const container=document.getElementById('enhTreeStats');
  if(!container || !window.enhSBTreeBounds)return;
  
  const b=window.enhSBTreeBounds;
  
  // Build path from root
  let pathSteps=[];
  let current={p:node.p,q:node.q};
  let left={p:1,q:b.fromN};
  let right={p:1,q:b.toN};
  
  // Trace path from boundaries to this node using mediants
  function tracePath(l,r,target,steps){
    const medP=l.p+r.p;
    const medQ=l.q+r.q;
    
    if(medP===target.p && medQ===target.q){
      steps.push({frac:`${medP}/${medQ}`,dir:'ROOT',from:`${l.p}/${l.q} ⊕ ${r.p}/${r.q}`});
      return true;
    }
    
    // Compare fractions: target vs mediant
    const targetVal=target.p/target.q;
    const medVal=medP/medQ;
    
    if(targetVal<medVal){
      // Go left
      if(tracePath(l,{p:medP,q:medQ},target,steps)){
        steps.unshift({frac:`${medP}/${medQ}`,dir:'→L',from:`${l.p}/${l.q} ⊕ ${r.p}/${r.q}`});
        return true;
      }
    }else{
      // Go right
      if(tracePath({p:medP,q:medQ},r,target,steps)){
        steps.unshift({frac:`${medP}/${medQ}`,dir:'→R',from:`${l.p}/${l.q} ⊕ ${r.p}/${r.q}`});
        return true;
      }
    }
    return false;
  }
  
  tracePath(left,right,node,pathSteps);
  
  // Build continued fraction representation
  let cfrac=[];
  let p0=0,q0=1,p1=1,q1=0;
  let num=node.p,den=node.q;
  while(den>0){
    const a=Math.floor(num/den);
    cfrac.push(a);
    [num,den]=[den,num-a*den];
    [p0,p1]=[p1,a*p1+p0];
    [q0,q1]=[q1,a*q1+q0];
    if(cfrac.length>20)break;
  }
  
  // Display
  let html=`<span style="color:#ffd700">Selected: ${node.p}/${node.q}</span> `;
  html+=`<span style="color:#00d9ff">= ${(node.p/node.q).toFixed(6)}</span> `;
  html+=`<span style="color:#9664ff">θ = ${(360*node.p/node.q).toFixed(2)}°</span> `;
  html+=`<span style="color:#00ff88">[${cfrac.join(';')}]</span> `;
  html+=`<span style="color:#888">Path: ${node.path||'M'}</span>`;
  
  container.innerHTML=html;
}

function enhPrimePreset(n){
document.getElementById('enhPrimeStart').value=2;
document.getElementById('enhPrimeEnd').value=n;
enhRunPrimeSieve();
}

function sieveOfEratosthenes(limit){
const sieve=new Array(limit+1).fill(true);
sieve[0]=sieve[1]=false;
for(let i=2;i*i<=limit;i++){
if(sieve[i]){
for(let j=i*i;j<=limit;j+=i)sieve[j]=false;
}}
const primes=[];
for(let i=2;i<=limit;i++)if(sieve[i])primes.push(i);
return primes;
}

// Animated Sector Sweep
let sectorSweepId = null;
let sectorSweepN = 2;
let sectorSweepDir = 1;

function animateSectorSweep() {
  if (sectorSweepId) {
    stopSectorSweep();
    return;
  }
  
  document.getElementById('sectorSweepBtn').textContent = 'Sector Sweep ';
  document.getElementById('sectorSweepBtn').style.background = 'rgba(255,215,0,.4)';
  
  sectorSweepN = 2;
  sectorSweepDir = 1;
  
  function step() {
    // Update sector
    document.getElementById('enhSectorFrom').value = sectorSweepN + 1;
    document.getElementById('enhSectorTo').value = sectorSweepN;
    updateEnhSector();
    drawEnhanced();
    
    // Move to next sector
    sectorSweepN += sectorSweepDir;
    
    // Bounce at limits
    if (sectorSweepN >= 15) {
      sectorSweepDir = -1;
    } else if (sectorSweepN <= 2) {
      sectorSweepDir = 1;
    }
    
    sectorSweepId = setTimeout(step, 800);
  }
  
  step();
}

function stopSectorSweep() {
  if (sectorSweepId) {
    clearTimeout(sectorSweepId);
    sectorSweepId = null;
  }
  document.getElementById('sectorSweepBtn').textContent = 'Sector Sweep ';
  document.getElementById('sectorSweepBtn').style.background = 'rgba(255,215,0,.15)';
}

function enhRunPrimeSieve(){
const start=Math.max(2,+document.getElementById('enhPrimeStart').value||2);
const end=Math.max(start,+document.getElementById('enhPrimeEnd').value||1000);
const results=document.getElementById('enhPrimeResults');
results.style.display='block';
results.innerHTML='<em style="color:#ffd700">Analyzing primes...</em>';

setTimeout(()=>{
// Get actual primes in range
const allPrimes=sieveOfEratosthenes(end);
const primesInRange=allPrimes.filter(p=>p>=start&&p<=end);
const actualCount=primesInRange.length;

// Get moduli from current selection
const moduli=enhGetModuli();
if(moduli.length===0){
results.innerHTML='<span style="color:#ff6496">No moduli selected. Set a range first.</span>';
return;
}

// For each modulus, count admissible residues and primes hitting them
const analysis=[];
let totalAdmissible=0;
let totalHits=0;

moduli.forEach(M=>{
if(M<2)return;
const coprimes=getCoprimes(M);
const admissibleCount=coprimes.length; // φ(M)

// Count primes in each residue class
const residueCounts={};
coprimes.forEach(r=>residueCounts[r]=0);

primesInRange.forEach(p=>{
const r=p%M;
if(coprimes.includes(r))residueCounts[r]++;
});

const primesInAdmissible=Object.values(residueCounts).reduce((s,c)=>s+c,0);
const expectedPerClass=actualCount/admissibleCount;
const density=primesInAdmissible/actualCount;

analysis.push({M,phi:admissibleCount,primesHit:primesInAdmissible,density,expectedPerClass,residueCounts});
totalAdmissible+=admissibleCount;
totalHits+=primesInAdmissible;
});

// Use largest modulus for detailed analysis
const largestM=Math.max(...moduli);
const mainAnalysis=analysis.find(a=>a.M===largestM);

// Predicted vs actual using Li(x) approximation
const li=x=>x>1?x/Math.log(x):0;
const liPredicted=li(end)-li(Math.max(2,start-1));

// Wessen-style density calculation
const C_M=mainAnalysis?mainAnalysis.phi/largestM:1;
const predictedByDensity=Math.round((end-start)*C_M/Math.log(end));

// Twin prime analysis if gap 2 is selected
let twinAnalysis='';
const gaps=enhGetGaps();
if(gaps.includes(2)&&mainAnalysis){
let twinCount=0;
for(let i=0;i<primesInRange.length-1;i++){
if(primesInRange[i+1]-primesInRange[i]===2)twinCount++;
}
// Count admissible twin pairs in residue classes
let admissibleTwinPairs=0;
const coprimes=getCoprimes(largestM);
coprimes.forEach(r=>{
const r2=(r+2)%largestM;
if(coprimes.includes(r2))admissibleTwinPairs++;
});
const twinDensity=admissibleTwinPairs/largestM;
twinAnalysis=`
<div style="margin-top:8px;padding:8px;background:rgba(255,100,150,.1);border-radius:4px;border:1px solid rgba(255,100,150,.3)">
<strong style="color:#ff6496">Twin Prime Analysis (gap=2)</strong>
<div style="display:grid;grid-template-columns:1fr 1fr;gap:4px;margin-top:4px;font-size:.75rem">
<span>Actual twins: <strong style="color:#ffd700">${twinCount}</strong></span>
<span>Admissible pairs: <strong style="color:#00ff88">${admissibleTwinPairs}</strong></span>
<span>Twin density: <strong style="color:#00d9ff">${fmt(twinDensity)}</strong></span>
<span>Expected ratio: <strong style="color:#9664ff">${fmt(twinCount/(admissibleTwinPairs||1))}</strong></span>
</div>
</div>`;
}

// Accuracy calculation
const accuracy=actualCount>0?(totalHits/actualCount)*100:0;
const liAccuracy=liPredicted>0?(actualCount/liPredicted)*100:0;

results.innerHTML=`
<div style="background:linear-gradient(135deg,rgba(0,255,136,.15),rgba(0,217,255,.1));padding:10px;border-radius:6px;margin-bottom:8px;border:1px solid #00ff88">
<div style="font-size:.9rem;font-weight:bold;color:#00ff88;margin-bottom:6px">Prime Sieve Results: ${start.toLocaleString()} to ${end.toLocaleString()}</div>
<div style="display:grid;grid-template-columns:repeat(3,1fr);gap:8px">
<div style="text-align:center;padding:8px;background:var(--bg1);border-radius:4px">
<div style="font-size:1.4rem;font-weight:bold;color:#ffd700">${actualCount.toLocaleString()}</div>
<div style="font-size:.65rem;color:var(--txt2)">ACTUAL π(${end.toLocaleString()})</div>
</div>
<div style="text-align:center;padding:8px;background:var(--bg1);border-radius:4px">
<div style="font-size:1.4rem;font-weight:bold;color:#00d9ff">${Math.round(liPredicted).toLocaleString()}</div>
<div style="font-size:.65rem;color:var(--txt2)">Li(x) PREDICTED</div>
</div>
<div style="text-align:center;padding:8px;background:var(--bg1);border-radius:4px">
<div style="font-size:1.4rem;font-weight:bold;color:${Math.abs(liAccuracy-100)<5?'#00ff88':'#ff8c00'}">${fmt(liAccuracy)}%</div>
<div style="font-size:.65rem;color:var(--txt2)">Li ACCURACY</div>
</div>
</div>
</div>
<div style="margin-bottom:8px;padding:8px;background:var(--bg1);border-radius:6px">
<strong style="color:#9664ff;font-size:.85rem">Admissible Residue Analysis (M=${largestM})</strong>
<div style="display:grid;grid-template-columns:1fr 1fr;gap:6px;margin-top:6px;font-size:.75rem">
<span>φ(M) admissible classes: <strong style="color:#ffd700">${mainAnalysis?.phi||0}</strong></span>
<span>Primes in admissible: <strong style="color:#00ff88">${mainAnalysis?.primesHit||0}</strong></span>
<span>C(M) = φ/M: <strong style="color:#00d9ff">${mainAnalysis?fmt(mainAnalysis.phi/largestM):'—'}</strong></span>
<span>Capture rate: <strong style="color:${accuracy>99?'#00ff88':'#ff8c00'}">${fmt(accuracy)}%</strong></span>
</div>
<div style="font-size:.7rem;color:var(--txt2);margin-top:6px">
All primes p>${largestM} fall into coprime residue classes mod M. Capture rate shows what % of primes land in φ(M) admissible slots.
</div>
</div>
${twinAnalysis}
<div style="padding:8px;background:var(--bg1);border-radius:6px">
<strong style="color:var(--acc);font-size:.8rem">Per-Modulus Breakdown:</strong>
<div style="font-size:.7rem;margin-top:4px;max-height:100px;overflow-y:auto">
${analysis.slice(0,10).map(a=>`<div style="display:flex;justify-content:space-between;padding:2px 0;border-bottom:1px solid rgba(255,255,255,.1)">
<span>M=${a.M}</span>
<span>φ=${a.phi}</span>
<span>hits=${a.primesHit}</span>
<span style="color:${a.density>0.99?'#00ff88':'#ff8c00'}">${fmt(a.density*100)}%</span>
</div>`).join('')}
${analysis.length>10?`<div style="color:var(--txt2);padding:4px 0">...+${analysis.length-10} more moduli</div>`:''}
</div>
</div>
`;
},10);
}

// ===== MODULAR PRIME SIEVE =====
let modSieveData = { primes: [], M: 30, currentN: 0, animId: null, residueCounts: {}, gap: 0 };

function setModSievePreset(M, N) {
document.getElementById('modSieveM').value = Math.min(210, M);
document.getElementById('modSieveMv').value = M;
document.getElementById('modSieveN').value = Math.min(100000, N);
document.getElementById('modSieveNv').value = N;
drawModSieve();
}

function setModSieveGap(g) {
modSieveData.gap = g;
// Update button styles
document.querySelectorAll('.gapsel').forEach(b => b.style.background = '#333');
const btn = document.getElementById('gapBtn' + g);
if (btn) btn.style.background = g === 0 ? '#333' : 'linear-gradient(45deg,#ff6496,#ffd700)';
drawModSieve();
}

function drawModSieve() {
if(!document.getElementById("cModSieve")) return;

const c1 = document.getElementById('cmodsieve'), ctx1 = c1.getContext('2d');
const c2 = document.getElementById('cmodsievebar'), ctx2 = c2.getContext('2d');
const M = +document.getElementById('modSieveMv').value || 30;
const maxN = +document.getElementById('modSieveNv').value || 10000;
const ptSize = +document.getElementById('modSievePtSize').value || 6;
const showLabels = document.getElementById('modSieveLabels')?.checked;
const showGrid = document.getElementById('modSieveGrid')?.checked;
const showExpected = document.getElementById('modSieveExpected')?.checked;
const showGapArcs = document.getElementById('modSieveGapArcs')?.checked;
const gap = modSieveData.gap || 0;

// Generate primes up to maxN
const primes = sieveOfEratosthenes(maxN);
modSieveData.primes = primes;
modSieveData.M = M;

// Get coprime residues
const coprimes = [];
for (let r = 1; r < M; r++) if (gcd(r, M) === 1) coprimes.push(r);
const phi = coprimes.length;

// Count primes in each residue class
const residueCounts = {};
coprimes.forEach(r => residueCounts[r] = 0);
primes.forEach(p => {
const r = p % M;
if (residueCounts[r] !== undefined) residueCounts[r]++;
});
modSieveData.residueCounts = residueCounts;
modSieveData.currentN = maxN;

// === CANVAS 1: Unit Circle ===
ctx1.fillStyle = canvBg();
ctx1.fillRect(0, 0, c1.width, c1.height);

const cx = c1.width / 2, cy = c1.height / 2;
const radius = Math.min(cx, cy) - 60;

// Draw grid circles
if (showGrid) {
ctx1.strokeStyle = gridC();
ctx1.lineWidth = 1;
for (let r = 0.25; r <= 1; r += 0.25) {
ctx1.beginPath();
ctx1.arc(cx, cy, radius * r, 0, 2 * PI);
ctx1.stroke();
}
// Draw axes
ctx1.beginPath();
ctx1.moveTo(cx - radius - 20, cy);
ctx1.lineTo(cx + radius + 20, cy);
ctx1.moveTo(cx, cy - radius - 20);
ctx1.lineTo(cx, cy + radius + 20);
ctx1.stroke();
}

// Draw unit circle
ctx1.strokeStyle = '#ffd700';
ctx1.lineWidth = 2;
ctx1.beginPath();
ctx1.arc(cx, cy, radius, 0, 2 * PI);
ctx1.stroke();

// Find max count for scaling
const maxCount = Math.max(...Object.values(residueCounts), 1);
const expected = primes.length / phi;

// Store point positions for click detection
modSieveData.points = [];
modSieveData.primesInClass = {};
coprimes.forEach(r => modSieveData.primesInClass[r] = primes.filter(p => p % M === r));

// Draw coprime points
coprimes.forEach(r => {
const angle = 2 * PI * r / M - PI / 2; // Start from top
const x = cx + radius * Math.cos(angle);
const y = cy + radius * Math.sin(angle);
const count = residueCounts[r];
const ratio = count / expected;

// Size based on count
const size = ptSize + (count / maxCount) * ptSize * 2;

// Store for click detection
modSieveData.points.push({ r, x, y, size, count, angle, M });

// Color based on ratio to expected (green = close to expected)
const hue = ratio > 1.1 ? 0 : ratio < 0.9 ? 240 : 120;
const sat = Math.min(100, Math.abs(ratio - 1) * 200);
ctx1.fillStyle = `hsl(${hue}, ${sat}%, 60%)`;

ctx1.beginPath();
ctx1.arc(x, y, size, 0, 2 * PI);
ctx1.fill();

// Label
if (showLabels && phi <= 48) {
ctx1.fillStyle = isDark() ? '#fff' : '#333';
ctx1.font = '11px Segoe UI';
ctx1.textAlign = 'center';
const lx = cx + (radius + 25) * Math.cos(angle);
const ly = cy + (radius + 25) * Math.sin(angle);
ctx1.fillText(`${r}`, lx, ly + 4);
// Count below
ctx1.font = '9px Segoe UI';
ctx1.fillStyle = '#ffd700';
ctx1.fillText(`(${count})`, lx, ly + 15);
}
});

// Draw gap arcs if enabled
if (showGapArcs && gap > 0) {
ctx1.strokeStyle = 'rgba(255,100,150,0.6)';
ctx1.lineWidth = 2;
coprimes.forEach(r => {
const r2 = (r + gap) % M;
if (coprimes.includes(r2)) {
const angle1 = 2 * PI * r / M - PI / 2;
const angle2 = 2 * PI * r2 / M - PI / 2;
const x1 = cx + radius * Math.cos(angle1);
const y1 = cy + radius * Math.sin(angle1);
const x2 = cx + radius * Math.cos(angle2);
const y2 = cy + radius * Math.sin(angle2);
ctx1.beginPath();
ctx1.moveTo(x1, y1);
// Draw arc through center for visual
const midAngle = (angle1 + angle2) / 2;
const midR = radius * 0.6;
const mx = cx + midR * Math.cos(midAngle);
const my = cy + midR * Math.sin(midAngle);
ctx1.quadraticCurveTo(mx, my, x2, y2);
ctx1.stroke();
}
});
}

// Title
ctx1.fillStyle = isDark() ? '#ffd700' : '#cc8800';
ctx1.font = 'bold 16px Segoe UI';
ctx1.textAlign = 'center';
ctx1.fillText(`Primes mod ${M} on Unit Circle (N ≤ ${maxN.toLocaleString()})${gap > 0 ? ' | Gap '+gap : ''}`, cx, 25);

// === CANVAS 2: Bar Chart ===
ctx2.fillStyle = canvBg();
ctx2.fillRect(0, 0, c2.width, c2.height);

const barPad = 50;
const barW = (c2.width - barPad * 2) / phi;
const barMaxH = c2.height - 100;

// Draw expected line
if (showExpected) {
const expectedY = c2.height - barPad - (expected / maxCount) * barMaxH;
ctx2.strokeStyle = '#ff6496';
ctx2.lineWidth = 2;
ctx2.setLineDash([8, 4]);
ctx2.beginPath();
ctx2.moveTo(barPad, expectedY);
ctx2.lineTo(c2.width - barPad, expectedY);
ctx2.stroke();
ctx2.setLineDash([]);
ctx2.fillStyle = '#ff6496';
ctx2.font = '11px Segoe UI';
ctx2.textAlign = 'right';
ctx2.fillText(`Expected: ${expected.toFixed(1)}`, c2.width - barPad, expectedY - 5);
}

// Draw bars
coprimes.forEach((r, i) => {
const count = residueCounts[r];
const barH = (count / maxCount) * barMaxH;
const x = barPad + i * barW;
const y = c2.height - barPad - barH;

// Bar color
const ratio = count / expected;
const hue = ratio > 1.1 ? 0 : ratio < 0.9 ? 240 : 120;
ctx2.fillStyle = `hsl(${hue}, 70%, 55%)`;
ctx2.fillRect(x + 2, y, barW - 4, barH);

// Residue label
if (phi <= 48) {
ctx2.fillStyle = isDark() ? '#fff' : '#333';
ctx2.font = '10px Segoe UI';
ctx2.textAlign = 'center';
ctx2.fillText(`${r}`, x + barW / 2, c2.height - barPad + 15);
}

// Count on top
ctx2.fillStyle = '#ffd700';
ctx2.font = '9px Segoe UI';
ctx2.fillText(`${count}`, x + barW / 2, y - 5);
});

// Axes
ctx2.strokeStyle = isDark() ? '#fff' : '#333';
ctx2.lineWidth = 1;
ctx2.beginPath();
ctx2.moveTo(barPad, barPad);
ctx2.lineTo(barPad, c2.height - barPad);
ctx2.lineTo(c2.width - barPad, c2.height - barPad);
ctx2.stroke();

// Y-axis labels
ctx2.fillStyle = isDark() ? '#fff' : '#333';
ctx2.font = '10px Segoe UI';
ctx2.textAlign = 'right';
for (let i = 0; i <= 4; i++) {
const val = Math.round(maxCount * i / 4);
const y = c2.height - barPad - (i / 4) * barMaxH;
ctx2.fillText(`${val}`, barPad - 5, y + 4);
}

// Title
ctx2.fillStyle = isDark() ? '#00ff88' : '#008844';
ctx2.font = 'bold 14px Segoe UI';
ctx2.textAlign = 'center';
ctx2.fillText(`Prime Count per Residue Class mod ${M}`, c2.width / 2, 20);

// Legend
legend('almodsieve', 'Modular Prime Sieve', [
['M', M, '#ffd700'],
['φ(M)', phi, '#00ff88'],
['π(N)', primes.length, '#00d9ff']
]);

// Stats
updateModSieveStats(M, phi, primes.length, maxN, residueCounts, expected);

// Set up click handler for unit circle
setupModSieveClick(c1);
}

function setupModSieveClick(canvas) {
canvas.onclick = function(e) {
const rect = canvas.getBoundingClientRect();
const mx = (e.clientX - rect.left) * (canvas.width / rect.width);
const my = (e.clientY - rect.top) * (canvas.height / rect.height);

for (const pt of modSieveData.points || []) {
const dist = Math.hypot(mx - pt.x, my - pt.y);
if (dist < pt.size + 8) {
const primesInClass = modSieveData.primesInClass[pt.r] || [];
const first20 = primesInClass.slice(0, 20);
const last5 = primesInClass.length > 25 ? primesInClass.slice(-5) : [];

modal(`Residue Class r = ${pt.r} (mod ${pt.M})`, [
['Residue r', pt.r],
['Modulus M', pt.M],
['Angle', `2π × ${pt.r}/${pt.M} = ${(pt.angle * 180 / PI + 90).toFixed(2)}°`],
['Prime count', pt.count],
['Expected', (modSieveData.primes.length / Object.keys(modSieveData.residueCounts).length).toFixed(2)],
['First primes', first20.join(', ') + (primesInClass.length > 20 ? '...' : '')],
primesInClass.length > 25 ? ['Last primes', '...' + last5.join(', ')] : null,
['Smallest prime', primesInClass[0] || 'N/A'],
['Largest prime', primesInClass[primesInClass.length - 1] || 'N/A']
].filter(x => x));
return;
}
}
};
}

function updateModSieveStats(M, phi, totalPrimes, N, residueCounts, expected) {
const counts = Object.values(residueCounts);
const mean = counts.reduce((a, b) => a + b, 0) / counts.length;
const variance = counts.reduce((s, c) => s + (c - mean) ** 2, 0) / counts.length;
const stdDev = Math.sqrt(variance);
const cv = stdDev / mean;
const maxCount = Math.max(...counts);
const minCount = Math.min(...counts);
const maxR = Object.entries(residueCounts).find(([r, c]) => c === maxCount)?.[0];
const minR = Object.entries(residueCounts).find(([r, c]) => c === minCount)?.[0];

document.getElementById('modSieveLiveStats').innerHTML = `
<div style="display:grid;grid-template-columns:repeat(3,1fr);gap:8px;margin-bottom:12px">
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center">
<div style="font-size:1.5rem;font-weight:bold;color:#ffd700">${M}</div>
<div style="font-size:.7rem;color:var(--txt2)">MODULUS M</div>
</div>
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center">
<div style="font-size:1.5rem;font-weight:bold;color:#00ff88">${phi}</div>
<div style="font-size:.7rem;color:var(--txt2)">φ(M) CLASSES</div>
</div>
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center">
<div style="font-size:1.5rem;font-weight:bold;color:#00d9ff">${totalPrimes.toLocaleString()}</div>
<div style="font-size:.7rem;color:var(--txt2)">π(${N.toLocaleString()})</div>
</div>
</div>
<div style="margin-bottom:10px;padding:10px;background:linear-gradient(135deg,rgba(0,255,136,.1),rgba(255,215,0,.1));border-radius:6px;border:1px solid rgba(0,255,136,.3)">
<strong style="color:#00ff88">Dirichlet Equidistribution</strong>
<div style="display:grid;grid-template-columns:1fr 1fr;gap:4px;margin-top:6px;font-size:.8rem">
<span>Expected per class:</span><span style="color:#ff6496;font-weight:bold">${expected.toFixed(2)}</span>
<span>Actual mean:</span><span style="color:#ffd700;font-weight:bold">${mean.toFixed(2)}</span>
<span>Std deviation:</span><span style="color:#00d9ff">${stdDev.toFixed(2)}</span>
<span>CV (lower = better):</span><span style="color:${cv < 0.1 ? '#00ff88' : cv < 0.2 ? '#ffd700' : '#ff6496'}">${(cv * 100).toFixed(2)}%</span>
</div>
</div>
<div style="margin-bottom:10px;padding-bottom:8px;border-bottom:1px solid var(--bord)">
<strong style="color:var(--acc)">Residue Class Extremes</strong>
<div style="display:grid;grid-template-columns:1fr 1fr;gap:4px;margin-top:6px;font-size:.8rem">
<span>Max: r≡${maxR} (mod ${M})</span><span style="color:#00ff88;font-weight:bold">${maxCount} primes</span>
<span>Min: r≡${minR} (mod ${M})</span><span style="color:#ff6496;font-weight:bold">${minCount} primes</span>
<span>Spread (max-min):</span><span style="color:#9664ff">${maxCount - minCount}</span>
<span>Ratio max/min:</span><span style="color:var(--txt)">${(maxCount / minCount).toFixed(3)}</span>
</div>
</div>
${getGapAnalysisHTML(M, modSieveData.primes, N)}
${modularSieveHTML(M, modSieveData.gap || 2, 'Modular Sieve (M)')}
<div style="padding:8px;background:var(--bg1);border-radius:6px;margin-top:10px">
<strong style="color:var(--acc);font-size:.8rem">Primes per Residue Class</strong>
<div style="font-size:.75rem;color:var(--txt2);margin-top:4px">
${Object.entries(residueCounts).slice(0, 10).map(([r, c]) => 
`<span style="display:inline-block;margin:2px;padding:2px 6px;background:rgba(255,215,0,.12);border-radius:3px">r=${r}: ${c}</span>`
).join('')}${phi > 10 ? `<span style="opacity:.6">+${phi - 10} more</span>` : ''}
</div>
</div>`;
}

// Gap analysis for prime pairs
function getGapAnalysisHTML(M, primes, maxN) {
const gap = modSieveData.gap;
if (!gap || gap === 0) return '';

// Get coprime residues
const coprimes = [];
for (let r = 1; r < M; r++) if (gcd(r, M) === 1) coprimes.push(r);

// Count admissible gap pairs (residue pairs where both r and r+g are coprime)
const admissiblePairs = [];
coprimes.forEach(r => {
const r2 = (r + gap) % M;
if (coprimes.includes(r2)) admissiblePairs.push([r, r2]);
});

// Count actual prime pairs with this gap
let primePairs = 0;
const pairsByResidue = {};
admissiblePairs.forEach(([r1, r2]) => pairsByResidue[r1 + '->' + r2] = 0);

for (let i = 0; i < primes.length - 1; i++) {
const p = primes[i];
const q = primes[i + 1];
if (q - p === gap) {
primePairs++;
const r1 = p % M;
const r2 = q % M;
const key = r1 + '->' + r2;
if (pairsByResidue[key] !== undefined) pairsByResidue[key]++;
}
}

// Gap distribution (counts of prime gaps 2,4,6,8,... up to 30)
const gapDist = {};
for (let g = 2; g <= 30; g += 2) gapDist[g] = 0;
for (let i = 0; i < primes.length - 1; i++) {
const d = primes[i + 1] - primes[i];
if (d <= 30 && d % 2 === 0) gapDist[d]++;
}

return `
<div style="margin-bottom:10px;padding:10px;background:linear-gradient(135deg,rgba(255,100,150,.1),rgba(150,100,255,.1));border-radius:6px;border:1px solid rgba(255,100,150,.3)">
<strong style="color:#ff6496">Gap ${gap} Analysis (Twin Prime Type)</strong>
<div style="display:grid;grid-template-columns:1fr 1fr;gap:4px;margin-top:6px;font-size:.8rem">
<span>Admissible pairs (mod ${M}):</span><span style="color:#ffd700;font-weight:bold">${admissiblePairs.length}</span>
<span>Actual prime pairs (gap=${gap}):</span><span style="color:#00ff88;font-weight:bold">${primePairs}</span>
<span>Expected density:</span><span style="color:#00d9ff">${(admissiblePairs.length / M).toFixed(4)}</span>
</div>
<div style="font-size:.7rem;color:var(--txt2);margin-top:6px">
Pairs by residue: ${Object.entries(pairsByResidue).slice(0, 6).map(([k, v]) => 
`<span style="padding:1px 4px;background:rgba(255,215,0,.1);border-radius:2px;margin:1px">${k}: ${v}</span>`
).join('')}${Object.keys(pairsByResidue).length > 6 ? '...' : ''}
</div>
</div>
<div style="margin-bottom:10px;padding:8px;background:var(--bg1);border-radius:6px">
<strong style="color:var(--acc);font-size:.8rem">Prime Gap Distribution (up to N=${maxN.toLocaleString()})</strong>
<div style="font-size:.75rem;color:var(--txt2);margin-top:4px">
${Object.entries(gapDist).map(([g, c]) => 
`<span style="display:inline-block;margin:2px;padding:2px 6px;background:${+g === gap ? 'rgba(255,100,150,.3)' : 'rgba(0,217,255,.12)'};border-radius:3px;${+g === gap ? 'font-weight:bold;color:#ff6496' : ''}">g=${g}: ${c}</span>`
).join('')}
</div>
</div>`;
}

let modSieveAnimId = null;
let modSieveAnimN = 0;

function toggleModSieveAnim() {
const btn = document.getElementById('modSievePlayBtn');
if (modSieveAnimId) {
clearInterval(modSieveAnimId);
modSieveAnimId = null;
btn.textContent = 'Play';
btn.style.background = 'linear-gradient(45deg,#ffd700,#ff6496)';
} else {
const maxN = +document.getElementById('modSieveNv').value || 10000;
const speed = +document.getElementById('modSieveSpeed').value || 10;
if (modSieveAnimN === 0 || modSieveAnimN >= maxN) modSieveAnimN = 100;

btn.textContent = ' Pause';
btn.style.background = 'linear-gradient(45deg,#ff6496,#9664ff)';

modSieveAnimId = setInterval(() => {
const step = Math.max(10, Math.floor(modSieveAnimN / 20)) * speed;
modSieveAnimN = Math.min(modSieveAnimN + step, maxN);
drawModSieveAnimFrame(modSieveAnimN);
if (modSieveAnimN >= maxN) {
clearInterval(modSieveAnimId);
modSieveAnimId = null;
btn.textContent = 'Play';
btn.style.background = 'linear-gradient(45deg,#ffd700,#ff6496)';
}
}, 50);
}
}

function resetModSieveAnim() {
if (modSieveAnimId) {
clearInterval(modSieveAnimId);
modSieveAnimId = null;
}
modSieveAnimN = 0;
document.getElementById('modSievePlayBtn').textContent = 'Play';
document.getElementById('modSievePlayBtn').style.background = 'linear-gradient(45deg,#ffd700,#ff6496)';
drawModSieve();
}

function drawModSieveAnimFrame(currentN) {
const c1 = document.getElementById('cmodsieve'), ctx1 = c1.getContext('2d');
const c2 = document.getElementById('cmodsievebar'), ctx2 = c2.getContext('2d');
const M = +document.getElementById('modSieveMv').value || 30;
const ptSize = +document.getElementById('modSievePtSize').value || 6;
const showLabels = document.getElementById('modSieveLabels')?.checked;
const showGrid = document.getElementById('modSieveGrid')?.checked;
const showExpected = document.getElementById('modSieveExpected')?.checked;

// Get primes up to currentN
const primes = modSieveData.primes.filter(p => p <= currentN);
const totalPrimes = primes.length;

// Get coprime residues
const coprimes = [];
for (let r = 1; r < M; r++) if (gcd(r, M) === 1) coprimes.push(r);
const phi = coprimes.length;

// Count primes in each residue class
const residueCounts = {};
coprimes.forEach(r => residueCounts[r] = 0);
primes.forEach(p => {
const r = p % M;
if (residueCounts[r] !== undefined) residueCounts[r]++;
});

// === CANVAS 1: Unit Circle ===
ctx1.fillStyle = canvBg();
ctx1.fillRect(0, 0, c1.width, c1.height);

const cx = c1.width / 2, cy = c1.height / 2;
const radius = Math.min(cx, cy) - 60;

if (showGrid) {
ctx1.strokeStyle = gridC();
ctx1.lineWidth = 1;
for (let r = 0.25; r <= 1; r += 0.25) {
ctx1.beginPath();
ctx1.arc(cx, cy, radius * r, 0, 2 * PI);
ctx1.stroke();
}
ctx1.beginPath();
ctx1.moveTo(cx - radius - 20, cy);
ctx1.lineTo(cx + radius + 20, cy);
ctx1.moveTo(cx, cy - radius - 20);
ctx1.lineTo(cx, cy + radius + 20);
ctx1.stroke();
}

ctx1.strokeStyle = '#ffd700';
ctx1.lineWidth = 2;
ctx1.beginPath();
ctx1.arc(cx, cy, radius, 0, 2 * PI);
ctx1.stroke();

const maxCount = Math.max(...Object.values(residueCounts), 1);
const expected = totalPrimes / phi;

coprimes.forEach(r => {
const angle = 2 * PI * r / M - PI / 2;
const x = cx + radius * Math.cos(angle);
const y = cy + radius * Math.sin(angle);
const count = residueCounts[r];
const ratio = count / (expected || 1);
const size = ptSize + (count / maxCount) * ptSize * 2;
const hue = ratio > 1.1 ? 0 : ratio < 0.9 ? 240 : 120;
const sat = Math.min(100, Math.abs(ratio - 1) * 200);
ctx1.fillStyle = `hsl(${hue}, ${sat}%, 60%)`;
ctx1.beginPath();
ctx1.arc(x, y, size, 0, 2 * PI);
ctx1.fill();
});

ctx1.fillStyle = isDark() ? '#ffd700' : '#cc8800';
ctx1.font = 'bold 16px Segoe UI';
ctx1.textAlign = 'center';
ctx1.fillText(`Primes mod ${M} — N = ${currentN.toLocaleString()} (π = ${totalPrimes})`, cx, 25);

// Progress arc
const progress = currentN / (+document.getElementById('modSieveNv').value || 10000);
ctx1.strokeStyle = '#00ff88';
ctx1.lineWidth = 4;
ctx1.beginPath();
ctx1.arc(cx, cy, radius + 15, -PI / 2, -PI / 2 + progress * 2 * PI);
ctx1.stroke();

// === CANVAS 2: Bar Chart ===
ctx2.fillStyle = canvBg();
ctx2.fillRect(0, 0, c2.width, c2.height);

const barPad = 50;
const barW = (c2.width - barPad * 2) / phi;
const barMaxH = c2.height - 100;

if (showExpected && expected > 0) {
const expectedY = c2.height - barPad - (expected / maxCount) * barMaxH;
ctx2.strokeStyle = '#ff6496';
ctx2.lineWidth = 2;
ctx2.setLineDash([8, 4]);
ctx2.beginPath();
ctx2.moveTo(barPad, expectedY);
ctx2.lineTo(c2.width - barPad, expectedY);
ctx2.stroke();
ctx2.setLineDash([]);
ctx2.fillStyle = '#ff6496';
ctx2.font = '11px Segoe UI';
ctx2.textAlign = 'right';
ctx2.fillText(`Expected: ${expected.toFixed(1)}`, c2.width - barPad, expectedY - 5);
}

coprimes.forEach((r, i) => {
const count = residueCounts[r];
const barH = (count / maxCount) * barMaxH;
const x = barPad + i * barW;
const y = c2.height - barPad - barH;
const ratio = count / (expected || 1);
const hue = ratio > 1.1 ? 0 : ratio < 0.9 ? 240 : 120;
ctx2.fillStyle = `hsl(${hue}, 70%, 55%)`;
ctx2.fillRect(x + 2, y, barW - 4, barH);
});

ctx2.strokeStyle = isDark() ? '#fff' : '#333';
ctx2.lineWidth = 1;
ctx2.beginPath();
ctx2.moveTo(barPad, barPad);
ctx2.lineTo(barPad, c2.height - barPad);
ctx2.lineTo(c2.width - barPad, c2.height - barPad);
ctx2.stroke();

ctx2.fillStyle = isDark() ? '#00ff88' : '#008844';
ctx2.font = 'bold 14px Segoe UI';
ctx2.textAlign = 'center';
ctx2.fillText(`N = ${currentN.toLocaleString()} | π(N) = ${totalPrimes} | Expected/class = ${expected.toFixed(1)}`, c2.width / 2, 20);

// Update stats
updateModSieveStats(M, phi, totalPrimes, currentN, residueCounts, expected);
legend('almodsieve', 'Modular Prime Sieve', [['N', currentN, '#ffd700'], ['π(N)', totalPrimes, '#00ff88'], ['φ(M)', phi, '#00d9ff']]);
}

function csvModSieve() {
const M = modSieveData.M;
const counts = modSieveData.residueCounts;
let csv = 'residue,prime_count,angle_deg\n';
Object.entries(counts).forEach(([r, count]) => {
csv += `${r},${count},${(360 * r / M).toFixed(2)}\n`;
});
dl(csv, `prime_sieve_mod${M}.csv`);
}

async function screenshotModSieve() {
await screenshotUnified('cmodsieve', 'modSieveLiveStats', `Modular Prime Sieve mod ${modSieveData.M}`, 'modular_prime_sieve.png');
}

function exportAllModSieve() {
screenshotTabAll({
canvases: ['cmodsieve', 'cmodsievebar'],
dashId: 'modSieveLiveStats',
title: 'Modular Prime Sieve',
filename: 'modular_prime_sieve_all.png'
});
}

// ===== 3D FAREY LATTICE VISUALIZATION =====
function drawEnhFarey3D(ctx,c,moduli,colMode,ptScale,zoom,lblSz,rot){
const tiltX=(+document.getElementById('enh3DX')?.value||30)*Math.PI/180;
const rotY=(+document.getElementById('enh3DY')?.value||0)*Math.PI/180 + rot;
const spinZ=(+document.getElementById('enh3DZ')?.value||0)*Math.PI/180;
const showChains=document.getElementById('enh3DChains')?.checked??true;
const showLabels=document.getElementById('enh3DLabels')?.checked;
lblSz=lblSz||9;

// Per-ring rotation settings
const enhRingInc=(+document.getElementById('enhRingInc')?.value||0)*Math.PI/180;
const enhPhase=(+document.getElementById('enhPhase')?.value||0)*Math.PI/180;
const enhInvertRings=document.getElementById('enhInvertRings')?.checked||false;

const cx=c.width/2,cy=c.height/2+30;

// Get max modulus for divisor hierarchy
const M=Math.max(...moduli);
const divisors=[];
for(let d=1;d<=M;d++)if(M%d===0)divisors.push(d);
divisors.sort((a,b)=>a-b);
const numLevels=divisors.length;

// 3D projection function
const project3D=(x,y,z)=>{
let x1=x*Math.cos(spinZ)-y*Math.sin(spinZ);
let y1=x*Math.sin(spinZ)+y*Math.cos(spinZ);
let x2=x1*Math.cos(rotY)+z*Math.sin(rotY);
let z1=-x1*Math.sin(rotY)+z*Math.cos(rotY);
let y2=y1*Math.cos(tiltX)-z1*Math.sin(tiltX);
let z2=y1*Math.sin(tiltX)+z1*Math.cos(tiltX);
const persp=600/(600-z2);
return{x:cx+x2*persp*zoom,y:cy-y2*persp*zoom,z:z2,scale:persp};
};

const maxRad=220,levelHeight=60;
const points=[];

// Create points for each level WITH per-ring rotation
divisors.forEach((d,lvl)=>{
const rad=maxRad*(lvl+1)/numLevels;
const z=-(numLevels-1-lvl)*levelHeight;
// Calculate ring rotation: ring index * increment
const ringIdx=enhInvertRings?(numLevels-1-lvl):lvl;
const ringRotation=ringIdx*enhRingInc+enhPhase;
for(let r=0;r<d;r++){
const ang=2*Math.PI*r/d-Math.PI/2+ringRotation;
const x3d=rad*Math.cos(ang);
const y3d=rad*Math.sin(ang);
const g=gcd(r,d);
const isCoprime=g===1;
const proj=project3D(x3d,y3d,z);
points.push({r,d,g,isCoprime,x3d,y3d,z,px:proj.x,py:proj.y,pz:proj.z,scale:proj.scale,lvl,ang,rad,ringRotation});
}});

// Sort by z for depth ordering
points.sort((a,b)=>a.pz-b.pz);

// Draw level rings
for(let lvl=0;lvl<numLevels;lvl++){
const d=divisors[lvl];
const rad=maxRad*(lvl+1)/numLevels;
const z=-(numLevels-1-lvl)*levelHeight;
ctx.strokeStyle=`rgba(255,215,0,${0.2+0.4*lvl/numLevels})`;
ctx.lineWidth=1;
ctx.beginPath();
for(let a=0;a<=360;a+=5){
const ang=a*Math.PI/180-Math.PI/2;
const p=project3D(rad*Math.cos(ang),rad*Math.sin(ang),z);
if(a===0)ctx.moveTo(p.x,p.y);else ctx.lineTo(p.x,p.y);
}
ctx.stroke();
if(showLabels){
const labelP=project3D(rad+15,0,z);
ctx.fillStyle=isDark()?'rgba(255,255,255,0.7)':'rgba(0,0,0,0.7)';
ctx.font='10px Segoe UI';ctx.textAlign='left';
ctx.fillText(`M'=${d} (φ=${eulerPhi(d)})`,labelP.x,labelP.y);
}}

// Draw Farey chains (reduction lines) with per-ring rotation
if(showChains){
for(const pt of points){
if(pt.d!==M||pt.isCoprime)continue;
const Mprime=M/pt.g;
const rprime=pt.r/pt.g;
const targetLvl=divisors.indexOf(Mprime);
if(targetLvl<0)continue;
const targetRad=maxRad*(targetLvl+1)/numLevels;
const targetZ=-(numLevels-1-targetLvl)*levelHeight;
// Apply per-ring rotation to target
const targetRingIdx=enhInvertRings?(numLevels-1-targetLvl):targetLvl;
const targetRingRotation=targetRingIdx*enhRingInc+enhPhase;
const targetAng=2*Math.PI*rprime/Mprime-Math.PI/2+targetRingRotation;
const target=project3D(targetRad*Math.cos(targetAng),targetRad*Math.sin(targetAng),targetZ);
ctx.strokeStyle='rgba(255,100,100,0.4)';
ctx.lineWidth=1;
ctx.beginPath();ctx.moveTo(pt.px,pt.py);ctx.lineTo(target.x,target.y);ctx.stroke();
}}

// Draw points (front to back, reversed)
points.slice().reverse().forEach(pt=>{
const sz=(pt.d===M?5:4)*ptScale*pt.scale;
let clr;
if(colMode==='gcd')clr=pt.isCoprime?'#ffd700':'#666';
else if(colMode==='ring')clr=`hsl(${pt.lvl*30},70%,55%)`;
else clr=`hsl(${(pt.r/pt.d)*360},80%,55%)`;
ctx.fillStyle=clr;
ctx.beginPath();ctx.arc(pt.px,pt.py,sz,0,2*Math.PI);ctx.fill();
if(pt.isCoprime){ctx.strokeStyle='rgba(255,255,255,0.8)';ctx.lineWidth=1;ctx.stroke();}
});

// Title
ctx.fillStyle=isDark()?'#ffd700':'#cc8800';ctx.font='bold 12px Segoe UI';ctx.textAlign='center';
ctx.fillText(`3D Farey Divisor Lattice: M=${M} (${numLevels} levels)`,c.width/2,20);
legend('alenhanced','3D Farey Lattice',[['Levels',numLevels,'#ffd700'],['M',M,'#00d9ff'],['φ(M)',eulerPhi(M),'#00ff88']]);
}

// ===== COMPOSITE STRUCTURE VISUALIZATION =====
function drawEnhComposite(ctx,c,moduli,colMode,ptScale,zoom,gaps,gapW,lblSz,rot){
const showProj=document.getElementById('enhCompProj')?.checked??true;
const showChannels=document.getElementById('enhCompChannels')?.checked??true;
const projOp=+document.getElementById('enhCompOp')?.value||0.5;
lblSz=lblSz||9;

// Per-ring rotation settings
const enhRingInc=(+document.getElementById('enhRingInc')?.value||0)*Math.PI/180;
const enhPhase=(+document.getElementById('enhPhase')?.value||0)*Math.PI/180 + (rot||0);
const enhInvertRings=document.getElementById('enhInvertRings')?.checked||false;

const cx=c.width/2,cy=c.height/2;

// Use largest modulus for composite view
const M=Math.max(...moduli);
const R=(Math.min(c.width,c.height)/2-60)*zoom;
const divisors=[];
for(let d=1;d<=M;d++)if(M%d===0)divisors.push(d);
const numChannels=divisors.length;

// Build residue data
const residues=[];
for(let r=0;r<M;r++){
const g=gcd(r,M);
const Mprime=M/g;
const rprime=r/g;
const isCoprime=g===1;
residues.push({r,g,Mprime,rprime,isCoprime});
}

// Get ring rotation for a given divisor
const getRingRotation=(d)=>{
const idx=divisors.indexOf(d);
const ringIdx=enhInvertRings?(numChannels-1-idx):idx;
return ringIdx*enhRingInc+enhPhase;
};

// Color function for points
const getColor=(r,m,isCoprime)=>{
if(colMode==='gcd')return isCoprime?'#ffd700':'#666';
if(colMode==='coprime')return isCoprime?'#00ff88':'#ff4040';
if(colMode==='ring')return `hsl(${(divisors.indexOf(m)/numChannels)*300},80%,55%)`;
if(colMode==='residue')return `hsl(${(r/m)*360},80%,55%)`;
if(colMode==='gap'){
const g=gcd(r,m);
return g===1?`hsl(${(r/m)*360},80%,55%)`:'#444';
}
if(colMode==='fire'){const t=r/m;return `rgb(${255},${Math.floor(t*180)},${Math.floor(t*50)})`;}
if(colMode==='plasma'){const t=r/m;return `hsl(${270-t*180},${80+t*20}%,${45+t*15}%)`;}
if(colMode==='viridis'){const t=r/m;return `hsl(${80+t*200},${70+t*20}%,${35+t*25}%)`;}
return `hsl(${(r/m)*360},80%,55%)`;
};

// Draw channel rings and POINTS ON EACH CHANNEL (like 3D view in 2D)
if(showChannels){
for(const d of divisors){
const rRing=R*d/M;
const rot=getRingRotation(d);
ctx.strokeStyle='rgba(255,215,0,0.3)';ctx.lineWidth=1;
ctx.beginPath();ctx.arc(cx,cy,rRing,0,2*Math.PI);ctx.stroke();

// Draw ALL points on this channel ring
for(let r=0;r<d;r++){
const isCoprime=gcd(r,d)===1;
const ang=-2*Math.PI*r/d+Math.PI/2+rot;
const x=cx+rRing*Math.cos(ang),y=cy+rRing*Math.sin(ang);
const clr=getColor(r,d,isCoprime);
const sz=(isCoprime?4:3)*ptScale*(d===M?1.2:0.8);
ctx.fillStyle=clr;
ctx.beginPath();ctx.arc(x,y,sz,0,2*Math.PI);ctx.fill();
if(isCoprime&&d>1){ctx.strokeStyle='rgba(255,255,255,0.5)';ctx.lineWidth=0.5;ctx.stroke();}
}

// Label
if(d!==M){
ctx.fillStyle=isDark()?'rgba(255,255,255,0.5)':'rgba(0,0,0,0.5)';
ctx.font='9px Segoe UI';ctx.textAlign='left';
ctx.fillText(`M'=${d}`,cx+rRing+3,cy);
}
}}

// Draw main ring
ctx.strokeStyle=gridC();ctx.lineWidth=2;
ctx.beginPath();ctx.arc(cx,cy,R,0,2*Math.PI);ctx.stroke();

// Draw projection lines with per-ring rotation
if(showProj){
ctx.globalAlpha=projOp;
for(const res of residues){
if(res.isCoprime)continue;
// Source angle on main ring M
const mainRot=getRingRotation(M);
const ang1=-2*Math.PI*res.r/M+Math.PI/2+mainRot;
const x1=cx+R*Math.cos(ang1),y1=cy+R*Math.sin(ang1);
// Target on channel ring
const rTarget=R*res.Mprime/M;
const targetRot=getRingRotation(res.Mprime);
const ang2=-2*Math.PI*res.rprime/res.Mprime+Math.PI/2+targetRot;
const x2=cx+rTarget*Math.cos(ang2),y2=cy+rTarget*Math.sin(ang2);
ctx.strokeStyle='#ff4040';ctx.lineWidth=1;
ctx.beginPath();ctx.moveTo(x1,y1);ctx.lineTo(x2,y2);ctx.stroke();
}
ctx.globalAlpha=1;
}

// Draw gap connections with per-ring rotation
const mainRot=getRingRotation(M);
if(gaps.length>0){
const coprimes=residues.filter(r=>r.isCoprime).map(r=>r.r);
gaps.forEach((gap,gi)=>{
const hue=(gi*360/gaps.length)%360;
ctx.strokeStyle=`hsla(${hue},80%,60%,0.6)`;ctx.lineWidth=gapW;
for(const r1 of coprimes){
const r2=(r1+gap)%M;
if(coprimes.includes(r2)){
const ang1=-2*Math.PI*r1/M+Math.PI/2+mainRot;
const ang2=-2*Math.PI*r2/M+Math.PI/2+mainRot;
ctx.beginPath();
ctx.moveTo(cx+R*Math.cos(ang1),cy+R*Math.sin(ang1));
ctx.lineTo(cx+R*Math.cos(ang2),cy+R*Math.sin(ang2));
ctx.stroke();
}}});
}

// Draw points on main ring (M) with per-ring rotation
for(const res of residues){
const ang=-2*Math.PI*res.r/M+Math.PI/2+mainRot;
const x=cx+R*Math.cos(ang),y=cy+R*Math.sin(ang);
const clr=getColor(res.r,M,res.isCoprime);
const sz=(res.isCoprime?5:4)*ptScale;
ctx.fillStyle=clr;
ctx.beginPath();ctx.arc(x,y,sz,0,2*Math.PI);ctx.fill();
if(res.isCoprime){ctx.strokeStyle='#fff';ctx.lineWidth=1;ctx.stroke();}
}

// Stats counts
let totalPts=0,coprimePts=0;
for(const d of divisors){
totalPts+=d;
for(let r=0;r<d;r++)if(gcd(r,d)===1)coprimePts++;
}

// Title
ctx.fillStyle=isDark()?'#ffd700':'#cc8800';ctx.font='bold 12px Segoe UI';ctx.textAlign='center';
ctx.fillText(`Composite Structure: M=${M} | φ(M)=${eulerPhi(M)} | ${divisors.length} channels | Color: ${colMode}`,c.width/2,20);
legend('alenhanced','Composite Structure',[['M',M,'#ffd700'],['φ(M)',eulerPhi(M),'#00ff88'],['Channels',divisors.length,'#00d9ff'],['Total Pts',totalPts,'#ff6496'],['Coprime',coprimePts,'#00ff88']]);
}

// ========== MULTIPLICATION TABLE ==========
function drawMultiplicationTable(ctx, c, m, colMode, ptScale, zoom, lblSz) {
  if (m < 1) m = 1;
  if (m > 100) m = 100; // Limit for readability
  ptScale = ptScale || 1;
  zoom = zoom || 1;
  lblSz = lblSz || 9;
  
  const tableType = document.getElementById('multTableType')?.value || 'mult';
  // Use common color mode if no specific table color selected
  const tableColorScheme = document.getElementById('multTableColor')?.value;
  const colorScheme = tableColorScheme || (colMode === 'angular' ? 'rainbow' : colMode === 'gcd' ? 'gcd' : colMode === 'quadres' ? 'quadres' : 'rainbow');
  const labelMode = document.getElementById('multLabelMode')?.value || 'value';
  const showSymmetry = document.getElementById('multShowSymmetry')?.checked;
  const showDiag = document.getElementById('multShowDiag')?.checked;
  const invertRings = document.getElementById('enhInvertRings')?.checked || false;
  
  ctx.fillStyle = canvBg();
  ctx.fillRect(0, 0, c.width, c.height);
  
  // Get units for Cayley table
  const units = [];
  for (let i = 1; i < m; i++) {
    if (gcd(i, m) === 1) units.push(i);
  }
  
  // Determine table elements - invert order if needed
  let elements = [];
  if (tableType === 'cayley') {
    elements = invertRings ? [...units].reverse() : units;
  } else {
    for (let i = 0; i < m; i++) elements.push(invertRings ? (m - 1 - i) : i);
  }
  
  const n = elements.length;
  if (n === 0) {
    ctx.fillStyle = '#fff';
    ctx.font = '16px Segoe UI';
    ctx.textAlign = 'center';
    ctx.fillText('No elements to display', c.width/2, c.height/2);
    return;
  }
  
  // Use full canvas - square table with zoom
  const titleHeight = 25;
  const footerHeight = 25;
  const headerSize = Math.max(20, Math.min(40, c.width / (n + 2))) * zoom;
  const availSize = (Math.min(c.width, c.height - titleHeight - footerHeight) - 10) * zoom;
  const cellSize = Math.floor((availSize - headerSize) / n) * ptScale;
  const tableSize = cellSize * n + headerSize;
  const startX = (c.width - tableSize) / 2;
  const startY = titleHeight + (c.height - titleHeight - footerHeight - tableSize) / 2;
  
  // Precompute element properties
  const idempotents = new Set();
  const quadraticResidues = new Set();
  const elementOrder = new Map();
  
  for (let a = 0; a < m; a++) {
    if ((a * a) % m === a) idempotents.add(a);
    quadraticResidues.add((a * a) % m);
  }
  
  // Compute multiplicative order for units
  for (const u of units) {
    let ord = 1, val = u;
    while (val % m !== 1 && ord < m) {
      val = (val * u) % m;
      ord++;
    }
    elementOrder.set(u, ord);
  }
  
  // Count divisors for divisibility scheme
  const divCount = (x) => {
    if (x === 0) return m;
    let count = 0;
    for (let d = 1; d <= x; d++) if (x % d === 0) count++;
    return count;
  };
  
  // Color function
  const getColor = (result, a, b) => {
    const t = result / Math.max(1, m - 1);
    
    if (colorScheme === 'rainbow') {
      return `hsl(${t * 360}, 75%, ${isDark() ? 45 : 55}%)`;
    } else if (colorScheme === 'modular') {
      return `hsl(${(result * 37) % 360}, 70%, ${isDark() ? 50 : 60}%)`;
    } else if (colorScheme === 'divisibility') {
      const dc = divCount(result);
      const maxDc = Math.max(1, divCount(m));
      const lightness = 25 + 45 * (dc / maxDc);
      return `hsl(200, 60%, ${lightness}%)`;
    } else if (colorScheme === 'zerodiv') {
      if (result === 0 && a !== 0 && b !== 0) return '#ff4040';
      if (gcd(a, m) === 1) return '#3388dd';
      if (a === 0) return '#333';
      return '#884444';
    } else if (colorScheme === 'idempotent') {
      return idempotents.has(result) ? '#ffd700' : (isDark() ? '#444' : '#999');
    } else if (colorScheme === 'order') {
      const ord = elementOrder.get(result) || 0;
      const maxOrd = eulerPhi(m);
      return `hsl(${(ord / Math.max(1, maxOrd)) * 270}, 80%, ${isDark() ? 50 : 55}%)`;
    } else if (colorScheme === 'gcd') {
      const g = gcd(result, m);
      if (g === 1) return '#00ff88';
      if (g === m || result === 0) return '#ff4040';
      return `hsl(${30 + (g / m) * 60}, 70%, 50%)`;
    } else if (colorScheme === 'quadres') {
      if (result === 0) return '#333';
      return quadraticResidues.has(result) ? '#9664ff' : '#445566';
    } else if (colorScheme === 'plasma') {
      const r = Math.floor(13 + t * 230);
      const g = Math.floor(8 + t * 92 + Math.sin(t * Math.PI) * 100);
      const b = Math.floor(135 + t * 80);
      return `rgb(${r},${g},${b})`;
    } else if (colorScheme === 'viridis') {
      const r = Math.floor(68 + t * 187);
      const g = Math.floor(1 + t * 206);
      const b = Math.floor(84 + t * 50);
      return `rgb(${r},${g},${b})`;
    } else if (colorScheme === 'thermal') {
      if (t < 0.33) return `rgb(0,0,${Math.floor(t * 3 * 255)})`;
      if (t < 0.66) return `rgb(${Math.floor((t - 0.33) * 3 * 255)},0,255)`;
      return `rgb(255,${Math.floor((t - 0.66) * 3 * 255)},${255 - Math.floor((t - 0.66) * 3 * 255)})`;
    } else if (colorScheme === 'grayscale') {
      const v = Math.floor(30 + t * 180);
      return `rgb(${v},${v},${v})`;
    }
    return `hsl(${t * 360}, 70%, 50%)`;
  };
  
  // Draw header row background
  ctx.fillStyle = isDark() ? 'rgba(255,215,0,0.15)' : 'rgba(255,215,0,0.25)';
  ctx.fillRect(startX, startY, tableSize, headerSize);
  ctx.fillRect(startX, startY, headerSize, tableSize);
  
  // Draw operation symbol in corner
  ctx.fillStyle = isDark() ? '#ffd700' : '#cc8800';
  ctx.font = `bold ${Math.min(headerSize * 0.6, 18)}px Segoe UI`;
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  const opSymbol = tableType === 'add' ? '+' : '×';
  ctx.fillText(opSymbol, startX + headerSize/2, startY + headerSize/2);
  
  // Draw column headers
  const headerFont = Math.min(headerSize * 0.5, cellSize * 0.6, 14);
  ctx.font = `bold ${headerFont}px Segoe UI`;
  for (let j = 0; j < n; j++) {
    const x = startX + headerSize + j * cellSize;
    ctx.fillStyle = isDark() ? '#ffd700' : '#cc8800';
    ctx.fillText(elements[j].toString(), x + cellSize/2, startY + headerSize/2);
  }
  
  // Draw row headers
  for (let i = 0; i < n; i++) {
    const y = startY + headerSize + i * cellSize;
    ctx.fillStyle = isDark() ? '#ffd700' : '#cc8800';
    ctx.fillText(elements[i].toString(), startX + headerSize/2, y + cellSize/2);
  }
  
  // Draw table cells
  const cellFont = Math.min(cellSize * 0.5, 14);
  for (let i = 0; i < n; i++) {
    for (let j = 0; j < n; j++) {
      const a = elements[i];
      const b = elements[j];
      const result = tableType === 'add' ? (a + b) % m : (a * b) % m;
      
      const x = startX + headerSize + j * cellSize;
      const y = startY + headerSize + i * cellSize;
      
      // Cell fill
      ctx.fillStyle = getColor(result, a, b);
      ctx.fillRect(x + 0.5, y + 0.5, cellSize - 1, cellSize - 1);
      
      // Highlight diagonal
      if (showDiag && i === j) {
        ctx.strokeStyle = '#ffd700';
        ctx.lineWidth = 2;
        ctx.strokeRect(x + 1, y + 1, cellSize - 2, cellSize - 2);
      }
      
      // Highlight symmetry
      if (showSymmetry && i !== j) {
        const otherResult = tableType === 'add' ? (b + a) % m : (b * a) % m;
        if (result === otherResult) {
          ctx.strokeStyle = 'rgba(0,217,255,0.5)';
          ctx.lineWidth = 1;
          ctx.strokeRect(x + 2, y + 2, cellSize - 4, cellSize - 4);
        }
      }
      
      // Cell labels
      if (labelMode !== 'none' && cellSize >= 12) {
        let labelText = result.toString();
        if (labelMode === 'order' && elementOrder.has(result)) {
          labelText = 'o' + elementOrder.get(result);
        }
        if (labelMode === 'small' && cellSize < 20) {
          ctx.font = `${Math.max(8, cellSize * 0.35)}px Segoe UI`;
        } else {
          ctx.font = `${cellFont}px Segoe UI`;
        }
        // Contrast text color
        const bg = getColor(result, a, b);
        const isLight = colorScheme === 'grayscale' ? result/m > 0.5 : 
                        (colorScheme === 'idempotent' && idempotents.has(result)) ||
                        (colorScheme === 'gcd' && gcd(result,m) === 1);
        ctx.fillStyle = isLight ? '#000' : '#fff';
        ctx.fillText(labelText, x + cellSize/2, y + cellSize/2);
      }
    }
  }
  
  // Grid lines
  ctx.strokeStyle = isDark() ? 'rgba(255,255,255,0.15)' : 'rgba(0,0,0,0.15)';
  ctx.lineWidth = 0.5;
  for (let i = 0; i <= n; i++) {
    ctx.beginPath();
    ctx.moveTo(startX + headerSize, startY + headerSize + i * cellSize);
    ctx.lineTo(startX + tableSize, startY + headerSize + i * cellSize);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(startX + headerSize + i * cellSize, startY + headerSize);
    ctx.lineTo(startX + headerSize + i * cellSize, startY + tableSize);
    ctx.stroke();
  }
  
  // Border
  ctx.strokeStyle = isDark() ? '#ffd700' : '#cc8800';
  ctx.lineWidth = 2;
  ctx.strokeRect(startX, startY, tableSize, tableSize);
  
  // Title
  const titleText = tableType === 'cayley' ? `Cayley Table (Z/${m}Z)* — ${units.length} units` :
                    tableType === 'add' ? `Addition Table (Z/${m}Z, +)` :
                    `Multiplication Table (Z/${m}Z, ×)`;
  ctx.fillStyle = isDark() ? '#ffd700' : '#cc8800';
  ctx.font = 'bold 14px Segoe UI';
  ctx.textAlign = 'center';
  ctx.fillText(titleText, c.width/2, 16);
  
  // Statistics subtitle
  const phiM = eulerPhi(m);
  const zeroDivs = m - phiM - 1;
  const mIsPrime = isPrime(m);
  const colorNames = {rainbow:'Rainbow',gcd:'GCD/Unit Group',product:'Product Value',idempotent:'Idempotents',nilpotent:'Nilpotents',zerodiv:'Zero Divisors',order:'Element Order',grayscale:'Grayscale',diagonal:'Diagonal',quadres:'Quadratic Residue',fire:'Fire',plasma:'Plasma'};
  ctx.fillStyle = isDark() ? '#aaa' : '#666';
  ctx.font = '11px Segoe UI';
  ctx.fillText(`m=${m} | φ(m)=${phiM} | ${idempotents.size} idempotents | ${mIsPrime ? 'PRIME (Field)' : zeroDivs + ' zero divisors'} | Color: ${colorNames[colorScheme]||colorScheme}`, c.width/2, c.height - 15);
  
  // Update legend with more stats
  legend('alenhanced', 'Multiplication Table', [
    ['Modulus m', m, '#ffd700'],
    ['φ(m) Units', phiM, '#00ff88'],
    ['Idempotents', idempotents.size, '#9664ff'],
    [mIsPrime ? 'Prime Field' : 'Zero Divisors', mIsPrime ? 'Yes' : zeroDivs, '#00d9ff'],
    ['Color', colorNames[colorScheme]||colorScheme, '#ff6496'],
    ['Table Size', n + '×' + n, '#888']
  ]);
}

// ===== GCD HEATMAP VISUALIZATION =====
function drawGCDHeatmap(ctx, c, moduli, colMode, ptScale, zoom, lblSz) {
  ctx.fillStyle = canvBg();
  ctx.fillRect(0, 0, c.width, c.height);
  ptScale = ptScale || 1;
  zoom = zoom || 1;
  lblSz = lblSz || 9;
  const invertRings = document.getElementById('enhInvertRings')?.checked || false;
  
  const padding = 60;
  const w = (c.width - 2 * padding) * zoom;
  const h = (c.height - 2 * padding) * zoom;
  const offsetX = (c.width - w) / 2;
  const offsetY = padding + (c.height - 2*padding - h) / 2;
  
  // Title
  ctx.fillStyle = isDark() ? '#ff8c00' : '#cc6600';
  ctx.font = `bold ${lblSz + 4}px Segoe UI`;
  ctx.textAlign = 'center';
  ctx.fillText('GCD Landscape: gcd(r, M) for all residues r and moduli M', c.width/2, 25);
  
  const numModuli = moduli.length;
  const maxM = Math.max(...moduli);
  const cellW = w / maxM * ptScale;
  const cellH = h / numModuli * ptScale;
  
  // Draw heatmap - invert row order if needed
  for (let i = 0; i < numModuli; i++) {
    const rowIdx = invertRings ? (numModuli - 1 - i) : i;
    const m = moduli[rowIdx];
    const y = offsetY + i * (h / numModuli);
    
    for (let r = 0; r < m; r++) {
      const g = gcd(r, m);
      const x = offsetX + (r / m) * w;
      const cellWidth = w / m;
      
      // Color by GCD
      let clr;
      if (g === 1) {
        clr = '#ffd700'; // Coprime = gold
      } else if (g === m) {
        clr = '#003366'; // r=0, gcd=m
      } else {
        const t = g / m;
        clr = `hsl(${200 + t * 60}, ${70 - t * 30}%, ${50 - t * 25}%)`;
      }
      
      ctx.fillStyle = clr;
      ctx.fillRect(x, y, cellWidth + 0.5, cellH + 0.5);
    }
    
    // Row label
    ctx.fillStyle = isDark() ? '#888' : '#666';
    ctx.font = '10px Segoe UI';
    ctx.textAlign = 'right';
    ctx.fillText('M=' + m, padding - 5, y + cellH/2 + 3);
  }
  
  // X-axis labels
  ctx.fillStyle = isDark() ? '#888' : '#666';
  ctx.font = '10px Segoe UI';
  ctx.textAlign = 'center';
  for (let f = 0; f <= 10; f++) {
    const x = padding + (f / 10) * w;
    ctx.fillText((f / 10).toFixed(1), x, c.height - padding + 15);
  }
  ctx.fillText('r/M (residue fraction)', c.width/2, c.height - 15);
  
  // Legend
  const legY = padding - 35;
  ctx.fillStyle = '#ffd700';
  ctx.fillRect(c.width - 200, legY, 15, 15);
  ctx.fillStyle = isDark() ? '#fff' : '#000';
  ctx.font = '11px Segoe UI';
  ctx.textAlign = 'left';
  ctx.fillText('gcd=1 (coprime)', c.width - 180, legY + 12);
  
  ctx.fillStyle = '#0066aa';
  ctx.fillRect(c.width - 200, legY + 20, 15, 15);
  ctx.fillStyle = isDark() ? '#fff' : '#000';
  ctx.fillText('gcd>1 (darker=higher)', c.width - 180, legY + 32);
}

// ===== TOTIENT LANDSCAPE VISUALIZATION =====
function drawTotientLandscape(ctx, c, moduli, colMode, ptScale, zoom, lblSz, rot) {
  ctx.fillStyle = canvBg();
  ctx.fillRect(0, 0, c.width, c.height);
  ptScale = ptScale || 1;
  zoom = zoom || 1;
  lblSz = lblSz || 9;
  rot = rot || 0;
  const invertRings = document.getElementById('enhInvertRings')?.checked || false;
  
  const cx = c.width / 2;
  const cy = c.height / 2;
  const maxR = Math.min(cx, cy) - 50;
  
  // Title
  ctx.fillStyle = isDark() ? '#00ff88' : '#008844';
  ctx.font = `bold ${lblSz + 4}px Segoe UI`;
  ctx.textAlign = 'center';
  ctx.fillText('Totient Ratio Landscape: φ(M)/M', c.width/2, 25);
  
  // Sort moduli by totient ratio
  const ratioData = moduli.map(m => ({
    m,
    phi: eulerPhi(m),
    ratio: eulerPhi(m) / m
  })).sort((a, b) => b.ratio - a.ratio);
  
  const numRings = ratioData.length;
  
  // Draw rings - radius proportional to totient ratio
  ratioData.forEach((d, idx) => {
    const ringIdx = invertRings ? (numRings - 1 - idx) : idx;
    const baseR = (ringIdx / numRings) * maxR * 0.9 + maxR * 0.1;
    const r = baseR * zoom;
    
    // Color by ratio
    const hue = d.ratio * 120; // 0 = red (low ratio), 120 = green (high ratio)
    ctx.strokeStyle = `hsl(${hue}, 70%, 50%)`;
    ctx.lineWidth = Math.max(1, 3 * d.ratio);
    
    ctx.beginPath();
    ctx.arc(cx, cy, r, 0, 2 * Math.PI);
    ctx.stroke();
    
    // Draw coprime points on this ring with rotation
    const coprimes = getCoprimes(d.m);
    ctx.fillStyle = `hsl(${hue}, 80%, 60%)`;
    coprimes.forEach(cp => {
      const theta = (cp / d.m) * 2 * Math.PI - Math.PI/2 + rot;
      const px = cx + r * Math.cos(theta);
      const py = cy + r * Math.sin(theta);
      ctx.beginPath();
      ctx.arc(px, py, 2 * ptScale, 0, 2 * Math.PI);
      ctx.fill();
    });
    
    // Label every few rings
    if (idx % Math.max(1, Math.floor(ratioData.length / 10)) === 0) {
      ctx.fillStyle = isDark() ? '#888' : '#666';
      ctx.font = `${lblSz}px Segoe UI`;
      ctx.textAlign = 'left';
      ctx.fillText(`M=${d.m} φ/M=${d.ratio.toFixed(3)}`, cx + r + 5, cy);
    }
  });
  
  // Draw reference circles for 6/π² density
  ctx.strokeStyle = 'rgba(255,215,0,0.5)';
  ctx.setLineDash([5, 5]);
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.arc(cx, cy, maxR * 0.6079 * zoom, 0, 2 * Math.PI);
  ctx.stroke();
  ctx.setLineDash([]);
  
  ctx.fillStyle = '#ffd700';
  ctx.font = '10px Segoe UI';
  ctx.fillText('6/π² ≈ 0.608', cx + maxR * 0.6079 * zoom + 5, cy - 10);
}

// ===== MULTIPLICATIVE ORBITS VISUALIZATION =====
function drawMultiplicativeOrbits(ctx, c, moduli, colMode, ptScale, zoom, lblSz, rot) {
  ctx.fillStyle = canvBg();
  ctx.fillRect(0, 0, c.width, c.height);
  ptScale = ptScale || 1;
  zoom = zoom || 1;
  lblSz = lblSz || 9;
  rot = rot || 0;
  const invertRings = document.getElementById('enhInvertRings')?.checked || false;
  
  const cx = c.width / 2;
  const cy = c.height / 2;
  const maxR = (Math.min(cx, cy) - 40) * zoom;
  
  // Use the largest modulus
  const m = moduli[moduli.length - 1] || 30;
  
  // Title
  ctx.fillStyle = isDark() ? '#9664ff' : '#6644cc';
  ctx.font = `bold ${lblSz + 4}px Segoe UI`;
  ctx.textAlign = 'center';
  ctx.fillText(`Multiplicative Orbits mod ${m}`, c.width/2, 25);
  
  // Find a generator (primitive root if exists)
  let gen = 2;
  const coprimes = getCoprimes(m);
  for (const g of [2, 3, 5, 7, 11]) {
    if (gcd(g, m) === 1) {
      gen = g;
      break;
    }
  }
  
  // Compute orbits
  const visited = new Set();
  const orbits = [];
  
  for (let start = 1; start < m; start++) {
    if (visited.has(start)) continue;
    if (gcd(start, m) !== 1) continue;
    
    const orbit = [start];
    visited.add(start);
    let curr = (start * gen) % m;
    while (curr !== start && !visited.has(curr)) {
      orbit.push(curr);
      visited.add(curr);
      curr = (curr * gen) % m;
    }
    orbits.push(orbit);
  }
  
  const numOrbits = orbits.length;
  
  // Draw each orbit in a different color
  orbits.forEach((orbit, orbIdx) => {
    const hue = (orbIdx / numOrbits) * 300;
    ctx.strokeStyle = `hsl(${hue}, 70%, 50%)`;
    ctx.fillStyle = `hsl(${hue}, 80%, 60%)`;
    ctx.lineWidth = 1.5;
    
    // Orbit radius - invert if needed
    const orbitRingIdx = invertRings ? (numOrbits - 1 - orbIdx) : orbIdx;
    const orbitR = maxR * 0.3 + (orbitRingIdx / numOrbits) * maxR * 0.7;
    
    // Draw orbit as connected points with rotation
    ctx.beginPath();
    orbit.forEach((r, i) => {
      const theta = (r / m) * 2 * Math.PI - Math.PI/2 + rot;
      const px = cx + orbitR * Math.cos(theta);
      const py = cy + orbitR * Math.sin(theta);
      
      if (i === 0) ctx.moveTo(px, py);
      else ctx.lineTo(px, py);
    });
    // Close the orbit
    const theta0 = (orbit[0] / m) * 2 * Math.PI - Math.PI/2 + rot;
    ctx.lineTo(cx + orbitR * Math.cos(theta0), cy + orbitR * Math.sin(theta0));
    ctx.stroke();
    
    // Draw points
    orbit.forEach(r => {
      const theta = (r / m) * 2 * Math.PI - Math.PI/2 + rot;
      const px = cx + orbitR * Math.cos(theta);
      const py = cy + orbitR * Math.sin(theta);
      ctx.beginPath();
      ctx.arc(px, py, 4 * ptScale, 0, 2 * Math.PI);
      ctx.fill();
    });
  });
  
  // Legend
  ctx.fillStyle = isDark() ? '#fff' : '#000';
  ctx.font = `${lblSz}px Segoe UI`;
  ctx.textAlign = 'left';
  ctx.fillText(`Generator g=${gen}, ${orbits.length} orbit(s)`, 10, c.height - 40);
  ctx.fillText(`φ(${m})=${coprimes.length}, orbit sizes: ${orbits.map(o => o.length).join(', ')}`, 10, c.height - 25);
}

// ===== FORD CIRCLES VISUALIZATION =====
function drawFordCirclesMode(ctx, c, moduli, colMode, ptScale, zoom, lblSz) {
  ctx.fillStyle = canvBg();
  ctx.fillRect(0, 0, c.width, c.height);
  ptScale = ptScale || 1;
  zoom = zoom || 1;
  lblSz = lblSz || 9;
  const invertRings = document.getElementById('enhInvertRings')?.checked || false;
  
  const maxQ = Math.max(...moduli, 10);
  const padding = 40;
  const w = c.width - 2 * padding;
  // Invert flips circles to bottom
  const baseY = invertRings ? (padding + 50) : (c.height - padding - 50);
  const circleDir = invertRings ? 1 : -1; // Direction circles extend
  
  // Title
  ctx.fillStyle = isDark() ? '#00d9ff' : '#0088cc';
  ctx.font = `bold ${lblSz + 4}px Segoe UI`;
  ctx.textAlign = 'center';
  ctx.fillText(`Ford Circles for Farey F_${maxQ}`, c.width/2, 25);
  
  // Draw baseline
  ctx.strokeStyle = isDark() ? '#444' : '#ccc';
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(padding, baseY);
  ctx.lineTo(c.width - padding, baseY);
  ctx.stroke();
  
  // Generate Farey fractions up to maxQ
  const fractions = [{p: 0, q: 1}, {p: 1, q: 1}];
  for (let q = 2; q <= maxQ; q++) {
    for (let p = 1; p < q; p++) {
      if (gcd(p, q) === 1) {
        fractions.push({p, q});
      }
    }
  }
  fractions.sort((a, b) => a.p/a.q - b.p/b.q);
  
  // Scale factor
  const scale = w * zoom;
  
  // Draw Ford circles
  fractions.forEach(f => {
    const x = padding + (f.p / f.q) * scale;
    const r = scale / (2 * f.q * f.q) * ptScale;
    
    if (r < 0.5) return; // Skip tiny circles
    
    // Color by denominator
    const hue = (f.q / maxQ) * 240;
    ctx.strokeStyle = `hsl(${hue}, 70%, 50%)`;
    ctx.fillStyle = `hsla(${hue}, 60%, 50%, 0.2)`;
    ctx.lineWidth = Math.max(0.5, 2 - f.q / 10);
    
    ctx.beginPath();
    ctx.arc(x, baseY + circleDir * r, r, 0, 2 * Math.PI);
    ctx.fill();
    ctx.stroke();
    
    // Label larger circles
    if (r > 10) {
      ctx.fillStyle = isDark() ? '#fff' : '#000';
      ctx.font = `${Math.min(12, r * 0.8)}px Segoe UI`;
      ctx.textAlign = 'center';
      const labelY = invertRings ? (baseY + 2*r + 12) : (baseY - 2*r - 3);
      ctx.fillText(`${f.p}/${f.q}`, x, labelY);
    }
  });
  
  // X-axis labels
  ctx.fillStyle = isDark() ? '#888' : '#666';
  ctx.font = '10px Segoe UI';
  ctx.textAlign = 'center';
  for (let i = 0; i <= 10; i++) {
    const x = padding + (i / 10) * scale;
    ctx.fillText((i / 10).toFixed(1), x, baseY + 15);
  }
  
  // Stats
  ctx.fillStyle = isDark() ? '#fff' : '#000';
  ctx.font = '11px Segoe UI';
  ctx.textAlign = 'left';
  ctx.fillText(`|F_${maxQ}| = ${fractions.length} fractions`, 10, c.height - 10);
}

// Helper: Set modulus for multiplication table
function setMultMod(m) {
  document.getElementById('enhMax').value = m;
  document.getElementById('enhMin').value = m;
  drawEnhanced();
}

// Helper: Inspect element in multiplication table
function inspectMultElement() {
  const a = +document.getElementById('multInspect').value;
  const m = +document.getElementById('enhMax').value || 30;
  const resultDiv = document.getElementById('multInspectResult');
  
  if (a < 0 || a >= m) {
    resultDiv.innerHTML = `<span style="color:#ff4040">Element must be in range [0, ${m-1}]</span>`;
    resultDiv.style.display = 'block';
    return;
  }
  
  const g = gcd(a, m);
  const isUnit = g === 1;
  const isIdemp = (a * a) % m === a;
  
  let html = `<div style="margin-bottom:8px"><strong style="color:#ffd700">Element Analysis: ${a} in Z/${m}Z</strong></div>`;
  html += `<div>gcd(${a}, ${m}) = ${g}</div>`;
  
  if (isUnit) {
    // Find order and inverse
    let order = 1;
    let pow = a;
    while (pow !== 1 && order < m) {
      pow = (pow * a) % m;
      order++;
    }
    
    // Find inverse using extended Euclidean algorithm
    let inv = 1;
    for (let i = 1; i < m; i++) {
      if ((a * i) % m === 1) { inv = i; break; }
    }
    
    // Generate powers
    const powers = [1];
    pow = a;
    for (let i = 1; i < order; i++) {
      powers.push(pow);
      pow = (pow * a) % m;
    }
    
    html += `<div style="color:#00ff88;font-weight:bold">UNIT (invertible)</div>`;
    html += `<div>Order: ${order}</div>`;
    html += `<div>Inverse: ${inv} (${a} x ${inv} = ${(a*inv)%m})</div>`;
    html += `<div>Powers: {${powers.join(', ')}}</div>`;
    
    if (order === eulerPhi(m)) {
      html += `<div style="color:#ffd700;font-weight:bold">PRIMITIVE ROOT (generates all units)</div>`;
    }
  } else {
    html += `<div style="color:#ff4040;font-weight:bold">ZERO DIVISOR (not invertible)</div>`;
    
    // Find what it multiplies to zero
    const zerosTo = [];
    for (let b = 1; b < m; b++) {
      if ((a * b) % m === 0) zerosTo.push(b);
    }
    html += `<div>${a} x {${zerosTo.slice(0,10).join(', ')}${zerosTo.length>10?'...':''}} = 0</div>`;
    
    // Check nilpotent
    let pow = a;
    let nilpOrder = 0;
    for (let k = 1; k <= m; k++) {
      if (pow === 0) { nilpOrder = k; break; }
      pow = (pow * a) % m;
    }
    if (nilpOrder > 0) {
      html += `<div style="color:#ff6496">NILPOTENT: ${a}^${nilpOrder} = 0</div>`;
    }
  }
  
  if (isIdemp) {
    html += `<div style="color:#9664ff;font-weight:bold">IDEMPOTENT: ${a}² = ${(a*a)%m} = ${a}</div>`;
  }
  
  resultDiv.innerHTML = html;
  resultDiv.style.display = 'block';
}

// ========== END ENHANCED RINGS ==========

let modRingData=[];

function setPhase(deg){document.getElementById('modPhase').value=deg;document.getElementById('modPhaseNum').value=deg;document.getElementById('modPhaseV').textContent=deg+'°';drawModRings();}
function setRingInc(deg){document.getElementById('ringInc').value=Math.min(180,deg);document.getElementById('ringIncV').textContent=deg+'°';drawModRings();}
function setEnhRingInc(deg){document.getElementById('enhRingInc').value=Math.min(180,deg);document.getElementById('enhRingIncV').textContent=deg+'°';drawEnhanced();}

// Parse fraction string like "1/2", "1/3", "2/5", "137.5/360" and convert to degrees
function parseFraction(str) {
  if (!str || str.trim() === '') return null;
  str = str.trim();
  // Handle direct degree input like "45" or "90"
  if (!str.includes('/')) {
    const deg = parseFloat(str);
    return isNaN(deg) ? null : deg;
  }
  // Handle fraction like "1/2", "1/3", etc.
  const parts = str.split('/');
  if (parts.length !== 2) return null;
  const num = parseFloat(parts[0]);
  const den = parseFloat(parts[1]);
  if (isNaN(num) || isNaN(den) || den === 0) return null;
  // a/m means a/m of a full rotation (360°)
  return (num / den) * 360;
}

function applyEnhFraction() {
  const input = document.getElementById('enhRingFrac').value;
  const deg = parseFraction(input);
  if (deg !== null) {
    // Clamp to 0-180 for the slider
    const clampedDeg = Math.min(180, Math.max(0, deg % 360));
    document.getElementById('enhRingInc').value = clampedDeg;
    document.getElementById('enhRingIncV').textContent = clampedDeg.toFixed(2) + '°';
    document.getElementById('enhFracDeg').textContent = '= ' + deg.toFixed(2) + '°';
    drawEnhanced();
  } else {
    document.getElementById('enhFracDeg').textContent = 'Invalid';
  }
}

function setEnhRingFrac(frac) {
  document.getElementById('enhRingFrac').value = frac;
  applyEnhFraction();
}

// Sieve Studio section switcher
function showSieveSection(section) {
  const sections = ['euler', 'primerings', 'modrings'];
  const btns = {euler:'secEuler', primerings:'secPrimeRings', modrings:'secModRings', all:'secAll'};
  sections.forEach(s => {
    const el = document.getElementById('sieveSection' + s.charAt(0).toUpperCase() + s.slice(1).replace('rings','Rings'));
    if (el) el.style.display = (section === 'all' || section === s) ? 'block' : 'none';
  });
  Object.entries(btns).forEach(([k,id]) => {
    const btn = document.getElementById(id);
    if (btn) btn.style.background = (k === section) ? 'rgba(150,100,255,0.2)' : 'transparent';
  });
  // Call draw functions after section is visible
  setTimeout(() => {
    if (section === 'euler' || section === 'all') drawEuler();
    if (section === 'primerings' || section === 'all') { computeSieveCalc(); drawPrimeRings(); }
    if (section === 'modrings' || section === 'all') drawModRings();
  }, 50);
}

function toggleModControls() {
  const mode = document.getElementById('modViewMode')?.value;
  const multi = document.getElementById('modMultiControls');
  const single = document.getElementById('modSingleControls');
  if (multi) multi.style.display = mode === 'multi' ? 'block' : 'none';
  if (single) single.style.display = mode === 'single' ? 'block' : 'none';
}

function drawModRings(){
const c=document.getElementById('cmod');
if (!c) return;
const ctx=c.getContext('2d');
const viewMode=document.getElementById('modViewMode')?.value || 'multi';

// Toggle control visibility
const multiCtrl = document.getElementById('modMultiControls');
const singleCtrl = document.getElementById('modSingleControls');
if (multiCtrl) multiCtrl.style.display=viewMode==='multi'?'block':'none';
if (singleCtrl) singleCtrl.style.display=viewMode==='single'?'block':'none';

if(viewMode==='single'){
drawSingleMProjection(c,ctx);
return;
}

const minM=+document.getElementById('modMin').value,maxM=+document.getElementById('modMax').value;
const spacing=document.getElementById('modSpace').value,col=document.getElementById('modCol').value;
const phase=+document.getElementById('modPhase').value*Math.PI/180,ptSz=+document.getElementById('modPtSz').value;
const ringInc=(+document.getElementById('ringInc')?.value||0)*Math.PI/180;
const invertRings=document.getElementById('modInvertRings')?.checked||false;
const showDirect=document.getElementById('modDirect')?.checked||false,showGcd1=document.getElementById('modGcd1')?.checked||false;
const showUnit=document.getElementById('modUnit')?.checked||false;
const gapThick=parseFloat(document.getElementById('gapThick')?.value||0.3);
const liftThick=parseFloat(document.getElementById('liftThick')?.value||0.5);
const labelMode=document.getElementById('modLabel')?.value||'none',labelSz=+document.getElementById('modLblSz')?.value||8;
const selectedGaps=[];
if(document.getElementById('gap2')?.checked)selectedGaps.push(2);
if(document.getElementById('gap4')?.checked)selectedGaps.push(4);
if(document.getElementById('gap6')?.checked)selectedGaps.push(6);
if(document.getElementById('gap8')?.checked)selectedGaps.push(8);
if(document.getElementById('gap10')?.checked)selectedGaps.push(10);
const smithEnabled=document.getElementById('smithMod')?.checked||false,smithAlpha=+document.getElementById('smithAMod')?.value||90;
const smithRMode=document.getElementById('smithRMod')?.value||'scaled',smithZoom=+document.getElementById('smithZoom')?.value||1;
const smithGrid=document.getElementById('smithGridMod')?.checked!==false,smithConstR=document.getElementById('smithCircRMod')?.checked!==false,smithConstX=document.getElementById('smithArcXMod')?.checked!==false;
// 3D rotation
const enable3D=document.getElementById('mod3D')?.checked||false;
const rot3DX=(+document.getElementById('mod3DX')?.value||0)*Math.PI/180;
const rot3DY=(+document.getElementById('mod3DY')?.value||0)*Math.PI/180;
const rot3DZ=(+document.getElementById('mod3DZ')?.value||0)*Math.PI/180;
const use3DPersp=document.getElementById('mod3DPersp')?.checked!==false;
const apply3DRotation=(x,y,z)=>{
let y1=y*Math.cos(rot3DX)-z*Math.sin(rot3DX),z1=y*Math.sin(rot3DX)+z*Math.cos(rot3DX);
let x2=x*Math.cos(rot3DY)+z1*Math.sin(rot3DY),z2=-x*Math.sin(rot3DY)+z1*Math.cos(rot3DY);
let x3=x2*Math.cos(rot3DZ)-y1*Math.sin(rot3DZ),y3=x2*Math.sin(rot3DZ)+y1*Math.cos(rot3DZ);
if(use3DPersp&&z2!==0){const persp=400/(400-z2);x3*=persp;y3*=persp;}
return{x:x3,y:y3,z:z2};};
ctx.fillStyle=canvBg();ctx.fillRect(0,0,c.width,c.height);
const cx=c.width/2,cy=c.height/2,maxRad=Math.min(cx,cy)-40;
const smithRad=maxRad*smithZoom;
if(smithEnabled){drawSmithGrid(ctx,cx,cy,smithRad,smithGrid,smithConstR,smithConstX);ctx.strokeStyle=bordC();ctx.lineWidth=2;ctx.beginPath();ctx.arc(cx,cy,smithRad,0,2*Math.PI);ctx.stroke();}
const rings=[];for(let m=minM;m<=maxM;m++)rings.push(m);
const getRadius=(m,i)=>{const n=rings.length;if(spacing==='uniform')return maxRad*(i+1)/(n+1);if(spacing==='linear')return maxRad*m/maxM;if(spacing==='sqrt')return maxRad*Math.sqrt(m)/Math.sqrt(maxM);if(spacing==='log')return maxRad*Math.log(m+1)/Math.log(maxM+1);if(spacing==='phi')return maxRad*eulerPhi(m)/eulerPhi(maxM);return maxRad*(i+1)/(n+1);};
const getSmithR=(i,m)=>{if(smithRMode==='unit')return 1;if(smithRMode==='scaled')return 0.5+(i/Math.max(1,rings.length-1))*1.5;if(smithRMode==='modulus')return Math.min(3,Math.log(m+1)/Math.log(10));return 1;};
const spf=(n)=>{if(n<2)return n;for(let p=2;p*p<=n;p++)if(n%p===0)return p;return n;};
const spfColors={2:'#FF6B6B',3:'#4ECDC4',5:'#FFE66D',7:'#95E1D3',11:'#F38181',13:'#AA96DA',17:'#FCBAD3',19:'#A8D8EA',23:'#DFE6E9'};
modRingData=[];let totalPts=0,totalGcd1=0;
if(showUnit&&minM===1&&!smithEnabled){ctx.strokeStyle='rgba(255,215,0,0.8)';ctx.lineWidth=3;ctx.beginPath();ctx.arc(cx,cy,getRadius(1,0),0,2*Math.PI);ctx.stroke();ctx.fillStyle='#ffd700';ctx.beginPath();ctx.arc(cx,cy,ptSz+2,0,2*Math.PI);ctx.fill();}
for(let i=0;i<rings.length;i++){const m=rings[i];if(m<2)continue;const rad=getRadius(m,i),phi=eulerPhi(m);
if(!smithEnabled){ctx.strokeStyle=gridC();ctx.lineWidth=1;ctx.beginPath();ctx.arc(cx,cy,rad,0,2*Math.PI);ctx.stroke();}
const coprimes=[];for(let r=0;r<m;r++)if(gcd(r,m)===1)coprimes.push(r);
const pts=[];for(let r=0;r<m;r++){const g=gcd(r,m),isGcd1=g===1;if(showGcd1&&!isGcd1)continue;
const ringIdx = invertRings ? (rings.length - 1 - i) : i;
const ang=2*Math.PI*r/m-Math.PI/2+phase+(ringIdx*ringInc);
let px,py;
if(smithEnabled){const smR=getSmithR(i,m);const theta=ang+smithAlpha*Math.PI/180;let gamma;if(smithRMode==='unit'){gamma={re:0,im:Math.tan(theta/2)};}else{const A=smR*Math.cos(theta)-1,B=smR*Math.sin(theta),C=smR*Math.cos(theta)+1;const denom=C*C+B*B;gamma=denom<1e-10?{re:0,im:0}:{re:(A*C+B*B)/denom,im:B*(C-A)/denom};}px=cx+gamma.re*smithRad;py=cy-gamma.im*smithRad;}
else if(enable3D){const baseX=rad*Math.cos(ang),baseY=rad*Math.sin(ang),baseZ=i*5;const rot=apply3DRotation(baseX,baseY,baseZ);px=cx+rot.x;py=cy+rot.y;}
else{px=cx+rad*Math.cos(ang);py=cy+rad*Math.sin(ang);}
let clr;const angle=r/m;
if(col==='rainbow')clr=`hsl(${Math.floor(angle*360)},75%,65%)`;
else if(col==='gcd')clr=isGcd1?'#ffd700':'#666666';
else if(col==='gcd_per_mod'){if(isGcd1){const modHue=(m*67)%360;clr=`hsl(${modHue},85%,70%)`;}else clr='#666666';}
else if(col==='gcd_spectrum'){if(isGcd1){const density=phi/m;const spectralHue=(density*240+r*15)%360;const sat=60+density*30;clr=`hsl(${spectralHue},${sat}%,65%)`;}else clr='#666666';}
else if(col==='spf'){const pf=spf(r);clr=spfColors[pf]||`hsl(${(pf*37)%360},70%,60%)`;}
else if(col==='ring')clr=`hsl(${Math.floor(i/rings.length*300)},78%,62%)`;
else if(col==='residue')clr=`hsl(${(r*37)%360},80%,70%)`;
else if(col==='prime'){const isPr=r>1&&[...Array(Math.floor(Math.sqrt(r))+1)].every((_,j)=>j<2||r%j!==0);clr=isPr?'#FF6B6B':'#4ECDC4';}
else clr=isGcd1?'#ffd700':'#666666';
pts.push({r,m,g,isGcd1,ang,px,py,clr,rad});totalPts++;if(isGcd1)totalGcd1++;}
for(const pt of pts){ctx.fillStyle=pt.clr;ctx.beginPath();ctx.arc(pt.px,pt.py,pt.isGcd1?ptSz:ptSz*.7,0,2*Math.PI);ctx.fill();}
const labelWhich=document.getElementById('modLabelWhich')?.value||'all';
if(labelMode!=='none'){ctx.font=`${labelSz}px Segoe UI`;ctx.textAlign='center';ctx.textBaseline='bottom';
for(const pt of pts){
// Check which points to label
if(labelWhich==='gcd1'&&!pt.isGcd1)continue;
if(labelWhich==='nongcd1'&&pt.isGcd1)continue;
if(labelWhich==='outer'&&i!==rings.length-1)continue;
if(labelWhich==='unit'&&pt.m!==1)continue;
let lbl='';
if(labelMode==='r')lbl=pt.r;
else if(labelMode==='rm')lbl=`${pt.r}/${pt.m}`;
else if(labelMode==='farey'){const g=gcd(pt.r,pt.m);const num=pt.r/g,den=pt.m/g;lbl=den===1?num.toString():`${num}/${den}`;}
else if(labelMode==='deg')lbl=Math.round((pt.ang+Math.PI/2)*180/Math.PI)+'°';
else if(labelMode==='rad'){const frac=(pt.r/pt.m)*2;const num=Math.round(frac*pt.m),den=pt.m;const g2=gcd(num,den);lbl=`${num/g2}π/${den/g2}`;}
else if(labelMode==='gcd')lbl=pt.g;
else if(labelMode==='coprime')lbl=pt.isGcd1?'OK':'X';
else if(labelMode==='factor'){const g=gcd(pt.r,pt.m);if(g>1){const redR=pt.r/g,redM=pt.m/g;lbl=`${pt.r}→${redR}/${redM}`;}else lbl=pt.r;}
else if(labelMode==='combined'){const deg=Math.round((pt.ang+Math.PI/2)*180/Math.PI);lbl=`${pt.r}\ngcd=${pt.g}\n${deg}°`;}
ctx.fillStyle=isDark()?'rgba(255,255,255,0.85)':'rgba(0,0,0,0.85)';
if(labelMode==='combined'){const lines=lbl.split('\n');lines.forEach((line,li)=>ctx.fillText(line,pt.px,pt.py-ptSz-2-li*labelSz));}
else ctx.fillText(lbl,pt.px,pt.py-ptSz-2);}}
modRingData.push({m,phi,pts,coprimes,index:i});}
const gapLineWidth=0.2+gapThick*2.8;
selectedGaps.forEach((gap,gapIdx)=>{const hue=(gapIdx*360/selectedGaps.length)%360;
for(const ring of modRingData){ring.coprimes.forEach(r=>{const r2=(r+gap)%ring.m;if(ring.coprimes.includes(r2)){const p1=ring.pts.find(p=>p.r===r&&p.isGcd1);const p2=ring.pts.find(p=>p.r===r2&&p.isGcd1);if(p1&&p2){ctx.beginPath();ctx.moveTo(p1.px,p1.py);ctx.lineTo(p2.px,p2.py);ctx.strokeStyle=`hsla(${hue},75%,65%,0.6)`;ctx.lineWidth=gapLineWidth;ctx.stroke();}}});}});
if(showDirect){const liftLineWidth=0.5+liftThick*3.5;ctx.strokeStyle='rgba(255,215,0,0.7)';ctx.lineWidth=liftLineWidth;
for(let i=0;i<modRingData.length-1;i++){const curr=modRingData[i],next=modRingData[i+1];for(const p1 of curr.pts){if(!p1.isGcd1)continue;const p2=next.pts.find(p=>p.r===p1.r&&p.isGcd1);if(p2){ctx.beginPath();ctx.moveTo(p1.px,p1.py);ctx.lineTo(p2.px,p2.py);ctx.stroke();}}}}
ctx.fillStyle=isDark()?'#00d9ff':'#0066cc';ctx.font='bold 14px Segoe UI';ctx.textAlign='center';
ctx.fillText(smithEnabled?`Smith Chart: M=${minM} to ${maxM}, α=${smithAlpha}°, Zoom ${smithZoom}x`:`Modular Rings M=${minM} to ${maxM}`,cx,20);
legend('almod',smithEnabled?'Smith Chart':'Modular Rings',[]);
const stmodEl = document.getElementById('stmod');
if (stmodEl) stmodEl.innerHTML='';
const phiData=modRingData.filter(r=>r.m>1).map(r=>({m:r.m,phi:r.phi,density:r.phi/r.m}));
if (document.getElementById('pmodphi')) Plotly.newPlot('pmodphi',[{x:phiData.map(d=>d.m),y:phiData.map(d=>d.density),type:'scatter',mode:'lines+markers',name:'φ(M)/M',line:{color:'#ffd700'},marker:{color:'#ffd700'}}],{...plo(),xaxis:{title:'Modulus M'},yaxis:{title:'φ(M)/M',range:[0,1]}});
const avgDensity=phiData.length>0?phiData.reduce((a,d)=>a+d.density,0)/phiData.length:0;
const minDensity=phiData.length>0?Math.min(...phiData.map(d=>d.density)):0;
const maxDensity=phiData.length>0?Math.max(...phiData.map(d=>d.density)):0;
const gapColors={2:'#FF6B6B',4:'#4ECDC4',6:'#FFE66D',8:'#95E1D3',10:'#F38181'};
let gapHtml=selectedGaps.length>0?selectedGaps.map(g=>`<span style="display:inline-block;padding:2px 8px;margin:2px;border-radius:4px;background:${gapColors[g]||'#888'};color:#000;font-weight:bold">Gap ${g}</span>`).join(''):'<em>None</em>';
const phaseDeg=phase*180/Math.PI,ringIncDeg=ringInc*180/Math.PI;
const modStatsEl = document.getElementById('modLiveStats');
if (modStatsEl) modStatsEl.innerHTML=`
<div style="margin-bottom:12px;padding-bottom:8px;border-bottom:1px solid var(--bord)">
<strong style="color:var(--acc)">Configuration</strong><br>
<div style="display:grid;grid-template-columns:1fr 1fr;gap:4px;margin-top:6px">
<span>Modulus Range:</span><span style="color:var(--txt)">${minM} → ${maxM}</span>
<span>Ring Count:</span><span style="color:var(--txt)">${rings.length}</span>
<span>Spacing:</span><span style="color:var(--txt)">${spacing}</span>
<span>Color Mode:</span><span style="color:var(--txt)">${col}</span>
</div>
</div>
<div style="margin-bottom:12px;padding-bottom:8px;border-bottom:1px solid var(--bord)">
<strong style="color:var(--acc)">Rotation Settings</strong><br>
<div style="display:grid;grid-template-columns:1fr 1fr;gap:4px;margin-top:6px">
<span>Global Phase α:</span><span style="color:#00d9ff;font-weight:bold">${phaseDeg.toFixed(2)}°</span>
<span>Phase as r/m:</span><span style="color:#9664ff">${phaseDeg>0?fmt(phaseDeg/360)+' rev':'0'}</span>
<span>Per-Ring Increment:</span><span style="color:#ffd700;font-weight:bold">${ringIncDeg.toFixed(2)}°</span>
<span>Total Twist:</span><span style="color:#ff8c00">${fmt(ringIncDeg*(rings.length-1))}°</span>
</div>
</div>
<div style="margin-bottom:12px;padding-bottom:8px;border-bottom:1px solid var(--bord)">
<strong style="color:var(--acc)">Statistics</strong><br>
<div style="display:grid;grid-template-columns:1fr 1fr;gap:4px;margin-top:6px">
<span>Total Residues:</span><span style="color:#00d9ff;font-weight:bold">${totalPts}</span>
<span>GCD=1 Count:</span><span style="color:#ffd700;font-weight:bold">${totalGcd1}</span>
<span>Coprime Density:</span><span style="color:#00ff88;font-weight:bold">${fmt(100*totalGcd1/totalPts)}%</span>
<span>Avg φ(M)/M:</span><span style="color:#ffd700">${fmt(avgDensity*100)}%</span>
<span>Min φ(M)/M:</span><span style="color:#ff6496">${fmt(minDensity*100)}%</span>
<span>Max φ(M)/M:</span><span style="color:#00ff88">${fmt(maxDensity*100)}%</span>
</div>
</div>
<div style="margin-bottom:12px;padding-bottom:8px;border-bottom:1px solid var(--bord)">
<strong style="color:var(--acc)">Active Gaps</strong><br>
<div style="margin-top:6px">${gapHtml}</div>
</div>
<div>
<strong style="color:var(--acc)">Connections</strong><br>
<div style="display:grid;grid-template-columns:1fr 1fr;gap:4px;margin-top:6px">
<span>Direct Lifts:</span><span style="color:${showDirect?'#00ff88':'#ff6496'}">${showDirect?'ON':'OFF'}</span>
<span>Smith Chart:</span><span style="color:${smithEnabled?'#00ff88':'#ff6496'}">${smithEnabled?'ON':'OFF'}</span>
${smithEnabled?`<span>Smith Zoom:</span><span style="color:var(--txt)">${smithZoom}x</span>
<span>Phase α:</span><span style="color:var(--txt)">${smithAlpha}°</span>`:''}
</div>
</div>
${singularSeriesHTML(maxM, selectedGaps[0]||2, 'Modular Sieve (Max M)')}`;
c.onclick=e=>{const rect=c.getBoundingClientRect(),mx=(e.clientX-rect.left)*(c.width/rect.width),my=(e.clientY-rect.top)*(c.height/rect.height);for(const ring of modRingData)for(const p of ring.pts)if(Math.hypot(mx-p.px,my-p.py)<ptSz+5){const theta=p.ang+smithAlpha*Math.PI/180;const smR=smithEnabled?getSmithR(ring.index,ring.m):1;let gamma;if(smithRMode==='unit')gamma={re:0,im:Math.tan(theta/2)};else{const A=smR*Math.cos(theta)-1,B=smR*Math.sin(theta),C=smR*Math.cos(theta)+1;const denom=C*C+B*B;gamma=denom<1e-10?{re:0,im:0}:{re:(A*C+B*B)/denom,im:B*(C-A)/denom};}modal('Residue Point',[['Residue r',p.r],['Modulus M',p.m],['GCD(r,M)',p.g],['Coprime χ(r)≠0',p.isGcd1?'Yes':'No'],['Angle θ',fmt(p.ang*180/Math.PI)+'°'],['φ(M)',ring.phi],smithEnabled?['Γ (Smith)',`${gamma.re.toFixed(4)} + ${gamma.im.toFixed(4)}i`]:['Ring Radius',fmt(p.rad)]]);return;}};}

// Single M Projection Mode (Farey Channels)
function drawSingleMProjection(c,ctx){
const M=+document.getElementById('modSingleM')?.value||60;
const showFarey=document.getElementById('modFareyLines')?.checked!==false;
const fareyStyle=document.getElementById('modFareyStyle')?.value||'straight';
const fareyCol=document.getElementById('modFareyCol')?.value||'red';
const fareyThick=+document.getElementById('modFareyThick')?.value||1;
const showChannels=document.getElementById('modShowChannels')?.checked!==false;
const showAllPts=document.getElementById('modShowAllPts')?.checked!==false;
const colorInner=document.getElementById('modColorInner')?.checked!==false;
const ptCol=document.getElementById('modSingleCol')?.value||'coprime';
const invert=document.getElementById('modInvert')?.checked||false;
const constellation=document.getElementById('modConstellation')?.value||'none';
const constColor=document.getElementById('modConstColor')?.value||'#ff00ff';
const filter=document.getElementById('modFilter')?.value||'all';
const innerLabel=document.getElementById('modInnerLabel')?.value||'none';
const highlightPrimes=document.getElementById('modHighlightPrimes')?.checked||false;

ctx.fillStyle=canvBg();ctx.fillRect(0,0,c.width,c.height);
const cx=c.width/2,cy=c.height/2,maxRad=Math.min(cx,cy)-50;

// Helper: smallest prime factor
const spf=(n)=>{if(n<2)return n;for(let p=2;p*p<=n;p++)if(n%p===0)return p;return n;};
// Helper: largest prime factor
const lpf=(n)=>{if(n<2)return n;let largest=1;for(let p=2;p*p<=n;p++){while(n%p===0){largest=p;n/=p;}}if(n>1)largest=n;return largest;};
// Helper: is prime
const isPrime=(n)=>{if(n<2)return false;if(n===2)return true;if(n%2===0)return false;for(let i=3;i*i<=n;i+=2)if(n%i===0)return false;return true;};
// Helper: is perfect square
const isSquare=(n)=>{const s=Math.floor(Math.sqrt(n));return s*s===n;};

// Get divisors of M for channel rings
const divisors=[];
for(let d=1;d<=M;d++)if(M%d===0)divisors.push(d);
divisors.sort((a,b)=>a-b);

// Compute prime factorization
const factors=[];
let temp=M;
for(let p=2;p*p<=temp;p++){let exp=0;while(temp%p===0){exp++;temp/=p;}if(exp>0)factors.push({p,exp});}
if(temp>1)factors.push({p:temp,exp:1});
const factorStr=factors.map(f=>f.exp>1?`${f.p}<sup>${f.exp}</sup>`:f.p).join('·');

// Ring radii: outer ring is M, inner rings are divisors
const ringMap={};
const numRings=divisors.length;
divisors.forEach((d,i)=>{
const idx=invert?numRings-1-i:i;
ringMap[d]={radius:maxRad*(idx+1)/numRings,index:idx};
});

// Draw channel rings
const showRingLabels=document.getElementById('modShowRingLabels')?.checked!==false;
if(showChannels){
ctx.lineWidth=1;
for(const d of divisors){
const rad=ringMap[d].radius;
ctx.strokeStyle=d===M?'rgba(0,217,255,0.8)':'rgba(255,215,0,0.5)';
ctx.lineWidth=d===M?2:1;
ctx.beginPath();ctx.arc(cx,cy,rad,0,2*Math.PI);ctx.stroke();
// Ring label
if(showRingLabels){
ctx.fillStyle=isDark()?'rgba(255,255,255,0.7)':'rgba(0,0,0,0.7)';
ctx.font='10px Segoe UI';ctx.textAlign='right';
ctx.fillText(`M'=${d}`,cx+rad-5,cy-5);
}
}}

// Compute residue data
const residues=[];
const phi=eulerPhi(M);
for(let r=0;r<M;r++){
const g=gcd(r,M);
const Mprime=M/g;
const rprime=r/g;
const isCoprime=g===1;
if(filter==='coprime'&&!isCoprime)continue;
if(filter==='noncoprime'&&isCoprime)continue;
if(filter==='prime'&&!isPrime(r))continue;
if(filter==='squares'&&!isSquare(r))continue;
residues.push({r,g,Mprime,rprime,isCoprime,spf:spf(r),lpf:lpf(r),isPrime:isPrime(r)});
}

// SPF colors
const spfColors={2:'#FF6B6B',3:'#4ECDC4',5:'#FFE66D',7:'#95E1D3',11:'#F38181',13:'#AA96DA',17:'#FCBAD3',19:'#A8D8EA',23:'#DFE6E9'};

// Draw Farey projection lines
if(showFarey){
ctx.lineWidth=fareyThick;
for(const res of residues){
if(res.isCoprime)continue; // Only reducible residues have projection lines
const outerRad=ringMap[M].radius;
const innerRad=ringMap[res.Mprime].radius;
const outerAng=2*Math.PI*res.r/M-Math.PI/2;
const innerAng=2*Math.PI*res.rprime/res.Mprime-Math.PI/2;

const x1=cx+outerRad*Math.cos(outerAng);
const y1=cy+outerRad*Math.sin(outerAng);
const x2=cx+innerRad*Math.cos(innerAng);
const y2=cy+innerRad*Math.sin(innerAng);

let lineCol;
if(fareyCol==='red')lineCol='rgba(255,0,0,0.6)';
else if(fareyCol==='gold')lineCol='rgba(255,215,0,0.6)';
else if(fareyCol==='gcd')lineCol=`hsla(${(res.g*60)%360},70%,50%,0.6)`;
else if(fareyCol==='depth'){const depth=Math.log2(res.g);lineCol=`hsla(${depth*60},70%,50%,0.6)`;}
else if(fareyCol==='gradient'){const t=res.r/M;lineCol=`hsla(${t*360},70%,50%,0.6)`;}
else if(fareyCol==='spf')lineCol=spfColors[res.spf]||`hsla(${(res.spf*37)%360},70%,50%,0.6)`;
else if(fareyCol==='channel')lineCol=`hsla(${(ringMap[res.Mprime].index*50)%360},70%,50%,0.6)`;
else lineCol='rgba(255,0,0,0.6)';

ctx.strokeStyle=lineCol;
ctx.beginPath();
if(fareyStyle==='curved'){
// Bezier curve
const midR=(outerRad+innerRad)/2;
const midAng=(outerAng+innerAng)/2;
const cpx=cx+midR*1.2*Math.cos(midAng);
const cpy=cy+midR*1.2*Math.sin(midAng);
ctx.moveTo(x1,y1);ctx.quadraticCurveTo(cpx,cpy,x2,y2);
}else if(fareyStyle==='arc'){
// Arc segment
const startAng=outerAng,endAng=innerAng;
ctx.arc(cx,cy,(outerRad+innerRad)/2,startAng,endAng,outerAng>innerAng);
}else{
ctx.moveTo(x1,y1);ctx.lineTo(x2,y2);
}
ctx.stroke();
}
}

// Draw points on rings
const ptSz=5;
const allPts=[];

for(const res of residues){
// Outer ring point
const outerRad=ringMap[M].radius;
const outerAng=2*Math.PI*res.r/M-Math.PI/2;
const ox=cx+outerRad*Math.cos(outerAng);
const oy=cy+outerRad*Math.sin(outerAng);

let clr;
if(ptCol==='coprime')clr=res.isCoprime?'#00ffff':'#ff4040';
else if(ptCol==='ring')clr=`hsl(${(ringMap[M].index*60)%360},70%,60%)`;
else if(ptCol==='gcd')clr=`hsl(${(res.g*50)%360},70%,60%)`;
else if(ptCol==='rainbow')clr=`hsl(${(res.r/M*360)},70%,60%)`;
else if(ptCol==='spf')clr=spfColors[res.spf]||`hsl(${(res.spf*37)%360},70%,60%)`;
else if(ptCol==='lpf')clr=`hsl(${(res.lpf*47)%360},70%,60%)`;
else if(ptCol==='prime')clr=res.isPrime?'#FF6B6B':'#4ECDC4';
else clr=res.isCoprime?'#00ffff':'#ff4040';

// Highlight primes with ring
if(highlightPrimes&&res.isPrime){
ctx.strokeStyle='#ffd700';ctx.lineWidth=2;
ctx.beginPath();ctx.arc(ox,oy,ptSz+3,0,2*Math.PI);ctx.stroke();
}

ctx.fillStyle=clr;
ctx.beginPath();ctx.arc(ox,oy,res.isCoprime?ptSz:ptSz*0.7,0,2*Math.PI);ctx.fill();

// Outer ring point labels
const outerLabel=document.getElementById('modOuterLabel')?.value||'none';
if(outerLabel!=='none'){
ctx.font='10px Segoe UI';ctx.textAlign='center';ctx.textBaseline='bottom';
ctx.fillStyle=isDark()?'rgba(255,255,255,0.85)':'rgba(0,0,0,0.85)';
let oLbl='';
if(outerLabel==='r')oLbl=res.r;
else if(outerLabel==='rm')oLbl=`${res.r}/${M}`;
else if(outerLabel==='farey'){const g2=gcd(res.r,M);oLbl=g2===M?'0':`${res.r/g2}/${M/g2}`;}
else if(outerLabel==='deg')oLbl=Math.round((outerAng+Math.PI/2)*180/Math.PI)+'°';
else if(outerLabel==='gcd')oLbl=res.g;
else if(outerLabel==='coprime')oLbl=res.isCoprime?'OK':'X';
else if(outerLabel==='channel')oLbl=`→${res.Mprime}`;
ctx.fillText(oLbl,ox,oy-ptSz-2);
}

allPts.push({r:res.r,m:M,g:res.g,Mprime:res.Mprime,rprime:res.rprime,isCoprime:res.isCoprime,px:ox,py:oy,ring:M});

// Inner ring points (if showing all)
if(showAllPts&&!res.isCoprime){
const innerRad=ringMap[res.Mprime].radius;
const innerAng=2*Math.PI*res.rprime/res.Mprime-Math.PI/2;
const ix=cx+innerRad*Math.cos(innerAng);
const iy=cy+innerRad*Math.sin(innerAng);

let innerClr=clr;
if(colorInner){
if(ptCol==='ring')innerClr=`hsl(${(ringMap[res.Mprime].index*60)%360},70%,60%)`;
else if(ptCol==='gcd')innerClr=`hsl(${(gcd(res.rprime,res.Mprime)*50)%360},70%,60%)`;
else if(ptCol==='spf')innerClr=spfColors[spf(res.rprime)]||`hsl(${(spf(res.rprime)*37)%360},70%,60%)`;
}else{
innerClr='rgba(255,215,0,0.7)';
}
ctx.fillStyle=innerClr;
ctx.beginPath();ctx.arc(ix,iy,ptSz*0.6,0,2*Math.PI);ctx.fill();
allPts.push({r:res.rprime,m:res.Mprime,g:1,Mprime:res.Mprime,rprime:res.rprime,isCoprime:true,px:ix,py:iy,ring:res.Mprime,originalR:res.r});

// Inner ring labels
if(innerLabel!=='none'){
ctx.font='9px Segoe UI';ctx.textAlign='center';ctx.textBaseline='bottom';
ctx.fillStyle=isDark()?'rgba(255,255,255,0.7)':'rgba(0,0,0,0.7)';
let innerLbl='';
if(innerLabel==='r')innerLbl=res.rprime;
else if(innerLabel==='rm')innerLbl=`${res.rprime}/${res.Mprime}`;
else if(innerLabel==='gcd')innerLbl=gcd(res.rprime,res.Mprime);
else if(innerLabel==='same')innerLbl=res.r;
ctx.fillText(innerLbl,ix,iy-ptSz-1);
}
}
}

// Draw constellation highlights (gap connections on outer ring)
if(constellation!=='none'){
const gap=constellation==='twin'?2:constellation==='cousin'?4:constellation==='sexy'?6:8;
const coprimes=residues.filter(r=>r.isCoprime).map(r=>r.r);
ctx.strokeStyle=constColor;ctx.lineWidth=2;
for(let i=0;i<coprimes.length;i++){
const r1=coprimes[i];
const r2=(r1+gap)%M;
if(coprimes.includes(r2)){
const ang1=2*Math.PI*r1/M-Math.PI/2;
const ang2=2*Math.PI*r2/M-Math.PI/2;
const rad=ringMap[M].radius;
const x1=cx+rad*Math.cos(ang1),y1=cy+rad*Math.sin(ang1);
const x2=cx+rad*Math.cos(ang2),y2=cy+rad*Math.sin(ang2);
ctx.beginPath();ctx.moveTo(x1,y1);ctx.lineTo(x2,y2);ctx.stroke();
}
}
}

// Title
ctx.fillStyle=isDark()?'#ffd700':'#cc8800';ctx.font='bold 14px Segoe UI';ctx.textAlign='center';
ctx.fillText(`Modular Reduction Projection: M = ${M}`,cx,20);
ctx.font='12px Segoe UI';ctx.fillStyle=isDark()?'#aaa':'#666';
ctx.fillText(factors.length>0?`= ${factors.map(f=>f.exp>1?f.p+'^'+f.exp:f.p).join(' × ')}`:(isPrime(M)?'(Prime)':''),cx,38);

// Legend
legend('almod','Single M Projection',[['Coprime (GCD=1)',phi,'#00ffff'],['Reducible (GCD>1)',M-phi,'#ff4040'],['Channels',divisors.length,'#ffd700']]);

// Stats
const channelCounts={};
for(const d of divisors)channelCounts[d]=0;
for(const res of residues)channelCounts[res.Mprime]++;

const modStatsEl2 = document.getElementById('modLiveStats');
if (modStatsEl2) modStatsEl2.innerHTML=`
<div style="display:grid;grid-template-columns:repeat(3,1fr);gap:8px;margin-bottom:12px">
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center"><div style="font-size:1.2rem;font-weight:bold;color:#00d9ff">${M}</div><div style="font-size:.65rem;color:var(--txt2)">MODULUS M</div></div>
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center"><div style="font-size:1.2rem;font-weight:bold;color:#ffd700">${phi}</div><div style="font-size:.65rem;color:var(--txt2)">φ(M)</div></div>
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center"><div style="font-size:1.2rem;font-weight:bold;color:#00ff88">${divisors.length}</div><div style="font-size:.65rem;color:var(--txt2)">CHANNELS</div></div>
</div>
<div style="margin-bottom:10px;padding-bottom:8px;border-bottom:1px solid var(--bord)">
<strong style="color:var(--acc)">Factorization</strong>
<div style="margin-top:5px;font-size:.9rem;color:#ffd700">${factors.length>0?factors.map(f=>f.exp>1?f.p+'<sup>'+f.exp+'</sup>':f.p).join(' × '):'Prime'}</div>
</div>
<div style="margin-bottom:10px;padding-bottom:8px;border-bottom:1px solid var(--bord)">
<strong style="color:var(--acc)">Density Analysis</strong>
<div style="display:grid;grid-template-columns:1fr 1fr;gap:3px;margin-top:5px;font-size:.75rem">
<span>Coprime Density:</span><span style="color:#00ff88">${fmt(phi/M*100)}%</span>
<span>Reducible:</span><span style="color:#ff6496">${M-phi} (${fmt((M-phi)/M*100)}%)</span>
<span>ω(M) distinct primes:</span><span style="color:#ffd700">${factors.length}</span>
<span>Ω(M) with mult:</span><span style="color:#9664ff">${factors.reduce((a,f)=>a+f.exp,0)}</span>
</div>
</div>
<div style="margin-bottom:10px;padding-bottom:8px;border-bottom:1px solid var(--bord)">
<strong style="color:var(--acc)">Channel Distribution</strong>
<div style="max-height:120px;overflow-y:auto;margin-top:5px">
${divisors.map(d=>`<div style="display:flex;justify-content:space-between;font-size:.75rem;padding:2px 0;border-bottom:1px solid rgba(255,255,255,.1)"><span>M'=${d}</span><span style="color:#00d9ff">${channelCounts[d]} residues</span><span style="color:#ffd700">${fmt(channelCounts[d]/M*100)}%</span></div>`).join('')}
</div>
</div>
${constellation!=='none'?`<div style="background:rgba(255,0,255,.1);padding:8px;border-radius:6px;font-size:.8rem">
<strong style="color:${constColor}">Constellation: ${constellation}</strong><br>
<span style="color:var(--txt2)">Gap-${constellation==='twin'?2:constellation==='cousin'?4:constellation==='sexy'?6:8} connections shown</span>
</div>`:''}`;

// Plotly chart for channel distribution
if (document.getElementById('pmodphi')) Plotly.newPlot('pmodphi',[{x:divisors.map(d=>'M\'='+d),y:divisors.map(d=>channelCounts[d]),type:'bar',marker:{color:divisors.map(d=>d===M?'#00d9ff':'#ffd700')}}],{...plo(),xaxis:{title:'Channel'},yaxis:{title:'Residue Count'}});

// Click handler
c.onclick=e=>{
const rect=c.getBoundingClientRect();
const mx=(e.clientX-rect.left)*(c.width/rect.width);
const my=(e.clientY-rect.top)*(c.height/rect.height);
for(const p of allPts){
if(Math.hypot(mx-p.px,my-p.py)<ptSz+5){
modal(`Residue r=${p.r} mod ${p.m}`,[
['r (residue)',p.r],
['M (modulus)',p.m],
['gcd(r,M)',p.g],
['Channel M\'',p.Mprime],
['Reduced r\'',p.rprime],
['Type',p.isCoprime?'Coprime (irreducible)':'Reducible'],
['Angle θ',fmt(p.r/p.m*360)+'°'],
['r/M',fmt(p.r/p.m)],
['Ring',p.ring===M?'Outer (M)':'Inner (M\'='+p.ring+')']
]);
return;
}
}
};
}


function csvMod(){let s='modulus,residue,gcd,coprime,angle_deg\n';for(const ring of modRingData)for(const p of ring.pts)s+=`${p.m},${p.r},${p.g},${p.isGcd1},${p.ang*180/Math.PI}\n`;dl(s,'modular_rings.csv');}

// 3D Farey Divisor Lattice
let farey3DData={M:30,divisors:[],points:[],chains:[]};
let farey3DAutoInterval=null;

function drawFarey3D(){
if(!document.getElementById("cFarey3D")) return;

const c=document.getElementById('cfarey3d'),ctx=c.getContext('2d');
const M=+document.getElementById('farey3DM').value||30;
const tiltX=(+document.getElementById('farey3DX').value)*Math.PI/180;
const rotY=(+document.getElementById('farey3DY').value)*Math.PI/180;
const spinZ=(+document.getElementById('farey3DZ').value)*Math.PI/180;
const vSpace=+document.getElementById('farey3DVsp').value;
const rSpace=+document.getElementById('farey3DRsp').value;
const showChains=document.getElementById('farey3DChains').checked;
const showModLabels=document.getElementById('farey3DModLabels')?.checked!==false;
const showLabels=document.getElementById('farey3DLabels').checked;
const labelAllRings=document.getElementById('farey3DLabelAll')?.checked;
const labelStyle=document.getElementById('farey3DLabelStyle')?.value||'r';
const zoom=+document.getElementById('farey3DZoom')?.value||1;
const colScheme=document.getElementById('farey3DCol').value;

document.getElementById('farey3DTitle').textContent=M;

ctx.fillStyle=canvBg();ctx.fillRect(0,0,c.width,c.height);
const cx=c.width/2,cy=c.height/2+50;

// Get divisors of M
const divisors=[];
for(let d=1;d<=M;d++)if(M%d===0)divisors.push(d);
divisors.sort((a,b)=>a-b);
const numLevels=divisors.length;

// 3D projection with zoom
const project3D=(x,y,z)=>{
// Rotate around Z
let x1=x*Math.cos(spinZ)-y*Math.sin(spinZ);
let y1=x*Math.sin(spinZ)+y*Math.cos(spinZ);
// Rotate around Y
let x2=x1*Math.cos(rotY)+z*Math.sin(rotY);
let z1=-x1*Math.sin(rotY)+z*Math.cos(rotY);
// Tilt around X
let y2=y1*Math.cos(tiltX)-z1*Math.sin(tiltX);
let z2=y1*Math.sin(tiltX)+z1*Math.cos(tiltX);
// Perspective with zoom
const persp=600/(600-z2)*zoom;
return{x:cx+x2*persp,y:cy-y2*persp,z:z2,scale:persp};
};

// Create points for each level
const points=[];
const maxRad=250*rSpace;
const levelHeight=80*vSpace;

divisors.forEach((d,lvl)=>{
const rad=maxRad*(lvl+1)/numLevels;
const z=-(numLevels-1-lvl)*levelHeight;
const phi=eulerPhi(d);

for(let r=0;r<d;r++){
const ang=2*Math.PI*r/d-Math.PI/2;
const x3d=rad*Math.cos(ang);
const y3d=rad*Math.sin(ang);
const g=gcd(r,d);
const isCoprime=g===1;
const proj=project3D(x3d,y3d,z);
points.push({r,d,g,isCoprime,x3d,y3d,z,px:proj.x,py:proj.y,pz:proj.z,scale:proj.scale,lvl,ang});
}
});

// Sort by z for proper depth ordering
points.sort((a,b)=>a.pz-b.pz);

// Draw level rings (back to front)
for(let lvl=0;lvl<numLevels;lvl++){
const d=divisors[lvl];
const rad=maxRad*(lvl+1)/numLevels;
const z=-(numLevels-1-lvl)*levelHeight;
ctx.strokeStyle=`rgba(255,215,0,${0.2+0.3*lvl/numLevels})`;
ctx.lineWidth=1;
ctx.beginPath();
for(let a=0;a<=360;a+=5){
const ang=a*Math.PI/180-Math.PI/2;
const p=project3D(rad*Math.cos(ang),rad*Math.sin(ang),z);
if(a===0)ctx.moveTo(p.x,p.y);else ctx.lineTo(p.x,p.y);
}
ctx.stroke();
// Level label (M'=d)
if(showModLabels){
const labelP=project3D(rad+15,0,z);
ctx.fillStyle=isDark()?'rgba(255,255,255,0.6)':'rgba(0,0,0,0.6)';
ctx.font='10px Segoe UI';ctx.textAlign='left';
ctx.fillText(`M'=${d}`,labelP.x,labelP.y);
}
}

// Draw Farey chains (reduction lines)
if(showChains){
for(const pt of points){
if(pt.d!==M||pt.isCoprime)continue;
// Find reduced point
const Mprime=M/pt.g;
const rprime=pt.r/pt.g;
const targetLvl=divisors.indexOf(Mprime);
if(targetLvl<0)continue;
const targetRad=maxRad*(targetLvl+1)/numLevels;
const targetZ=-(numLevels-1-targetLvl)*levelHeight;
const targetAng=2*Math.PI*rprime/Mprime-Math.PI/2;
const target=project3D(targetRad*Math.cos(targetAng),targetRad*Math.sin(targetAng),targetZ);
ctx.strokeStyle='rgba(255,215,0,0.4)';
ctx.lineWidth=1;
ctx.beginPath();ctx.moveTo(pt.px,pt.py);ctx.lineTo(target.x,target.y);ctx.stroke();
}
}

// Helper for label text
const getLabelText=(pt)=>{
if(labelStyle==='r')return pt.r;
if(labelStyle==='gcd')return pt.g;
if(labelStyle==='frac')return pt.r+'/'+pt.d;
if(labelStyle==='zi')return 'ζ^'+pt.r;
if(labelStyle==='coprime')return pt.isCoprime?'OK':'·';
return pt.r;
};

// Draw points
const ptSz=4;
for(const pt of points){
let clr;
if(colScheme==='coprime')clr=pt.isCoprime?'#00ffff':'#ff4040';
else if(colScheme==='level')clr=`hsl(${(pt.lvl*360/numLevels)},70%,60%)`;
else if(colScheme==='gcd')clr=`hsl(${(pt.g*50)%360},70%,60%)`;
else if(colScheme==='rainbow')clr=`hsl(${(pt.r/pt.d*360)},70%,60%)`;
else clr=pt.isCoprime?'#00ffff':'#ff4040';

const sz=ptSz*pt.scale;
ctx.fillStyle=clr;
ctx.beginPath();ctx.arc(pt.px,pt.py,sz,0,2*Math.PI);ctx.fill();

// Label points
const shouldLabel=showLabels&&pt.scale>0.7&&(pt.d===M||labelAllRings);
if(shouldLabel){
ctx.fillStyle=isDark()?'rgba(255,255,255,0.8)':'rgba(0,0,0,0.8)';
ctx.font=`${Math.max(7,9*pt.scale)}px Segoe UI`;ctx.textAlign='center';
ctx.fillText(getLabelText(pt),pt.px,pt.py-sz-2);
}
}

// Title
ctx.fillStyle=isDark()?'#9664ff':'#6644bb';ctx.font='bold 14px Segoe UI';ctx.textAlign='center';
ctx.fillText(`3D Farey Divisor Lattice: M = ${M}`,c.width/2,20);
ctx.font='11px Segoe UI';ctx.fillStyle=isDark()?'#aaa':'#666';
ctx.fillText(`${numLevels} levels | ${points.length} total points | φ(${M}) = ${eulerPhi(M)} | Zoom ${zoom}×`,c.width/2,38);

// Legend
legend('alfarey3d','3D Farey Lattice',[['Levels',numLevels,'#ffd700'],['Coprimes',eulerPhi(M),'#00ffff'],['Reducible',M-eulerPhi(M),'#ff4040']]);

// Stats
const phi=eulerPhi(M);
const factors=[];let temp=M;
for(let p=2;p*p<=temp;p++){let exp=0;while(temp%p===0){exp++;temp/=p;}if(exp>0)factors.push({p,exp});}
if(temp>1)factors.push({p:temp,exp:1});

document.getElementById('farey3DStats').innerHTML=`
<div style="display:grid;grid-template-columns:repeat(3,1fr);gap:8px;margin-bottom:12px">
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center"><div style="font-size:1.3rem;font-weight:bold;color:#9664ff">${M}</div><div style="font-size:.7rem;color:var(--txt2)">MODULUS M</div></div>
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center"><div style="font-size:1.3rem;font-weight:bold;color:#ffd700">${numLevels}</div><div style="font-size:.7rem;color:var(--txt2)">LATTICE LEVELS</div></div>
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center"><div style="font-size:1.3rem;font-weight:bold;color:#00d9ff">${points.filter(p=>!p.isCoprime&&p.d===M).length}</div><div style="font-size:.7rem;color:var(--txt2)">REDUCTION MAPS</div></div>
</div>
<div style="margin-bottom:10px;padding-bottom:8px;border-bottom:1px solid var(--bord)">
<strong style="color:var(--acc)">Factorization</strong>
<div style="margin-top:5px;font-size:.9rem;color:#ffd700">${factors.length>0?factors.map(f=>f.exp>1?f.p+'<sup>'+f.exp+'</sup>':f.p).join(' × '):'Prime'}</div>
</div>
<div style="margin-bottom:10px;padding-bottom:8px;border-bottom:1px solid var(--bord)">
<strong style="color:var(--acc)">Divisor Ring Structure</strong>
<div style="display:flex;flex-wrap:wrap;gap:4px;margin-top:6px">
${divisors.map(d=>`<span style="background:${d===M?'#00d9ff':d===1?'#ffd700':'var(--bg1)'};padding:2px 6px;border-radius:4px;font-size:.75rem">${d}</span>`).join('')}
</div>
</div>
<div>
<strong style="color:var(--acc)">Totient Values</strong>
<div style="display:grid;grid-template-columns:1fr 1fr;gap:4px;margin-top:6px;font-size:.8rem">
<span>φ(${M}):</span><span style="color:#00ff88">${phi}</span>
<span>Coprime Density:</span><span style="color:#ffd700">${fmt(phi/M*100)}%</span>
</div>
</div>
${singularSeriesHTML(M, 2, 'Modular Sieve')}`;

farey3DData={M,divisors,points};

// Click handler
c.onclick=e=>{
const rect=c.getBoundingClientRect();
const mx=(e.clientX-rect.left)*(c.width/rect.width);
const my=(e.clientY-rect.top)*(c.height/rect.height);
for(const pt of points){
if(Math.hypot(mx-pt.px,my-pt.py)<6){
modal(`Point on Level ${pt.lvl+1}`,[
['Residue r',pt.r],
['Modulus M\'',pt.d],
['GCD(r,M\')',pt.g],
['Coprime',pt.isCoprime?'Yes (irreducible)':'No (reducible)'],
['Level',`${pt.lvl+1} of ${numLevels}`],
['Angle θ',fmt(pt.ang*180/Math.PI+90)+'°']
]);
return;
}
}
};

// Mouse wheel zoom
c.onwheel=e=>{
const zoom=document.getElementById('farey3DZoom');
const newVal=Math.max(0.5,Math.min(3,+zoom.value+(e.deltaY>0?-0.1:0.1)));
zoom.value=newVal.toFixed(1);
document.getElementById('farey3DZoomV').textContent=newVal.toFixed(1)+'×';
drawFarey3D();
e.preventDefault();
};
}

function toggleFarey3DAuto(){
if(document.getElementById('farey3DAuto').checked){
farey3DAutoInterval=setInterval(()=>{
const y=document.getElementById('farey3DY');
y.value=(+y.value+2)%360;
document.getElementById('farey3DYV').textContent=y.value+'°';
drawFarey3D();
},50);
}else{
if(farey3DAutoInterval)clearInterval(farey3DAutoInterval);
farey3DAutoInterval=null;
}
}

async function screenshotFarey3D(){
const M=document.getElementById('farey3DM').value;
await screenshotUnified('cfarey3d','farey3DStats',`3D Farey Divisor Lattice — M = ${M}`,'farey3d_complete.png',{dashH:300});
}

function csvFarey3D(){
let s='level,modulus,residue,gcd,coprime,angle_deg\n';
for(const pt of farey3DData.points)s+=`${pt.lvl+1},${pt.d},${pt.r},${pt.g},${pt.isCoprime},${fmt(pt.ang*180/Math.PI+90)}\n`;
dl(s,'farey3d_lattice.csv');
}

// Dirichlet Characters
let dirData={M:12,chars:[],current:null};

function getDirichletChars(M){
// Generate all Dirichlet characters mod M
// For simplicity, we compute character values as roots of unity
const phi=eulerPhi(M);
const units=[];
for(let r=1;r<M;r++)if(gcd(r,M)===1)units.push(r);

// Find a generator if exists (primitive root)
let gen=null;
for(const g of units){if(mulOrd(g,M)===phi){gen=g;break;}}

const chars=[];
// Principal character
const chi0={idx:0,name:'χ₀',values:{},order:1};
for(let r=0;r<M;r++)chi0.values[r]=gcd(r,M)===1?{re:1,im:0}:{re:0,im:0};
chars.push(chi0);

// Other characters (if primitive root exists)
if(gen!==null){
for(let k=1;k<phi;k++){
const chi={idx:k,name:`χ_${k}`,values:{},order:phi/gcd(k,phi)};
for(let r=0;r<M;r++){
if(gcd(r,M)>1){chi.values[r]={re:0,im:0};}
else{
// Find discrete log of r base gen
let dlog=0,x=1;
for(let i=0;i<phi;i++){if(x===r){dlog=i;break;}x=(x*gen)%M;}
const ang=2*Math.PI*k*dlog/phi;
chi.values[r]={re:Math.cos(ang),im:Math.sin(ang)};}}
chars.push(chi);}}
else{
// No primitive root - just create principal
for(let k=1;k<Math.min(phi,10);k++){
const chi={idx:k,name:`χ_${k}`,values:{},order:1};
for(let r=0;r<M;r++)chi.values[r]=gcd(r,M)===1?{re:1,im:0}:{re:0,im:0};
chars.push(chi);}}
return chars;}

function drawDirichlet(){
if(!document.getElementById("cDir")) return;

const c=document.getElementById('cdir'),ctx=c.getContext('2d');
const M=+document.getElementById('dirMv').value||+document.getElementById('dirM').value;
const charIdx=+document.getElementById('dirIdx').value;
const viz=document.getElementById('dirViz').value;
const col=document.getElementById('dirCol').value;
const ptSz=+document.getElementById('dirPtSz').value;
const showLabels=document.getElementById('dirLabels').checked;
const showGrid=document.getElementById('dirGrid').checked;
const showRays=document.getElementById('dirRays').checked;
const showConnect=document.getElementById('dirConnect').checked;
const Lterms=+document.getElementById('dirLterms').value;

ctx.fillStyle=canvBg();ctx.fillRect(0,0,c.width,c.height);
document.getElementById('dirMdisp').textContent=M;

// Generate characters
dirData.M=M;
dirData.chars=getDirichletChars(M);
const phi=eulerPhi(M);

// Update slider max
document.getElementById('dirIdx').max=Math.min(dirData.chars.length-1,phi-1);
const chi=dirData.chars[Math.min(charIdx,dirData.chars.length-1)]||dirData.chars[0];
dirData.current=chi;

// Update label
const idxLabel=document.getElementById('dirIdxLabel');
idxLabel.textContent=charIdx===0?'(Principal χ₀)':`(Order ${chi.order})`;

const cx=c.width/2,cy=c.height/2,R=Math.min(cx,cy)-80;
const pad=50,w=c.width-2*pad,h=c.height-2*pad;

// Collect data
const pts=[];
let supportCount=0,zeroCount=0;
for(let r=0;r<M;r++){
const v=chi.values[r];
const isSupport=Math.abs(v.re)>1e-10||Math.abs(v.im)>1e-10;
if(isSupport)supportCount++;else zeroCount++;
const arg=Math.atan2(v.im,v.re);
const mag=Math.sqrt(v.re*v.re+v.im*v.im);
pts.push({r,v,isSupport,arg,mag,gcdVal:gcd(r,M)});}

if(viz==='circle'||viz==='support'){
// Unit circle visualization
if(showGrid){
ctx.strokeStyle=gridC();ctx.lineWidth=1;
ctx.beginPath();ctx.arc(cx,cy,R,0,2*Math.PI);ctx.stroke();
// Axes
ctx.beginPath();ctx.moveTo(cx-R-20,cy);ctx.lineTo(cx+R+20,cy);ctx.stroke();
ctx.beginPath();ctx.moveTo(cx,cy-R-20);ctx.lineTo(cx,cy+R+20);ctx.stroke();
// Labels
ctx.fillStyle=isDark()?'#888':'#666';ctx.font='12px Segoe UI';ctx.textAlign='center';
ctx.fillText('Re',cx+R+30,cy+4);ctx.fillText('Im',cx,cy-R-25);
ctx.fillText('1',cx+R+5,cy+15);ctx.fillText('-1',cx-R-10,cy+15);
ctx.fillText('i',cx+10,cy-R+5);ctx.fillText('-i',cx+10,cy+R+15);}

if(showRays){
ctx.strokeStyle='rgba(150,100,255,0.3)';ctx.lineWidth=1;
for(let k=0;k<phi;k++){
const ang=2*Math.PI*k/phi;
ctx.beginPath();ctx.moveTo(cx,cy);ctx.lineTo(cx+R*1.1*Math.cos(ang),cy-R*1.1*Math.sin(ang));ctx.stroke();}}

// Draw character values on unit circle
const drawnPts=[];
for(const p of pts){
let x,y;
if(p.isSupport){
x=cx+R*p.v.re;y=cy-R*p.v.im;
}else{
// Zero values - place at origin or along real axis
x=cx;y=cy;}

let clr;
if(col==='support')clr=p.isSupport?'#ffd700':'#555';
else if(col==='arg')clr=p.isSupport?`hsl(${(p.arg+Math.PI)/(2*Math.PI)*360},80%,55%)`:'#555';
else if(col==='real')clr=p.isSupport?(p.v.re>=0?'#00ff88':'#ff6496'):'#555';
else clr=p.isSupport?`hsl(${chi.order*60},70%,55%)`:'#555';

if(p.isSupport){
ctx.fillStyle=clr;
ctx.beginPath();ctx.arc(x,y,ptSz,0,2*Math.PI);ctx.fill();
ctx.strokeStyle=isDark()?'#fff':'#000';ctx.lineWidth=1;ctx.stroke();
drawnPts.push({x,y,p});

if(showLabels&&M<=24){
ctx.fillStyle=isDark()?'#fff':'#000';ctx.font='10px Arial';ctx.textAlign='center';
ctx.fillText(p.r,x,y-ptSz-5);}}}

if(showConnect&&drawnPts.length>1){
ctx.strokeStyle='rgba(0,217,255,0.4)';ctx.lineWidth=1;ctx.beginPath();
const sorted=[...drawnPts].sort((a,b)=>a.p.r-b.p.r);
ctx.moveTo(sorted[0].x,sorted[0].y);
for(let i=1;i<sorted.length;i++)ctx.lineTo(sorted[i].x,sorted[i].y);
ctx.closePath();ctx.stroke();}

// Show zeros clustered
ctx.fillStyle='#555';ctx.font='11px Segoe UI';ctx.textAlign='center';
const zeros=pts.filter(p=>!p.isSupport);
if(zeros.length>0){
ctx.fillText(`χ(r)=0 for r∈{${zeros.slice(0,8).map(p=>p.r).join(',')}}${zeros.length>8?'...':''}`,cx,c.height-30);}}

else if(viz==='residues'){
// Residue class bar visualization
const barW=w/(M+1),barH=h*0.6;
ctx.fillStyle=isDark()?'#ffd700':'#cc8800';ctx.font='bold 14px Segoe UI';ctx.textAlign='center';
ctx.fillText(`Residue Classes mod ${M}`,cx,pad-10);

for(let r=0;r<M;r++){
const p=pts[r];
const x=pad+(r+0.5)*barW;
const barHeight=p.isSupport?barH:barH*0.2;
const clr=p.isSupport?'#ffd700':'#555';
ctx.fillStyle=clr;
ctx.fillRect(x-barW*0.4,cy+barH/2-barHeight,barW*0.8,barHeight);
ctx.fillStyle=isDark()?'#fff':'#000';ctx.font='10px Arial';
ctx.fillText(r,x,cy+barH/2+20);
if(p.isSupport&&showLabels){
ctx.fillStyle='#00d9ff';ctx.font='9px Arial';
const vStr=p.v.im===0?p.v.re.toFixed(2):`e^{${(p.arg/Math.PI).toFixed(2)}πi}`;
ctx.fillText(p.v.re.toFixed(1),x,cy+barH/2-barHeight-8);}}}

else if(viz==='table'){
// Full character table
const chars=dirData.chars.slice(0,Math.min(10,phi));
const cellW=w/(M+2),cellH=25;
ctx.font='11px Segoe UI';
// Header
ctx.fillStyle='#00d9ff';ctx.textAlign='center';
ctx.fillText('r',pad+cellW/2,pad+cellH/2);
for(let r=0;r<M;r++)ctx.fillText(r,pad+(r+1.5)*cellW,pad+cellH/2);
// Rows for each character
for(let ci=0;ci<chars.length;ci++){
const chi=chars[ci];
const y=pad+(ci+1.5)*cellH;
ctx.fillStyle='#ffd700';ctx.fillText(chi.name,pad+cellW/2,y);
for(let r=0;r<M;r++){
const v=chi.values[r];
const isZ=Math.abs(v.re)<1e-10&&Math.abs(v.im)<1e-10;
ctx.fillStyle=isZ?'#555':Math.abs(v.im)<1e-10?(v.re>0?'#00ff88':'#ff6496'):'#00d9ff';
let txt=isZ?'0':Math.abs(v.im)<1e-10?v.re.toFixed(0):Math.abs(v.re)<1e-10?(v.im>0?'i':'-i'):'ω';
ctx.fillText(txt,pad+(r+1.5)*cellW,y);}}}

else if(viz==='lfunction'){

ctx.fillStyle=isDark()?'#ffd700':'#cc8800';ctx.font='bold 16px Segoe UI';ctx.textAlign='center';
ctx.fillText(`L(s,χ) = Σ χ(n)/nˢ  (${Lterms} terms)`,cx,cy-80);
ctx.fillStyle=isDark()?'#00d9ff':'#0066cc';ctx.font='14px Segoe UI';
// Compute for display
const sDisp=[1,2,3];
for(let si=0;si<sDisp.length;si++){
const s=sDisp[si];
let Lre=0,Lim=0;
for(let n=1;n<=Lterms;n++){const v=chi.values[n%M];Lre+=v.re*Math.pow(n,-s);Lim+=v.im*Math.pow(n,-s);}
ctx.fillText(`L(${s},χ) ≈ ${Lre.toFixed(4)} + ${Lim.toFixed(4)}i   |L| = ${Math.sqrt(Lre*Lre+Lim*Lim).toFixed(4)}`,cx,cy-30+si*30);}}


const sVals=[1,1.2,1.5,2,2.5,3,4,5];
const Ldata=[];
for(const s of sVals){
let Lre=0,Lim=0;
for(let n=1;n<=Lterms;n++){
const v=chi.values[n%M];
const coef=Math.pow(n,-s);
Lre+=v.re*coef;Lim+=v.im*coef;}
Ldata.push({s,Lre,Lim,Lmag:Math.sqrt(Lre*Lre+Lim*Lim)});}
Plotly.newPlot('pdirL',[
{x:sVals,y:Ldata.map(d=>d.Lre),name:'Re L(s,χ)',mode:'lines+markers',line:{color:'#00d9ff'}},
{x:sVals,y:Ldata.map(d=>d.Lim),name:'Im L(s,χ)',mode:'lines+markers',line:{color:'#ff8c00'}},
{x:sVals,y:Ldata.map(d=>d.Lmag),name:'|L(s,χ)|',mode:'lines+markers',line:{color:'#00ff88'}}
],{...plo(),xaxis:{title:'s'},yaxis:{title:'L(s,χ)'}});

// Distribution chart
const argBins=[];
for(let k=0;k<8;k++){
const lo=-Math.PI+k*Math.PI/4,hi=lo+Math.PI/4;
const cnt=pts.filter(p=>p.isSupport&&p.arg>=lo&&p.arg<hi).length;
argBins.push({bin:`${(lo/Math.PI*180).toFixed(0)}°`,count:cnt});}
Plotly.newPlot('pdirDist',[{x:argBins.map(b=>b.bin),y:argBins.map(b=>b.count),type:'bar',marker:{color:'#9664ff'}}],{...plo(),xaxis:{title:'Argument'},yaxis:{title:'Count'}});

// Orthogonality check
const orthoData=[];
for(let i=0;i<Math.min(5,dirData.chars.length);i++){
for(let j=i;j<Math.min(5,dirData.chars.length);j++){
let sumRe=0,sumIm=0;
for(let r=0;r<M;r++){
const vi=dirData.chars[i].values[r],vj=dirData.chars[j].values[r];
sumRe+=vi.re*vj.re+vi.im*vj.im;sumIm+=vi.im*vj.re-vi.re*vj.im;}
orthoData.push({i,j,sum:Math.sqrt(sumRe*sumRe+sumIm*sumIm)});}}
Plotly.newPlot('pdirOrtho',[{x:orthoData.map(d=>`χ${d.i}·χ̄${d.j}`),y:orthoData.map(d=>d.sum),type:'bar',marker:{color:orthoData.map(d=>d.i===d.j?'#ffd700':'#555')}}],{...plo(),xaxis:{title:'Character Pair'},yaxis:{title:'|Σχᵢχ̄ⱼ|'}});

// Legend
legend('aldir','Character Info',[['Support χ≠0',supportCount,'#ffd700'],['Zero χ=0',zeroCount,'#555'],['Order',chi.order,'#00d9ff']]);

// Live stats
document.getElementById('dirLiveStats').innerHTML=`
<div style="display:grid;grid-template-columns:repeat(3,1fr);gap:8px;margin-bottom:12px">
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center"><div style="font-size:1.4rem;font-weight:bold;color:#00d9ff">${M}</div><div style="font-size:.7rem;color:var(--txt2)">MODULUS M</div></div>
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center"><div style="font-size:1.4rem;font-weight:bold;color:#ffd700">${phi}</div><div style="font-size:.7rem;color:var(--txt2)">φ(M)</div></div>
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center"><div style="font-size:1.4rem;font-weight:bold;color:#00ff88">${dirData.chars.length}</div><div style="font-size:.7rem;color:var(--txt2)">CHARACTERS</div></div>
</div>
<div style="margin-bottom:10px;padding-bottom:8px;border-bottom:1px solid var(--bord)">
<strong style="color:var(--acc)">Current Character χ_${charIdx}</strong>
<div style="display:grid;grid-template-columns:1fr 1fr;gap:3px;margin-top:5px;font-size:.8rem">
<span>Order:</span><span style="color:#9664ff">${chi.order}</span>
<span>Support size:</span><span style="color:#ffd700">${supportCount}</span>
<span>Zero count:</span><span style="color:#555">${zeroCount}</span>
<span>Is principal:</span><span style="color:${charIdx===0?'#00ff88':'#ff6496'}">${charIdx===0?'Yes':'No'}</span>
</div>
</div>
<div style="margin-bottom:10px;padding-bottom:8px;border-bottom:1px solid var(--bord)">
<strong style="color:var(--acc)">Support (χ(r) ≠ 0)</strong>
<div style="margin-top:5px;font-size:.8rem;color:var(--txt2)">
r ∈ {${pts.filter(p=>p.isSupport).slice(0,12).map(p=>p.r).join(', ')}}${supportCount>12?'...':''}
</div>
</div>
<div style="margin-bottom:10px;padding-bottom:8px;border-bottom:1px solid var(--bord)">
<strong style="color:var(--acc)">Vanishing (χ(r) = 0)</strong>
<div style="margin-top:5px;font-size:.8rem;color:#555">
r ∈ {${pts.filter(p=>!p.isSupport).map(p=>p.r).join(', ')||'∅'}}
</div>
</div>
<div>
<strong style="color:var(--acc)">Key Properties</strong>
<div style="margin-top:5px;font-size:.75rem;line-height:1.5;color:var(--txt2)">
• Completely multiplicative: χ(ab)=χ(a)χ(b)<br>
• χ(1) = 1 always<br>
• |χ(r)| = 1 when χ(r) ≠ 0<br>
• χ(r+M) = χ(r) (periodic)
</div>
</div>`;

// Table
document.getElementById('tdirT').innerHTML='<tr><th>r</th><th>gcd(r,M)</th><th>χ(r)</th><th>|χ(r)|</th><th>arg(χ(r))</th><th>Support?</th></tr>'+
pts.map(p=>`<tr onclick="modal('χ(${p.r})',[['r',${p.r}],['gcd(${p.r},${M})',${p.gcdVal}],['Re χ(r)',${p.v.re.toFixed(6)}],['Im χ(r)',${p.v.im.toFixed(6)}],['|χ(r)|',${p.mag.toFixed(6)}],['arg χ(r)',${(p.arg/Math.PI).toFixed(4)}+'π']])" style="cursor:pointer;color:${p.isSupport?'#ffd700':'#555'}"><td>${p.r}</td><td>${p.gcdVal}</td><td>${p.isSupport?(Math.abs(p.v.im)<1e-6?p.v.re.toFixed(2):`${p.v.re.toFixed(2)}+${p.v.im.toFixed(2)}i`):'0'}</td><td>${p.mag.toFixed(3)}</td><td>${p.isSupport?(p.arg/Math.PI).toFixed(3)+'π':'—'}</td><td>${p.isSupport?'OK':''}</td></tr>`).join('');

// Click handler
c.onclick=e=>{const rect=c.getBoundingClientRect(),mx=(e.clientX-rect.left)*(c.width/rect.width),my=(e.clientY-rect.top)*(c.height/rect.height);
if(viz==='circle'||viz==='support'){
for(const p of pts){if(!p.isSupport)continue;
const x=cx+R*p.v.re,y=cy-R*p.v.im;
if(Math.hypot(mx-x,my-y)<ptSz+5){
modal(`χ(${p.r})`,[['r',p.r],['gcd(r,M)',p.gcdVal],['χ(r)',`${p.v.re.toFixed(4)}+${p.v.im.toFixed(4)}i`],['|χ(r)|',p.mag.toFixed(6)],['arg(χ(r))',(p.arg/Math.PI).toFixed(4)+'π']]);break;}}}};}

function showAllChars(){
const M=+document.getElementById('dirMv').value;
const chars=getDirichletChars(M);
const rows=chars.slice(0,15).map(chi=>[chi.name,chi.order]);
modal(`All ${chars.length} Characters mod ${M}`,rows);}

function csvDir(){
const M=dirData.M,chi=dirData.current;
let s='r,gcd,re_chi,im_chi,mag,arg,support\n';
for(let r=0;r<M;r++){
const v=chi.values[r];
const mag=Math.sqrt(v.re*v.re+v.im*v.im);
const arg=Math.atan2(v.im,v.re);
s+=`${r},${gcd(r,M)},${v.re},${v.im},${mag},${arg},${mag>0.5?1:0}\n`;}
dl(s,'dirichlet_char.csv');}

async function screenshotDir(){
const M=document.getElementById('dirMv').value,idx=document.getElementById('dirIdx').value;
await screenshotUnified('cdir','dirLiveStats',`Dirichlet Character χ_${idx} mod ${M}`,'dirichlet_char.png',{dashH:350});
}

// Twin Primes & Prime Gaps
let twinData={primes:[],gaps:[],twins:[]};

function sievePrimes(N){
const sieve=new Array(N+1).fill(true);
sieve[0]=sieve[1]=false;
for(let i=2;i*i<=N;i++)if(sieve[i])for(let j=i*i;j<=N;j+=i)sieve[j]=false;
const primes=[];for(let i=2;i<=N;i++)if(sieve[i])primes.push(i);
return primes;}

function drawTwin(){
if(!document.getElementById("cTwin")) return;

const c=document.getElementById('ctwin'),ctx=c.getContext('2d');
const N=+document.getElementById('twinNv').value||+document.getElementById('twinN').value;
const g=+document.getElementById('twinGv').value||+document.getElementById('twinG').value;
const viz=document.getElementById('twinViz').value;
const col=document.getElementById('twinCol').value;
const ptSz=+document.getElementById('twinPtSz').value;
const showLabels=document.getElementById('twinLabels').checked;
const showGrid=document.getElementById('twinGrid').checked;
const showAvg=document.getElementById('twinAvg').checked;
const showTheory=document.getElementById('twinTheory').checked;
const constType=document.getElementById('twinConst').value;

ctx.fillStyle=canvBg();ctx.fillRect(0,0,c.width,c.height);
document.getElementById('twinNdisp').textContent=N;

// Generate primes
const primes=sievePrimes(N);
twinData.primes=primes;

// Compute gaps
const gaps=[];
for(let i=1;i<primes.length;i++)gaps.push({p:primes[i-1],gap:primes[i]-primes[i-1],idx:i});
twinData.gaps=gaps;

// Find twin primes (or other constellations)
const twins=[];
let gapPattern=[2];
if(constType==='cousin')gapPattern=[4];
else if(constType==='sexy')gapPattern=[6];
else if(constType==='triplet')gapPattern=[2,4];
else if(constType==='quadruplet')gapPattern=[2,4,2];

for(let i=0;i<primes.length-gapPattern.length;i++){
let match=true;
for(let j=0;j<gapPattern.length;j++){
if(primes[i+j+1]-primes[i+j]!==gapPattern[j]){match=false;break;}}
if(match)twins.push({p:primes[i],constellation:primes.slice(i,i+gapPattern.length+1)});}
twinData.twins=twins;

// Brun's constant partial sum
let brunSum=0;
const brunPartial=[];
for(const t of twins.filter(t=>t.constellation.length===2)){
brunSum+=1/t.p+1/t.constellation[1];
brunPartial.push({p:t.p,sum:brunSum});}

const pad=60,w=c.width-2*pad,h=c.height-2*pad;
const cx=c.width/2,cy=c.height/2;

// Gap frequency
const gapFreq={};
for(const g of gaps)gapFreq[g.gap]=(gapFreq[g.gap]||0)+1;
const gapArr=Object.entries(gapFreq).map(([g,c])=>({gap:+g,count:c})).sort((a,b)=>a.gap-b.gap);

if(viz==='gaps'){
// Histogram of prime gaps
const maxGap=Math.max(...gaps.map(g=>g.gap));
const barW=w/Math.min(maxGap/2+1,30);
const maxCount=Math.max(...gapArr.map(g=>g.count));
if(showGrid){
ctx.strokeStyle=gridC();ctx.lineWidth=0.5;
for(let i=0;i<=5;i++){const y=pad+h-i*h/5;ctx.beginPath();ctx.moveTo(pad,y);ctx.lineTo(pad+w,y);ctx.stroke();}}
ctx.fillStyle=isDark()?'#ffd700':'#cc8800';ctx.font='bold 14px Segoe UI';ctx.textAlign='center';
ctx.fillText('Prime Gap Distribution',cx,30);
for(const gd of gapArr.slice(0,30)){
const x=pad+(gd.gap/2-1)*barW;
const barH=h*gd.count/maxCount;
let clr=gd.gap===2?'#ffd700':gd.gap===4?'#00d9ff':gd.gap===6?'#ff8c00':`hsl(${gd.gap*10},70%,50%)`;
ctx.fillStyle=clr;
ctx.fillRect(x,pad+h-barH,barW*0.8,barH);
ctx.fillStyle=isDark()?'#fff':'#000';ctx.font='9px Arial';
ctx.fillText(gd.gap,x+barW*0.4,pad+h+15);
if(showLabels)ctx.fillText(gd.count,x+barW*0.4,pad+h-barH-5);}}

else if(viz==='pairs'){
// Show twin prime pairs as points
const maxP=primes[primes.length-1];
ctx.fillStyle=isDark()?'#ffd700':'#cc8800';ctx.font='bold 14px Segoe UI';ctx.textAlign='center';
ctx.fillText(`${constType.charAt(0).toUpperCase()+constType.slice(1)} Prime Pairs (gap=${gapPattern.join(',')})`,cx,30);
if(showGrid){ctx.strokeStyle=gridC();ctx.lineWidth=0.5;ctx.strokeRect(pad,pad,w,h);}
for(let i=0;i<twins.length;i++){
const t=twins[i];
const x=pad+w*t.p/maxP;
const y=pad+h-h*i/Math.max(twins.length-1,1);
ctx.fillStyle='#ffd700';
ctx.beginPath();ctx.arc(x,y,ptSz,0,2*Math.PI);ctx.fill();
if(showLabels&&twins.length<30){
ctx.fillStyle=isDark()?'#fff':'#000';ctx.font='9px Arial';
ctx.fillText(`(${t.constellation.join(',')})`,x+ptSz+3,y+3);}}}

else if(viz==='density'){
// Gap density by range
const ranges=[];
const rangeSize=Math.ceil(N/10);
for(let r=0;r<10;r++){
const lo=r*rangeSize,hi=(r+1)*rangeSize;
const rangeGaps=gaps.filter(g=>g.p>=lo&&g.p<hi);
const twinCount=rangeGaps.filter(g=>g.gap===g).length;
const avgGap=rangeGaps.length?rangeGaps.reduce((a,g)=>a+g.gap,0)/rangeGaps.length:0;
ranges.push({lo,hi,count:rangeGaps.length,avgGap,twinCount});}
const maxAvg=Math.max(...ranges.map(r=>r.avgGap));
const barW=w/10;
for(let i=0;i<ranges.length;i++){
const r=ranges[i];
const x=pad+i*barW;
const barH=h*r.avgGap/maxAvg;
ctx.fillStyle=`hsl(${i*36},70%,50%)`;
ctx.fillRect(x,pad+h-barH,barW*0.8,barH);
ctx.fillStyle=isDark()?'#fff':'#000';ctx.font='9px Arial';ctx.textAlign='center';
ctx.fillText(`${(r.lo/1000).toFixed(0)}k`,x+barW*0.4,pad+h+15);}}

else if(viz==='brun'){
// Brun's constant convergence
if(brunPartial.length>0){
const maxSum=brunPartial[brunPartial.length-1].sum;
ctx.fillStyle=isDark()?'#ffd700':'#cc8800';ctx.font='bold 14px Segoe UI';ctx.textAlign='center';
ctx.fillText("Brun's Constant B₂ ≈ 1.902 (Convergence)",cx,30);
if(showGrid){ctx.strokeStyle=gridC();ctx.lineWidth=0.5;
for(let i=0;i<=5;i++){const y=pad+h-i*h/5;ctx.beginPath();ctx.moveTo(pad,y);ctx.lineTo(pad+w,y);ctx.stroke();
ctx.fillStyle=isDark()?'#666':'#999';ctx.font='10px Arial';ctx.textAlign='right';
ctx.fillText((maxSum*i/5).toFixed(3),pad-5,y+3);}}
ctx.beginPath();ctx.strokeStyle='#00d9ff';ctx.lineWidth=2;
for(let i=0;i<brunPartial.length;i++){
const x=pad+w*i/(brunPartial.length-1);
const y=pad+h-h*brunPartial[i].sum/maxSum;
if(i===0)ctx.moveTo(x,y);else ctx.lineTo(x,y);}
ctx.stroke();
// Reference line at B2 ≈ 1.902
if(showTheory&&maxSum>1.5){
ctx.strokeStyle='#ff006e';ctx.setLineDash([5,5]);ctx.beginPath();
const y1902=pad+h-h*1.902/maxSum;
ctx.moveTo(pad,y1902);ctx.lineTo(pad+w,y1902);ctx.stroke();ctx.setLineDash([]);
ctx.fillStyle='#ff006e';ctx.font='11px Arial';ctx.textAlign='left';
ctx.fillText('B₂ ≈ 1.902',pad+w-60,y1902-5);}}}

else if(viz==='constellation'){
// Prime constellations visualization  
ctx.fillStyle=isDark()?'#ffd700':'#cc8800';ctx.font='bold 14px Segoe UI';ctx.textAlign='center';
ctx.fillText(`Prime ${constType.charAt(0).toUpperCase()+constType.slice(1)}s: ${twins.length} found`,cx,30);
const cols=Math.ceil(Math.sqrt(twins.length));
const rows=Math.ceil(twins.length/cols);
const cellW=w/cols,cellH=h/rows;
for(let i=0;i<Math.min(twins.length,100);i++){
const t=twins[i];
const col=i%cols,row=Math.floor(i/cols);
const x=pad+col*cellW+cellW/2;
const y=pad+row*cellH+cellH/2;
ctx.fillStyle=`hsl(${i*7},70%,55%)`;
ctx.beginPath();ctx.arc(x,y,ptSz,0,2*Math.PI);ctx.fill();
ctx.fillStyle=isDark()?'#fff':'#000';ctx.font='8px Arial';ctx.textAlign='center';
ctx.fillText(t.constellation.join(','),x,y+ptSz+10);}}

// Charts
Plotly.newPlot('ptwinGap',[{x:gapArr.slice(0,20).map(g=>g.gap),y:gapArr.slice(0,20).map(g=>g.count),type:'bar',marker:{color:gapArr.slice(0,20).map(g=>g.gap===2?'#ffd700':'#00d9ff')}}],{...plo(),xaxis:{title:'Gap'},yaxis:{title:'Count'}});

Plotly.newPlot('ptwinBrun',[{x:brunPartial.map(b=>b.p),y:brunPartial.map(b=>b.sum),mode:'lines',line:{color:'#00d9ff',width:2},name:'Σ(1/p+1/(p+2))'}],{...plo(),xaxis:{title:'p'},yaxis:{title:"Brun's partial sum"}});

Plotly.newPlot('ptwinLog',[{x:gaps.map(g=>Math.log(g.p)),y:gaps.map(g=>g.gap),mode:'markers',marker:{size:3,color:'#9664ff'},name:'Gap'},{x:gaps.map(g=>Math.log(g.p)),y:gaps.map((_,i)=>{const localGaps=gaps.slice(Math.max(0,i-20),i+20);return localGaps.reduce((a,g)=>a+g.gap,0)/localGaps.length;}),mode:'lines',line:{color:'#ffd700',width:2},name:'Running Avg'}],{...plo(),xaxis:{title:'ln(p)'},yaxis:{title:'Gap'}});

// Stats
const avgGap=gaps.reduce((a,g)=>a+g.gap,0)/gaps.length;
const maxGapVal=Math.max(...gaps.map(g=>g.gap));
const gapG=gaps.filter(g=>g.gap===g).length;
legend('altwin','Gap Statistics',[['Twin pairs',twins.filter(t=>t.constellation.length===2).length,'#ffd700'],['Avg gap',avgGap.toFixed(2),'#00d9ff'],['Max gap',maxGapVal,'#ff006e']]);

// Live stats
document.getElementById('twinLiveStats').innerHTML=`
<div style="background:linear-gradient(135deg,rgba(0,217,255,.15),rgba(255,215,0,.1));padding:10px;border-radius:8px;margin-bottom:12px;border:1px solid var(--acc)">
<div style="font-size:.7rem;color:var(--txt2);margin-bottom:4px">TAB: Twin Primes | FIELD: ℤ (Primes) | TYPE: ${constType} Constellation</div>
<div style="display:grid;grid-template-columns:repeat(3,1fr);gap:6px;font-size:.75rem">
<span>N: <strong style="color:#00d9ff">${N}</strong></span>
<span>Type: <strong style="color:#ffd700">${constType}</strong></span>
<span>Primes: <strong style="color:#00ff88">${primes.length}</strong></span>
</div>
</div>
<div style="display:grid;grid-template-columns:repeat(3,1fr);gap:8px;margin-bottom:12px">
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center"><div style="font-size:1.4rem;font-weight:bold;color:#00d9ff">${primes.length}</div><div style="font-size:.7rem;color:var(--txt2)">PRIMES ≤ N</div></div>
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center"><div style="font-size:1.4rem;font-weight:bold;color:#ffd700">${twins.length}</div><div style="font-size:.7rem;color:var(--txt2)">${constType.toUpperCase()}S</div></div>
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center"><div style="font-size:1.4rem;font-weight:bold;color:#00ff88">${avgGap.toFixed(2)}</div><div style="font-size:.7rem;color:var(--txt2)">AVG GAP</div></div>
</div>
<div style="display:grid;grid-template-columns:repeat(2,1fr);gap:8px;margin-bottom:12px">
<div style="background:var(--bg1);padding:8px;border-radius:6px;text-align:center"><div style="font-size:1rem;font-weight:bold;color:#9664ff">${fmt(2*1.32*N/(Math.log(N)*Math.log(N)))}</div><div style="font-size:.65rem;color:var(--txt2)">HARDY-LITTLEWOOD PRED</div></div>
<div style="background:var(--bg1);padding:8px;border-radius:6px;text-align:center"><div style="font-size:1rem;font-weight:bold;color:#ff8c00">${fmt(100*twins.length/primes.length)}%</div><div style="font-size:.65rem;color:var(--txt2)">TWIN RATIO</div></div>
</div>
<div style="margin-bottom:10px;padding-bottom:8px;border-bottom:1px solid var(--bord)">
<strong style="color:var(--acc)">Gap Analysis</strong>
<div style="display:grid;grid-template-columns:1fr 1fr;gap:3px;margin-top:5px;font-size:.8rem">
<span>Most common gap:</span><span style="color:#ffd700">${gapArr[0]?.gap||0} (${gapArr[0]?.count||0}×)</span>
<span>Max gap:</span><span style="color:#ff006e">${maxGapVal}</span>
<span>Gap=2 count:</span><span style="color:#00d9ff">${gapFreq[2]||0}</span>
<span>Gap=6 count:</span><span style="color:#ff8c00">${gapFreq[6]||0}</span>
</div>
</div>
<div style="margin-bottom:10px;padding-bottom:8px;border-bottom:1px solid var(--bord)">
<strong style="color:var(--acc)">Brun's Constant</strong>
<div style="display:grid;grid-template-columns:1fr 1fr;gap:3px;margin-top:5px;font-size:.8rem">
<span>Partial sum:</span><span style="color:#00d9ff">${brunPartial.length?brunPartial[brunPartial.length-1].sum.toFixed(6):'—'}</span>
<span>B₂ ≈:</span><span style="color:#9664ff">1.902160...</span>
<span>Twin pairs:</span><span style="color:#ffd700">${twins.filter(t=>t.constellation.length===2).length}</span>
<span>Convergence:</span><span style="color:#00ff88">Proved (Brun 1919)</span>
</div>
</div>
<div>
<strong style="color:var(--acc)">First ${constType}s</strong>
<div style="margin-top:5px;font-size:.75rem;color:var(--txt2)">
${twins.slice(0,8).map(t=>`(${t.constellation.join(',')})`).join(', ')}${twins.length>8?'...':''}
</div>
</div>`;

// Table
document.getElementById('ttwinT').innerHTML='<tr><th>p</th><th>p+g</th><th>Gap</th><th>log(p)</th><th>gap/log(p)</th><th>Σ1/p</th></tr>'+
twins.slice(0,100).map((t,i)=>{
const bp=brunPartial.find(b=>b.p===t.p);
return`<tr onclick="modal('${constType} at ${t.p}',[['p',${t.p}],['Constellation','${t.constellation.join(', ')}']])" style="cursor:pointer"><td>${t.p}</td><td>${t.constellation[1]||''}</td><td>${t.constellation[1]-t.p||''}</td><td>${Math.log(t.p).toFixed(3)}</td><td>${((t.constellation[1]-t.p)/Math.log(t.p)).toFixed(3)}</td><td>${bp?bp.sum.toFixed(4):'—'}</td></tr>`;}).join('');}

function csvTwin(){
let s='p,gap,constellation,brun_partial\n';
let bsum=0;
for(const t of twinData.twins){
if(t.constellation.length===2)bsum+=1/t.p+1/t.constellation[1];
s+=`${t.p},${t.constellation[1]-t.p},"${t.constellation.join(',')}",${bsum}\n`;}
dl(s,'twin_primes.csv');}

async function screenshotTwin(){
const c=document.getElementById('ctwin'),dashData=extractDashboardData('twinLiveStats');
const N=document.getElementById('twinNv').value;
const scale=2,pad=30,dashH=380;
const out=document.createElement('canvas');
out.width=(c.width+pad*2)*scale;out.height=(c.height+dashH+pad*3)*scale;
const ctx=out.getContext('2d');ctx.scale(scale,scale);
const isDk=isDark();
ctx.fillStyle=isDk?'#0d1321':'#ffffff';ctx.fillRect(0,0,out.width/scale,out.height/scale);
ctx.fillStyle=isDk?'#00d9ff':'#0066cc';ctx.font='bold 18px Segoe UI';ctx.textAlign='center';
ctx.fillText(`Twin Prime Analysis — N=${N}`,out.width/scale/2,pad);
ctx.drawImage(c,pad,pad+25,c.width,c.height);
const dashY=c.height+pad+45;
ctx.fillStyle=isDk?'#151b2d':'#f5f5f5';ctx.fillRect(pad,dashY-10,c.width,dashH);
ctx.textAlign='left';
renderDashboard(ctx,dashData,pad+10,dashY,c.width-20,isDk,dashH-30);
ctx.fillStyle=isDk?'#506080':'#888';ctx.font='10px Segoe UI';ctx.textAlign='center';
ctx.fillText('Möbius Shell Sieve — wessengetachew.github.io',out.width/scale/2,out.height/scale-10);
out.toBlob(b=>{const a=document.createElement('a');a.href=URL.createObjectURL(b);a.download='twin_primes.png';a.click();},'image/png',1.0);}

// Prime Counting π(x)
let piData={xs:[],pis:[],lis:[],xlnxs:[]};

function Li(x){
// Logarithmic integral approximation
if(x<=2)return 0;
let sum=0;const dx=0.1;
for(let t=2;t<=x;t+=dx)sum+=dx/Math.log(t);
return sum;}

function RiemannR(x){
// Riemann R function (simplified)
let sum=0;
for(let n=1;n<=100;n++){
const m=mob(n);
if(m!==0)sum+=m/n*Li(Math.pow(x,1/n));}
return sum;}

function drawPi(){
if(!document.getElementById("pPi")) return;

const c=document.getElementById('cpi'),ctx=c.getContext('2d');
const X=+document.getElementById('piXv').value||+document.getElementById('piX').value;
const step=+document.getElementById('piStep').value;
const viz=document.getElementById('piViz').value;
const showLi=document.getElementById('piLi').checked;
const showXlnx=document.getElementById('piXlnx').checked;
const showRiem=document.getElementById('piRiemann').checked;
const showGrid=document.getElementById('piGrid').checked;
const showLog=document.getElementById('piLog').checked;
const showBounds=document.getElementById('piBounds').checked;
const ptSz=+document.getElementById('piPtSz').value;

ctx.fillStyle=canvBg();ctx.fillRect(0,0,c.width,c.height);
document.getElementById('piXdisp').textContent=X;

// Compute π(x) for range
const primes=sievePrimes(X);
const xs=[],pis=[],lis=[],xlnxs=[],riems=[];
let piCount=0,primeIdx=0;
for(let x=step;x<=X;x+=step){
while(primeIdx<primes.length&&primes[primeIdx]<=x){piCount++;primeIdx++;}
xs.push(x);
pis.push(piCount);
lis.push(Li(x));
xlnxs.push(x/Math.log(x));
if(showRiem&&x<=10000)riems.push(RiemannR(x));else riems.push(null);}
piData={xs,pis,lis,xlnxs,riems};

const pad=60,w=c.width-2*pad,h=c.height-2*pad;
const maxPi=Math.max(...pis);

if(viz==='count'||viz==='compare'){
// Plot π(x) and approximations
ctx.fillStyle=isDark()?'#ffd700':'#cc8800';ctx.font='bold 14px Segoe UI';ctx.textAlign='center';
ctx.fillText('Prime Counting Function π(x)',c.width/2,30);
if(showGrid){
ctx.strokeStyle=gridC();ctx.lineWidth=0.5;
for(let i=0;i<=5;i++){
const y=pad+h-i*h/5;ctx.beginPath();ctx.moveTo(pad,y);ctx.lineTo(pad+w,y);ctx.stroke();
ctx.fillStyle=isDark()?'#666':'#999';ctx.font='10px Arial';ctx.textAlign='right';
ctx.fillText(Math.round(maxPi*i/5),pad-5,y+3);}}
// x/ln(x) line
if(showXlnx){
ctx.beginPath();ctx.strokeStyle='#ff8c00';ctx.lineWidth=1.5;
for(let i=0;i<xs.length;i++){
const x=pad+w*xs[i]/X;const y=pad+h-h*xlnxs[i]/maxPi;
if(i===0)ctx.moveTo(x,y);else ctx.lineTo(x,y);}
ctx.stroke();}
// Li(x) line
if(showLi){
ctx.beginPath();ctx.strokeStyle='#00ff88';ctx.lineWidth=1.5;
for(let i=0;i<xs.length;i++){
const x=pad+w*xs[i]/X;const y=pad+h-h*lis[i]/maxPi;
if(i===0)ctx.moveTo(x,y);else ctx.lineTo(x,y);}
ctx.stroke();}
// π(x) actual
ctx.beginPath();ctx.strokeStyle='#00d9ff';ctx.lineWidth=2;
for(let i=0;i<xs.length;i++){
const x=pad+w*xs[i]/X;const y=pad+h-h*pis[i]/maxPi;
if(i===0)ctx.moveTo(x,y);else ctx.lineTo(x,y);}
ctx.stroke();
// Legend
ctx.font='11px Segoe UI';ctx.textAlign='left';
let ly=pad+20;
ctx.fillStyle='#00d9ff';ctx.fillRect(pad+10,ly-8,15,3);ctx.fillText('π(x)',pad+30,ly);ly+=18;
if(showXlnx){ctx.fillStyle='#ff8c00';ctx.fillRect(pad+10,ly-8,15,3);ctx.fillText('x/ln(x)',pad+30,ly);ly+=18;}
if(showLi){ctx.fillStyle='#00ff88';ctx.fillRect(pad+10,ly-8,15,3);ctx.fillText('Li(x)',pad+30,ly);}}

else if(viz==='error'){
// Error plot
const liErrs=pis.map((p,i)=>p-lis[i]);
const xlnxErrs=pis.map((p,i)=>p-xlnxs[i]);
const maxErr=Math.max(...liErrs.map(Math.abs),...xlnxErrs.map(Math.abs));
ctx.fillStyle=isDark()?'#ffd700':'#cc8800';ctx.font='bold 14px Segoe UI';ctx.textAlign='center';
ctx.fillText('Approximation Errors: π(x) - Approx',c.width/2,30);
// Zero line
ctx.strokeStyle=gridC();ctx.lineWidth=1;ctx.beginPath();
ctx.moveTo(pad,pad+h/2);ctx.lineTo(pad+w,pad+h/2);ctx.stroke();
// Li error
ctx.beginPath();ctx.strokeStyle='#00ff88';ctx.lineWidth=2;
for(let i=0;i<xs.length;i++){
const x=pad+w*xs[i]/X;const y=pad+h/2-h/2*liErrs[i]/maxErr;
if(i===0)ctx.moveTo(x,y);else ctx.lineTo(x,y);}
ctx.stroke();
// x/ln(x) error
ctx.beginPath();ctx.strokeStyle='#ff8c00';ctx.lineWidth=2;
for(let i=0;i<xs.length;i++){
const x=pad+w*xs[i]/X;const y=pad+h/2-h/2*xlnxErrs[i]/maxErr;
if(i===0)ctx.moveTo(x,y);else ctx.lineTo(x,y);}
ctx.stroke();}

else if(viz==='ratio'){
// π(x)·ln(x)/x ratio → 1
const ratios=pis.map((p,i)=>p*Math.log(xs[i])/xs[i]);
ctx.fillStyle=isDark()?'#ffd700':'#cc8800';ctx.font='bold 14px Segoe UI';ctx.textAlign='center';
ctx.fillText('PNT Ratio: π(x)·ln(x)/x → 1',c.width/2,30);
const maxR=Math.max(...ratios),minR=Math.min(...ratios);
// Reference line at 1
ctx.strokeStyle='#ff006e';ctx.setLineDash([5,5]);ctx.lineWidth=1;ctx.beginPath();
const y1=pad+h-(1-minR)/(maxR-minR)*h;
ctx.moveTo(pad,y1);ctx.lineTo(pad+w,y1);ctx.stroke();ctx.setLineDash([]);
// Ratio curve
ctx.beginPath();ctx.strokeStyle='#00d9ff';ctx.lineWidth=2;
for(let i=0;i<xs.length;i++){
const x=pad+w*xs[i]/X;const y=pad+h-(ratios[i]-minR)/(maxR-minR)*h;
if(i===0)ctx.moveTo(x,y);else ctx.lineTo(x,y);}
ctx.stroke();}

else if(viz==='density'){
// Prime density 1/ln(x)
ctx.fillStyle=isDark()?'#ffd700':'#cc8800';ctx.font='bold 14px Segoe UI';ctx.textAlign='center';
ctx.fillText('Prime Density ≈ 1/ln(x)',c.width/2,30);
const empirical=[];
for(let i=1;i<pis.length;i++)empirical.push((pis[i]-pis[i-1])/step);
const theory=xs.map(x=>1/Math.log(x));
const maxD=Math.max(...empirical,...theory);
// Theory
ctx.beginPath();ctx.strokeStyle='#ff8c00';ctx.lineWidth=2;
for(let i=0;i<xs.length;i++){
const x=pad+w*xs[i]/X;const y=pad+h-h*theory[i]/maxD;
if(i===0)ctx.moveTo(x,y);else ctx.lineTo(x,y);}
ctx.stroke();
// Empirical (smoothed)
ctx.beginPath();ctx.strokeStyle='#00d9ff';ctx.lineWidth=2;
for(let i=0;i<empirical.length;i++){
const x=pad+w*xs[i+1]/X;
const avgD=empirical.slice(Math.max(0,i-5),i+5).reduce((a,b)=>a+b,0)/Math.min(10,i+5);
const y=pad+h-h*avgD/maxD;
if(i===0)ctx.moveTo(x,y);else ctx.lineTo(x,y);}
ctx.stroke();}

// Charts
const liErrs=pis.map((p,i)=>Math.abs(p-lis[i]));
const xlnxErrs=pis.map((p,i)=>Math.abs(p-xlnxs[i]));
Plotly.newPlot('ppiErr',[
{x:xs,y:liErrs,name:'|π(x)-Li(x)|',mode:'lines',line:{color:'#00ff88'}},
{x:xs,y:xlnxErrs,name:'|π(x)-x/ln(x)|',mode:'lines',line:{color:'#ff8c00'}}
],{...plo(),xaxis:{title:'x'},yaxis:{title:'Absolute Error'}});

Plotly.newPlot('ppiComp',[
{x:xs,y:pis,name:'π(x)',mode:'lines',line:{color:'#00d9ff',width:2}},
{x:xs,y:lis,name:'Li(x)',mode:'lines',line:{color:'#00ff88'}},
{x:xs,y:xlnxs,name:'x/ln(x)',mode:'lines',line:{color:'#ff8c00'}}
],{...plo(),xaxis:{title:'x'},yaxis:{title:'Count'}});

const ratios=pis.map((p,i)=>xs[i]>10?p*Math.log(xs[i])/xs[i]:null).filter(x=>x!==null);
Plotly.newPlot('ppiRatio',[
{x:xs.filter((_,i)=>xs[i]>10),y:ratios,mode:'lines',line:{color:'#9664ff',width:2},name:'π(x)ln(x)/x'},
{x:[xs[0],xs[xs.length-1]],y:[1,1],mode:'lines',line:{color:'#ff006e',dash:'dash'},name:'Limit=1'}
],{...plo(),xaxis:{title:'x'},yaxis:{title:'Ratio',range:[0.8,1.3]}});

// Stats
const finalPi=pis[pis.length-1];
const finalLi=lis[lis.length-1];
const finalXlnx=xlnxs[xlnxs.length-1];
legend('alpi','π(x) Statistics',[['π('+X+')',finalPi,'#00d9ff'],['Li error',Math.abs(finalPi-finalLi).toFixed(1),'#00ff88'],['x/ln error',Math.abs(finalPi-finalXlnx).toFixed(1),'#ff8c00']]);

// Live stats
document.getElementById('piLiveStats').innerHTML=`
<div style="background:linear-gradient(135deg,rgba(0,217,255,.15),rgba(255,215,0,.1));padding:10px;border-radius:8px;margin-bottom:12px;border:1px solid var(--acc)">
<div style="font-size:.7rem;color:var(--txt2);margin-bottom:4px">TAB: Prime Counting π(x) | FIELD: ℤ (Primes) | TYPE: Counting Function</div>
<div style="display:grid;grid-template-columns:repeat(3,1fr);gap:6px;font-size:.75rem">
<span>Max x: <strong style="color:#00d9ff">${X}</strong></span>
<span>π(x): <strong style="color:#ffd700">${finalPi}</strong></span>
<span>Density: <strong style="color:#00ff88">${fmt(100*finalPi/X)}%</strong></span>
</div>
</div>
<div style="display:grid;grid-template-columns:repeat(3,1fr);gap:8px;margin-bottom:12px">
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center"><div style="font-size:1.4rem;font-weight:bold;color:#00d9ff">${finalPi}</div><div style="font-size:.7rem;color:var(--txt2)">π(${X}) ACTUAL</div></div>
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center"><div style="font-size:1.4rem;font-weight:bold;color:#00ff88">${finalLi.toFixed(1)}</div><div style="font-size:.7rem;color:var(--txt2)">Li(${X}) PRED</div></div>
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center"><div style="font-size:1.4rem;font-weight:bold;color:#ff8c00">${finalXlnx.toFixed(1)}</div><div style="font-size:.7rem;color:var(--txt2)">x/ln(x)</div></div>
</div>
<div style="display:grid;grid-template-columns:repeat(2,1fr);gap:8px;margin-bottom:12px">
<div style="background:var(--bg1);padding:8px;border-radius:6px;text-align:center"><div style="font-size:1rem;font-weight:bold;color:#9664ff">${(finalPi-finalLi).toFixed(2)}</div><div style="font-size:.65rem;color:var(--txt2)">Li ERROR</div></div>
<div style="background:var(--bg1);padding:8px;border-radius:6px;text-align:center"><div style="font-size:1rem;font-weight:bold;color:#ff6496">${(100*(finalPi-finalLi)/finalPi).toFixed(3)}%</div><div style="font-size:.65rem;color:var(--txt2)">REL ERROR</div></div>
</div>
<div style="margin-bottom:10px;padding-bottom:8px;border-bottom:1px solid var(--bord)">
<strong style="color:var(--acc)">Error Analysis at x=${X}</strong>
<div style="display:grid;grid-template-columns:1fr 1fr;gap:3px;margin-top:5px;font-size:.8rem">
<span>Li(x) error:</span><span style="color:#00ff88">${(finalPi-finalLi).toFixed(2)} (${(100*(finalPi-finalLi)/finalPi).toFixed(3)}%)</span>
<span>x/ln(x) error:</span><span style="color:#ff8c00">${(finalPi-finalXlnx).toFixed(2)} (${(100*(finalPi-finalXlnx)/finalPi).toFixed(2)}%)</span>
<span>Li is better by:</span><span style="color:#9664ff">${(Math.abs(finalPi-finalXlnx)-Math.abs(finalPi-finalLi)).toFixed(1)}</span>
<span>Ratio π·ln/x:</span><span style="color:#00d9ff">${(finalPi*Math.log(X)/X).toFixed(4)}</span>
</div>
</div>
<div style="margin-bottom:10px;padding-bottom:8px;border-bottom:1px solid var(--bord)">
<strong style="color:var(--acc)">Prime Number Theorem</strong>
<div style="margin-top:5px;font-size:.8rem;color:var(--txt2)">
π(x) ~ x/ln(x) as x → ∞<br>
Better: π(x) ~ Li(x) = ∫₂ˣ dt/ln(t)
</div>
</div>
<div>
<strong style="color:var(--acc)">Key Values</strong>
<div style="display:grid;grid-template-columns:1fr 1fr;gap:3px;margin-top:5px;font-size:.75rem">
<span>π(100):</span><span style="color:var(--txt)">25</span>
<span>π(1000):</span><span style="color:var(--txt)">168</span>
<span>π(10000):</span><span style="color:var(--txt)">1229</span>
<span>π(100000):</span><span style="color:var(--txt)">9592</span>
</div>
</div>`;

// Table
document.getElementById('tpiT').innerHTML='<tr><th>x</th><th>π(x)</th><th>x/ln(x)</th><th>Li(x)</th><th>Error Li</th><th>Rel %</th></tr>'+
xs.slice(0,100).map((x,i)=>`<tr onclick="modal('π(${x})',[['x',${x}],['π(x)',${pis[i]}],['Li(x)',${lis[i].toFixed(2)}],['x/ln(x)',${xlnxs[i].toFixed(2)}]])" style="cursor:pointer"><td>${x}</td><td>${pis[i]}</td><td>${xlnxs[i].toFixed(1)}</td><td>${lis[i].toFixed(1)}</td><td>${(pis[i]-lis[i]).toFixed(1)}</td><td>${(100*(pis[i]-lis[i])/pis[i]).toFixed(2)}%</td></tr>`).join('');}

function csvPi(){
let s='x,pi_x,li_x,x_ln_x,error_li,error_xlnx\n';
for(let i=0;i<piData.xs.length;i++)s+=`${piData.xs[i]},${piData.pis[i]},${piData.lis[i]},${piData.xlnxs[i]},${piData.pis[i]-piData.lis[i]},${piData.pis[i]-piData.xlnxs[i]}\n`;
dl(s,'prime_counting.csv');}

async function screenshotPi(){
const X=document.getElementById('piXv').value;
await screenshotUnified('cpi','piLiveStats',`Prime Counting Function — x=${X}`,'prime_counting.png',{dashH:320});
}

// Composite Channel Projection
let compData={M:60,residues:[],channels:[]};
let compSweepInterval=null,compSweepR=1;

function factorizeArr(n){
const factors=[];
let d=2;
while(d*d<=n){
while(n%d===0){factors.push(d);n/=d;}
d++;}
if(n>1)factors.push(n);
return factors;}

function getDivisors(n){
const divs=[1];
for(let i=2;i<=n;i++)if(n%i===0)divs.push(i);
return divs;}

function smallestPrimeFactor(n){
if(n<=1)return 1;
if(n%2===0)return 2;
for(let i=3;i*i<=n;i+=2)if(n%i===0)return i;
return n;}

function largestPrimeFactor(n){
const f=factorizeArr(n);
return f.length?f[f.length-1]:1;}

function drawComp(){
if(!document.getElementById("cComp")) return;

const c=document.getElementById('ccomp'),ctx=c.getContext('2d');
const M=+document.getElementById('compMv').value||+document.getElementById('compM').value;
const viz=document.getElementById('compViz').value;
const col=document.getElementById('compCol').value;
const showProj=document.getElementById('compProj').checked;
const showLabels=document.getElementById('compLabels').checked;
const showMult=document.getElementById('compMult').checked;
const showCoprime=document.getElementById('compCoprime').checked;
const lineOp=+document.getElementById('compLineOp').value;
const ptSz=+document.getElementById('compPtSz').value;

ctx.fillStyle=canvBg();ctx.fillRect(0,0,c.width,c.height);
document.getElementById('compMdisp').textContent=M;

compData.M=M;
const phi=eulerPhi(M);
const divs=getDivisors(M);
const factors=factorizeArr(M);
const primeFactors=[...new Set(factors)];

// Build residue data
const residues=[];
const channelCounts={};
for(let r=0;r<M;r++){
const g=gcd(r,M);
const Mprime=M/g;
const rprime=r/g;
const isCoprime=g===1;
const spf=smallestPrimeFactor(g);
const lpf=largestPrimeFactor(g);
residues.push({r,g,Mprime,rprime,isCoprime,spf,lpf});
channelCounts[Mprime]=(channelCounts[Mprime]||0)+1;}
compData.residues=residues;
compData.channels=divs.map(d=>({M:d,count:channelCounts[d]||0,mult:M/d}));

const cx=c.width/2,cy=c.height/2,R=Math.min(cx,cy)-60;

if(viz==='projection'||viz==='rings'){
// Draw main ring (M)
ctx.strokeStyle=gridC();ctx.lineWidth=1;
ctx.beginPath();ctx.arc(cx,cy,R,0,2*Math.PI);ctx.stroke();

// Draw channel rings (divisors of M)
if(showProj){
for(const d of divs){
if(d===M)continue;
const rRing=R*d/M;
ctx.strokeStyle='rgba(255,215,0,0.3)';ctx.lineWidth=1;
ctx.beginPath();ctx.arc(cx,cy,rRing,0,2*Math.PI);ctx.stroke();}}

// Draw projection lines for reducible residues
if(showProj){
ctx.globalAlpha=lineOp;
for(const res of residues){
if(res.isCoprime)continue;
const ang1=-2*Math.PI*res.r/M;
const x1=cx+R*Math.cos(ang1),y1=cy+R*Math.sin(ang1);
const rTarget=R*res.Mprime/M;
const ang2=-2*Math.PI*res.rprime/res.Mprime;
const x2=cx+rTarget*Math.cos(ang2),y2=cy+rTarget*Math.sin(ang2);
ctx.strokeStyle='#ff4040';ctx.lineWidth=1;
ctx.beginPath();ctx.moveTo(x1,y1);ctx.lineTo(x2,y2);ctx.stroke();}
ctx.globalAlpha=1;}

// Draw points
const filter=document.getElementById('compFilter').value;
for(const res of residues){
if(!showCoprime&&res.isCoprime)continue;
if(filter==='coprime'&&!res.isCoprime)continue;
if(filter==='reducible'&&res.isCoprime)continue;
const ang=-2*Math.PI*res.r/M;
const x=cx+R*Math.cos(ang),y=cy+R*Math.sin(ang);
let clr;
if(col==='type')clr=res.isCoprime?'#00d9ff':'#ff4040';
else if(col==='gcd')clr=res.g===1?'#00d9ff':`hsl(${res.g*30},70%,50%)`;
else if(col==='spf')clr=`hsl(${res.spf*40},80%,50%)`;
else if(col==='lpf')clr=`hsl(${res.lpf*25},70%,55%)`;
else if(col==='depth')clr=`hsl(${(1-res.Mprime/M)*280},70%,50%)`;
else clr=res.isCoprime?'#00d9ff':'#ff4040';
ctx.fillStyle=clr;
ctx.beginPath();ctx.arc(x,y,ptSz,0,2*Math.PI);ctx.fill();
if(res.isCoprime){ctx.strokeStyle='#fff';ctx.lineWidth=1;ctx.stroke();}
if(showLabels&&M<=30){
ctx.fillStyle=isDark()?'#fff':'#000';ctx.font='9px Arial';ctx.textAlign='center';
ctx.fillText(res.r,x,y-ptSz-3);}}

// Draw gap connections for coprime residues
const gaps=[];
if(document.getElementById('compGap2').checked)gaps.push({gap:2,color:'#ff6b6b'});
if(document.getElementById('compGap4').checked)gaps.push({gap:4,color:'#4ecdc4'});
if(document.getElementById('compGap6').checked)gaps.push({gap:6,color:'#ffe66d'});
const gapCol=document.getElementById('compGapCol').value;
const gapThick=+document.getElementById('compGapThick').value;
const coprimes=residues.filter(r=>r.isCoprime).map(r=>r.r);

for(const{gap,color}of gaps){
ctx.lineWidth=gapThick;
for(const r1 of coprimes){
const r2=(r1+gap)%M;
if(coprimes.includes(r2)){
const ang1=-2*Math.PI*r1/M;
const ang2=-2*Math.PI*r2/M;
const x1=cx+R*Math.cos(ang1),y1=cy+R*Math.sin(ang1);
const x2=cx+R*Math.cos(ang2),y2=cy+R*Math.sin(ang2);
ctx.strokeStyle=gapCol==='auto'?color:gapCol==='magenta'?'#ff00ff':gapCol==='cyan'?'#00ffff':'#ffd700';
ctx.beginPath();ctx.moveTo(x1,y1);ctx.lineTo(x2,y2);ctx.stroke();
}}}}

else if(viz==='channels'){
// Bar chart of channels
const barW=(c.width-100)/divs.length;
const maxCount=Math.max(...compData.channels.map(ch=>ch.count));
ctx.fillStyle=isDark()?'#ffd700':'#cc8800';ctx.font='bold 14px Segoe UI';ctx.textAlign='center';
ctx.fillText(`Channel Distribution for M=${M}`,cx,30);
for(let i=0;i<compData.channels.length;i++){
const ch=compData.channels[i];
const x=50+i*barW;
const barH=(c.height-100)*ch.count/maxCount;
ctx.fillStyle=ch.M===M?'#00d9ff':`hsl(${i*360/divs.length},70%,50%)`;
ctx.fillRect(x,c.height-50-barH,barW*0.8,barH);
ctx.fillStyle=isDark()?'#fff':'#000';ctx.font='10px Arial';
ctx.fillText(`M'=${ch.M}`,x+barW*0.4,c.height-35);
if(showMult)ctx.fillText(`×${ch.mult}`,x+barW*0.4,c.height-50-barH-5);}}

else if(viz==='factorization'){
// Factor tree visualization
ctx.fillStyle=isDark()?'#ffd700':'#cc8800';ctx.font='bold 16px Segoe UI';ctx.textAlign='center';
ctx.fillText(`M = ${M} = ${factors.join(' × ')}`,cx,40);
ctx.fillStyle=isDark()?'#00d9ff':'#0066cc';ctx.font='14px Segoe UI';
ctx.fillText(`Prime factors: {${primeFactors.join(', ')}}`,cx,70);
ctx.fillText(`φ(${M}) = ${phi}`,cx,100);
ctx.fillText(`τ(${M}) = ${divs.length} divisors`,cx,130);
// Draw divisor lattice
const levels={};
for(const d of divs){
const nf=factorizeArr(d).length;
if(!levels[nf])levels[nf]=[];
levels[nf].push(d);}
const levelKeys=Object.keys(levels).map(Number).sort((a,b)=>a-b);
const levelH=(c.height-200)/Math.max(levelKeys.length,1);
for(let li=0;li<levelKeys.length;li++){
const lv=levels[levelKeys[li]];
const y=180+li*levelH;
const xStep=c.width/(lv.length+1);
for(let i=0;i<lv.length;i++){
const x=xStep*(i+1);
ctx.fillStyle=lv[i]===M?'#ffd700':lv[i]===1?'#00ff88':'#00d9ff';
ctx.beginPath();ctx.arc(x,y,15,0,2*Math.PI);ctx.fill();
ctx.fillStyle=isDark()?'#000':'#fff';ctx.font='bold 11px Arial';
ctx.fillText(lv[i],x,y+4);}}}

// Charts
Plotly.newPlot('pcompDist',[{x:compData.channels.map(ch=>`M'=${ch.M}`),y:compData.channels.map(ch=>ch.count),type:'bar',marker:{color:compData.channels.map(ch=>ch.M===M?'#00d9ff':'#ff8c00')}}],{...plo(),xaxis:{title:'Channel'},yaxis:{title:'Residues'}});

const divPhis=divs.map(d=>({d,phi:eulerPhi(d),ratio:eulerPhi(d)/d}));
Plotly.newPlot('pcompDiv',[{x:divs,y:divs.map(d=>M/d),type:'bar',name:'Multiplicity',marker:{color:'#9664ff'}}],{...plo(),xaxis:{title:'Divisor M\''},yaxis:{title:'Multiplicity d=M/M\''}});

Plotly.newPlot('pcompPhi',[{x:divs,y:divPhis.map(d=>d.ratio),mode:'lines+markers',line:{color:'#00ff88'},name:'φ(M\')/M\''},{x:[divs[0],divs[divs.length-1]],y:[6/Math.PI**2,6/Math.PI**2],mode:'lines',line:{color:'#ff006e',dash:'dash'},name:'6/π²'}],{...plo(),xaxis:{title:'Divisor'},yaxis:{title:'Coprime Density'}});

// Legend
const coprimeCount=residues.filter(r=>r.isCoprime).length;
const reducibleCount=M-coprimeCount;
legend('alcomp','Channel Stats',[['Coprime φ(M)',coprimeCount,'#00d9ff'],['Reducible',reducibleCount,'#ff4040'],['Channels τ(M)',divs.length,'#ffd700']]);

// Live stats
document.getElementById('compLiveStats').innerHTML=`
<div style="display:grid;grid-template-columns:repeat(3,1fr);gap:8px;margin-bottom:12px">
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center"><div style="font-size:1.4rem;font-weight:bold;color:#ffd700">${M}</div><div style="font-size:.7rem;color:var(--txt2)">MODULUS M</div></div>
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center"><div style="font-size:1.4rem;font-weight:bold;color:#00d9ff">${phi}</div><div style="font-size:.7rem;color:var(--txt2)">φ(M)</div></div>
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center"><div style="font-size:1.4rem;font-weight:bold;color:#ff4040">${reducibleCount}</div><div style="font-size:.7rem;color:var(--txt2)">REDUCIBLE</div></div>
</div>
<div style="margin-bottom:10px;padding-bottom:8px;border-bottom:1px solid var(--bord)">
<strong style="color:var(--acc)">Factorization</strong>
<div style="margin-top:5px;font-size:.9rem;color:var(--txt)">M = ${factors.join(' × ')}</div>
<div style="font-size:.8rem;color:var(--txt2)">Prime factors: {${primeFactors.join(', ')}}</div>
</div>
<div style="margin-bottom:10px;padding-bottom:8px;border-bottom:1px solid var(--bord)">
<strong style="color:var(--acc)">Density Analysis</strong>
<div style="display:grid;grid-template-columns:1fr 1fr;gap:3px;margin-top:5px;font-size:.8rem">
<span>φ(M)/M:</span><span style="color:#00ff88">${(phi/M*100).toFixed(2)}%</span>
<span>Reducible ratio:</span><span style="color:#ff4040">${(reducibleCount/M*100).toFixed(2)}%</span>
<span>6/π² limit:</span><span style="color:#9664ff">60.79%</span>
<span>Channels τ(M):</span><span style="color:#ffd700">${divs.length}</span>
</div>
</div>
<div style="margin-bottom:10px;padding-bottom:8px;border-bottom:1px solid var(--bord)">
<strong style="color:var(--acc)">Divisors of M</strong>
<div style="margin-top:5px;font-size:.75rem;color:var(--txt2)">{${divs.join(', ')}}</div>
</div>
<div>
<strong style="color:var(--acc)">Channel Multiplicities</strong>
<div style="margin-top:5px;font-size:.75rem;color:var(--txt2)">
${compData.channels.slice(0,8).map(ch=>`M'=${ch.M}: ×${ch.mult}`).join(' | ')}${compData.channels.length>8?'...':''}
</div>
</div>`;

// Table
document.getElementById('tcompT').innerHTML='<tr><th>r</th><th>gcd(r,M)</th><th>Channel M\'</th><th>Reduced r\'</th><th>Type</th><th>Multiplicity</th></tr>'+
residues.slice(0,100).map(res=>`<tr onclick="modal('Residue ${res.r} mod ${M}',[['r',${res.r}],['gcd(r,M)',${res.g}],['Channel M\\'',${res.Mprime}],['Reduced r\\'',${res.rprime}],['Type','${res.isCoprime?'Coprime':'Reducible'}'],['SPF',${res.spf}],['LPF',${res.lpf}]])" style="cursor:pointer;color:${res.isCoprime?'#00d9ff':'#ff4040'}"><td>${res.r}</td><td>${res.g}</td><td>${res.Mprime}</td><td>${res.rprime}</td><td>${res.isCoprime?'Coprime':'Reducible'}</td><td>${M/res.Mprime}</td></tr>`).join('');

// Click handler
c.onclick=e=>{const rect=c.getBoundingClientRect(),mx=(e.clientX-rect.left)*(c.width/rect.width),my=(e.clientY-rect.top)*(c.height/rect.height);
const cx=c.width/2,cy=c.height/2,R=Math.min(cx,cy)-60;
for(const res of residues){
const ang=-2*Math.PI*res.r/M;
const x=cx+R*Math.cos(ang),y=cy+R*Math.sin(ang);
if(Math.hypot(mx-x,my-y)<ptSz+5){
modal(`Residue ${res.r} mod ${M}`,[['r',res.r],['gcd(r,M)',res.g],['Channel M\'',res.Mprime],['Reduced r\'',res.rprime],['Type',res.isCoprime?'Coprime':'Reducible'],['Multiplicity',M/res.Mprime]]);break;}}};}

function startCompSweep(){
stopCompSweep();
const M=+document.getElementById('compMv').value;
const coprimes=compData.residues.filter(r=>r.isCoprime).map(r=>r.r);
let idx=0;
compSweepInterval=setInterval(()=>{
compSweepR=coprimes[idx%coprimes.length];
document.getElementById('compSweepR').textContent='r='+compSweepR;
// Highlight current coprime
drawComp();
const c=document.getElementById('ccomp'),ctx=c.getContext('2d');
const cx=c.width/2,cy=c.height/2,R=Math.min(cx,cy)-60;
const ang=-2*Math.PI*compSweepR/M;
const x=cx+R*Math.cos(ang),y=cy+R*Math.sin(ang);
ctx.fillStyle='#ffd700';ctx.beginPath();ctx.arc(x,y,12,0,2*Math.PI);ctx.fill();
ctx.strokeStyle='#fff';ctx.lineWidth=2;ctx.stroke();
idx++;},500);}

function stopCompSweep(){if(compSweepInterval){clearInterval(compSweepInterval);compSweepInterval=null;}}

function csvComp(){
let s='r,gcd,channel_M,reduced_r,type,multiplicity,spf,lpf\n';
for(const res of compData.residues)s+=`${res.r},${res.g},${res.Mprime},${res.rprime},${res.isCoprime?'coprime':'reducible'},${compData.M/res.Mprime},${res.spf},${res.lpf}\n`;
dl(s,'composite_channels.csv');}

async function screenshotComp(){
const M=document.getElementById('compMv').value;
await screenshotUnified('ccomp','compLiveStats',`Composite Channel Projection — M=${M}`,'composite_channels.png',{dashH:350});
}

// Coprime Pairs Grid
let copairData={N:60,pairs:[],coprimeCount:0};
let copairAnimInterval=null;

function drawCopair(){
if(!document.getElementById("cCopair")) return;

const c=document.getElementById('ccopair'),ctx=c.getContext('2d');
const N=+document.getElementById('copairNv').value||+document.getElementById('copairN').value;
const viz=document.getElementById('copairViz').value;
const col=document.getElementById('copairCol').value;
const showCircle=document.getElementById('copairCircle').checked;
const showDiag=document.getElementById('copairDiag').checked;
const showPrime=document.getElementById('copairPrime').checked;
const showLabels=document.getElementById('copairLabels').checked;
const showAxes=document.getElementById('copairAxes').checked;
const circleR=+document.getElementById('copairR').value/100;
const modHighlight=document.getElementById('copairMod').value;

ctx.fillStyle=canvBg();ctx.fillRect(0,0,c.width,c.height);
document.getElementById('copairNdisp').textContent=N;
document.getElementById('copairAnimN').textContent='N='+N;

// Compute coprime pairs and disc statistics
let coprimeCount=0,discCoprime=0,discTotal=0;
const gcdCounts={};
const R=N*circleR;
const theory=6/Math.PI**2;

// Möbius function
function mobius(n){
if(n===1)return 1;
let result=1,temp=n;
for(let p=2;p*p<=temp;p++){
if(temp%p===0){
temp/=p;
if(temp%p===0)return 0;
result*=-1;}}
if(temp>1)result*=-1;
return result;}

// Compute M(N) = Σμ(n)
let mobiusSum=0,mobiusSumN2=0;
for(let n=1;n<=N;n++){
const mu=mobius(n);
mobiusSum+=mu;
mobiusSumN2+=mu/(n*n);}

for(let a=1;a<=N;a++){
for(let b=1;b<=N;b++){
const g=gcd(a,b);
const isCoprime=g===1;
if(isCoprime)coprimeCount++;
gcdCounts[g]=(gcdCounts[g]||0)+1;
const dist2=a*a+b*b;
if(dist2<=R*R){
discTotal++;
if(isCoprime)discCoprime++;}}}

const totalPairs=N*N;
const ratio=coprimeCount/totalPairs;
const expectedDisc=theory*Math.PI*R*R;
const errorE=discCoprime-expectedDisc;
const errorRatio=Math.abs(errorE)/Math.sqrt(R);

const pad=40,w=c.width-2*pad,h=c.height-2*pad;
const scale=Math.min(w,h)/N;

// Color function
function getColor(a,b,g,isCoprime){
if(showPrime&&!isPrime(a)&&!isPrime(b))return 'rgba(50,50,50,0.3)';
if(modHighlight!=='none'){
const m=+modHighlight;
if(a%m===0||b%m===0)return '#ffd700';}
if(col==='classic')return isCoprime?'#00ff88':'#333';
if(col==='gcd')return isCoprime?'#00ff88':`hsl(${g*40},60%,40%)`;
if(col==='neon')return isCoprime?'#00ffff':'#ff00ff';
if(col==='heatmap')return isCoprime?`hsl(${120-g*10},80%,50%)`:`hsl(${g*20},60%,35%)`;
if(col==='highcontrast')return isCoprime?'#ffff00':'#000';
if(col==='angle')return `hsl(${Math.atan2(b,a)*180/Math.PI*2},70%,${isCoprime?55:35}%)`;
if(col==='norm')return `hsl(${(a*a+b*b)%360},70%,${isCoprime?55:35}%)`;
return isCoprime?'#00ff88':'#333';}

if(viz==='grid'||viz==='gcdmap'||viz==='disc'){
// Draw grid
const cellW=w/N,cellH=h/N;
for(let a=1;a<=N;a++){
for(let b=1;b<=N;b++){
const g=gcd(a,b);
const isCoprime=g===1;
const x=pad+(a-1)*cellW;
const y=pad+h-b*cellH;
ctx.fillStyle=getColor(a,b,g,isCoprime);
ctx.fillRect(x,y,cellW+0.5,cellH+0.5);}}

// Axes
if(showAxes){
ctx.strokeStyle=gridC();ctx.lineWidth=1;
ctx.beginPath();ctx.moveTo(pad,pad+h);ctx.lineTo(pad+w,pad+h);ctx.stroke();
ctx.beginPath();ctx.moveTo(pad,pad);ctx.lineTo(pad,pad+h);ctx.stroke();
ctx.fillStyle=isDark()?'#00d9ff':'#0066cc';ctx.font='11px Segoe UI';ctx.textAlign='center';
ctx.fillText('a',pad+w/2,pad+h+25);
ctx.save();ctx.translate(15,pad+h/2);ctx.rotate(-Math.PI/2);ctx.fillText('b',0,0);ctx.restore();}

// Diagonals
if(showDiag){
ctx.strokeStyle='#ffd700';ctx.lineWidth=1.5;ctx.setLineDash([5,5]);
ctx.beginPath();ctx.moveTo(pad,pad+h);ctx.lineTo(pad+w,pad);ctx.stroke();
ctx.beginPath();ctx.moveTo(pad,pad);ctx.lineTo(pad+w,pad+h);ctx.stroke();ctx.setLineDash([]);}

// Radius circle
if(showCircle||viz==='disc'){
const cx=pad,cy=pad+h;
const rPx=R*scale;
ctx.strokeStyle='#ff006e';ctx.lineWidth=2;
ctx.beginPath();ctx.arc(cx,cy,rPx,0,-Math.PI/2,true);ctx.stroke();
ctx.fillStyle='#ff006e';ctx.font='11px Arial';
ctx.fillText(`R=${R.toFixed(1)}`,cx+rPx*0.7,cy-rPx*0.7);}

// Labels
if(showLabels&&N<=40){
ctx.fillStyle=isDark()?'#888':'#555';ctx.font='8px Arial';ctx.textAlign='center';
for(let i=1;i<=N;i+=Math.ceil(N/20)){
ctx.fillText(i,pad+(i-0.5)*cellW,pad+h+12);
ctx.fillText(i,pad-12,pad+h-(i-0.5)*cellH+3);}}}

else if(viz==='density'){
ctx.fillStyle=isDark()?'#ffd700':'#cc8800';ctx.font='bold 14px Segoe UI';ctx.textAlign='center';
ctx.fillText('Coprime Density Convergence to 6/π²',c.width/2,25);
const densities=[];
for(let n=5;n<=N;n+=Math.max(1,Math.floor(N/50))){
let cnt=0;
for(let a=1;a<=n;a++)for(let b=1;b<=n;b++)if(gcd(a,b)===1)cnt++;
densities.push({n,ratio:cnt/(n*n)});}
ctx.strokeStyle='#ff006e';ctx.lineWidth=2;ctx.setLineDash([5,5]);
const y6pi=pad+h*(1-theory);
ctx.beginPath();ctx.moveTo(pad,y6pi);ctx.lineTo(pad+w,y6pi);ctx.stroke();ctx.setLineDash([]);
ctx.fillStyle='#ff006e';ctx.font='11px Arial';ctx.textAlign='left';
ctx.fillText('6/π² ≈ 0.6079',pad+5,y6pi-5);
ctx.beginPath();ctx.strokeStyle='#00ff88';ctx.lineWidth=2;
for(let i=0;i<densities.length;i++){
const x=pad+w*i/(densities.length-1);
const y=pad+h*(1-densities[i].ratio);
if(i===0)ctx.moveTo(x,y);else ctx.lineTo(x,y);}
ctx.stroke();}

else if(viz==='scatter'){
ctx.fillStyle=isDark()?'#ffd700':'#cc8800';ctx.font='bold 14px Segoe UI';ctx.textAlign='center';
ctx.fillText('Primitive Lattice Vectors (Visible from Origin)',c.width/2,25);
const plotN=Math.min(N,120);
for(let a=1;a<=plotN;a++){
for(let b=1;b<=plotN;b++){
if(gcd(a,b)!==1)continue;
if(showPrime&&!isPrime(a)&&!isPrime(b))continue;
const x=pad+w*a/plotN;
const y=pad+h-h*b/plotN;
ctx.fillStyle=`hsl(${Math.atan2(b,a)*180/Math.PI*2},70%,55%)`;
ctx.beginPath();ctx.arc(x,y,2.5,0,2*Math.PI);ctx.fill();}}
if(showCircle){
ctx.strokeStyle='#ff006e';ctx.lineWidth=2;
ctx.beginPath();ctx.arc(pad,pad+h,R*w/plotN,0,-Math.PI/2,true);ctx.stroke();}}

// Charts
const gcdArr=Object.entries(gcdCounts).map(([g,c])=>({g:+g,count:c})).sort((a,b)=>a.g-b.g).slice(0,12);
Plotly.newPlot('pcopairGcd',[{x:gcdArr.map(g=>`${g.g}`),y:gcdArr.map(g=>g.count),type:'bar',marker:{color:gcdArr.map(g=>g.g===1?'#00ff88':'#ff8c00')}}],{...plo(),xaxis:{title:'gcd'},yaxis:{title:'Count'}});

// Disc analysis chart
const discData=[];
for(let r=10;r<=N;r+=Math.max(1,Math.floor(N/25))){
let vr=0;
for(let a=1;a<=r;a++)for(let b=1;b<=r;b++)if(a*a+b*b<=r*r&&gcd(a,b)===1)vr++;
const exp=theory*Math.PI*r*r;
discData.push({r,vr,exp,err:vr-exp,errRatio:Math.abs(vr-exp)/Math.sqrt(r)});}
Plotly.newPlot('pcopairDisc',[
{x:discData.map(d=>d.r),y:discData.map(d=>d.vr),mode:'lines',name:'V(R)',line:{color:'#00ff88'}},
{x:discData.map(d=>d.r),y:discData.map(d=>d.exp),mode:'lines',name:'(6/π²)πR²',line:{color:'#ffd700',dash:'dash'}}
],{...plo(),xaxis:{title:'Radius R'},yaxis:{title:'Coprime in Disc'}});

// Convergence chart
const convData=[];
for(let n=10;n<=N;n+=Math.max(1,Math.floor(N/25))){
let cnt=0;
for(let a=1;a<=n;a++)for(let b=1;b<=n;b++)if(gcd(a,b)===1)cnt++;
convData.push({n,ratio:cnt/(n*n)});}
Plotly.newPlot('pcopairConv',[
{x:convData.map(d=>d.n),y:convData.map(d=>d.ratio),mode:'lines+markers',line:{color:'#00ff88'},name:'A_N/N²'},
{x:[10,N],y:[theory,theory],mode:'lines',line:{color:'#ff006e',dash:'dash'},name:'6/π²'}
],{...plo(),xaxis:{title:'N'},yaxis:{title:'Ratio',range:[0.55,0.68]}});

// Möbius chart
const mobData=[];
let mSum=0;
for(let n=1;n<=Math.min(N,200);n+=Math.max(1,Math.floor(N/50))){
for(let k=(mobData.length?mobData[mobData.length-1].n+1:1);k<=n;k++)mSum+=mobius(k);
mobData.push({n,mSum,bound:Math.sqrt(n)});}
Plotly.newPlot('pcopairMob',[
{x:mobData.map(d=>d.n),y:mobData.map(d=>d.mSum),mode:'lines',name:'M(N)',line:{color:'#00d9ff'}},
{x:mobData.map(d=>d.n),y:mobData.map(d=>d.bound),mode:'lines',name:'√N',line:{color:'#ffd700',dash:'dot'}},
{x:mobData.map(d=>d.n),y:mobData.map(d=>-d.bound),mode:'lines',name:'-√N',line:{color:'#ffd700',dash:'dot'}}
],{...plo(),xaxis:{title:'N'},yaxis:{title:'M(N) = Σμ(n)'}});

// RH bound chart
Plotly.newPlot('pcopairRH',[
{x:discData.map(d=>d.r),y:discData.map(d=>d.errRatio),mode:'lines+markers',line:{color:'#ff006e'},name:'|E(R)|/R^½'}
],{...plo(),xaxis:{title:'R'},yaxis:{title:'|E(R)|/√R',range:[0,Math.max(...discData.map(d=>d.errRatio))*1.2]}});

// Legend
legend('alcopair','Statistics',[['Coprime A_N',coprimeCount,'#00ff88'],['V(R) in disc',discCoprime,'#00d9ff'],['|E(R)|/√R',errorRatio.toFixed(2),'#ff006e']]);

// Live stats
const absErr=Math.abs(ratio-theory);
document.getElementById('copairLiveStats').innerHTML=`
<div style="background:linear-gradient(135deg,rgba(0,217,255,.15),rgba(255,215,0,.1));padding:10px;border-radius:8px;margin-bottom:12px;border:1px solid var(--acc)">
<div style="font-size:.7rem;color:var(--txt2);margin-bottom:4px">TAB: Coprime Pairs | FIELD: ℤ×ℤ Grid | TYPE: GCD=1 Counting</div>
<div style="display:grid;grid-template-columns:repeat(3,1fr);gap:6px;font-size:.75rem">
<span>Grid N: <strong style="color:#00d9ff">${N}</strong></span>
<span>Total: <strong style="color:#ffd700">${(N*N).toLocaleString()}</strong></span>
<span>Coprime: <strong style="color:#00ff88">${coprimeCount.toLocaleString()}</strong></span>
</div>
</div>
<div style="display:grid;grid-template-columns:repeat(3,1fr);gap:8px;margin-bottom:12px">
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center"><div style="font-size:1.3rem;font-weight:bold;color:#00d9ff">${N}</div><div style="font-size:.65rem;color:var(--txt2)">GRID N</div></div>
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center"><div style="font-size:1.3rem;font-weight:bold;color:#00ff88">${coprimeCount.toLocaleString()}</div><div style="font-size:.65rem;color:var(--txt2)">COPRIME (ACTUAL)</div></div>
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center"><div style="font-size:1.3rem;font-weight:bold;color:#ffd700">${Math.round(N*N*theory).toLocaleString()}</div><div style="font-size:.65rem;color:var(--txt2)">PREDICTED (6N²/π²)</div></div>
</div>
<div style="display:grid;grid-template-columns:repeat(3,1fr);gap:8px;margin-bottom:12px">
<div style="background:var(--bg1);padding:8px;border-radius:6px;text-align:center"><div style="font-size:1rem;font-weight:bold;color:#9664ff">${ratio.toFixed(5)}</div><div style="font-size:.6rem;color:var(--txt2)">DENSITY A_N/N²</div></div>
<div style="background:var(--bg1);padding:8px;border-radius:6px;text-align:center"><div style="font-size:1rem;font-weight:bold;color:#ff8c00">${theory.toFixed(6)}</div><div style="font-size:.6rem;color:var(--txt2)">THEORY 6/π²</div></div>
<div style="background:var(--bg1);padding:8px;border-radius:6px;text-align:center"><div style="font-size:1rem;font-weight:bold;color:${absErr<0.01?'#00ff88':'#ff6496'}">${absErr.toFixed(6)}</div><div style="font-size:.6rem;color:var(--txt2)">ERROR</div></div>
</div>
<div style="margin-bottom:10px;padding-bottom:8px;border-bottom:1px solid var(--bord)">
<strong style="color:var(--acc)">Density Analysis</strong>
<div style="display:grid;grid-template-columns:1fr 1fr;gap:3px;margin-top:5px;font-size:.75rem">
<span>Theory 6/π²:</span><span style="color:#ff006e">${theory.toFixed(6)}</span>
<span>Error:</span><span style="color:#ffd700">${absErr.toFixed(6)}</span>
<span>Relative:</span><span style="color:#9664ff">${(100*absErr/theory).toFixed(3)}%</span>
</div>
</div>
<div style="margin-bottom:10px;padding-bottom:8px;border-bottom:1px solid var(--bord)">
<strong style="color:var(--acc)">Disc Analysis (R=${R.toFixed(1)})</strong>
<div style="display:grid;grid-template-columns:1fr 1fr;gap:3px;margin-top:5px;font-size:.75rem">
<span>V(R) coprime:</span><span style="color:#00ff88">${discCoprime}</span>
<span>Expected:</span><span style="color:#ffd700">${expectedDisc.toFixed(1)}</span>
<span>E(R):</span><span style="color:#ff006e">${errorE.toFixed(2)}</span>
<span>|E(R)|/√R:</span><span style="color:#00d9ff;font-weight:bold">${errorRatio.toFixed(3)}</span>
</div>
</div>
<div style="margin-bottom:10px;padding-bottom:8px;border-bottom:1px solid var(--bord)">
<strong style="color:var(--acc)">Möbius Analysis</strong>
<div style="display:grid;grid-template-columns:1fr 1fr;gap:3px;margin-top:5px;font-size:.75rem">
<span>M(N)=Σμ(n):</span><span style="color:#00d9ff">${mobiusSum}</span>
<span>|M(N)|/√N:</span><span style="color:#ffd700">${(Math.abs(mobiusSum)/Math.sqrt(N)).toFixed(3)}</span>
<span>Σμ(n)/n²:</span><span style="color:#00ff88">${mobiusSumN2.toFixed(6)}</span>
</div>
</div>
<div style="background:rgba(255,0,110,.1);padding:8px;border-radius:6px;font-size:.75rem">
<strong style="color:#ff006e">RH Connection</strong><br>
<span style="color:var(--txt2)">|E(R)|=O(R^½⁺ᵋ)  RH true. Current |E|/√R = ${errorRatio.toFixed(3)}</span>
</div>`;

// Table
const samplePairs=[];
for(let a=1;a<=Math.min(12,N);a++){
for(let b=1;b<=Math.min(12,N);b++){
const g=gcd(a,b);
samplePairs.push({a,b,g,norm:a*a+b*b,angle:(Math.atan2(b,a)*180/Math.PI).toFixed(1)});}}
document.getElementById('tcopairT').innerHTML='<tr><th>a</th><th>b</th><th>gcd</th><th>Norm</th><th>θ°</th><th>Coprime?</th></tr>'+
samplePairs.slice(0,100).map(p=>`<tr onclick="modal('Pair (${p.a},${p.b})',[['a',${p.a}],['b',${p.b}],['gcd(a,b)',${p.g}],['Norm a²+b²',${p.norm}],['Angle',${p.angle}+'°'],['Coprime',${p.g===1}],['Visible from origin',${p.g===1}]])" style="cursor:pointer;color:${p.g===1?'#00ff88':'#666'}"><td>${p.a}</td><td>${p.b}</td><td>${p.g}</td><td>${p.norm}</td><td>${p.angle}</td><td>${p.g===1?'OK':''}</td></tr>`).join('');

// Click handler
c.onclick=e=>{
const rect=c.getBoundingClientRect();
const mx=(e.clientX-rect.left)*(c.width/rect.width);
const my=(e.clientY-rect.top)*(c.height/rect.height);
const cellW=(c.width-80)/N,cellH=(c.height-80)/N;
const a=Math.floor((mx-40)/cellW)+1;
const b=N-Math.floor((my-40)/cellH);
if(a>=1&&a<=N&&b>=1&&b<=N){
const g=gcd(a,b);
const norm=a*a+b*b;
const angle=(Math.atan2(b,a)*180/Math.PI).toFixed(2);
modal(`Lattice Point (${a}, ${b})`,[['a',a],['b',b],['gcd(a,b)',g],['Coprime (visible)?',g===1?'Yes':'No'],['Norm a²+b²',norm],['Distance √(a²+b²)',Math.sqrt(norm).toFixed(3)],['Angle θ',angle+'°'],['Gaussian z',`${a}+${b}i`],['In disc R=${R.toFixed(1)}?',norm<=R*R?'Yes':'No']]);}};}

function startCopairAnim(){
stopCopairAnim();
let n=10;
const maxN=+document.getElementById('copairNv').value;
copairAnimInterval=setInterval(()=>{
document.getElementById('copairNv').value=n;
drawCopair();
n+=2;
if(n>maxN)stopCopairAnim();},200);}

function stopCopairAnim(){if(copairAnimInterval){clearInterval(copairAnimInterval);copairAnimInterval=null;}}

function csvCopair(){
const N=copairData.N;
let s='a,b,gcd,coprime,sum,product\n';
for(let a=1;a<=Math.min(N,100);a++){
for(let b=1;b<=Math.min(N,100);b++){
const g=gcd(a,b);
s+=`${a},${b},${g},${g===1?1:0},${a+b},${a*b}\n`;}}
dl(s,'coprime_pairs.csv');}

async function screenshotCopair(){
const N=document.getElementById('copairNv').value;
await screenshotUnified('ccopair','copairLiveStats',`Coprime Pairs Grid — N=${N}`,'coprime_pairs.png',{dashH:350});
}

// Sierpiński Problem: 6ab ± a ± b
let sierpData={N:200,covered:new Set(),uncovered:[]};

function sierpinski6ab(maxN,maxAB){
const covered=new Set();
const formCounts={pp:new Set(),pm:new Set(),mp:new Set(),mm:new Set()};
const maxA=maxAB||Math.ceil(Math.sqrt(maxN/6))+5;
for(let a=1;a<=maxA;a++){
for(let b=1;b<=maxA;b++){
const pp=6*a*b+a+b;
const pm=6*a*b+a-b;
const mp=6*a*b-a+b;
const mm=6*a*b-a-b;
if(pp>0&&pp<=maxN){covered.add(pp);formCounts.pp.add(pp);}
if(pm>0&&pm<=maxN){covered.add(pm);formCounts.pm.add(pm);}
if(mp>0&&mp<=maxN){covered.add(mp);formCounts.mp.add(mp);}
if(mm>0&&mm<=maxN){covered.add(mm);formCounts.mm.add(mm);}}}
const uncovered=[];
for(let n=1;n<=maxN;n++)if(!covered.has(n))uncovered.push(n);
return {covered,uncovered,formCounts};}

function drawSierp(){
if(!document.getElementById("cSierp")) return;

const c=document.getElementById('csierp'),ctx=c.getContext('2d');
const N=+document.getElementById('sierpNv').value||+document.getElementById('sierpN').value;
const maxAB=+document.getElementById('sierpABv').value;
const viz=document.getElementById('sierpViz').value;
const form=document.getElementById('sierpForm').value;
const showLabels=document.getElementById('sierpLabels').checked;
const showGCD=document.getElementById('sierpGCD').checked;

ctx.fillStyle=canvBg();ctx.fillRect(0,0,c.width,c.height);
document.getElementById('sierpNdisp').textContent=N;

const result=sierpinski6ab(N,maxAB);
sierpData={N,covered:result.covered,uncovered:result.uncovered};

const pad=40,w=c.width-2*pad,h=c.height-2*pad;

if(viz==='coverage'){
// Grid showing covered vs uncovered
const cols=Math.ceil(Math.sqrt(N*1.5));
const rows=Math.ceil(N/cols);
const cellW=w/cols,cellH=h/rows;
for(let n=1;n<=N;n++){
const col=(n-1)%cols;
const row=Math.floor((n-1)/cols);
const x=pad+col*cellW;
const y=pad+row*cellH;
let isCovered=result.covered.has(n);
if(form!=='all'){
isCovered=result.formCounts[form].has(n);}
ctx.fillStyle=isCovered?'#00ff88':'#ff4040';
ctx.fillRect(x+1,y+1,cellW-2,cellH-2);
if(showLabels&&N<=100){
ctx.fillStyle=isDark()?'#fff':'#000';ctx.font='8px Arial';ctx.textAlign='center';
ctx.fillText(n,x+cellW/2,y+cellH/2+3);}}
// Title
ctx.fillStyle=isDark()?'#ffd700':'#cc8800';ctx.font='bold 14px Segoe UI';ctx.textAlign='center';
ctx.fillText(`Coverage Map: ${result.covered.size} covered, ${result.uncovered.length} uncovered`,c.width/2,25);}

else if(viz==='lattice'){
// Show lattice points (a,b) and what they cover
const maxPlot=Math.min(maxAB,50);
const scale=Math.min(w,h)/maxPlot;
ctx.fillStyle=isDark()?'#ffd700':'#cc8800';ctx.font='bold 14px Segoe UI';ctx.textAlign='center';
ctx.fillText('Lattice (a,b): Each point generates 4 values via 6ab±a±b',c.width/2,25);
for(let a=1;a<=maxPlot;a++){
for(let b=1;b<=maxPlot;b++){
const x=pad+a*scale;
const y=pad+h-b*scale;
const g=gcd(a,b);
let clr='#00d9ff';
if(showGCD){
if(g%6===0)clr='#ffd700';
else if(g%3===0)clr='#ff8c00';
else if(g%2===0)clr='#9664ff';}
ctx.fillStyle=clr;
ctx.beginPath();ctx.arc(x,y,3,0,2*Math.PI);ctx.fill();}}
// Axes
ctx.strokeStyle=gridC();ctx.lineWidth=1;
ctx.beginPath();ctx.moveTo(pad,pad+h);ctx.lineTo(pad+w,pad+h);ctx.stroke();
ctx.beginPath();ctx.moveTo(pad,pad);ctx.lineTo(pad,pad+h);ctx.stroke();
ctx.fillStyle=isDark()?'#00d9ff':'#0066cc';ctx.font='11px Segoe UI';
ctx.fillText('a',pad+w/2,pad+h+25);
ctx.save();ctx.translate(15,pad+h/2);ctx.rotate(-Math.PI/2);ctx.fillText('b',0,0);ctx.restore();}

else if(viz==='gaps'){
// Show gaps between uncovered numbers
ctx.fillStyle=isDark()?'#ffd700':'#cc8800';ctx.font='bold 14px Segoe UI';ctx.textAlign='center';
ctx.fillText(`Uncovered Numbers (${result.uncovered.length} total)`,c.width/2,25);
if(result.uncovered.length>0){
const maxU=result.uncovered[result.uncovered.length-1];
for(let i=0;i<result.uncovered.length;i++){
const n=result.uncovered[i];
const x=pad+w*n/maxU;
const y=pad+h/2;
ctx.fillStyle='#ff4040';
ctx.beginPath();ctx.arc(x,y,5,0,2*Math.PI);ctx.fill();
if(showLabels&&result.uncovered.length<=50){
ctx.fillStyle=isDark()?'#fff':'#000';ctx.font='9px Arial';ctx.textAlign='center';
ctx.fillText(n,x,y-10);}}}
// Mark gaps
ctx.strokeStyle='#ffd700';ctx.lineWidth=1;
for(let i=1;i<result.uncovered.length;i++){
const gap=result.uncovered[i]-result.uncovered[i-1];
if(gap>10){
const x1=pad+w*result.uncovered[i-1]/result.uncovered[result.uncovered.length-1];
const x2=pad+w*result.uncovered[i]/result.uncovered[result.uncovered.length-1];
ctx.beginPath();ctx.moveTo(x1,pad+h/2+20);ctx.lineTo(x2,pad+h/2+20);ctx.stroke();
ctx.fillStyle='#ffd700';ctx.font='8px Arial';
ctx.fillText(gap,(x1+x2)/2,pad+h/2+35);}}}

else if(viz==='modular'){
// Modular distribution of uncovered numbers
ctx.fillStyle=isDark()?'#ffd700':'#cc8800';ctx.font='bold 14px Segoe UI';ctx.textAlign='center';
ctx.fillText('Uncovered Numbers by Residue Class mod 6 and mod 12',c.width/2,25);
const mod6=[0,0,0,0,0,0];
const mod12=[0,0,0,0,0,0,0,0,0,0,0,0];
for(const n of result.uncovered){
mod6[n%6]++;
mod12[n%12]++;}
// Draw mod 6 bars
const barW=w/2/6-10;
for(let i=0;i<6;i++){
const x=pad+i*(barW+10);
const barH=mod6[i]*5;
ctx.fillStyle=`hsl(${i*60},70%,50%)`;
ctx.fillRect(x,pad+h/2-barH,barW,barH);
ctx.fillStyle=isDark()?'#fff':'#000';ctx.font='10px Arial';ctx.textAlign='center';
ctx.fillText(`${i}`,x+barW/2,pad+h/2+15);
ctx.fillText(mod6[i],x+barW/2,pad+h/2-barH-5);}
ctx.fillText('mod 6',pad+w/4,pad+h/2+35);
// Draw mod 12 bars
const barW2=w/2/12-5;
for(let i=0;i<12;i++){
const x=pad+w/2+i*(barW2+5);
const barH=mod12[i]*5;
ctx.fillStyle=`hsl(${i*30},70%,50%)`;
ctx.fillRect(x,pad+h/2-barH,barW2,barH);
ctx.fillStyle=isDark()?'#fff':'#000';ctx.font='8px Arial';ctx.textAlign='center';
ctx.fillText(`${i}`,x+barW2/2,pad+h/2+12);
ctx.fillText(mod12[i],x+barW2/2,pad+h/2-barH-5);}
ctx.fillText('mod 12',pad+3*w/4,pad+h/2+35);}

// Charts
const formData=[
{form:'6ab+a+b',count:result.formCounts.pp.size},
{form:'6ab+a-b',count:result.formCounts.pm.size},
{form:'6ab-a+b',count:result.formCounts.mp.size},
{form:'6ab-a-b',count:result.formCounts.mm.size}];
Plotly.newPlot('psierpForm',[{x:formData.map(f=>f.form),y:formData.map(f=>f.count),type:'bar',marker:{color:['#00ff88','#00d9ff','#ffd700','#ff8c00']}}],{...plo(),xaxis:{title:'Form'},yaxis:{title:'Numbers Covered'}});

// Gap distribution
const gaps=[];
for(let i=1;i<result.uncovered.length;i++){
gaps.push(result.uncovered[i]-result.uncovered[i-1]);}
const gapCounts={};
for(const g of gaps)gapCounts[g]=(gapCounts[g]||0)+1;
const gapArr=Object.entries(gapCounts).map(([g,c])=>({gap:+g,count:c})).sort((a,b)=>a.gap-b.gap).slice(0,15);
Plotly.newPlot('psierpGaps',[{x:gapArr.map(g=>`gap ${g.gap}`),y:gapArr.map(g=>g.count),type:'bar',marker:{color:'#ff4040'}}],{...plo(),xaxis:{title:'Gap Size'},yaxis:{title:'Frequency'}});

// Coverage rate
const rateData=[];
const step=Math.max(5,Math.floor(N/25));
for(let n=20;n<=N;n+=step){
const r=sierpinski6ab(n,Math.ceil(Math.sqrt(n/6))+5);
rateData.push({n,rate:100*r.covered.size/n});}
if(rateData.length>0){
Plotly.newPlot('psierpRate',[{x:rateData.map(d=>d.n),y:rateData.map(d=>d.rate),mode:'lines+markers',line:{color:'#00ff88'},marker:{size:6}}],{...plo(),xaxis:{title:'N'},yaxis:{title:'Coverage %',range:[Math.min(90,...rateData.map(d=>d.rate))-2,100]}});
}else{
Plotly.newPlot('psierpRate',[],{...plo()});}

// Legend
legend('alsierp','Statistics',[['Covered',result.covered.size,'#00ff88'],['Uncovered',result.uncovered.length,'#ff4040'],['Rate',(100*result.covered.size/N).toFixed(2)+'%','#ffd700']]);

// Live stats
const coverageRate=(100*result.covered.size/N).toFixed(2);
document.getElementById('sierpLiveStats').innerHTML=`
<div style="display:grid;grid-template-columns:repeat(3,1fr);gap:8px;margin-bottom:12px">
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center"><div style="font-size:1.3rem;font-weight:bold;color:#00d9ff">${N}</div><div style="font-size:.65rem;color:var(--txt2)">MAX N</div></div>
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center"><div style="font-size:1.3rem;font-weight:bold;color:#00ff88">${result.covered.size}</div><div style="font-size:.65rem;color:var(--txt2)">COVERED</div></div>
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center"><div style="font-size:1.3rem;font-weight:bold;color:#ff4040">${result.uncovered.length}</div><div style="font-size:.65rem;color:var(--txt2)">UNCOVERED</div></div>
</div>
<div style="margin-bottom:10px;padding-bottom:8px;border-bottom:1px solid var(--bord)">
<strong style="color:var(--acc)">Coverage Analysis</strong>
<div style="display:grid;grid-template-columns:1fr 1fr;gap:3px;margin-top:5px;font-size:.75rem">
<span>Coverage Rate:</span><span style="color:#00ff88">${coverageRate}%</span>
<span>Search Depth:</span><span style="color:#ffd700">a,b ≤ ${maxAB}</span>
<span>First Uncovered:</span><span style="color:#ff4040">${result.uncovered[0]||'none'}</span>
<span>Last Uncovered:</span><span style="color:#ff4040">${result.uncovered[result.uncovered.length-1]||'none'}</span>
</div>
</div>
<div style="margin-bottom:10px;padding-bottom:8px;border-bottom:1px solid var(--bord)">
<strong style="color:var(--acc)">Form Coverage</strong>
<div style="display:grid;grid-template-columns:1fr 1fr;gap:3px;margin-top:5px;font-size:.75rem">
<span>6ab+a+b:</span><span style="color:#00ff88">${result.formCounts.pp.size}</span>
<span>6ab+a-b:</span><span style="color:#00d9ff">${result.formCounts.pm.size}</span>
<span>6ab-a+b:</span><span style="color:#ffd700">${result.formCounts.mp.size}</span>
<span>6ab-a-b:</span><span style="color:#ff8c00">${result.formCounts.mm.size}</span>
</div>
</div>
<div style="background:rgba(255,64,64,.1);padding:8px;border-radius:6px;font-size:.75rem">
<strong style="color:#ff4040">Open Problem (1964)</strong><br>
<span style="color:var(--txt2)">Are there infinitely many uncovered integers? Known: 78 uncovered ≤1000</span>
</div>`;

// Table
document.getElementById('tsierpT').innerHTML='<tr><th>n</th><th>n mod 6</th><th>n mod 12</th><th>Factorization</th><th>Neighbors</th></tr>'+
result.uncovered.slice(0,50).map(n=>{
const factors=factorizeArr(n).join('×')||'1';
const prev=result.uncovered[result.uncovered.indexOf(n)-1]||'-';
const next=result.uncovered[result.uncovered.indexOf(n)+1]||'-';
return `<tr onclick="testSierpNum(${n})" style="cursor:pointer;color:#ff4040"><td>${n}</td><td>${n%6}</td><td>${n%12}</td><td>${factors}</td><td>${prev}, ${next}</td></tr>`;}).join('');

// Click handler
c.onclick=e=>{
const rect=c.getBoundingClientRect();
const mx=(e.clientX-rect.left)*(c.width/rect.width);
const my=(e.clientY-rect.top)*(c.height/rect.height);
if(viz==='coverage'){
const cols=Math.ceil(Math.sqrt(N*1.5));
const cellW=(c.width-80)/cols,cellH=(c.height-80)/Math.ceil(N/cols);
const col=Math.floor((mx-40)/cellW);
const row=Math.floor((my-40)/cellH);
const n=row*cols+col+1;
if(n>=1&&n<=N){
const isCovered=result.covered.has(n);
modal(`Number ${n}`,[['n',n],['Covered?',isCovered?'Yes':'No'],['n mod 6',n%6],['n mod 12',n%12],['Factorization',factorizeArr(n).join('×')||'1']]);}}};
}

function testSierpNum(n){
if(!n)n=+document.getElementById('sierpTest').value;
const maxAB=+document.getElementById('sierpABv').value;
const reps=[];
for(let a=1;a<=maxAB;a++){
for(let b=1;b<=maxAB;b++){
if(6*a*b+a+b===n)reps.push(`6·${a}·${b}+${a}+${b}`);
if(6*a*b+a-b===n)reps.push(`6·${a}·${b}+${a}-${b}`);
if(6*a*b-a+b===n)reps.push(`6·${a}·${b}-${a}+${b}`);
if(6*a*b-a-b===n)reps.push(`6·${a}·${b}-${a}-${b}`);}}
const msg=reps.length>0?reps.slice(0,5).join('\n'):'No representation found';
modal(`Test n = ${n}`,[['n',n],['Covered?',reps.length>0?'Yes':'No'],['Representations',reps.length],['Examples',msg]]);}

function csvSierp(){
let s='n,covered,mod6,mod12,factorization\n';
for(let n=1;n<=sierpData.N;n++){
const isCov=sierpData.covered.has(n)?1:0;
s+=`${n},${isCov},${n%6},${n%12},"${factorizeArr(n).join('×')||'1'}"\n`;}
dl(s,'sierpinski_coverage.csv');}

async function screenshotSierp(){
const c=document.getElementById('csierp'),dashData=extractDashboardData('sierpLiveStats');
const N=document.getElementById('sierpNv').value;
const scale=2,pad=30,dashH=380;
const out=document.createElement('canvas');
out.width=(c.width+pad*2)*scale;out.height=(c.height+dashH+pad*3)*scale;
const ctx=out.getContext('2d');ctx.scale(scale,scale);
const isDk=isDark();
ctx.fillStyle=isDk?'#0d1321':'#ffffff';ctx.fillRect(0,0,out.width/scale,out.height/scale);
ctx.fillStyle=isDk?'#00d9ff':'#0066cc';ctx.font='bold 18px Segoe UI';ctx.textAlign='center';
ctx.fillText(`Sierpiński Problem — N=${N}`,out.width/scale/2,pad);
ctx.drawImage(c,pad,pad+25,c.width,c.height);
const dashY=c.height+pad+45;
ctx.fillStyle=isDk?'#151b2d':'#f5f5f5';ctx.fillRect(pad,dashY-10,c.width,dashH);
ctx.textAlign='left';
renderDashboard(ctx,dashData,pad+10,dashY,c.width-20,isDk,dashH-30);
ctx.fillStyle=isDk?'#506080':'#888';ctx.font='10px Segoe UI';ctx.textAlign='center';
ctx.fillText('Möbius Shell Sieve — wessengetachew.github.io',out.width/scale/2,out.height/scale-10);
out.toBlob(b=>{const a=document.createElement('a');a.href=URL.createObjectURL(b);a.download='sierpinski.png';a.click();},'image/png',1.0);}

// k-Free Integers (Squarefree, Cubefree, etc.)
const zetaVals={2:ZETA2,3:ZETA3,4:ZETA4,5:ZETA5,6:ZETA6,7:ZETA7,8:ZETA8};

function isKfree(n,k){
if(n<=1)return n===1;
for(let p=2;p*p<=n;p++){
if(n%p===0){
let cnt=0;
while(n%p===0){cnt++;n/=p;}
if(cnt>=k)return false;}}
return true;}

function countKfree(N,k){
let count=0;
const nonKfree=[];
for(let n=1;n<=N;n++){
if(isKfree(n,k))count++;
else if(nonKfree.length<100)nonKfree.push(n);}
return {count,nonKfree};}

function drawKfree(){
if(!document.getElementById("cKfree")) return;

const c=document.getElementById('ckfree'),ctx=c.getContext('2d');
const N=+document.getElementById('kfreeNv').value||+document.getElementById('kfreeN').value;
const k=+document.getElementById('kfreeK').value;
const viz=document.getElementById('kfreeViz').value;
const showTheory=document.getElementById('kfreeTheory').checked;
const showBound=document.getElementById('kfreeBound').checked;

ctx.fillStyle=canvBg();ctx.fillRect(0,0,c.width,c.height);
document.getElementById('kfreeKdisp').textContent=k;
document.getElementById('kfreeNdisp').textContent=N;

let zetaLocal=zetaVals[k]||1;
const density=1/zetaLocal;
const result=countKfree(N,k);
const predicted=N/zetaLocal;
const error=result.count-predicted;
const errorBound=Math.pow(N,1/k);
const errorRatio=Math.abs(error)/errorBound;

const pad=50,w=c.width-2*pad,h=c.height-2*pad;

if(viz==='density'){
ctx.fillStyle=isDark()?'#ffd700':'#cc8800';ctx.font='bold 14px Segoe UI';ctx.textAlign='center';
ctx.fillText(`${k===2?'Squarefree':k===3?'Cubefree':k+'-free'} Density Convergence to 1/ζ(${k})`,c.width/2,25);
const densData=[];
const step=Math.max(10,Math.floor(N/40));
for(let n=50;n<=N;n+=step){
const r=countKfree(n,k);
densData.push({n,ratio:r.count/n});}
// Theory line
if(showTheory){
ctx.strokeStyle='#ff006e';ctx.lineWidth=2;ctx.setLineDash([5,5]);
const yTheory=pad+h*(1-density);
ctx.beginPath();ctx.moveTo(pad,yTheory);ctx.lineTo(pad+w,yTheory);ctx.stroke();ctx.setLineDash([]);
ctx.fillStyle='#ff006e';ctx.font='11px Arial';ctx.textAlign='left';
ctx.fillText(`1/ζ(${k}) ≈ ${density.toFixed(4)}`,pad+5,yTheory-5);}
// Density curve
ctx.beginPath();ctx.strokeStyle='#00ff88';ctx.lineWidth=2;
for(let i=0;i<densData.length;i++){
const x=pad+w*i/(densData.length-1);
const y=pad+h*(1-densData[i].ratio);
if(i===0)ctx.moveTo(x,y);else ctx.lineTo(x,y);}
ctx.stroke();}

else if(viz==='error'){
ctx.fillStyle=isDark()?'#ffd700':'#cc8800';ctx.font='bold 14px Segoe UI';ctx.textAlign='center';
ctx.fillText(`Error Term E(N) = Q_${k}(N) - N/ζ(${k})`,c.width/2,25);
const errData=[];
const step=Math.max(10,Math.floor(N/40));
for(let n=50;n<=N;n+=step){
const r=countKfree(n,k);
const pred=n/zeta;
errData.push({n,err:r.count-pred,bound:Math.pow(n,1/k)});}
const maxErr=Math.max(...errData.map(d=>Math.abs(d.err)));
const maxBound=Math.max(...errData.map(d=>d.bound));
const scale=Math.max(maxErr,maxBound);
// Error curve
ctx.beginPath();ctx.strokeStyle='#00d9ff';ctx.lineWidth=2;
for(let i=0;i<errData.length;i++){
const x=pad+w*i/(errData.length-1);
const y=pad+h/2-h/2*errData[i].err/scale;
if(i===0)ctx.moveTo(x,y);else ctx.lineTo(x,y);}
ctx.stroke();
// Bound curves
if(showBound){
ctx.strokeStyle='#ffd700';ctx.lineWidth=1.5;ctx.setLineDash([3,3]);
ctx.beginPath();
for(let i=0;i<errData.length;i++){
const x=pad+w*i/(errData.length-1);
const y=pad+h/2-h/2*errData[i].bound/scale;
if(i===0)ctx.moveTo(x,y);else ctx.lineTo(x,y);}
ctx.stroke();
ctx.beginPath();
for(let i=0;i<errData.length;i++){
const x=pad+w*i/(errData.length-1);
const y=pad+h/2+h/2*errData[i].bound/scale;
if(i===0)ctx.moveTo(x,y);else ctx.lineTo(x,y);}
ctx.stroke();ctx.setLineDash([]);}
// Zero line
ctx.strokeStyle=gridC();ctx.lineWidth=1;
ctx.beginPath();ctx.moveTo(pad,pad+h/2);ctx.lineTo(pad+w,pad+h/2);ctx.stroke();}

else if(viz==='grid'){
ctx.fillStyle=isDark()?'#ffd700':'#cc8800';ctx.font='bold 14px Segoe UI';ctx.textAlign='center';
ctx.fillText(`${k}-free Numbers Grid (green = ${k}-free)`,c.width/2,25);
const gridN=Math.min(N,500);
const cols=Math.ceil(Math.sqrt(gridN*1.5));
const rows=Math.ceil(gridN/cols);
const cellW=w/cols,cellH=h/rows;
for(let n=1;n<=gridN;n++){
const col=(n-1)%cols;
const row=Math.floor((n-1)/cols);
const x=pad+col*cellW;
const y=pad+row*cellH;
ctx.fillStyle=isKfree(n,k)?'#00ff88':'#ff4040';
ctx.fillRect(x+0.5,y+0.5,cellW-1,cellH-1);}}

else if(viz==='compare'){
ctx.fillStyle=isDark()?'#ffd700':'#cc8800';ctx.font='bold 14px Segoe UI';ctx.textAlign='center';
ctx.fillText('Comparing Densities for k = 2, 3, 4, 5, 6',c.width/2,25);
const colors=['#00ff88','#00d9ff','#ffd700','#ff8c00','#ff006e'];
for(let ki=2;ki<=6;ki++){
const dens=1/zetaVals[ki];
const y=pad+h*(1-dens);
ctx.strokeStyle=colors[ki-2];ctx.lineWidth=2;ctx.setLineDash([]);
ctx.beginPath();ctx.moveTo(pad,y);ctx.lineTo(pad+w,y);ctx.stroke();
ctx.fillStyle=colors[ki-2];ctx.font='11px Arial';ctx.textAlign='left';
ctx.fillText(`k=${ki}: 1/ζ(${ki})=${dens.toFixed(4)}`,pad+10+(ki-2)*120,y-5);}}

// Charts - Zeta reference
const zetaData=[2,3,4,5,6].map(ki=>({k:ki,zeta:zetaVals[ki],inv:1/zetaVals[ki]}));
Plotly.newPlot('pkfreeZeta',[{x:zetaData.map(d=>`k=${d.k}`),y:zetaData.map(d=>d.inv),type:'bar',marker:{color:['#00ff88','#00d9ff','#ffd700','#ff8c00','#ff006e']},name:'1/ζ(k)'}],{...plo(),xaxis:{title:'k'},yaxis:{title:'Density 1/ζ(k)',range:[0.5,1]}});

// Error chart
const errData=[];
const step=Math.max(10,Math.floor(N/30));
for(let n=50;n<=N;n+=step){
const r=countKfree(n,k);
const pred=n/zeta;
errData.push({n,err:r.count-pred});}
Plotly.newPlot('pkfreeErr',[{x:errData.map(d=>d.n),y:errData.map(d=>d.err),mode:'lines',line:{color:'#00d9ff'},name:'E(N)'}],{...plo(),xaxis:{title:'N'},yaxis:{title:'Error'}});

// Ratio chart
const ratioData=errData.map(d=>({n:d.n,ratio:Math.abs(d.err)/Math.pow(d.n,1/k)}));
Plotly.newPlot('pkfreeRatio',[{x:ratioData.map(d=>d.n),y:ratioData.map(d=>d.ratio),mode:'lines+markers',line:{color:'#ff006e'},name:'|E|/N^(1/k)'}],{...plo(),xaxis:{title:'N'},yaxis:{title:'Ratio'}});

// Legend
legend('alkfree','Statistics',[['Q_k(N)',result.count,'#00ff88'],['Predicted',predicted.toFixed(1),'#ffd700'],['Error',error.toFixed(2),'#00d9ff']]);

// Live stats
document.getElementById('kfreeLiveStats').innerHTML=`
<div style="display:grid;grid-template-columns:repeat(3,1fr);gap:8px;margin-bottom:12px">
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center"><div style="font-size:1.3rem;font-weight:bold;color:#00d9ff">${k}</div><div style="font-size:.65rem;color:var(--txt2)">k VALUE</div></div>
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center"><div style="font-size:1.3rem;font-weight:bold;color:#00ff88">${result.count}</div><div style="font-size:.65rem;color:var(--txt2)">Q_k(N)</div></div>
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center"><div style="font-size:1.3rem;font-weight:bold;color:#ffd700">${(result.count/N).toFixed(5)}</div><div style="font-size:.65rem;color:var(--txt2)">DENSITY</div></div>
</div>
<div style="margin-bottom:10px;padding-bottom:8px;border-bottom:1px solid var(--bord)">
<strong style="color:var(--acc)">Theoretical Values</strong>
<div style="display:grid;grid-template-columns:1fr 1fr;gap:3px;margin-top:5px;font-size:.75rem">
<span>ζ(${k}):</span><span style="color:#ffd700">${zeta.toFixed(6)}</span>
<span>1/ζ(${k}):</span><span style="color:#00ff88">${density.toFixed(6)}</span>
<span>Predicted:</span><span style="color:#9664ff">${predicted.toFixed(2)}</span>
</div>
</div>
<div style="margin-bottom:10px;padding-bottom:8px;border-bottom:1px solid var(--bord)">
<strong style="color:var(--acc)">Error Analysis</strong>
<div style="display:grid;grid-template-columns:1fr 1fr;gap:3px;margin-top:5px;font-size:.75rem">
<span>E(N):</span><span style="color:#00d9ff">${error.toFixed(3)}</span>
<span>|E(N)|:</span><span style="color:#ff006e">${Math.abs(error).toFixed(3)}</span>
<span>Bound N^(1/${k}):</span><span style="color:#ffd700">${errorBound.toFixed(2)}</span>
<span>|E|/Bound:</span><span style="color:#ff8c00;font-weight:bold">${errorRatio.toFixed(4)}</span>
</div>
</div>
<div style="background:rgba(0,255,136,.1);padding:8px;border-radius:6px;font-size:.75rem">
<strong style="color:#00ff88">Boundary Principle</strong><br>
<span style="color:var(--txt2)">Error O(N^(1/k)) from (k-1)-dim boundary truncation</span>
</div>`;

// Table
const nonKfreeData=result.nonKfree.slice(0,40).map(n=>{
const f=factorizeArr(n);
let smallestPk=0;
for(let p=2;p*p<=n;p++){
let cnt=0,temp=n;
while(temp%p===0){cnt++;temp/=p;}
if(cnt>=k){smallestPk=p;break;}}
return {n,factors:f.join('×'),pk:`${smallestPk}^${k}`,p:smallestPk};});
document.getElementById('tkfreeT').innerHTML='<tr><th>n</th><th>Factorization</th><th>Divisible by p^k</th><th>Smallest p</th></tr>'+
nonKfreeData.map(d=>`<tr style="color:#ff4040"><td>${d.n}</td><td>${d.factors}</td><td>${d.pk}</td><td>${d.p}</td></tr>`).join('');}

function csvKfree(){
const N=+document.getElementById('kfreeNv').value;
const k=+document.getElementById('kfreeK').value;
let s=`n,is_${k}_free,cumulative_count,density\n`;
let cnt=0;
for(let n=1;n<=N;n++){
const kf=isKfree(n,k)?1:0;
cnt+=kf;
s+=`${n},${kf},${cnt},${(cnt/n).toFixed(6)}\n`;}
dl(s,`${k}_free_integers.csv`);}

async function screenshotKfree(){
const c=document.getElementById('ckfree'),dashData=extractDashboardData('kfreeLiveStats');
const N=document.getElementById('kfreeNv').value,k=document.getElementById('kfreeK').value;
const scale=2,pad=30,dashH=380;
const out=document.createElement('canvas');
out.width=(c.width+pad*2)*scale;out.height=(c.height+dashH+pad*3)*scale;
const ctx=out.getContext('2d');ctx.scale(scale,scale);
const isDk=isDark();
ctx.fillStyle=isDk?'#0d1321':'#ffffff';ctx.fillRect(0,0,out.width/scale,out.height/scale);
ctx.fillStyle=isDk?'#00d9ff':'#0066cc';ctx.font='bold 18px Segoe UI';ctx.textAlign='center';
ctx.fillText(`${k}-Free Integers — N=${N}`,out.width/scale/2,pad);
ctx.drawImage(c,pad,pad+25,c.width,c.height);
const dashY=c.height+pad+45;
ctx.fillStyle=isDk?'#151b2d':'#f5f5f5';ctx.fillRect(pad,dashY-10,c.width,dashH);
ctx.textAlign='left';
renderDashboard(ctx,dashData,pad+10,dashY,c.width-20,isDk,dashH-30);
ctx.fillStyle=isDk?'#506080':'#888';ctx.font='10px Segoe UI';ctx.textAlign='center';
ctx.fillText('Möbius Shell Sieve — wessengetachew.github.io',out.width/scale/2,out.height/scale-10);
out.toBlob(b=>{const a=document.createElement('a');a.href=URL.createObjectURL(b);a.download='k_free.png';a.click();},'image/png',1.0);}

// Euler Product for π and ζ(2n)
let eulerData={primes:[],product:1,target:Math.PI};

// Epsilon-based prime limit calculation
function setEulerEpsilon() {
const eps = +document.getElementById('eulerEpsilon').value;
if (eps === 0) return; // Manual mode

// For pi (from zeta(2)), error ~ 1/Pmax approximately
// For zeta(2n), error ~ 1/Pmax^(2n-1) approximately
const target = document.getElementById('eulerTarget').value;
let Pmax;

if (target === 'pi' || target === 'z2') {
// Error ~ 1/Pmax, so Pmax ~ 1/eps
Pmax = Math.ceil(1 / eps);
} else if (target === 'z4') {
// Error ~ 1/Pmax^3, so Pmax ~ (1/eps)^(1/3)
Pmax = Math.ceil(Math.pow(1 / eps, 1/3));
} else if (target === 'z6') {
// Error ~ 1/Pmax^5
Pmax = Math.ceil(Math.pow(1 / eps, 1/5));
} else {
// z8: Error ~ 1/Pmax^7
Pmax = Math.ceil(Math.pow(1 / eps, 1/7));
}

Pmax = Math.min(100000, Math.max(10, Pmax));
document.getElementById('eulerPmaxv').value = Pmax;
document.getElementById('eulerPmax').value = Math.min(10000, Pmax);
drawEuler();
}

function setEulerAccuracy(digits) {
const eps = Math.pow(10, -digits);
document.getElementById('eulerEpsilon').value = eps;
setEulerEpsilon();
}

function eulerProductPrimes(primes,s){
let product=1;
for(const p of primes){
product*=1/(1-Math.pow(p,-s));}
return product;}

function drawEuler(){
const c=document.getElementById('ceuler');
if (!c) return;
const ctx=c.getContext('2d');
const Pmax=+document.getElementById('eulerPmaxv')?.value||+document.getElementById('eulerPmax')?.value||1000;
const target=document.getElementById('eulerTarget')?.value||'pi';
const viz=document.getElementById('eulerViz')?.value||'convergence';
const mod=+document.getElementById('eulerMod')?.value||30;
const showRef=document.getElementById('eulerRef')?.checked!==false;
const showError=document.getElementById('eulerError')?.checked!==false;

ctx.fillStyle=canvBg();ctx.fillRect(0,0,c.width,c.height);

// Generate primes
const primes=sievePrimes(Pmax);

// Target values
const targets={
pi:{s:2,exact:Math.PI,name:'π',transform:z=>Math.sqrt(6*z)},
z2:{s:2,exact:Math.PI**2/6,name:'ζ(2)',transform:z=>z},
z4:{s:4,exact:Math.PI**4/90,name:'ζ(4)',transform:z=>z},
z6:{s:6,exact:Math.PI**6/945,name:'ζ(6)',transform:z=>z},
z8:{s:8,exact:1.00407735619794,name:'ζ(8)',transform:z=>z}};
const tgt=targets[target];
const s=tgt.s;

// Compute Euler product
let zetaEuler=eulerProductPrimes(primes,s);
const computed=tgt.transform(zetaEuler);
const error=Math.abs(computed-tgt.exact);
const relError=error/tgt.exact;

// Update displays if they exist
const dispTarget=document.getElementById('eulerTargetDisp');
const dispPmax=document.getElementById('eulerPmaxDisp');
if(dispTarget)dispTarget.textContent=tgt.name;
if(dispPmax)dispPmax.textContent=Pmax;

const pad=50,w=c.width-2*pad,h=c.height-2*pad;

// Gap-class analysis
const gapClasses={};
for(let i=0;i<primes.length-1;i++){
const gap=primes[i+1]-primes[i];
if(!gapClasses[gap])gapClasses[gap]=[];
gapClasses[gap].push(primes[i]);}

// Residue channel analysis
const channels={};
for(let a=1;a<mod;a++){
if(gcd(a,mod)===1)channels[a]=[];}
for(const p of primes){
const r=p%mod;
if(channels[r])channels[r].push(p);}

if(viz==='convergence'){
ctx.fillStyle=isDark()?'#ffd700':'#cc8800';ctx.font='bold 14px Segoe UI';ctx.textAlign='center';
ctx.fillText(`Computing ${tgt.name} via Euler Product`,c.width/2,25);
// Convergence curve
const convData=[];
const step=Math.max(1,Math.floor(primes.length/60));
let prod=1;
for(let i=0;i<primes.length;i++){
prod*=1/(1-Math.pow(primes[i],-s));
if(i%step===0||i===primes.length-1){
const val=tgt.transform(prod);
convData.push({p:primes[i],val});}}
const maxP=primes[primes.length-1];
const minV=Math.min(...convData.map(d=>d.val))*0.999;
const maxV=Math.max(...convData.map(d=>d.val),tgt.exact)*1.001;
// Reference line
if(showRef){
ctx.strokeStyle='#ff006e';ctx.lineWidth=2;ctx.setLineDash([5,5]);
const yRef=pad+h*(1-(tgt.exact-minV)/(maxV-minV));
ctx.beginPath();ctx.moveTo(pad,yRef);ctx.lineTo(pad+w,yRef);ctx.stroke();ctx.setLineDash([]);
ctx.fillStyle='#ff006e';ctx.font='11px Arial';ctx.textAlign='left';
ctx.fillText(`${tgt.name} = ${tgt.exact.toFixed(10)}`,pad+5,yRef-5);}
// Convergence curve
ctx.beginPath();ctx.strokeStyle='#00ff88';ctx.lineWidth=2;
for(let i=0;i<convData.length;i++){
const x=pad+w*convData[i].p/maxP;
const y=pad+h*(1-(convData[i].val-minV)/(maxV-minV));
if(i===0)ctx.moveTo(x,y);else ctx.lineTo(x,y);}
ctx.stroke();}

else if(viz==='contributions'){
ctx.fillStyle=isDark()?'#ffd700':'#cc8800';ctx.font='bold 14px Segoe UI';ctx.textAlign='center';
ctx.fillText('Individual Prime Contributions to ζ('+s+')',c.width/2,25);
const contribs=primes.slice(0,50).map(p=>({p,contrib:1/(1-Math.pow(p,-s))}));
const maxC=Math.max(...contribs.map(c=>c.contrib));
const barW=w/contribs.length-2;
for(let i=0;i<contribs.length;i++){
const barH=h*(contribs[i].contrib-1)/(maxC-1);
const x=pad+i*(barW+2);
const y=pad+h-barH;
ctx.fillStyle=`hsl(${i*7},70%,50%)`;
ctx.fillRect(x,y,barW,barH);}}

else if(viz==='gaps'){
ctx.fillStyle=isDark()?'#ffd700':'#cc8800';ctx.font='bold 14px Segoe UI';ctx.textAlign='center';
ctx.fillText('Gap-Class Decomposition: ζ(s) = ∏_g P_g(s)',c.width/2,25);
const gapArr=Object.entries(gapClasses).map(([g,ps])=>{
let prod=1;
for(const p of ps)prod*=1/(1-Math.pow(p,-s));
return {gap:+g,count:ps.length,prod};}).sort((a,b)=>a.gap-b.gap).slice(0,15);
const maxProd=Math.max(...gapArr.map(g=>g.prod));
const barW=w/gapArr.length-4;
for(let i=0;i<gapArr.length;i++){
const barH=h*Math.log(gapArr[i].prod)/Math.log(maxProd);
const x=pad+i*(barW+4);
const y=pad+h-barH;
ctx.fillStyle=`hsl(${gapArr[i].gap*20},70%,50%)`;
ctx.fillRect(x,y,barW,barH);
ctx.fillStyle=isDark()?'#fff':'#000';ctx.font='9px Arial';ctx.textAlign='center';
ctx.fillText(`g=${gapArr[i].gap}`,x+barW/2,pad+h+12);}}

else if(viz==='residue'){
ctx.fillStyle=isDark()?'#ffd700':'#cc8800';ctx.font='bold 14px Segoe UI';ctx.textAlign='center';
ctx.fillText(`Residue Channels mod ${mod} (φ(${mod})=${Object.keys(channels).length} channels)`,c.width/2,25);
const chanArr=Object.entries(channels).map(([a,ps])=>{
let prod=1;
for(const p of ps)prod*=1/(1-Math.pow(p,-s));
return {a:+a,count:ps.length,prod};}).sort((a,b)=>a.a-b.a);
const maxProd=Math.max(...chanArr.map(c=>c.prod));
const barW=w/chanArr.length-2;
for(let i=0;i<chanArr.length;i++){
const barH=h*Math.log(chanArr[i].prod)/Math.log(maxProd);
const x=pad+i*(barW+2);
const y=pad+h-barH;
ctx.fillStyle=`hsl(${chanArr[i].a*360/mod},70%,50%)`;
ctx.fillRect(x,y,barW,barH);
if(chanArr.length<=20){
ctx.fillStyle=isDark()?'#fff':'#000';ctx.font='8px Arial';ctx.textAlign='center';
ctx.fillText(chanArr[i].a,x+barW/2,pad+h+10);}}}

// Charts
const zetaRef=[{k:2,val:Math.PI**2/6},{k:4,val:Math.PI**4/90},{k:6,val:Math.PI**6/945},{k:8,val:1.00407735619794}];
if(document.getElementById('peulerZeta')) Plotly.newPlot('peulerZeta',[{x:zetaRef.map(z=>`ζ(${z.k})`),y:zetaRef.map(z=>z.val),type:'bar',marker:{color:['#00ff88','#00d9ff','#ffd700','#ff8c00']}}],{...plo(),yaxis:{title:'Value'}});

// Convergence chart
const convData=[];
let prod=1;
const step=Math.max(1,Math.floor(primes.length/40));
for(let i=0;i<primes.length;i++){
prod*=1/(1-Math.pow(primes[i],-s));
if(i%step===0||i===primes.length-1){
convData.push({p:primes[i],val:tgt.transform(prod)});}}
if(document.getElementById('peulerConv')) Plotly.newPlot('peulerConv',[
{x:convData.map(d=>d.p),y:convData.map(d=>d.val),mode:'lines',line:{color:'#00ff88'},name:'Computed'},
{x:[2,Pmax],y:[tgt.exact,tgt.exact],mode:'lines',line:{color:'#ff006e',dash:'dash'},name:'Exact'}
],{...plo(),xaxis:{title:'Prime'},yaxis:{title:tgt.name}});

// Error chart
const errData=convData.map(d=>({p:d.p,err:Math.abs(d.val-tgt.exact)}));
if(document.getElementById('peulerErr')) Plotly.newPlot('peulerErr',[{x:errData.map(d=>d.p),y:errData.map(d=>d.err),mode:'lines',line:{color:'#ff006e'}}],{...plo(),xaxis:{title:'Prime'},yaxis:{title:'|Error|',type:'log'}});

// Gap chart
const gapArr=Object.entries(gapClasses).map(([g,ps])=>({gap:+g,count:ps.length})).sort((a,b)=>a.gap-b.gap).slice(0,12);
if(document.getElementById('peulerGap')) Plotly.newPlot('peulerGap',[{x:gapArr.map(g=>`gap ${g.gap}`),y:gapArr.map(g=>g.count),type:'bar',marker:{color:'#00d9ff'}}],{...plo(),xaxis:{title:'Gap'},yaxis:{title:'Primes'}});

// Residue chart
const chanArrRes=Object.entries(channels).map(([a,ps])=>({a:+a,count:ps.length})).sort((a,b)=>a.a-b.a);
if(document.getElementById('peulerRes')) Plotly.newPlot('peulerRes',[{x:chanArrRes.map(c=>`${c.a}`),y:chanArrRes.map(c=>c.count),type:'bar',marker:{color:chanArrRes.map(c=>`hsl(${c.a*360/mod},70%,50%)`)}}],{...plo(),xaxis:{title:`Residue mod ${mod}`},yaxis:{title:'Primes'}});

// Legend
legend('aleuler','Euler Product',[['Computed',computed.toFixed(12),'#00ff88'],['Exact',tgt.exact.toFixed(12),'#ff006e'],['Primes',primes.length,'#00d9ff']]);

eulerData={primes,product:zeta,computed,target:tgt.exact};

// Live stats
const eulerStatsEl = document.getElementById('eulerLiveStats');
if (eulerStatsEl) eulerStatsEl.innerHTML=`
<div style="display:grid;grid-template-columns:repeat(3,1fr);gap:8px;margin-bottom:12px">
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center"><div style="font-size:1.1rem;font-weight:bold;color:#00d9ff">${primes.length}</div><div style="font-size:.65rem;color:var(--txt2)">PRIMES</div></div>
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center"><div style="font-size:1.1rem;font-weight:bold;color:#00ff88">${computed.toFixed(10)}</div><div style="font-size:.65rem;color:var(--txt2)">${tgt.name} COMPUTED</div></div>
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center"><div style="font-size:1.1rem;font-weight:bold;color:#ff006e">${tgt.exact.toFixed(10)}</div><div style="font-size:.65rem;color:var(--txt2)">${tgt.name} EXACT</div></div>
</div>
<div style="margin-bottom:10px;padding-bottom:8px;border-bottom:1px solid var(--bord)">
<strong style="color:var(--acc)">Accuracy Analysis</strong>
<div style="display:grid;grid-template-columns:1fr 1fr;gap:3px;margin-top:5px;font-size:.75rem">
<span>Absolute Error:</span><span style="color:#ffd700">${error.toExponential(4)}</span>
<span>Relative Error:</span><span style="color:#9664ff">${(relError*100).toExponential(3)}%</span>
<span>Correct Digits:</span><span style="color:#00ff88">~${Math.max(0,-Math.floor(Math.log10(relError))).toFixed(0)}</span>
<span>Convergence Rate:</span><span style="color:#00d9ff">~1/P_max</span>
</div>
</div>
<div style="margin-bottom:10px;padding-bottom:8px;border-bottom:1px solid var(--bord)">
<strong style="color:var(--acc)">Euler Product ζ(${s})</strong>
<div style="display:grid;grid-template-columns:1fr 1fr;gap:3px;margin-top:5px;font-size:.75rem">
<span>ζ(${s}) computed:</span><span style="color:#00d9ff">${zeta.toFixed(10)}</span>
<span>Largest prime:</span><span style="color:#ffd700">${primes[primes.length-1]}</span>
<span>Gap classes:</span><span style="color:#ff8c00">${Object.keys(gapClasses).length}</span>
<span>P_max / π(P_max):</span><span style="color:#9664ff">${(primes[primes.length-1]/primes.length).toFixed(2)}</span>
</div>
</div>
<div style="margin-bottom:10px;padding-bottom:8px;border-bottom:1px solid var(--bord)">
<strong style="color:var(--acc)">Reference Zeta Values</strong>
<div style="display:grid;grid-template-columns:1fr 1fr;gap:3px;margin-top:5px;font-size:.75rem">
<span>ζ(2) = π²/6:</span><span style="color:#00ff88">${(Math.PI*Math.PI/6).toFixed(8)}</span>
<span>ζ(4) = π⁴/90:</span><span style="color:#00d9ff">${(Math.pow(Math.PI,4)/90).toFixed(8)}</span>
<span>ζ(6) = π⁶/945:</span><span style="color:#ffd700">${(Math.pow(Math.PI,6)/945).toFixed(8)}</span>
<span>ζ(8) = π⁸/9450:</span><span style="color:#9664ff">${(Math.pow(Math.PI,8)/9450).toFixed(8)}</span>
</div>
</div>
<div style="background:rgba(0,255,136,.1);padding:8px;border-radius:6px;font-size:.75rem">
<strong style="color:#00ff88">Basel Problem (Euler 1734)</strong><br>
<span style="color:var(--txt2)">ζ(2) = 1+1/4+1/9+... = π²/6<br>π = √(6·∏<sub>p</sub>(1-p⁻²)⁻¹)</span>
</div>`;
}

function csvEuler(){
const primes=eulerData.primes;
const s=document.getElementById('eulerTarget').value==='pi'?2:+document.getElementById('eulerTarget').value.slice(1);
let csv='prime,index,1/(1-p^-s),cumulative_product\n';
let prod=1;
for(let i=0;i<primes.length;i++){
const factor=1/(1-Math.pow(primes[i],-s));
prod*=factor;
csv+=`${primes[i]},${i+1},${factor.toFixed(12)},${prod.toFixed(12)}\n`;}
dl(csv,'euler_product.csv');}

async function screenshotEuler(){
const Pmax=document.getElementById('eulerPmaxv').value;
await screenshotUnified('ceuler','eulerLiveStats',`Euler Product — Primes ≤ ${Pmax}`,'euler_product.png',{dashH:350});
}

// Chord Length Uniformity Analysis
let chordData={results:[]};

function chordCV(n){
const coprimes=[];
for(let r=1;r<n;r++)if(gcd(r,n)===1)coprimes.push(r);
if(coprimes.length<2)return {cv:0,mean:0,stdDev:0,phi:coprimes.length,gapRatio:1,chords:[]};
const chords=[];
for(let i=0;i<coprimes.length;i++){
const r1=coprimes[i];
const r2=coprimes[(i+1)%coprimes.length];
const gap=(r2>r1)?(r2-r1):(r2+n-r1);
chords.push(2*Math.sin(Math.PI*gap/n));}
const mean=chords.reduce((a,b)=>a+b,0)/chords.length;
const variance=chords.reduce((a,b)=>a+(b-mean)**2,0)/chords.length;
const stdDev=Math.sqrt(variance);
const cv=mean>0?stdDev/mean:0;
const gapRatio=Math.max(...chords)/Math.min(...chords);
return {cv,mean,stdDev,phi:coprimes.length,gapRatio,chords};}

function drawChord(){
if(!document.getElementById("cChord")) return;

const c=document.getElementById('cchord'),ctx=c.getContext('2d');
const maxN=+document.getElementById('chordNv').value||+document.getElementById('chordN').value;
const viz=document.getElementById('chordViz').value;
const testN=+document.getElementById('chordTest').value||97;
const showThresh=document.getElementById('chordThresh').checked;
const showLabels=document.getElementById('chordLabels').checked;

ctx.fillStyle=canvBg();ctx.fillRect(0,0,c.width,c.height);

// Compute CV for all n in range
const results=[];
let primeSum=0,primeCount=0,compSum=0,compCount=0;
for(let n=3;n<=maxN;n++){
const r=chordCV(n);
const prime=isPrime(n);
results.push({n,cv:r.cv,phi:r.phi,gapRatio:r.gapRatio,prime});
if(prime){primeSum+=r.cv;primeCount++;}
else{compSum+=r.cv;compCount++;}}
chordData.results=results;

const primeAvg=primeCount>0?primeSum/primeCount:0;
const compAvg=compCount>0?compSum/compCount:0;
const separation=compAvg>0?((compAvg-primeAvg)/compAvg*100):0;

const pad=50,w=c.width-2*pad,h=c.height-2*pad;
const baseThreshold=+document.getElementById('chordThreshVal')?.value||0.22;
const threshExp=+document.getElementById('chordThreshExp')?.value||0;
const adaptiveThresh=document.getElementById('chordAdaptive')?.checked;
const colorBy=document.getElementById('chordColorBy')?.value||'primality';

// Calculate threshold function
function getThreshold(n) {
  if(adaptiveThresh && threshExp > 0) {
    return baseThreshold * Math.pow(n, -threshExp);
  }
  return baseThreshold;
}

// Get color for a result based on colorBy option
function getPointColor(r) {
  if(colorBy === 'primality') return r.prime ? '#00ff88' : '#ff4040';
  if(colorBy === 'lpf') {
    // Lowest prime factor coloring
    const lpf = lowestPrimeFactor(r.n);
    if(lpf === r.n) return '#00ff88'; // prime
    const lpfColors = {2:'#ff4040',3:'#ffd700',5:'#00d9ff',7:'#9664ff',11:'#ff8c00',13:'#ff00ff'};
    return lpfColors[lpf] || `hsl(${lpf*37%360},70%,50%)`;
  }
  if(colorBy === 'cv') {
    const cvNorm = Math.min(1, r.cv / 0.5);
    return `hsl(${(1-cvNorm)*120},80%,50%)`; // green=low CV, red=high CV
  }
  if(colorBy === 'phi') {
    const phiRatio = r.phi / r.n;
    return `hsl(${phiRatio*240},80%,50%)`; // blue=low ratio, red=high ratio
  }
  return r.prime ? '#00ff88' : '#ff4040';
}

// Calculate stats with adaptive threshold
let correctWithBase=0, correctWithAdaptive=0;
for(const r of results){
  const baseCorrect = (r.prime && r.cv < baseThreshold) || (!r.prime && r.cv >= baseThreshold);
  const adaptCorrect = (r.prime && r.cv < getThreshold(r.n)) || (!r.prime && r.cv >= getThreshold(r.n));
  if(baseCorrect) correctWithBase++;
  if(adaptCorrect) correctWithAdaptive++;
}
chordData.accuracyBase = 100 * correctWithBase / results.length;
chordData.accuracyAdaptive = 100 * correctWithAdaptive / results.length;
chordData.threshExp = threshExp;
chordData.baseThreshold = baseThreshold;

if(viz==='scatter'){
ctx.fillStyle=isDark()?'#ffd700':'#cc8800';ctx.font='bold 14px Segoe UI';ctx.textAlign='center';
const colorLabel = colorBy === 'lpf' ? 'by Lowest Prime Factor' : colorBy === 'cv' ? 'by CV Value' : colorBy === 'phi' ? 'by φ(n)/n' : 'Primes (green) vs Composites (red)';
ctx.fillText(`Chord CV: ${colorLabel}`,c.width/2,25);
const maxCV=Math.max(...results.map(r=>r.cv),0.5);
// Threshold line(s)
if(showThresh){
ctx.strokeStyle='#ffd700';ctx.lineWidth=2;ctx.setLineDash([5,5]);
if(adaptiveThresh && threshExp > 0) {
  // Draw adaptive threshold curve
  ctx.beginPath();
  for(let n=3;n<=maxN;n++){
    const x=pad+w*(n-3)/(maxN-3);
    const thresh = getThreshold(n);
    const y=pad+h*(1-thresh/maxCV);
    if(n===3) ctx.moveTo(x,y); else ctx.lineTo(x,y);
  }
  ctx.stroke();
  ctx.fillStyle='#ffd700';ctx.font='10px Arial';ctx.textAlign='left';
  ctx.fillText(`CV=${baseThreshold}×n^(-${threshExp})`,pad+5,pad+20);
} else {
  const yThresh=pad+h*(1-baseThreshold/maxCV);
  ctx.beginPath();ctx.moveTo(pad,yThresh);ctx.lineTo(pad+w,yThresh);ctx.stroke();
  ctx.fillStyle='#ffd700';ctx.font='10px Arial';ctx.textAlign='left';
  ctx.fillText(`CV=${baseThreshold} threshold`,pad+5,yThresh-5);
}
ctx.setLineDash([]);}
// Plot points
for(const r of results){
const x=pad+w*(r.n-3)/(maxN-3);
const y=pad+h*(1-r.cv/maxCV);
ctx.fillStyle=getPointColor(r);
ctx.beginPath();ctx.arc(x,y,3,0,2*Math.PI);ctx.fill();}
// Axes
ctx.strokeStyle=gridC();ctx.lineWidth=1;
ctx.beginPath();ctx.moveTo(pad,pad+h);ctx.lineTo(pad+w,pad+h);ctx.stroke();
ctx.beginPath();ctx.moveTo(pad,pad);ctx.lineTo(pad,pad+h);ctx.stroke();
ctx.fillStyle=isDark()?'#00d9ff':'#0066cc';ctx.font='11px Segoe UI';
ctx.textAlign='center';ctx.fillText('n',pad+w/2,pad+h+25);
ctx.save();ctx.translate(15,pad+h/2);ctx.rotate(-Math.PI/2);ctx.fillText('CV',0,0);ctx.restore();}

else if(viz==='histogram'){
ctx.fillStyle=isDark()?'#ffd700':'#cc8800';ctx.font='bold 14px Segoe UI';ctx.textAlign='center';
ctx.fillText('CV Distribution: Primes vs Composites',c.width/2,25);
const bins=20;
const primeBins=new Array(bins).fill(0);
const compBins=new Array(bins).fill(0);
for(const r of results){
const bin=Math.min(bins-1,Math.floor(r.cv*bins/0.6));
if(r.prime)primeBins[bin]++;else compBins[bin]++;}
const maxBin=Math.max(...primeBins,...compBins);
const barW=w/bins/2-2;
for(let i=0;i<bins;i++){
const x=pad+i*w/bins;
const ph=h*primeBins[i]/maxBin;
const ch=h*compBins[i]/maxBin;
ctx.fillStyle='#00ff88';ctx.fillRect(x,pad+h-ph,barW,ph);
ctx.fillStyle='#ff4040';ctx.fillRect(x+barW+2,pad+h-ch,barW,ch);}
// Labels
ctx.fillStyle=isDark()?'#888':'#666';ctx.font='9px Arial';ctx.textAlign='center';
for(let i=0;i<=bins;i+=5){
ctx.fillText((i*0.6/bins).toFixed(2),pad+i*w/bins,pad+h+12);}}

else if(viz==='separation'){
ctx.fillStyle=isDark()?'#ffd700':'#cc8800';ctx.font='bold 14px Segoe UI';ctx.textAlign='center';
ctx.fillText('Separation Growth by Range',c.width/2,25);
const ranges=[50,100,200,300,400,500,maxN].filter(r=>r<=maxN);
const sepData=[];
for(const rng of ranges){
let ps=0,pc=0,cs=0,cc=0;
for(const r of results){
if(r.n>rng)continue;
if(r.prime){ps+=r.cv;pc++;}else{cs+=r.cv;cc++;}}
const pa=pc>0?ps/pc:0;
const ca=cc>0?cs/cc:0;
sepData.push({rng,sep:ca>0?(ca-pa)/ca*100:0,primeAvg:pa,compAvg:ca});}
const maxSep=Math.max(...sepData.map(d=>d.sep),80);
ctx.beginPath();ctx.strokeStyle='#00ff88';ctx.lineWidth=3;
for(let i=0;i<sepData.length;i++){
const x=pad+w*i/(sepData.length-1);
const y=pad+h*(1-sepData[i].sep/maxSep);
if(i===0)ctx.moveTo(x,y);else ctx.lineTo(x,y);}
ctx.stroke();
// Points with labels
for(let i=0;i<sepData.length;i++){
const x=pad+w*i/(sepData.length-1);
const y=pad+h*(1-sepData[i].sep/maxSep);
ctx.fillStyle='#00ff88';ctx.beginPath();ctx.arc(x,y,6,0,2*Math.PI);ctx.fill();
ctx.fillStyle=isDark()?'#fff':'#000';ctx.font='10px Arial';ctx.textAlign='center';
ctx.fillText((sepData[i].sep||0).toFixed(1)+'%',x,y-12);
ctx.fillText('n≤'+sepData[i].rng,x,pad+h+15);}}

else if(viz==='single'){
const r=chordCV(testN);
const prime=isPrime(testN);
ctx.fillStyle=isDark()?'#ffd700':'#cc8800';ctx.font='bold 14px Segoe UI';ctx.textAlign='center';
ctx.fillText(`Chord Analysis for n=${testN} (${prime?'PRIME':'COMPOSITE'})`,c.width/2,25);
// Draw unit circle with coprime points
const cx=c.width/2,cy=c.height/2+20,rad=Math.min(w,h)/2-30;
ctx.strokeStyle=gridC();ctx.lineWidth=1;
ctx.beginPath();ctx.arc(cx,cy,rad,0,2*Math.PI);ctx.stroke();
// Draw coprime points and chords
const coprimes=[];
for(let i=1;i<testN;i++)if(gcd(i,testN)===1)coprimes.push(i);
for(let i=0;i<coprimes.length;i++){
const angle=2*Math.PI*coprimes[i]/testN-Math.PI/2;
const x=cx+rad*Math.cos(angle);
const y=cy+rad*Math.sin(angle);
ctx.fillStyle='#00ff88';ctx.beginPath();ctx.arc(x,y,5,0,2*Math.PI);ctx.fill();
// Draw chord to next
const nextAngle=2*Math.PI*coprimes[(i+1)%coprimes.length]/testN-Math.PI/2;
const nx=cx+rad*Math.cos(nextAngle);
const ny=cy+rad*Math.sin(nextAngle);
ctx.strokeStyle='rgba(0,255,136,0.3)';ctx.lineWidth=1;
ctx.beginPath();ctx.moveTo(x,y);ctx.lineTo(nx,ny);ctx.stroke();}
// Info
ctx.fillStyle=isDark()?'#fff':'#000';ctx.font='12px Segoe UI';ctx.textAlign='left';
ctx.fillText(`φ(${testN}) = ${r.phi}`,pad,pad+h-60);
ctx.fillText(`CV = ${(r.cv||0).toFixed(4)}`,pad,pad+h-40);
ctx.fillText(`Gap Ratio = ${(r.gapRatio||1).toFixed(3)}`,pad,pad+h-20);
ctx.fillText(`Verdict: ${(r.cv||0)<0.22?'Likely Prime':'Likely Composite'}`,pad+200,pad+h-40);}

else if(viz==='compare'){
// Compare 2-3 moduli side by side
const n1=testN;
const n2=+document.getElementById('chordTest2').value||100;
const n3=+document.getElementById('chordTest3').value||0;
const nums=n3>2?[n1,n2,n3]:[n1,n2];
const cols=nums.length;
const cw=(c.width-pad*2)/cols-10;
const rad=Math.min(cw/2-20,(h-80)/2-20);

ctx.fillStyle=isDark()?'#ffd700':'#cc8800';ctx.font='bold 14px Segoe UI';ctx.textAlign='center';
ctx.fillText(`Comparing ${nums.length} Moduli: ${nums.join(' vs ')}`,c.width/2,20);

const colors=['#00ff88','#ff8c00','#00d9ff'];
const bgColors=['rgba(0,255,136,0.1)','rgba(255,140,0,0.1)','rgba(0,217,255,0.1)'];

nums.forEach((n,idx)=>{
const cv=chordCV(n);
const prime=isPrime(n);
const cx=pad+cw/2+idx*(cw+10)+5;
const cy=pad+rad+50;

// Background panel
ctx.fillStyle=bgColors[idx];
ctx.fillRect(pad+idx*(cw+10),pad+35,cw,h-45);

// Title
ctx.fillStyle=colors[idx];ctx.font='bold 13px Segoe UI';ctx.textAlign='center';
ctx.fillText(`n = ${n}`,cx,pad+52);
ctx.fillStyle=prime?'#00ff88':'#ff4040';ctx.font='11px Segoe UI';
ctx.fillText(prime?'PRIME':'COMPOSITE',cx,pad+68);

// Circle
ctx.strokeStyle=gridC();ctx.lineWidth=1;
ctx.beginPath();ctx.arc(cx,cy,rad,0,2*Math.PI);ctx.stroke();

// Draw coprime points and chords
const coprimes=[];
for(let i=1;i<n;i++)if(gcd(i,n)===1)coprimes.push(i);
for(let i=0;i<coprimes.length;i++){
const angle=2*Math.PI*coprimes[i]/n-Math.PI/2;
const x=cx+rad*Math.cos(angle);
const y=cy+rad*Math.sin(angle);
ctx.fillStyle=colors[idx];ctx.beginPath();ctx.arc(x,y,3,0,2*Math.PI);ctx.fill();
// Chord to next
const nextAngle=2*Math.PI*coprimes[(i+1)%coprimes.length]/n-Math.PI/2;
const nx=cx+rad*Math.cos(nextAngle);
const ny=cy+rad*Math.sin(nextAngle);
ctx.strokeStyle=colors[idx].replace(')',',0.25)').replace('rgb','rgba');
ctx.lineWidth=1;ctx.beginPath();ctx.moveTo(x,y);ctx.lineTo(nx,ny);ctx.stroke();}

// Stats below circle
const statsY=cy+rad+20;
ctx.fillStyle=isDark()?'#e0e0e0':'#333';ctx.font='11px Segoe UI';ctx.textAlign='center';
ctx.fillText(`φ(${n}) = ${cv.phi||0}`,cx,statsY);
ctx.fillStyle=colors[idx];ctx.font='bold 12px Segoe UI';
ctx.fillText(`CV = ${(cv.cv||0).toFixed(4)}`,cx,statsY+16);
ctx.fillStyle=isDark()?'#aaa':'#666';ctx.font='10px Segoe UI';
ctx.fillText(`Gap: ${(cv.gapRatio||1).toFixed(2)}`,cx,statsY+30);
ctx.fillText(`Mean: ${(cv.mean||0).toFixed(3)}`,cx,statsY+43);
ctx.fillText(`σ: ${(cv.stdDev||0).toFixed(4)}`,cx,statsY+56);

// Verdict bar
const barY=statsY+68;
ctx.fillStyle=(cv.cv||0)<0.22?'rgba(0,255,136,0.3)':'rgba(255,64,64,0.3)';
ctx.fillRect(cx-cw/2+10,barY,cw-20,20);
ctx.fillStyle=(cv.cv||0)<0.22?'#00ff88':'#ff4040';ctx.font='bold 10px Segoe UI';
ctx.fillText((cv.cv||0)<0.22?'LIKELY PRIME':'LIKELY COMPOSITE',cx,barY+14);
});

// Comparison summary at bottom
const summaryY=pad+h-25;
ctx.fillStyle=isDark()?'#888':'#666';ctx.font='10px Segoe UI';ctx.textAlign='center';
const cvs=nums.map(n=>(chordCV(n).cv||0));
const minCV=Math.min(...cvs);
const winner=nums[cvs.indexOf(minCV)];
ctx.fillText(`Lowest CV: n=${winner} (${(minCV||0).toFixed(4)}) — Most uniform distribution`,c.width/2,summaryY);}

// Charts
const primeResults=results.filter(r=>r.prime);
const compResults=results.filter(r=>!r.prime);
Plotly.newPlot('pchordDist',[
{x:primeResults.map(r=>r.cv),type:'histogram',name:'Primes',marker:{color:'#00ff88'},opacity:0.7,nbinsx:20},
{x:compResults.map(r=>r.cv),type:'histogram',name:'Composites',marker:{color:'#ff4040'},opacity:0.7,nbinsx:20}
],{...plo(),barmode:'overlay',xaxis:{title:'CV'},yaxis:{title:'Count'}});

// Separation chart
const sepRanges=[50,100,150,200,300,400,500].filter(r=>r<=maxN);
const sepVals=sepRanges.map(rng=>{
let ps=0,pc=0,cs=0,cc=0;
for(const r of results){if(r.n>rng)continue;if(r.prime){ps+=r.cv;pc++;}else{cs+=r.cv;cc++;}}
const pa=pc>0?ps/pc:0,ca=cc>0?cs/cc:0;
return ca>0?(ca-pa)/ca*100:0;});
Plotly.newPlot('pchordSep',[{x:sepRanges.map(r=>'≤'+r),y:sepVals,type:'bar',marker:{color:'#00d9ff'}}],{...plo(),xaxis:{title:'Range'},yaxis:{title:'Separation %'}});

// Average CV
Plotly.newPlot('pchordAvg',[{x:['Primes','Composites'],y:[primeAvg,compAvg],type:'bar',marker:{color:['#00ff88','#ff4040']}}],{...plo(),yaxis:{title:'Average CV'}});

// Legend
const testR=chordCV(testN);
legend('alchord','Analysis',[['Prime Avg CV',(primeAvg||0).toFixed(4),'#00ff88'],['Comp Avg CV',(compAvg||0).toFixed(4),'#ff4040'],['Separation',(separation||0).toFixed(1)+'%','#00d9ff']]);

// Live stats
document.getElementById('chordLiveStats').innerHTML=`
<div style="display:grid;grid-template-columns:repeat(3,1fr);gap:8px;margin-bottom:12px">
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center"><div style="font-size:1.2rem;font-weight:bold;color:#00d9ff">${maxN}</div><div style="font-size:.65rem;color:var(--txt2)">MAX N</div></div>
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center"><div style="font-size:1.2rem;font-weight:bold;color:#00ff88">${primeCount}</div><div style="font-size:.65rem;color:var(--txt2)">PRIMES</div></div>
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center"><div style="font-size:1.2rem;font-weight:bold;color:#ff4040">${compCount}</div><div style="font-size:.65rem;color:var(--txt2)">COMPOSITES</div></div>
</div>
<div style="margin-bottom:10px;padding-bottom:8px;border-bottom:1px solid var(--bord)">
<strong style="color:var(--acc)">CV Statistics</strong>
<div style="display:grid;grid-template-columns:1fr 1fr;gap:3px;margin-top:5px;font-size:.75rem">
<span>Prime Avg CV:</span><span style="color:#00ff88">${(primeAvg||0).toFixed(4)}</span>
<span>Composite Avg CV:</span><span style="color:#ff4040">${(compAvg||0).toFixed(4)}</span>
<span>Separation:</span><span style="color:#00d9ff;font-weight:bold">${(separation||0).toFixed(1)}%</span>
<span>Threshold:</span><span style="color:#ffd700">CV < ${baseThreshold}${adaptiveThresh && threshExp > 0 ? '×n^(-'+threshExp+')' : ''}</span>
</div>
</div>
<div style="margin-bottom:10px;padding-bottom:8px;border-bottom:1px solid var(--bord)">
<strong style="color:var(--acc)">Classification Accuracy</strong>
<div style="display:grid;grid-template-columns:1fr 1fr;gap:3px;margin-top:5px;font-size:.75rem">
<span>Base (${baseThreshold}):</span><span style="color:${(chordData.accuracyBase||0)>90?'#00ff88':(chordData.accuracyBase||0)>80?'#ffd700':'#ff6496'};font-weight:bold">${(chordData.accuracyBase||0).toFixed(1)}%</span>
${adaptiveThresh && threshExp > 0 ? `<span>Adaptive:</span><span style="color:${(chordData.accuracyAdaptive||0)>90?'#00ff88':(chordData.accuracyAdaptive||0)>80?'#ffd700':'#ff6496'};font-weight:bold">${(chordData.accuracyAdaptive||0).toFixed(1)}%</span>` : ''}
<span>True Positive:</span><span style="color:#00ff88">${results.filter(r=>r.prime&&(r.cv||0)<getThreshold(r.n)).length}</span>
<span>True Negative:</span><span style="color:#00ff88">${results.filter(r=>!r.prime&&(r.cv||0)>=getThreshold(r.n)).length}</span>
<span>False Positive:</span><span style="color:#ff6496">${results.filter(r=>!r.prime&&(r.cv||0)<getThreshold(r.n)).length}</span>
<span>False Negative:</span><span style="color:#ff6496">${results.filter(r=>r.prime&&(r.cv||0)>=getThreshold(r.n)).length}</span>
</div>
</div>
${colorBy === 'lpf' ? `<div style="margin-bottom:10px;padding-bottom:8px;border-bottom:1px solid var(--bord)">
<strong style="color:var(--acc)">Color Legend (Lowest Prime Factor)</strong>
<div style="display:flex;flex-wrap:wrap;gap:4px;margin-top:5px;font-size:.7rem">
<span style="background:#00ff88;color:#000;padding:2px 6px;border-radius:3px">Prime</span>
<span style="background:#ff4040;color:#fff;padding:2px 6px;border-radius:3px">÷2</span>
<span style="background:#ffd700;color:#000;padding:2px 6px;border-radius:3px">÷3</span>
<span style="background:#00d9ff;color:#000;padding:2px 6px;border-radius:3px">÷5</span>
<span style="background:#9664ff;color:#fff;padding:2px 6px;border-radius:3px">÷7</span>
<span style="background:#ff8c00;color:#000;padding:2px 6px;border-radius:3px">÷11</span>
<span style="background:#ff00ff;color:#fff;padding:2px 6px;border-radius:3px">÷13</span>
</div>
</div>` : ''}
<div style="margin-bottom:10px;padding-bottom:8px;border-bottom:1px solid var(--bord)">
<strong style="color:var(--acc)">Test n = ${testN}</strong>
<div style="display:grid;grid-template-columns:1fr 1fr;gap:3px;margin-top:5px;font-size:.75rem">
<span>Type:</span><span style="color:${isPrime(testN)?'#00ff88':'#ff4040'}">${isPrime(testN)?'Prime':'Composite'}</span>
<span>φ(n):</span><span style="color:#ffd700">${testR.phi||0}</span>
<span>CV:</span><span style="color:#00d9ff">${(testR.cv||0).toFixed(4)}</span>
<span>Gap Ratio:</span><span style="color:#9664ff">${(testR.gapRatio||1).toFixed(3)}</span>
${!isPrime(testN) ? `<span>Lowest PF:</span><span style="color:#ff8c00">${lowestPrimeFactor(testN)}</span>` : ''}
</div>
</div>
<div style="background:${(testR.cv||0)<getThreshold(testN)?'rgba(0,255,136,.15)':'rgba(255,64,64,.15)'};padding:8px;border-radius:6px;font-size:.8rem">
<strong style="color:${(testR.cv||0)<getThreshold(testN)?'#00ff88':'#ff4040'}">Verdict: ${(testR.cv||0)<getThreshold(testN)?'Likely Prime':'Likely Composite'}</strong>
<div style="font-size:.65rem;color:var(--txt2);margin-top:4px">Threshold for n=${testN}: ${getThreshold(testN).toFixed(4)}</div>
</div>
${singularSeriesHTML(testN, 2, 'Modular Sieve (n as M)')}`;

// Table
const tableData=results.slice(0,60).map(r=>({...r,verdict:(r.cv||0)<getThreshold(r.n)?'Prime?':'Comp?'}));
document.getElementById('tchordT').innerHTML='<tr><th>n</th><th>Type</th><th>φ(n)</th><th>CV</th><th>Gap Ratio</th><th>Verdict</th></tr>'+
tableData.map(r=>`<tr onclick="document.getElementById('chordTest').value=${r.n};drawChord()" style="cursor:pointer;color:${r.prime?'#00ff88':'#ff4040'}"><td>${r.n}</td><td>${r.prime?'Prime':'Comp'}</td><td>${r.phi}</td><td>${(r.cv||0).toFixed(4)}</td><td>${(r.gapRatio||1).toFixed(2)}</td><td>${r.verdict}</td></tr>`).join('');

// Update CV Length Classification stats
updateCVLengthStats();

// Click handler for scatter plot
c.onclick=e=>{
const rect=c.getBoundingClientRect();
const mx=(e.clientX-rect.left)*(c.width/rect.width);
const my=(e.clientY-rect.top)*(c.height/rect.height);

if(viz==='scatter'){
const maxCV=Math.max(...results.map(r=>r.cv),0.5);
for(const r of results){
const x=pad+w*(r.n-3)/(maxN-3);
const y=pad+h*(1-(r.cv||0)/maxCV);
if(Math.hypot(mx-x,my-y)<8){
const cv=chordCV(r.n);
modal('Chord Analysis n='+r.n,[
['n',r.n],
['Type',r.prime?'Prime':'Composite'],
['φ(n)',cv.phi||0],
['CV (σ/μ)',(cv.cv||0).toFixed(6)],
['Mean Chord',(cv.mean||0).toFixed(6)],
['Std Dev',(cv.stdDev||0).toFixed(6)],
['Gap Ratio',(cv.gapRatio||1).toFixed(4)],
['Chord Count',cv.chords?.length||0],
['Min Chord',cv.chords?.length?Math.min(...cv.chords).toFixed(4):'0'],
['Max Chord',cv.chords?.length?Math.max(...cv.chords).toFixed(4):'0'],
['CV Threshold','< 0.22 = Prime'],
['Verdict',(cv.cv||0)<0.22?'Likely Prime':'Likely Composite']
]);
document.getElementById('chordTest').value=r.n;
break;}}}

else if(viz==='single'){
// Click on single circle shows coprime details
const cx=c.width/2,cy=c.height/2+20,rad=Math.min(w,h)/2-30;
const coprimes=[];
for(let i=1;i<testN;i++)if(gcd(i,testN)===1)coprimes.push(i);
for(let i=0;i<coprimes.length;i++){
const angle=2*Math.PI*coprimes[i]/testN-Math.PI/2;
const px=cx+rad*Math.cos(angle);
const py=cy+rad*Math.sin(angle);
if(Math.hypot(mx-px,my-py)<10){
const r=coprimes[i];
const nextR=coprimes[(i+1)%coprimes.length];
const gap=(nextR>r)?(nextR-r):(nextR+testN-r);
const chordLen=2*Math.sin(Math.PI*gap/testN);
modal(`Coprime r=${r} mod ${testN}`,[
['Residue r',r],
['Next coprime',nextR],
['Gap to next',gap],
['Chord length',chordLen.toFixed(6)],
['Angle θ',(coprimes[i]/testN*360).toFixed(2)+'°'],
['r/n',fmt(r/testN)],
['gcd(r,n)',gcd(r,testN)]
]);
break;}}}

else if(viz==='compare'){
// Click on compare circles
const n1=testN;
const n2=+document.getElementById('chordTest2').value||100;
const n3=+document.getElementById('chordTest3').value||0;
const nums=n3>2?[n1,n2,n3]:[n1,n2];
const cols=nums.length;
const cw=(c.width-pad*2)/cols-10;
const rad=Math.min(cw/2-20,(h-80)/2-20);

for(let idx=0;idx<nums.length;idx++){
const n=nums[idx];
const cx=pad+cw/2+idx*(cw+10)+5;
const cy=pad+rad+50;
if(Math.hypot(mx-cx,my-cy)<rad+20){
const cv=chordCV(n);
modal(`Chord Analysis n=${n}`,[
['n',n],
['Type',isPrime(n)?'Prime':'Composite'],
['φ(n)',cv.phi],
['CV (σ/μ)',cv.cv.toFixed(6)],
['Mean Chord',cv.mean.toFixed(6)],
['Std Dev',cv.stdDev.toFixed(6)],
['Gap Ratio',cv.gapRatio.toFixed(4)],
['Chord Count',cv.chords.length],
['Verdict',cv.cv<0.22?'Likely Prime':'Likely Composite']
]);
break;}}}};}

function csvChord(){
let csv='n,type,phi,cv,gap_ratio,verdict\n';
for(const r of chordData.results){
csv+=`${r.n},${r.prime?'prime':'composite'},${r.phi||0},${(r.cv||0).toFixed(6)},${(r.gapRatio||1).toFixed(4)},${(r.cv||0)<0.22?'likely_prime':'likely_composite'}\n`;}
dl(csv,'chord_uniformity.csv');}

function toggleChordSSOptions(){
const opts=document.getElementById('ssChordOpts');
if(opts)opts.style.display=opts.style.display==='none'?'block':'none';
}

async function screenshotChord(){
const maxN=document.getElementById('chordNv').value;
const scale=+(document.getElementById('ssChordRes')?.value||2);
const legendFontSize=+(document.getElementById('ssChordFont')?.value||12);
await screenshotUnified('cchord','chordLiveStats',`Chord Uniformity — n ≤ ${maxN}`,'chord_uniformity.png',{scale:scale,dashH:350,legendFontSize:legendFontSize});
}

// CV Length Classification System
function getCVLength(cv){
const l1=+document.getElementById('chordL1')?.value||0.15;
const l2=+document.getElementById('chordL2')?.value||0.22;
const l3=+document.getElementById('chordL3')?.value||0.28;
const l4=+document.getElementById('chordL4')?.value||0.35;
if(cv<l1)return 1;
if(cv<l2)return 2;
if(cv<l3)return 3;
if(cv<l4)return 4;
return 5;
}

function getCVLengthColor(len){
const colors=['#00ff88','#ffd700','#ff8c00','#ff4040','#9664ff'];
return colors[Math.min(len-1,4)];
}

function updateCVLengthStats(){
const enabled=document.getElementById('chordLengthEnable')?.checked;
const statsDiv=document.getElementById('chordLengthStats');
if(!statsDiv)return;
if(!enabled||!chordData.results||chordData.results.length===0){
  statsDiv.style.display='none';return;
}
statsDiv.style.display='block';

const l1=+document.getElementById('chordL1')?.value||0.15;
const l2=+document.getElementById('chordL2')?.value||0.22;
const l3=+document.getElementById('chordL3')?.value||0.28;
const l4=+document.getElementById('chordL4')?.value||0.35;

// Classify all results
const lengths={1:[],2:[],3:[],4:[],5:[]};
const primesInLength={1:0,2:0,3:0,4:0,5:0};
const compsInLength={1:0,2:0,3:0,4:0,5:0};

for(const r of chordData.results){
  const len=getCVLength(r.cv||0);
  lengths[len].push(r);
  if(r.prime)primesInLength[len]++;
  else compsInLength[len]++;
}

// Calculate accuracy if we say Length 1 = Prime
const truePos=primesInLength[1];
const falsePos=compsInLength[1];
const falseNeg=primesInLength[2]+primesInLength[3]+primesInLength[4]+primesInLength[5];
const trueNeg=compsInLength[2]+compsInLength[3]+compsInLength[4]+compsInLength[5];
const accuracy=chordData.results.length>0?100*(truePos+trueNeg)/chordData.results.length:0;
const precision=truePos+falsePos>0?100*truePos/(truePos+falsePos):0;
const recall=truePos+falseNeg>0?100*truePos/(truePos+falseNeg):0;

let html=`<div style="display:grid;grid-template-columns:repeat(5,1fr);gap:4px;margin-bottom:8px">`;
for(let i=1;i<=5;i++){
  const total=lengths[i].length;
  const primes=primesInLength[i];
  const comps=compsInLength[i];
  const purity=total>0?Math.max(primes,comps)/total*100:0;
  html+=`<div style="text-align:center;padding:4px;background:${getCVLengthColor(i)};color:#000;border-radius:4px;font-size:.7rem">
    <div style="font-weight:bold">L${i}</div>
    <div>${total} total</div>
    <div style="font-size:.6rem">${primes}P / ${comps}C</div>
  </div>`;
}
html+=`</div>`;
html+=`<div style="display:grid;grid-template-columns:repeat(4,1fr);gap:4px;font-size:.7rem">
  <div><span style="color:#00ff88">Accuracy:</span> ${accuracy.toFixed(1)}%</div>
  <div><span style="color:#ffd700">Precision:</span> ${precision.toFixed(1)}%</div>
  <div><span style="color:#00d9ff">Recall:</span> ${recall.toFixed(1)}%</div>
  <div><span style="color:#ff4040">Error:</span> ${(100-accuracy).toFixed(1)}%</div>
</div>`;
html+=`<div style="margin-top:4px;font-size:.65rem;color:var(--txt2)">L1 → Prime prediction | Thresholds: ${l1}/${l2}/${l3}/${l4}</div>`;
statsDiv.innerHTML=html;
}

function autoTuneCVLengths(){
if(!chordData.results||chordData.results.length===0){alert('Run analysis first');return;}

// Find optimal L1 threshold to maximize accuracy
let bestL1=0.15,bestAcc=0;
for(let t=0.10;t<=0.30;t+=0.01){
  let tp=0,tn=0;
  for(const r of chordData.results){
    const cv=r.cv||0;
    if(r.prime&&cv<t)tp++;
    if(!r.prime&&cv>=t)tn++;
  }
  const acc=(tp+tn)/chordData.results.length*100;
  if(acc>bestAcc){bestAcc=acc;bestL1=t;}
}
document.getElementById('chordL1').value=bestL1.toFixed(2);

// Set other thresholds proportionally
document.getElementById('chordL2').value=(bestL1+0.07).toFixed(2);
document.getElementById('chordL3').value=(bestL1+0.13).toFixed(2);
document.getElementById('chordL4').value=(bestL1+0.20).toFixed(2);

drawChord();
alert(`Optimized! L1=${bestL1.toFixed(2)} gives ${bestAcc.toFixed(1)}% accuracy`);
}

// ==================== GOLDBACH CONJECTURE ====================
let goldbachData={partitions:[],maxN:0};

function goldbachPartitions(n){
if(n<4||n%2!==0)return[];
const primes=sievePrimes(n);
const primeSet=new Set(primes);
const parts=[];
for(let i=0;i<primes.length&&primes[i]<=n/2;i++){
const p=primes[i],q=n-p;
if(primeSet.has(q))parts.push({p,q,diff:q-p});}
return parts;}

function drawGoldbach(){
if(!document.getElementById("cGold")) return;

const c=document.getElementById('cgold'),ctx=c.getContext('2d');
const maxN=+document.getElementById('goldNv').value||+document.getElementById('goldN').value;
const testN=+document.getElementById('goldTest').value;
const viz=document.getElementById('goldViz').value;
const col=document.getElementById('goldCol').value;
const ptSz=+document.getElementById('goldPtSz').value;
const showGrid=document.getElementById('goldGrid').checked;
const showTrend=document.getElementById('goldTrend').checked;

ctx.fillStyle=canvBg();ctx.fillRect(0,0,c.width,c.height);

const results=[];
let maxCount=0,totalParts=0;
for(let n=4;n<=maxN;n+=2){
const parts=goldbachPartitions(n);
const count=parts.length;
const minP=parts.length>0?Math.min(...parts.map(p=>p.p)):0;
const maxGap=parts.length>0?Math.max(...parts.map(p=>p.diff)):0;
results.push({n,count,parts,minP,maxGap});
maxCount=Math.max(maxCount,count);
totalParts+=count;}
goldbachData={partitions:results,maxN};

const pad=60,w=c.width-2*pad,h=c.height-2*pad;

if(viz==='comet'||viz==='partitions'){
ctx.fillStyle=isDark()?'#ffd700':'#cc8800';ctx.font='bold 14px Segoe UI';ctx.textAlign='center';
ctx.fillText('Goldbach Comet — Partition Count G(n)',c.width/2,30);

if(showGrid){ctx.strokeStyle=gridC();ctx.lineWidth=0.5;
for(let i=0;i<=5;i++){const y=pad+h-i*h/5;ctx.beginPath();ctx.moveTo(pad,y);ctx.lineTo(pad+w,y);ctx.stroke();
ctx.fillStyle=isDark()?'#666':'#999';ctx.font='10px Arial';ctx.textAlign='right';ctx.fillText(Math.round(maxCount*i/5),pad-5,y+3);}
for(let i=0;i<=5;i++){const x=pad+i*w/5;ctx.beginPath();ctx.moveTo(x,pad);ctx.lineTo(x,pad+h);ctx.stroke();
ctx.fillStyle=isDark()?'#666':'#999';ctx.font='10px Arial';ctx.textAlign='center';ctx.fillText(Math.round(4+i*(maxN-4)/5),x,pad+h+15);}}

for(const r of results){
const x=pad+w*(r.n-4)/(maxN-4);
const y=pad+h-h*r.count/maxCount;
let clr;
if(col==='count')clr=`hsl(${120-r.count/maxCount*120},80%,50%)`;
else if(col==='minPrime')clr=`hsl(${r.minP/r.n*240},80%,50%)`;
else if(col==='maxGap')clr=`hsl(${r.maxGap/(r.n/2)*120},80%,50%)`;
else clr='#00d9ff';
ctx.fillStyle=clr;ctx.beginPath();ctx.arc(x,y,ptSz,0,2*Math.PI);ctx.fill();}

if(showTrend){
ctx.strokeStyle='rgba(255,136,0,0.6)';ctx.lineWidth=2;ctx.beginPath();
for(let i=0;i<results.length;i++){
const r=results[i];
const expectedG=r.n>10?2*0.6601*r.n/Math.pow(Math.log(r.n),2):r.count;
const x=pad+w*(r.n-4)/(maxN-4);
const y=pad+h-h*Math.min(expectedG,maxCount)/maxCount;
if(i===0)ctx.moveTo(x,y);else ctx.lineTo(x,y);}
ctx.stroke();}}

else if(viz==='single'){
const tn=testN%2===0?testN:testN+1;
const parts=goldbachPartitions(tn);
ctx.fillStyle=isDark()?'#ffd700':'#cc8800';ctx.font='bold 14px Segoe UI';ctx.textAlign='center';
ctx.fillText(`Goldbach Partitions of ${tn} — ${parts.length} ways`,c.width/2,30);
const cx=c.width/2,cy=c.height/2,rad=Math.min(w,h)/2-20;
ctx.strokeStyle=bordC();ctx.lineWidth=2;ctx.beginPath();ctx.arc(cx,cy,rad,0,2*Math.PI);ctx.stroke();
for(let i=0;i<parts.length;i++){
const {p,q}=parts[i];
const angP=2*Math.PI*p/tn-Math.PI/2,angQ=2*Math.PI*q/tn-Math.PI/2;
const px=cx+rad*Math.cos(angP),py=cy+rad*Math.sin(angP);
const qx=cx+rad*Math.cos(angQ),qy=cy+rad*Math.sin(angQ);
ctx.strokeStyle=`hsl(${i*360/parts.length},80%,50%)`;ctx.lineWidth=2;
ctx.beginPath();ctx.moveTo(px,py);ctx.lineTo(qx,qy);ctx.stroke();
ctx.fillStyle=`hsl(${i*360/parts.length},80%,50%)`;
ctx.beginPath();ctx.arc(px,py,5,0,2*Math.PI);ctx.fill();
ctx.beginPath();ctx.arc(qx,qy,5,0,2*Math.PI);ctx.fill();
ctx.fillStyle=isDark()?'#fff':'#000';ctx.font='10px Arial';ctx.textAlign='center';
ctx.fillText(p,px,py-10);ctx.fillText(q,qx,qy-10);}}

else if(viz==='heatmap'){
ctx.fillStyle=isDark()?'#ffd700':'#cc8800';ctx.font='bold 14px Segoe UI';ctx.textAlign='center';
ctx.fillText('Goldbach Heatmap — p + q = n',c.width/2,30);
const primes=sievePrimes(maxN);
const cellW=w/primes.length,cellH=h/primes.length;
for(let i=0;i<primes.length&&i<100;i++){
for(let j=i;j<primes.length&&j<100;j++){
const n=primes[i]+primes[j];
if(n<=maxN&&n%2===0){
const intensity=n/maxN;
ctx.fillStyle=`hsl(${240-intensity*240},70%,${30+intensity*40}%)`;
ctx.fillRect(pad+i*cellW,pad+j*cellH,cellW,cellH);}}}}

else if(viz==='weak'){
// Weak Goldbach: every odd n ≥ 7 = p + q + r (three primes)
ctx.fillStyle=isDark()?'#9664ff':'#6644cc';ctx.font='bold 14px Segoe UI';ctx.textAlign='center';
ctx.fillText('Weak Goldbach — Odd n = p + q + r (3 primes) [PROVED by Helfgott 2013]',c.width/2,25);
const primes=sievePrimes(maxN);
const primeSet=new Set(primes);
const weakResults=[];
let maxWeakCount=0;
for(let n=7;n<=maxN;n+=2){
let count=0;
const reps=[];
for(let i=0;i<primes.length&&primes[i]<=n-4;i++){
for(let j=i;j<primes.length&&primes[i]+primes[j]<=n-2;j++){
const rem=n-primes[i]-primes[j];
if(rem>=2&&primeSet.has(rem)){
count++;
if(reps.length<3)reps.push([primes[i],primes[j],rem]);}}}
weakResults.push({n,count,reps});
maxWeakCount=Math.max(maxWeakCount,count);}
// Plot
if(showGrid){ctx.strokeStyle=gridC();ctx.lineWidth=0.5;
for(let i=0;i<=5;i++){const y=pad+h-i*h/5;ctx.beginPath();ctx.moveTo(pad,y);ctx.lineTo(pad+w,y);ctx.stroke();}}
for(const r of weakResults){
const x=pad+w*(r.n-7)/(maxN-7);
const y=pad+h-h*r.count/maxWeakCount;
const clr=`hsl(${270-r.count/maxWeakCount*90},80%,55%)`;
ctx.fillStyle=clr;ctx.beginPath();ctx.arc(x,y,ptSz,0,2*Math.PI);ctx.fill();}
// Show first few representations
ctx.fillStyle=isDark()?'#aaa':'#666';ctx.font='10px Segoe UI';ctx.textAlign='left';
const testOdd=testN%2===1?testN:testN+1;
const testReps=weakResults.find(r=>r.n===testOdd);
if(testReps&&testReps.reps.length>0){
ctx.fillText(`${testOdd} = ${testReps.reps.slice(0,3).map(r=>r.join('+')).join(' = ')}`,pad+10,c.height-15);}}

const testParts=goldbachPartitions(testN%2===0?testN:testN+1);
const avgCount=results.length>0?totalParts/results.length:0;
const maxCountN=results.reduce((a,r)=>r.count>a.count?r:a,{count:0,n:0});
const minCountN=results.filter(r=>r.count>0).reduce((a,r)=>r.count<a.count?r:a,{count:Infinity,n:0});
const zeros=results.filter(r=>r.count===0).length;

legend('algold1','Goldbach Analysis',[['Max G(n)',maxCount+' at n='+maxCountN.n,'#00ff88'],['Avg G(n)',fmt(avgCount),'#ffd700']]);
legend('algold2','Test n='+(testN%2===0?testN:testN+1),[['Partitions',testParts.length,'#00d9ff'],['Min Prime',testParts[0]?.p||0,'#9664ff']]);

Plotly.newPlot('pgold',[{x:results.map(r=>r.n),y:results.map(r=>r.count),type:'scatter',mode:'markers',marker:{size:3,color:results.map(r=>`hsl(${120-r.count/maxCount*120},80%,50%)`)}}],{...plo(),xaxis:{title:'n'},yaxis:{title:'G(n)'}});

document.getElementById('goldLiveStats').innerHTML=`
<div style="background:linear-gradient(135deg,rgba(0,217,255,.15),rgba(255,215,0,.1));padding:10px;border-radius:8px;margin-bottom:12px;border:1px solid var(--acc)">
<div style="font-size:.7rem;color:var(--txt2);margin-bottom:4px">TAB: Goldbach Conjecture | FIELD: ℤ (Even) | TYPE: Prime Sum Partitions</div>
<div style="display:grid;grid-template-columns:repeat(3,1fr);gap:6px;font-size:.75rem">
<span>Max N: <strong style="color:#00d9ff">${maxN}</strong></span>
<span>Test n: <strong style="color:#ffd700">${testN}</strong></span>
<span>Mode: <strong style="color:#00ff88">${viz}</strong></span>
</div>
</div>
<div style="display:grid;grid-template-columns:repeat(3,1fr);gap:8px;margin-bottom:12px">
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center"><div style="font-size:1.3rem;font-weight:bold;color:#00d9ff">${results.length}</div><div style="font-size:.7rem;color:var(--txt2)">EVEN NUMBERS</div></div>
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center"><div style="font-size:1.3rem;font-weight:bold;color:#ffd700">${totalParts}</div><div style="font-size:.7rem;color:var(--txt2)">TOTAL PARTITIONS</div></div>
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center"><div style="font-size:1.3rem;font-weight:bold;color:#00ff88">${zeros}</div><div style="font-size:.7rem;color:var(--txt2)">COUNTEREXAMPLES</div></div>
</div>
<div style="display:grid;grid-template-columns:repeat(2,1fr);gap:8px;margin-bottom:12px">
<div style="background:var(--bg1);padding:8px;border-radius:6px;text-align:center"><div style="font-size:1rem;font-weight:bold;color:#9664ff">${maxCount}</div><div style="font-size:.6rem;color:var(--txt2)">MAX G(n) at ${maxCountN.n}</div></div>
<div style="background:var(--bg1);padding:8px;border-radius:6px;text-align:center"><div style="font-size:1rem;font-weight:bold;color:#ff8c00">${fmt(avgCount)}</div><div style="font-size:.6rem;color:var(--txt2)">AVG PARTITIONS</div></div>
</div>
<div style="margin-bottom:10px;padding-bottom:8px;border-bottom:1px solid var(--bord)">
<strong style="color:var(--acc)">Partition Statistics</strong>
<div style="display:grid;grid-template-columns:1fr 1fr;gap:3px;margin-top:5px;font-size:.8rem">
<span>Max G(n):</span><span style="color:#00ff88">${maxCount} at n=${maxCountN.n}</span>
<span>Min G(n):</span><span style="color:#ff6496">${minCountN.count} at n=${minCountN.n}</span>
<span>Average G(n):</span><span style="color:#ffd700">${fmt(avgCount)}</span>
<span>Total pairs:</span><span style="color:#00d9ff">${totalParts}</span>
</div>
</div>
<div style="margin-bottom:10px;padding-bottom:8px;border-bottom:1px solid var(--bord)">
<strong style="color:var(--acc)">Hardy-Littlewood Prediction</strong>
<div style="display:grid;grid-template-columns:1fr 1fr;gap:3px;margin-top:5px;font-size:.8rem">
<span>Twin Prime Constant C₂:</span><span style="color:#9664ff">0.6601618...</span>
<span>G(n) ~ 2C₂·n/(ln n)²:</span><span style="color:#ff8c00">${fmt(2*0.6601*maxN/Math.pow(Math.log(maxN),2))}</span>
<span>Actual at n=${maxN}:</span><span style="color:#00ff88">${results[results.length-1]?.count||0}</span>
</div>
</div>
<div style="background:${zeros===0?'rgba(0,255,136,.15)':'rgba(255,64,64,.15)'};padding:8px;border-radius:6px;font-size:.8rem">
<strong style="color:${zeros===0?'#00ff88':'#ff4040'}">${zeros===0?'OK Goldbach verified for all n ≤ '+maxN:'X Found '+zeros+' counterexamples!'}</strong>
</div>`;

document.getElementById('tgoldT').innerHTML='<tr><th>n</th><th>G(n)</th><th>Min p</th><th>Max Gap</th><th>First Partition</th></tr>'+
results.slice(0,100).map(r=>`<tr onclick="document.getElementById('goldTest').value=${r.n};document.getElementById('goldViz').value='single';drawGoldbach()" style="cursor:pointer;color:${r.count===0?'#ff4040':r.count>10?'#00ff88':'inherit'}"><td>${r.n}</td><td>${r.count}</td><td>${r.minP}</td><td>${r.maxGap}</td><td>${r.parts[0]?r.parts[0].p+'+'+r.parts[0].q:'—'}</td></tr>`).join('');}

function csvGoldbach(){let s='n,partition_count,min_prime,max_gap,partitions\n';for(const r of goldbachData.partitions)s+=`${r.n},${r.count},${r.minP},${r.maxGap},"${r.parts.map(p=>p.p+'+'+p.q).join('; ')}"\n`;dl(s,'goldbach.csv');}
function expGoldbach(){const c=document.getElementById('cgold');c.toBlob(b=>{const a=document.createElement('a');a.href=URL.createObjectURL(b);a.download='goldbach.png';a.click();});}

async function screenshotGoldbach(){
const c=document.getElementById('cgold'),dashData=extractDashboardData('goldLiveStats');
const maxN=document.getElementById('goldNv').value;
const scale=2,pad=30,dashH=380;
const out=document.createElement('canvas');
out.width=(c.width+pad*2)*scale;out.height=(c.height+dashH+pad*3)*scale;
const ctx=out.getContext('2d');ctx.scale(scale,scale);
const isDk=isDark();
ctx.fillStyle=isDk?'#0d1321':'#ffffff';ctx.fillRect(0,0,out.width/scale,out.height/scale);
ctx.fillStyle=isDk?'#00d9ff':'#0066cc';ctx.font='bold 18px Segoe UI';ctx.textAlign='center';
ctx.fillText(`Goldbach Conjecture — n ≤ ${maxN}`,out.width/scale/2,pad);
ctx.drawImage(c,pad,pad+25,c.width,c.height);
const dashY=c.height+pad+45;
ctx.fillStyle=isDk?'#151b2d':'#f5f5f5';ctx.fillRect(pad,dashY-10,c.width,dashH);
ctx.textAlign='left';
renderDashboard(ctx,dashData,pad+10,dashY,c.width-20,isDk,dashH-30);
ctx.fillStyle=isDk?'#506080':'#888';ctx.font='10px Segoe UI';ctx.textAlign='center';
ctx.fillText('Möbius Shell Sieve — wessengetachew.github.io',out.width/scale/2,out.height/scale-10);
out.toBlob(b=>{const a=document.createElement('a');a.href=URL.createObjectURL(b);a.download='goldbach_complete.png';a.click();},'image/png',1.0);}

// ==================== PRIME GAPS ====================
let gapData={gaps:[],records:[]};

function drawGap(){
const c=document.getElementById('cgap'),ctx=c.getContext('2d');
const maxN=+document.getElementById('gapNv').value||+document.getElementById('gapN').value;
const viz=document.getElementById('gapViz').value;
const col=document.getElementById('gapCol').value;
const ptSz=+document.getElementById('gapPtSz').value;
const showGrid=document.getElementById('gapGrid').checked;
const showCramér=document.getElementById('gapCramér').checked;

ctx.fillStyle=canvBg();ctx.fillRect(0,0,c.width,c.height);

const primes=sievePrimes(maxN);
const gaps=[],records=[];
let maxGap=0,sumGap=0,recordGap=0;
const gapFreq={};
for(let i=1;i<primes.length;i++){
const g=primes[i]-primes[i-1];
const cramér=Math.pow(Math.log(primes[i]),2);
const ratio=g/Math.log(primes[i]);
gaps.push({p:primes[i-1],pNext:primes[i],gap:g,cramér,ratio,isRecord:g>recordGap});
if(g>recordGap){recordGap=g;records.push({p:primes[i-1],gap:g,ratio});}
maxGap=Math.max(maxGap,g);
sumGap+=g;
gapFreq[g]=(gapFreq[g]||0)+1;}
gapData={gaps,records,primes};

const pad=60,w=c.width-2*pad,h=c.height-2*pad;

if(viz==='scatter'||viz==='ratio'){
const isRatio=viz==='ratio';
const maxY=isRatio?Math.max(...gaps.map(g=>g.ratio)):maxGap;
ctx.fillStyle=isDark()?'#ffd700':'#cc8800';ctx.font='bold 14px Segoe UI';ctx.textAlign='center';
ctx.fillText(isRatio?'Prime Gap Ratio g/ln(p)':'Prime Gaps g = p_{n+1} - p_n',c.width/2,30);

if(showGrid){ctx.strokeStyle=gridC();ctx.lineWidth=0.5;
for(let i=0;i<=5;i++){const y=pad+h-i*h/5;ctx.beginPath();ctx.moveTo(pad,y);ctx.lineTo(pad+w,y);ctx.stroke();
ctx.fillStyle=isDark()?'#666':'#999';ctx.font='10px Arial';ctx.textAlign='right';ctx.fillText(fmt(maxY*i/5),pad-5,y+3);}}

if(showCramér&&!isRatio){
ctx.strokeStyle='rgba(255,136,0,0.5)';ctx.lineWidth=2;ctx.beginPath();
for(let i=0;i<gaps.length;i+=Math.max(1,Math.floor(gaps.length/500))){
const x=pad+w*i/gaps.length;
const cramér=Math.pow(Math.log(gaps[i].p),2);
const y=pad+h-h*Math.min(cramér,maxY)/maxY;
if(i===0)ctx.moveTo(x,y);else ctx.lineTo(x,y);}
ctx.stroke();}

for(let i=0;i<gaps.length;i++){
const g=gaps[i];
const x=pad+w*i/gaps.length;
const yVal=isRatio?g.ratio:g.gap;
const y=pad+h-h*yVal/maxY;
let clr;
if(col==='gap')clr=`hsl(${240-g.gap/maxGap*240},80%,50%)`;
else if(col==='record')clr=g.isRecord?'#ff006e':'#00d9ff';
else if(col==='cramér')clr=g.gap>g.cramér?'#ff4040':'#00ff88';
else clr='#00d9ff';
ctx.fillStyle=clr;ctx.beginPath();ctx.arc(x,y,g.isRecord?ptSz+2:ptSz,0,2*Math.PI);ctx.fill();}}

else if(viz==='histogram'){
ctx.fillStyle=isDark()?'#ffd700':'#cc8800';ctx.font='bold 14px Segoe UI';ctx.textAlign='center';
ctx.fillText('Prime Gap Distribution',c.width/2,30);
const gapKeys=Object.keys(gapFreq).map(Number).sort((a,b)=>a-b);
const maxFreq=Math.max(...Object.values(gapFreq));
const barW=w/gapKeys.length;
for(let i=0;i<gapKeys.length;i++){
const g=gapKeys[i],f=gapFreq[g];
const x=pad+i*barW,barH=h*f/maxFreq;
ctx.fillStyle=g===2?'#ffd700':`hsl(${g*10},70%,50%)`;
ctx.fillRect(x,pad+h-barH,barW-1,barH);}}

else if(viz==='records'){
ctx.fillStyle=isDark()?'#ffd700':'#cc8800';ctx.font='bold 14px Segoe UI';ctx.textAlign='center';
ctx.fillText('Record Prime Gaps',c.width/2,30);
const maxRecGap=records.length>0?Math.max(...records.map(r=>r.gap)):1;
if(showGrid){ctx.strokeStyle=gridC();ctx.lineWidth=0.5;
for(let i=0;i<=5;i++){const y=pad+h-i*h/5;ctx.beginPath();ctx.moveTo(pad,y);ctx.lineTo(pad+w,y);ctx.stroke();}}
for(let i=0;i<records.length;i++){
const r=records[i];
const x=pad+w*Math.log(r.p)/Math.log(primes[primes.length-1]);
const y=pad+h-h*r.gap/maxRecGap;
ctx.fillStyle='#ff006e';ctx.beginPath();ctx.arc(x,y,5,0,2*Math.PI);ctx.fill();
if(i<20){ctx.fillStyle=isDark()?'#fff':'#000';ctx.font='9px Arial';ctx.textAlign='center';ctx.fillText(r.gap,x,y-8);}}}

else if(viz==='adjacent'){
// Adjacent gap correlation: plot g_n versus g_{n+1}
ctx.fillStyle=isDark()?'#9664ff':'#6644cc';ctx.font='bold 14px Segoe UI';ctx.textAlign='center';
ctx.fillText('Adjacent Gap Correlation: g_n versus g_{n+1}',c.width/2,30);
const maxG=maxGap;
if(showGrid){ctx.strokeStyle=gridC();ctx.lineWidth=0.5;
for(let i=0;i<=5;i++){
const gx=pad+i*w/5,gy=pad+i*h/5;
ctx.beginPath();ctx.moveTo(gx,pad);ctx.lineTo(gx,pad+h);ctx.stroke();
ctx.beginPath();ctx.moveTo(pad,gy);ctx.lineTo(pad+w,gy);ctx.stroke();}}
// Diagonal line g_n = g_{n+1}
ctx.strokeStyle='rgba(255,215,0,0.5)';ctx.lineWidth=2;ctx.setLineDash([5,5]);
ctx.beginPath();ctx.moveTo(pad,pad+h);ctx.lineTo(pad+w,pad);ctx.stroke();ctx.setLineDash([]);
// Plot points
for(let i=0;i<gaps.length-1;i++){
const g1=gaps[i].gap,g2=gaps[i+1].gap;
const x=pad+w*g1/maxG;
const y=pad+h-h*g2/maxG;
const isTwinPair=g1===2&&g2===2;
ctx.fillStyle=isTwinPair?'#ffd700':g1===g2?'#00ff88':'#00d9ff';
ctx.globalAlpha=0.5;
ctx.beginPath();ctx.arc(x,y,ptSz,0,2*Math.PI);ctx.fill();
ctx.globalAlpha=1.0;}
// Labels
ctx.fillStyle=isDark()?'#aaa':'#666';ctx.font='11px Segoe UI';
ctx.textAlign='center';ctx.fillText('g_n',c.width/2,c.height-10);
ctx.save();ctx.translate(15,c.height/2);ctx.rotate(-Math.PI/2);ctx.fillText('g_{n+1}',0,0);ctx.restore();}

else if(viz==='merit'){
// Gap merit: g/ln(p) - larger values are more "surprising"
ctx.fillStyle=isDark()?'#00ff88':'#00aa55';ctx.font='bold 14px Segoe UI';ctx.textAlign='center';
ctx.fillText('Gap Merit M = g/ln(p) — Larger = More Surprising',c.width/2,30);
const merits=gaps.map(g=>({...g,merit:g.gap/Math.log(g.p)}));
const maxMerit=Math.max(...merits.map(m=>m.merit));
const topMerits=merits.filter(m=>m.merit>2).sort((a,b)=>b.merit-a.merit);
if(showGrid){ctx.strokeStyle=gridC();ctx.lineWidth=0.5;
for(let i=0;i<=5;i++){const y=pad+h-i*h/5;ctx.beginPath();ctx.moveTo(pad,y);ctx.lineTo(pad+w,y);ctx.stroke();
ctx.fillStyle=isDark()?'#666':'#999';ctx.font='10px Arial';ctx.textAlign='right';ctx.fillText(fmt(maxMerit*i/5),pad-5,y+3);}}
// Reference line at merit=1
ctx.strokeStyle='rgba(255,215,0,0.5)';ctx.lineWidth=2;ctx.setLineDash([5,5]);
const y1=pad+h-h*1/maxMerit;
ctx.beginPath();ctx.moveTo(pad,y1);ctx.lineTo(pad+w,y1);ctx.stroke();ctx.setLineDash([]);
ctx.fillStyle='#ffd700';ctx.font='10px Segoe UI';ctx.textAlign='left';ctx.fillText('Expected (M=1)',pad+5,y1-5);
// Plot
for(let i=0;i<merits.length;i++){
const m=merits[i];
const x=pad+w*i/merits.length;
const y=pad+h-h*m.merit/maxMerit;
const clr=m.merit>2?'#ff006e':m.merit>1.5?'#ff8c00':m.merit>1?'#ffd700':'#00d9ff';
ctx.fillStyle=clr;ctx.beginPath();ctx.arc(x,y,m.merit>2?4:ptSz,0,2*Math.PI);ctx.fill();}
// Highlight top merits
ctx.fillStyle=isDark()?'#fff':'#000';ctx.font='9px Arial';ctx.textAlign='left';
topMerits.slice(0,5).forEach((m,i)=>{
ctx.fillText(`p=${m.p}, g=${m.gap}, M=${m.merit.toFixed(2)}`,pad+w-150,pad+15+i*12);});}

const avgGap=gaps.length>0?sumGap/gaps.length:0;
const gap2Count=gapFreq[2]||0;
const mostCommon=Object.entries(gapFreq).sort((a,b)=>b[1]-a[1])[0];

legend('algap1','Gap Statistics',[['Max Gap',maxGap,'#ff006e'],['Avg Gap',fmt(avgGap),'#00d9ff']]);
legend('algap2','Distribution',[['Gap=2 (twins)',gap2Count,'#ffd700'],['Records',records.length,'#9664ff']]);

const gapKeys=Object.keys(gapFreq).map(Number).sort((a,b)=>a-b).slice(0,30);
Plotly.newPlot('pgap',[{x:gapKeys,y:gapKeys.map(g=>gapFreq[g]),type:'bar',marker:{color:gapKeys.map(g=>g===2?'#ffd700':`hsl(${g*10},70%,50%)`)}}],{...plo(),xaxis:{title:'Gap'},yaxis:{title:'Frequency'}});

document.getElementById('gapLiveStats').innerHTML=`
<div style="display:grid;grid-template-columns:repeat(3,1fr);gap:8px;margin-bottom:12px">
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center"><div style="font-size:1.3rem;font-weight:bold;color:#00d9ff">${primes.length}</div><div style="font-size:.7rem;color:var(--txt2)">PRIMES</div></div>
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center"><div style="font-size:1.3rem;font-weight:bold;color:#ff006e">${maxGap}</div><div style="font-size:.7rem;color:var(--txt2)">MAX GAP</div></div>
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center"><div style="font-size:1.3rem;font-weight:bold;color:#ffd700">${records.length}</div><div style="font-size:.7rem;color:var(--txt2)">RECORDS</div></div>
</div>
<div style="margin-bottom:10px;padding-bottom:8px;border-bottom:1px solid var(--bord)">
<strong style="color:var(--acc)">Gap Statistics</strong>
<div style="display:grid;grid-template-columns:1fr 1fr;gap:3px;margin-top:5px;font-size:.8rem">
<span>Average gap:</span><span style="color:#00d9ff">${fmt(avgGap)}</span>
<span>ln(N):</span><span style="color:#9664ff">${fmt(Math.log(maxN))}</span>
<span>Gap=2 (twins):</span><span style="color:#ffd700">${gap2Count}</span>
<span>Most common:</span><span style="color:#00ff88">${mostCommon?mostCommon[0]+' ('+mostCommon[1]+'×)':'-'}</span>
</div>
</div>
<div style="margin-bottom:10px;padding-bottom:8px;border-bottom:1px solid var(--bord)">
<strong style="color:var(--acc)">Cramér Analysis</strong>
<div style="display:grid;grid-template-columns:1fr 1fr;gap:3px;margin-top:5px;font-size:.8rem">
<span>Cramér bound (ln N)²:</span><span style="color:#ff8c00">${fmt(Math.pow(Math.log(maxN),2))}</span>
<span>Max/Cramér ratio:</span><span style="color:${maxGap<Math.pow(Math.log(maxN),2)?'#00ff88':'#ff4040'}">${fmt(maxGap/Math.pow(Math.log(maxN),2))}</span>
<span>Gaps exceeding Cramér:</span><span style="color:#ff6496">${gaps.filter(g=>g.gap>g.cramér).length}</span>
</div>
</div>
<div style="margin-bottom:10px;padding-bottom:8px;border-bottom:1px solid var(--bord)">
<strong style="color:var(--acc)">First Record Gaps</strong>
<div style="font-size:.75rem;color:var(--txt2);margin-top:5px">
${records.slice(0,8).map(r=>`<span style="display:inline-block;padding:2px 6px;margin:2px;border-radius:3px;background:#ff006e;color:#fff;font-weight:bold">g=${r.gap} at p=${r.p}</span>`).join('')}
</div>
</div>`;

document.getElementById('tgapT').innerHTML='<tr><th>p</th><th>Gap</th><th>p+gap</th><th>g/ln(p)</th><th>Record?</th></tr>'+
records.slice(0,50).map(r=>`<tr style="color:#ff006e"><td>${r.p}</td><td>${r.gap}</td><td>${r.p+r.gap}</td><td>${fmt(r.ratio)}</td><td>OK</td></tr>`).join('');}

function csvGap(){let s='p,gap,p_next,ratio,is_record\n';for(const g of gapData.gaps)s+=`${g.p},${g.gap},${g.pNext},${g.ratio},${g.isRecord}\n`;dl(s,'prime_gaps.csv');}
function expGap(){const c=document.getElementById('cgap');c.toBlob(b=>{const a=document.createElement('a');a.href=URL.createObjectURL(b);a.download='prime_gaps.png';a.click();});}

async function screenshotGap(){
const c=document.getElementById('cgap'),dashData=extractDashboardData('gapLiveStats');
const maxN=document.getElementById('gapNv').value;
const scale=2,pad=30,dashH=400;
const out=document.createElement('canvas');
out.width=(c.width+pad*2)*scale;out.height=(c.height+dashH+pad*3)*scale;
const ctx=out.getContext('2d');ctx.scale(scale,scale);
const isDk=isDark();
ctx.fillStyle=isDk?'#0d1321':'#ffffff';ctx.fillRect(0,0,out.width/scale,out.height/scale);
ctx.fillStyle=isDk?'#00d9ff':'#0066cc';ctx.font='bold 18px Segoe UI';ctx.textAlign='center';
ctx.fillText(`Prime Gaps — N ≤ ${maxN}`,out.width/scale/2,pad);
ctx.drawImage(c,pad,pad+25,c.width,c.height);
const dashY=c.height+pad+45;
ctx.fillStyle=isDk?'#151b2d':'#f5f5f5';ctx.fillRect(pad,dashY-10,c.width,dashH);
ctx.textAlign='left';
renderDashboard(ctx,dashData,pad+10,dashY,c.width-20,isDk,dashH-30);
ctx.fillStyle=isDk?'#506080':'#888';ctx.font='10px Segoe UI';ctx.textAlign='center';
ctx.fillText('Möbius Shell Sieve — wessengetachew.github.io',out.width/scale/2,out.height/scale-10);
out.toBlob(b=>{const a=document.createElement('a');a.href=URL.createObjectURL(b);a.download='prime_gaps_complete.png';a.click();},'image/png',1.0);}

// ==================== SOPHIE GERMAIN PRIMES ====================
let sophieData={primes:[],pairs:[]};

function isSophieGermain(p,primeSet){return primeSet.has(p)&&primeSet.has(2*p+1);}
function isSafePrime(p,primeSet){return primeSet.has(p)&&p>2&&(p-1)/2>0&&primeSet.has((p-1)/2);}

function cunninghamChain(p,primeSet,type){
const chain=[p];
let curr=p;
while(true){
const next=type===1?2*curr+1:2*curr-1;
if(!primeSet.has(next))break;
chain.push(next);
curr=next;}
return chain;}

function drawSophie(){
const c=document.getElementById('csoph'),ctx=c.getContext('2d');
const maxN=+document.getElementById('sophNv').value||+document.getElementById('sophN').value;
const type=document.getElementById('sophType').value;
const viz=document.getElementById('sophViz').value;
const ptSz=+document.getElementById('sophPtSz').value;
const showGrid=document.getElementById('sophGrid').checked;
const showPairs=document.getElementById('sophPairs').checked;

ctx.fillStyle=canvBg();ctx.fillRect(0,0,c.width,c.height);

const primes=sievePrimes(maxN*2+1);
const primeSet=new Set(primes);
const results=[];
let maxChain=0;

if(type==='sophie'){
for(const p of primes){
if(p<=maxN&&isSophieGermain(p,primeSet)){
results.push({p,q:2*p+1,type:'sophie'});}}}
else if(type==='safe'){
for(const p of primes){
if(p<=maxN&&isSafePrime(p,primeSet)){
results.push({p,q:(p-1)/2,type:'safe'});}}}
else if(type==='cunningham1'||type==='cunningham2'){
const ctype=type==='cunningham1'?1:2;
const seen=new Set();
for(const p of primes){
if(p<=maxN&&!seen.has(p)){
const chain=cunninghamChain(p,primeSet,ctype);
if(chain.length>=2){
chain.forEach(x=>seen.add(x));
results.push({p,chain,len:chain.length,type});
maxChain=Math.max(maxChain,chain.length);}}}}
sophieData={primes:results,type,maxN};

const pad=60,w=c.width-2*pad,h=c.height-2*pad;
const typeLabel=type==='sophie'?'Sophie Germain Primes (p, 2p+1)':type==='safe'?'Safe Primes (2p+1 where p prime)':type==='cunningham1'?'Cunningham Chains (1st kind)':'Cunningham Chains (2nd kind)';

ctx.fillStyle=isDark()?'#ffd700':'#cc8800';ctx.font='bold 14px Segoe UI';ctx.textAlign='center';
ctx.fillText(typeLabel,c.width/2,30);

if(viz==='scatter'){
if(showGrid){ctx.strokeStyle=gridC();ctx.lineWidth=0.5;
for(let i=0;i<=5;i++){const x=pad+i*w/5;ctx.beginPath();ctx.moveTo(x,pad);ctx.lineTo(x,pad+h);ctx.stroke();
const y=pad+h-i*h/5;ctx.beginPath();ctx.moveTo(pad,y);ctx.lineTo(pad+w,y);ctx.stroke();}}

if(type==='sophie'||type==='safe'){
const maxP=results.length>0?Math.max(...results.map(r=>r.p)):maxN;
const maxQ=results.length>0?Math.max(...results.map(r=>r.q)):maxN;
for(const r of results){
const x=pad+w*r.p/maxP;
const y=pad+h-h*r.q/maxQ;
if(showPairs){ctx.strokeStyle='rgba(150,100,255,0.3)';ctx.lineWidth=1;
ctx.beginPath();ctx.moveTo(x,y);ctx.lineTo(pad+w*r.q/maxP,pad+h-h*r.p/maxQ);ctx.stroke();}
ctx.fillStyle=type==='sophie'?'#00ff88':'#ff8c00';
ctx.beginPath();ctx.arc(x,y,ptSz,0,2*Math.PI);ctx.fill();}}
else{
for(const r of results){
const clr=`hsl(${r.len*60},80%,50%)`;
for(let i=0;i<r.chain.length;i++){
const x=pad+w*r.chain[i]/maxN;
const y=pad+h-h*r.len/maxChain;
ctx.fillStyle=clr;ctx.beginPath();ctx.arc(x,y,ptSz+i,0,2*Math.PI);ctx.fill();}}}}

else if(viz==='density'){
const binSize=Math.ceil(maxN/50);
const bins=[];
for(let i=0;i<50;i++){
const lo=i*binSize,hi=(i+1)*binSize;
const count=results.filter(r=>r.p>=lo&&r.p<hi).length;
bins.push({lo,hi,count});}
const maxBin=Math.max(...bins.map(b=>b.count));
for(let i=0;i<bins.length;i++){
const barH=h*bins[i].count/maxBin;
ctx.fillStyle=`hsl(${120-bins[i].count/maxBin*120},70%,50%)`;
ctx.fillRect(pad+i*w/50,pad+h-barH,w/50-1,barH);}}

else if(viz==='chains'&&(type==='cunningham1'||type==='cunningham2')){
const chainLens={};
for(const r of results){chainLens[r.len]=(chainLens[r.len]||0)+1;}
const lenKeys=Object.keys(chainLens).map(Number).sort((a,b)=>a-b);
const maxFreq=Math.max(...Object.values(chainLens));
const barW=w/lenKeys.length;
for(let i=0;i<lenKeys.length;i++){
const len=lenKeys[i],f=chainLens[len];
ctx.fillStyle=`hsl(${len*60},70%,50%)`;
const barH=h*f/maxFreq;
ctx.fillRect(pad+i*barW,pad+h-barH,barW-2,barH);
ctx.fillStyle=isDark()?'#fff':'#000';ctx.font='10px Arial';ctx.textAlign='center';
ctx.fillText('len='+len,pad+i*barW+barW/2,pad+h+15);}}

const density=results.length/maxN;
const expected=maxN>100?1.32*maxN/Math.pow(Math.log(maxN),2):results.length;

legend('alsoph1',typeLabel,[['Count',results.length,'#00ff88'],['Density',fmt(density*100)+'%','#ffd700']]);
legend('alsoph2','Analysis',[['Expected ~',fmt(expected),'#9664ff'],['Largest',results[results.length-1]?.p||0,'#00d9ff']]);

const dist=[];
for(let i=0;i<Math.min(results.length,30);i++)dist.push(results[i].p);
Plotly.newPlot('psoph',[{x:dist,y:dist.map((_,i)=>i+1),type:'scatter',mode:'markers',marker:{size:6,color:'#00ff88'}}],{...plo(),xaxis:{title:'p'},yaxis:{title:'Index'}});

document.getElementById('sophLiveStats').innerHTML=`
<div style="display:grid;grid-template-columns:repeat(3,1fr);gap:8px;margin-bottom:12px">
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center"><div style="font-size:1.3rem;font-weight:bold;color:#00ff88">${results.length}</div><div style="font-size:.7rem;color:var(--txt2)">${type.toUpperCase()}</div></div>
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center"><div style="font-size:1.3rem;font-weight:bold;color:#ffd700">${fmt(density*100)}%</div><div style="font-size:.7rem;color:var(--txt2)">DENSITY</div></div>
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center"><div style="font-size:1.3rem;font-weight:bold;color:#00d9ff">${results[results.length-1]?.p||0}</div><div style="font-size:.7rem;color:var(--txt2)">LARGEST</div></div>
</div>
<div style="margin-bottom:10px;padding-bottom:8px;border-bottom:1px solid var(--bord)">
<strong style="color:var(--acc)">Statistics</strong>
<div style="display:grid;grid-template-columns:1fr 1fr;gap:3px;margin-top:5px;font-size:.8rem">
<span>Count:</span><span style="color:#00ff88">${results.length}</span>
<span>Expected ~C·n/(ln n)²:</span><span style="color:#9664ff">${fmt(expected)}</span>
<span>Ratio actual/expected:</span><span style="color:#ffd700">${fmt(results.length/expected)}</span>
<span>Smallest:</span><span style="color:#00d9ff">${results[0]?.p||0}</span>
</div>
</div>
${type.includes('cunningham')?`<div style="margin-bottom:10px;padding-bottom:8px;border-bottom:1px solid var(--bord)">
<strong style="color:var(--acc)">Chain Statistics</strong>
<div style="display:grid;grid-template-columns:1fr 1fr;gap:3px;margin-top:5px;font-size:.8rem">
<span>Max chain length:</span><span style="color:#ff006e">${maxChain}</span>
<span>Chains of length 2:</span><span style="color:#00d9ff">${results.filter(r=>r.len===2).length}</span>
<span>Chains of length 3+:</span><span style="color:#ffd700">${results.filter(r=>r.len>=3).length}</span>
</div>
</div>`:''}
<div style="margin-bottom:10px;padding-bottom:8px;border-bottom:1px solid var(--bord)">
<strong style="color:var(--acc)">First ${type==='sophie'?'Sophie Germain':type==='safe'?'Safe':'Cunningham'} Primes</strong>
<div style="font-size:.75rem;color:var(--txt2);margin-top:5px">
${results.slice(0,10).map(r=>type.includes('cunningham')?`<span style="display:inline-block;padding:2px 6px;margin:2px;border-radius:3px;background:hsl(${r.len*60},70%,50%);color:#000;font-weight:bold">${r.chain.join('→')}</span>`:`<span style="display:inline-block;padding:2px 6px;margin:2px;border-radius:3px;background:#00ff88;color:#000;font-weight:bold">${r.p}→${r.q}</span>`).join('')}
</div>
</div>`;

document.getElementById('tsophT').innerHTML='<tr><th>p</th><th>'+(type.includes('cunningham')?'Chain':'q=2p+1 or (p-1)/2')+'</th><th>'+(type.includes('cunningham')?'Length':'Type')+'</th></tr>'+
results.slice(0,80).map(r=>type.includes('cunningham')?`<tr style="color:hsl(${r.len*60},80%,50%)"><td>${r.p}</td><td>${r.chain.join('→')}</td><td>${r.len}</td></tr>`:`<tr style="color:#00ff88"><td>${r.p}</td><td>${r.q}</td><td>${type}</td></tr>`).join('');}

function csvSophie(){let s='p,'+(sophieData.type.includes('cunningham')?'chain,length':'q,type')+'\n';for(const r of sophieData.primes)s+=sophieData.type.includes('cunningham')?`${r.p},"${r.chain.join(',')}",${r.len}\n`:`${r.p},${r.q},${r.type}\n`;dl(s,'sophie_germain.csv');}
function expSophie(){const c=document.getElementById('csoph');c.toBlob(b=>{const a=document.createElement('a');a.href=URL.createObjectURL(b);a.download='sophie_germain.png';a.click();});}

async function screenshotSophie(){
const c=document.getElementById('csoph'),dashData=extractDashboardData('sophLiveStats');
const maxN=document.getElementById('sophNv').value,type=document.getElementById('sophType').value;
const scale=2,pad=30,dashH=400;
const out=document.createElement('canvas');
out.width=(c.width+pad*2)*scale;out.height=(c.height+dashH+pad*3)*scale;
const ctx=out.getContext('2d');ctx.scale(scale,scale);
const isDk=isDark();
ctx.fillStyle=isDk?'#0d1321':'#ffffff';ctx.fillRect(0,0,out.width/scale,out.height/scale);
ctx.fillStyle=isDk?'#00d9ff':'#0066cc';ctx.font='bold 18px Segoe UI';ctx.textAlign='center';
ctx.fillText(`Sophie Germain Analysis — N ≤ ${maxN}`,out.width/scale/2,pad);
ctx.drawImage(c,pad,pad+25,c.width,c.height);
const dashY=c.height+pad+45;
ctx.fillStyle=isDk?'#151b2d':'#f5f5f5';ctx.fillRect(pad,dashY-10,c.width,dashH);
ctx.textAlign='left';
renderDashboard(ctx,dashData,pad+10,dashY,c.width-20,isDk,dashH-30);
ctx.fillStyle=isDk?'#506080':'#888';ctx.font='10px Segoe UI';ctx.textAlign='center';
ctx.fillText('Möbius Shell Sieve — wessengetachew.github.io',out.width/scale/2,out.height/scale-10);
out.toBlob(b=>{const a=document.createElement('a');a.href=URL.createObjectURL(b);a.download='sophie_germain_complete.png';a.click();},'image/png',1.0);}

async function screenshotMod(){
const viewMode=document.getElementById('modViewMode').value;
let title;
if(viewMode==='single'){
const M=document.getElementById('modSingleM').value;
title=`Modular Reduction Projection — M=${M}`;
}else{
const minM=document.getElementById('modMin').value,maxM=document.getElementById('modMax').value;
title=`Modular Ring System θ=2πr/M — M=${minM}→${maxM}`;
}
await screenshotUnified('cmod','modLiveStats',title,'modular_rings_complete.png',{dashH:350,legend:'Gold = GCD(r,M)=1 — Dirichlet Character Support χ(r)≠0'});
}

async function screenshot3D4K(){
const c=document.getElementById('c3d'),dashData=extractDashboardData('stats3dLive');
const res=+document.getElementById('ss3dRes').value||4,bg=document.getElementById('ss3dBg').value;
const showTitle=document.getElementById('ss3dTitle').checked,showLegend=document.getElementById('ss3dLegend').checked,showStats=document.getElementById('ss3dStats').checked;
const titleTxt=document.getElementById('ss3dTitleTxt').value||'3D Visualization';
const pad=60,titleH=showTitle?80:0,legendH=showLegend?80:0,statsH=showStats?300:0;
const out=document.createElement('canvas');out.width=c.width*res;out.height=(c.height+titleH+legendH+statsH+40)*res;
const ctx=out.getContext('2d');ctx.scale(res,res);
const isDk=bg!=='white';
if(bg==='black')ctx.fillStyle='#000';else if(bg==='white')ctx.fillStyle='#fff';else if(bg==='transparent')ctx.fillStyle='transparent';else ctx.fillStyle=canvBg();
ctx.fillRect(0,0,out.width/res,out.height/res);
let yOff=0;
if(showTitle){ctx.fillStyle=isDk?'#00d9ff':'#0066cc';ctx.font='bold 24px Segoe UI';ctx.textAlign='center';ctx.fillText(titleTxt,c.width/2,pad);ctx.font='14px Segoe UI';ctx.fillStyle=isDk?'#aaa':'#666';ctx.fillText('By Wessen Getachew · @7dview',c.width/2,pad+30);yOff=titleH;}
ctx.drawImage(c,0,yOff);yOff+=c.height+20;
if(showStats&&dashData.cards.length>0){
ctx.fillStyle=isDk?'#151b2d':'#f5f5f5';ctx.fillRect(20,yOff,c.width-40,statsH-20);
renderDashboard(ctx,dashData,30,yOff+15,c.width-60,isDk,statsH-50);yOff+=statsH;}
if(showLegend){ctx.fillStyle=isDk?'#00d9ff':'#0066cc';ctx.font='bold 14px Segoe UI';ctx.textAlign='left';ctx.fillText('Legend',pad,yOff+15);ctx.font='11px Segoe UI';const legs=[['GCD=1 (Primitive)','#ffd700'],['GCD=2','#00d9ff'],['GCD=3','#9664ff'],['GCD>3','#ff6496']];let lx=pad+70;legs.forEach(([txt,clr])=>{ctx.fillStyle=clr;ctx.fillRect(lx,yOff+5,12,12);ctx.fillStyle=isDk?'#e0e0ff':'#333';ctx.fillText(txt,lx+16,yOff+15);lx+=130;});}
ctx.fillStyle=isDk?'#506080':'#888';ctx.font='10px Segoe UI';ctx.textAlign='center';
ctx.fillText('Möbius Shell Sieve — wessengetachew.github.io',c.width/2,out.height/res-15);
out.toBlob(b=>{const a=document.createElement('a');a.href=URL.createObjectURL(b);a.download=`mobius_3d_${res}x.png`;a.click();},'image/png',1.0);}

// ==================== MERTENS FUNCTION M(x) ====================
let mertensData={values:[],maxX:0};

function computeMertens(maxX){
const mu=new Array(maxX+1).fill(1);
const sieve=new Array(maxX+1).fill(true);
// Compute Möbius function
for(let p=2;p<=maxX;p++){
if(sieve[p]){
for(let m=p;m<=maxX;m+=p){mu[m]*=-1;sieve[m]=false;}
for(let m=p*p;m<=maxX;m+=p*p)mu[m]=0;
for(let m=p;m<=maxX;m+=p)sieve[m]=true;
}}
// Compute cumulative M(x)
const M=new Array(maxX+1);
M[0]=0;
for(let n=1;n<=maxX;n++)M[n]=M[n-1]+mu[n];
return{mu,M};
}

function drawMertens(){
const c=document.getElementById('cmert'),ctx=c.getContext('2d');
const maxX=+document.getElementById('mertXv').value||+document.getElementById('mertX').value;
const viz=document.getElementById('mertViz').value;
const col=document.getElementById('mertCol').value;
const showSqrt=document.getElementById('mertBoundSqrt').checked;
const showRH=document.getElementById('mertBoundRH').checked;
const ptSz=+document.getElementById('mertPtSz').value;

ctx.fillStyle=canvBg();ctx.fillRect(0,0,c.width,c.height);

const{mu,M}=computeMertens(maxX);
mertensData={mu,M,maxX};

const pad=60,w=c.width-2*pad,h=c.height-2*pad;
const cx=pad,cy=c.height/2;

// Determine data range
let data,yMin,yMax,ylabel;
if(viz==='cumulative'||viz==='both'){
data=M.slice(1);
yMin=Math.min(...data);yMax=Math.max(...data);
ylabel='M(x)';
}else if(viz==='normalized'){
data=M.slice(1).map((m,i)=>m/Math.sqrt(i+1));
yMin=Math.min(...data);yMax=Math.max(...data);
ylabel='M(x)/√x';
}else if(viz==='mobius'){
data=mu.slice(1);
yMin=-1.5;yMax=1.5;
ylabel='μ(n)';
}else{
data=M.slice(1);
yMin=Math.min(...data);yMax=Math.max(...data);
ylabel='M(x)';
}

const margin=Math.abs(yMax-yMin)*0.1||1;
yMin-=margin;yMax+=margin;
const scX=w/maxX,scY=h/(yMax-yMin);

// Grid
ctx.strokeStyle=gridC();ctx.lineWidth=0.5;
for(let i=0;i<=10;i++){
const gx=pad+i*w/10;
ctx.beginPath();ctx.moveTo(gx,pad);ctx.lineTo(gx,c.height-pad);ctx.stroke();
const gy=pad+i*h/10;
ctx.beginPath();ctx.moveTo(pad,gy);ctx.lineTo(c.width-pad,gy);ctx.stroke();
}

// Axes
ctx.strokeStyle=bordC();ctx.lineWidth=2;
ctx.beginPath();ctx.moveTo(pad,pad);ctx.lineTo(pad,c.height-pad);ctx.lineTo(c.width-pad,c.height-pad);ctx.stroke();
// Zero line
if(yMin<0&&yMax>0){
const y0=c.height-pad+yMin*scY;
ctx.strokeStyle='rgba(255,215,0,0.5)';ctx.lineWidth=1;
ctx.beginPath();ctx.moveTo(pad,y0);ctx.lineTo(c.width-pad,y0);ctx.stroke();
}

// Bounds
if(showSqrt&&(viz==='cumulative'||viz==='both')){
ctx.strokeStyle='rgba(0,255,136,0.4)';ctx.lineWidth=1;ctx.setLineDash([5,3]);
ctx.beginPath();
for(let x=1;x<=maxX;x++){
const px=pad+x*scX;
const py=c.height-pad-(Math.sqrt(x)-yMin)*scY;
if(x===1)ctx.moveTo(px,py);else ctx.lineTo(px,py);
}ctx.stroke();
ctx.beginPath();
for(let x=1;x<=maxX;x++){
const px=pad+x*scX;
const py=c.height-pad-(-Math.sqrt(x)-yMin)*scY;
if(x===1)ctx.moveTo(px,py);else ctx.lineTo(px,py);
}ctx.stroke();
ctx.setLineDash([]);
}

// Draw data
const allPts=[];
if(viz==='mobius'){
// Bar chart for μ(n)
for(let n=1;n<=maxX;n++){
const px=pad+n*scX;
const py0=c.height-pad+yMin*scY;
const py=c.height-pad-(mu[n]-yMin)*scY;
let clr;
if(col==='sign'){clr=mu[n]===1?'#00ff88':mu[n]===-1?'#ff6496':'#666';}
else if(col==='squarefree'){clr=mu[n]!==0?'#ffd700':'#444';}
else{const omega=countDistinctPrimes(n);clr=`hsl(${omega*60},70%,50%)`;}
ctx.fillStyle=clr;
ctx.fillRect(px-ptSz/2,Math.min(py,py0),ptSz,Math.abs(py-py0)||1);
allPts.push({n,mu:mu[n],M:M[n],px,py});
}
}else{
// Line/scatter for M(x)
ctx.strokeStyle='#00d9ff';ctx.lineWidth=1.5;
ctx.beginPath();
for(let n=1;n<=maxX;n++){
const val=viz==='normalized'?M[n]/Math.sqrt(n):M[n];
const px=pad+n*scX;
const py=c.height-pad-(val-yMin)*scY;
if(n===1)ctx.moveTo(px,py);else ctx.lineTo(px,py);
allPts.push({n,mu:mu[n],M:M[n],val,px,py});
}
ctx.stroke();
// Points
for(const pt of allPts){
let clr;
if(col==='sign'){clr=mu[pt.n]===1?'#00ff88':mu[pt.n]===-1?'#ff6496':'#666';}
else if(col==='squarefree'){clr=mu[pt.n]!==0?'#ffd700':'#444';}
else{const omega=countDistinctPrimes(pt.n);clr=`hsl(${omega*60},70%,50%)`;}
ctx.fillStyle=clr;ctx.beginPath();ctx.arc(pt.px,pt.py,ptSz,0,2*Math.PI);ctx.fill();
}
}

// Labels
ctx.fillStyle=isDark()?'#fff':'#000';ctx.font='12px Segoe UI';
ctx.textAlign='center';ctx.fillText('n',c.width/2,c.height-15);
ctx.save();ctx.translate(15,c.height/2);ctx.rotate(-Math.PI/2);ctx.fillText(ylabel,0,0);ctx.restore();

// Title
ctx.fillStyle=isDark()?'#ffd700':'#cc8800';ctx.font='bold 14px Segoe UI';ctx.textAlign='center';
ctx.fillText(`Mertens Function M(x) = Σμ(n) — x ≤ ${maxX}`,c.width/2,25);

// Stats
const maxM=Math.max(...M.slice(1));
const minM=Math.min(...M.slice(1));
const finalM=M[maxX];
const sqrtX=Math.sqrt(maxX);
const ratio=finalM/sqrtX;
const mu1Count=mu.slice(1).filter(m=>m===1).length;
const muNeg1Count=mu.slice(1).filter(m=>m===-1).length;
const mu0Count=mu.slice(1).filter(m=>m===0).length;
const sqfreeRatio=((mu1Count+muNeg1Count)/maxX*100);

// Sign change analysis
let signChanges=0,lastSign=0;
const signChangePoints=[];
for(let n=1;n<=maxX;n++){
  if(M[n]!==0){
    const sign=M[n]>0?1:-1;
    if(lastSign!==0&&sign!==lastSign){signChanges++;signChangePoints.push(n);}
    lastSign=sign;
  }
}
const firstSignChange=signChangePoints.length>0?signChangePoints[0]:'-';
const signChangeDensity=signChanges/maxX*1000;

legend('almert','Mertens M(x)',[['M('+maxX+')',finalM,'#00d9ff'],['Max M',maxM,'#00ff88'],['Min M',minM,'#ff6496']]);

document.getElementById('mertLiveStats').innerHTML=`
<div style="background:linear-gradient(135deg,rgba(0,217,255,.15),rgba(255,215,0,.1));padding:10px;border-radius:8px;margin-bottom:12px;border:1px solid var(--acc)">
<div style="font-size:.7rem;color:var(--txt2);margin-bottom:4px">TAB: Mertens M(x) | FIELD: ℤ | TYPE: Σμ(n) Cumulative Sum</div>
<div style="display:grid;grid-template-columns:repeat(3,1fr);gap:6px;font-size:.75rem">
<span>Max x: <strong style="color:#00d9ff">${maxX}</strong></span>
<span>M(x): <strong style="color:#ffd700">${finalM}</strong></span>
<span>Mode: <strong style="color:#00ff88">${viz}</strong></span>
</div>
</div>
<div style="display:grid;grid-template-columns:repeat(3,1fr);gap:8px;margin-bottom:12px">
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center"><div style="font-size:1.3rem;font-weight:bold;color:#00d9ff">${maxX}</div><div style="font-size:.7rem;color:var(--txt2)">MAX x</div></div>
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center"><div style="font-size:1.3rem;font-weight:bold;color:#ffd700">${finalM}</div><div style="font-size:.7rem;color:var(--txt2)">M(${maxX}) ACTUAL</div></div>
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center"><div style="font-size:1.3rem;font-weight:bold;color:${Math.abs(ratio)<1?'#00ff88':'#ff6496'}">${fmt(ratio)}</div><div style="font-size:.7rem;color:var(--txt2)">M(x)/√x</div></div>
</div>
<div style="display:grid;grid-template-columns:repeat(3,1fr);gap:8px;margin-bottom:12px">
<div style="background:var(--bg1);padding:8px;border-radius:6px;text-align:center"><div style="font-size:1rem;font-weight:bold;color:#00ff88">${maxM}</div><div style="font-size:.6rem;color:var(--txt2)">MAX M(x)</div></div>
<div style="background:var(--bg1);padding:8px;border-radius:6px;text-align:center"><div style="font-size:1rem;font-weight:bold;color:#ff6496">${minM}</div><div style="font-size:.6rem;color:var(--txt2)">MIN M(x)</div></div>
<div style="background:var(--bg1);padding:8px;border-radius:6px;text-align:center"><div style="font-size:1rem;font-weight:bold;color:#9664ff">±${fmt(sqrtX)}</div><div style="font-size:.6rem;color:var(--txt2)">√x BOUND</div></div>
</div>
<div style="margin-bottom:10px;padding-bottom:8px;border-bottom:1px solid var(--bord)">
<strong style="color:var(--acc)">Mertens Values</strong>
<div style="display:grid;grid-template-columns:1fr 1fr;gap:4px;margin-top:6px;font-size:.8rem">
<span>Maximum M(x):</span><span style="color:#00ff88;font-weight:bold">${maxM}</span>
<span>Minimum M(x):</span><span style="color:#ff6496;font-weight:bold">${minM}</span>
<span>√x bound:</span><span style="color:#ffd700">±${fmt(sqrtX)}</span>
<span>|M(x)/√x| max:</span><span style="color:${Math.max(Math.abs(maxM),Math.abs(minM))/sqrtX<1?'#00ff88':'#ff6496'}">${fmt(Math.max(Math.abs(maxM),Math.abs(minM))/sqrtX)}</span>
</div>
</div>
<div style="margin-bottom:10px;padding-bottom:8px;border-bottom:1px solid var(--bord)">
<strong style="color:var(--acc)">Möbius Distribution</strong>
<div style="display:grid;grid-template-columns:1fr 1fr;gap:4px;margin-top:6px;font-size:.8rem">
<span>μ(n) = +1:</span><span style="color:#00ff88">${mu1Count} (${fmt(mu1Count/maxX*100)}%)</span>
<span>μ(n) = -1:</span><span style="color:#ff6496">${muNeg1Count} (${fmt(muNeg1Count/maxX*100)}%)</span>
<span>μ(n) = 0:</span><span style="color:#666">${mu0Count} (${fmt(mu0Count/maxX*100)}%)</span>
<span>Squarefree:</span><span style="color:#ffd700">${fmt(sqfreeRatio)}% (→6/π²≈60.8%)</span>
</div>
</div>
<div style="margin-bottom:10px;padding-bottom:8px;border-bottom:1px solid var(--bord)">
<strong style="color:#9664ff">Sign Change Analysis</strong>
<div style="display:grid;grid-template-columns:1fr 1fr;gap:4px;margin-top:6px;font-size:.8rem">
<span>Total sign changes:</span><span style="color:#9664ff;font-weight:bold">${signChanges}</span>
<span>First change at:</span><span style="color:#00d9ff">n = ${firstSignChange}</span>
<span>Density per 1000:</span><span style="color:#ffd700">${fmt(signChangeDensity)}</span>
<span>Last 5 changes:</span><span style="color:#ff8c00">${signChangePoints.slice(-5).join(', ')||'none'}</span>
</div>
</div>
<div style="background:${Math.abs(ratio)<1?'rgba(0,255,136,.1)':'rgba(255,100,150,.1)'};padding:8px;border-radius:6px">
<strong style="color:${Math.abs(ratio)<1?'#00ff88':'#ff6496'}">RH Status: ${Math.abs(ratio)<1?'CONSISTENT':'CHECK NEEDED'}</strong>
<div style="font-size:.75rem;color:var(--txt2);margin-top:4px">|M(x)/√x| ${Math.abs(ratio)<1?'<':'≥'} 1 at x=${maxX}</div>
</div>`;

// Plotly charts
Plotly.newPlot('pmertRatio',[{x:[...Array(maxX)].map((_,i)=>i+1),y:M.slice(1).map((m,i)=>m/Math.sqrt(i+1)),type:'scatter',mode:'lines',name:'M(x)/√x',line:{color:'#00d9ff'}}],{...plo(),xaxis:{title:'x'},yaxis:{title:'M(x)/√x'}});
Plotly.newPlot('pmertDist',[{x:['+1','-1','0'],y:[mu1Count,muNeg1Count,mu0Count],type:'bar',marker:{color:['#00ff88','#ff6496','#666']}}],{...plo(),xaxis:{title:'μ(n) value'},yaxis:{title:'Count'}});

// Click handler
c.onclick=e=>{
const rect=c.getBoundingClientRect();
const mx=(e.clientX-rect.left)*(c.width/rect.width);
const my=(e.clientY-rect.top)*(c.height/rect.height);
for(const pt of allPts){
if(Math.hypot(mx-pt.px,my-pt.py)<ptSz+5){
modal(`Mertens at n=${pt.n}`,[
['n',pt.n],['μ(n)',pt.mu],['M(n)',pt.M],
['M(n)/√n',fmt(pt.M/Math.sqrt(pt.n))],
['√n',fmt(Math.sqrt(pt.n))],
['|M(n)| < √n',Math.abs(pt.M)<Math.sqrt(pt.n)?'Yes':'No']
]);return;
}}};
}

function countDistinctPrimes(n){
let count=0,d=2;
while(d*d<=n){if(n%d===0){count++;while(n%d===0)n/=d;}d++;}
if(n>1)count++;
return count;
}

async function screenshotMertens(){
const maxX=document.getElementById('mertXv').value;
await screenshotUnified('cmert','mertLiveStats',`Mertens Function M(x) — x ≤ ${maxX}`,'mertens_complete.png',{dashH:350});
}

function csvMertens(){
let s='n,mu_n,M_n,M_n_over_sqrt_n\n';
for(let n=1;n<=mertensData.maxX;n++)s+=`${n},${mertensData.mu[n]},${mertensData.M[n]},${mertensData.M[n]/Math.sqrt(n)}\n`;
dl(s,'mertens_data.csv');
}

// ==================== CHEBYSHEV FUNCTIONS ψ(x), θ(x) ====================
let chebyshevData={psi:[],theta:[],lambda:[],maxX:0};

function vonMangoldt(n){
// Λ(n) = log(p) if n = p^k for some prime p and k ≥ 1, else 0
if(n<2)return 0;
let p=2,logp=0;
while(p*p<=n){
if(n%p===0){
let m=n;
while(m%p===0)m/=p;
if(m===1)return Math.log(p);
return 0;
}
p++;
}
// n is prime
return Math.log(n);
}

function computeChebyshev(maxX){
const primes=sievePrimes(maxX);
const primeSet=new Set(primes);
const psi=new Array(maxX+1).fill(0);
const theta=new Array(maxX+1).fill(0);
const lambda=new Array(maxX+1).fill(0);

for(let n=2;n<=maxX;n++){
lambda[n]=vonMangoldt(n);
psi[n]=psi[n-1]+lambda[n];
theta[n]=theta[n-1]+(primeSet.has(n)?Math.log(n):0);
}
psi[0]=0;psi[1]=0;theta[0]=0;theta[1]=0;
return{psi,theta,lambda,primes};
}

function drawChebyshev(){
const c=document.getElementById('ccheb'),ctx=c.getContext('2d');
const maxX=+document.getElementById('chebXv').value||+document.getElementById('chebX').value;
const func=document.getElementById('chebFunc').value;
const showX=document.getElementById('chebShowX').checked;
const showRH=document.getElementById('chebShowRH').checked;
const norm=document.getElementById('chebNorm').value;
const ptSz=+document.getElementById('chebPtSz').value;

ctx.fillStyle=canvBg();ctx.fillRect(0,0,c.width,c.height);

const{psi,theta,lambda,primes}=computeChebyshev(maxX);
chebyshevData={psi,theta,lambda,primes,maxX};

const pad=60,w=c.width-2*pad,h=c.height-2*pad;

// Determine data
let data1,data2,label1,label2,yMin,yMax;
if(norm==='ratio'){
data1=psi.slice(2).map((v,i)=>v/(i+2));
data2=theta.slice(2).map((v,i)=>v/(i+2));
label1='ψ(x)/x';label2='θ(x)/x';
yMin=0;yMax=Math.max(...data1,1.2);
}else if(norm==='error_norm'){
data1=psi.slice(2).map((v,i)=>(v-(i+2))/Math.sqrt(i+2));
data2=theta.slice(2).map((v,i)=>(v-(i+2))/Math.sqrt(i+2));
label1='(ψ(x)-x)/√x';label2='(θ(x)-x)/√x';
yMin=Math.min(...data1,...data2)-1;yMax=Math.max(...data1,...data2)+1;
}else{
if(func==='error'){
data1=psi.slice(2).map((v,i)=>v-(i+2));
label1='ψ(x)-x';
yMin=Math.min(...data1);yMax=Math.max(...data1);
}else{
data1=psi.slice(2);
data2=theta.slice(2);
label1='ψ(x)';label2='θ(x)';
yMin=0;yMax=Math.max(...data1,maxX);
}
}

const margin=(yMax-yMin)*0.1||1;
yMin-=margin;yMax+=margin;
const scX=w/(maxX-2),scY=h/(yMax-yMin);

// Grid
ctx.strokeStyle=gridC();ctx.lineWidth=0.5;
for(let i=0;i<=10;i++){
const gx=pad+i*w/10,gy=pad+i*h/10;
ctx.beginPath();ctx.moveTo(gx,pad);ctx.lineTo(gx,c.height-pad);ctx.stroke();
ctx.beginPath();ctx.moveTo(pad,gy);ctx.lineTo(c.width-pad,gy);ctx.stroke();
}

// y=x reference line
if(showX&&norm==='raw'&&func!=='error'){
ctx.strokeStyle='rgba(255,215,0,0.5)';ctx.lineWidth=2;ctx.setLineDash([5,5]);
ctx.beginPath();ctx.moveTo(pad,c.height-pad-(0-yMin)*scY);ctx.lineTo(c.width-pad,c.height-pad-(maxX-yMin)*scY);ctx.stroke();
ctx.setLineDash([]);
}
if(showX&&norm==='ratio'){
ctx.strokeStyle='rgba(255,215,0,0.5)';ctx.lineWidth=2;ctx.setLineDash([5,5]);
ctx.beginPath();ctx.moveTo(pad,c.height-pad-(1-yMin)*scY);ctx.lineTo(c.width-pad,c.height-pad-(1-yMin)*scY);ctx.stroke();
ctx.setLineDash([]);
}

// Draw ψ(x)
ctx.strokeStyle='#00d9ff';ctx.lineWidth=2;
ctx.beginPath();
for(let i=0;i<data1.length;i++){
const px=pad+i*scX;
const py=c.height-pad-(data1[i]-yMin)*scY;
if(i===0)ctx.moveTo(px,py);else ctx.lineTo(px,py);
}ctx.stroke();

// Draw θ(x) if showing both
if((func==='both'||func==='theta')&&data2){
ctx.strokeStyle='#ff6496';ctx.lineWidth=2;
ctx.beginPath();
for(let i=0;i<data2.length;i++){
const px=pad+i*scX;
const py=c.height-pad-(data2[i]-yMin)*scY;
if(i===0)ctx.moveTo(px,py);else ctx.lineTo(px,py);
}ctx.stroke();
}

// Title
ctx.fillStyle=isDark()?'#ffd700':'#cc8800';ctx.font='bold 14px Segoe UI';ctx.textAlign='center';
ctx.fillText(`Chebyshev Functions — x ≤ ${maxX}`,c.width/2,25);

// Labels
ctx.fillStyle=isDark()?'#fff':'#000';ctx.font='12px Segoe UI';
ctx.textAlign='center';ctx.fillText('x',c.width/2,c.height-15);
ctx.save();ctx.translate(15,c.height/2);ctx.rotate(-Math.PI/2);ctx.fillText(label1,0,0);ctx.restore();

// Stats
const finalPsi=psi[maxX];
const finalTheta=theta[maxX];
const psiRatio=finalPsi/maxX;
const thetaRatio=finalTheta/maxX;
const error=finalPsi-maxX;
const normError=error/Math.sqrt(maxX);
const primeCount=primes.length;

legend('alcheb','Chebyshev',[['ψ('+maxX+')',fmt(finalPsi),'#00d9ff'],['θ('+maxX+')',fmt(finalTheta),'#ff6496'],['Primes',primeCount,'#ffd700']]);

document.getElementById('chebLiveStats').innerHTML=`
<div style="display:grid;grid-template-columns:repeat(3,1fr);gap:8px;margin-bottom:12px">
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center"><div style="font-size:1.3rem;font-weight:bold;color:#00d9ff">${fmt(finalPsi)}</div><div style="font-size:.7rem;color:var(--txt2)">ψ(${maxX})</div></div>
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center"><div style="font-size:1.3rem;font-weight:bold;color:#ff6496">${fmt(finalTheta)}</div><div style="font-size:.7rem;color:var(--txt2)">θ(${maxX})</div></div>
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center"><div style="font-size:1.3rem;font-weight:bold;color:#ffd700">${primeCount}</div><div style="font-size:.7rem;color:var(--txt2)">π(${maxX})</div></div>
</div>
<div style="margin-bottom:10px;padding-bottom:8px;border-bottom:1px solid var(--bord)">
<strong style="color:var(--acc)">Prime Number Theorem</strong>
<div style="display:grid;grid-template-columns:1fr 1fr;gap:4px;margin-top:6px;font-size:.8rem">
<span>ψ(x)/x:</span><span style="color:#00d9ff;font-weight:bold">${fmt(psiRatio)} (→1)</span>
<span>θ(x)/x:</span><span style="color:#ff6496;font-weight:bold">${fmt(thetaRatio)} (→1)</span>
<span>ψ(x) - x:</span><span style="color:${error<0?'#ff6496':'#00ff88'}">${fmt(error)}</span>
<span>(ψ(x)-x)/√x:</span><span style="color:#ffd700">${fmt(normError)}</span>
</div>
</div>
<div style="margin-bottom:10px;padding-bottom:8px;border-bottom:1px solid var(--bord)">
<strong style="color:var(--acc)">Von Mangoldt Λ(n)</strong>
<div style="display:grid;grid-template-columns:1fr 1fr;gap:4px;margin-top:6px;font-size:.8rem">
<span>Λ(n)>0 count:</span><span style="color:#00d9ff">${lambda.filter(l=>l>0).length}</span>
<span>Max Λ(n):</span><span style="color:#ffd700">${fmt(Math.max(...lambda))}</span>
<span>Σ Λ(n):</span><span style="color:#ff6496">${fmt(finalPsi)}</span>
<span>ψ-θ diff:</span><span style="color:#9664ff">${fmt(finalPsi-finalTheta)}</span>
</div>
</div>
<div style="background:rgba(0,217,255,.1);padding:8px;border-radius:6px">
<strong style="color:#00d9ff">PNT Verification</strong>
<div style="font-size:.75rem;color:var(--txt2);margin-top:4px">ψ(x)/x = ${fmt(psiRatio)} ≈ 1 confirms PNT</div>
</div>`;

// Plotly charts
Plotly.newPlot('pchebRatio',[
{x:[...Array(maxX-1)].map((_,i)=>i+2),y:psi.slice(2).map((v,i)=>v/(i+2)),name:'ψ(x)/x',line:{color:'#00d9ff'}},
{x:[...Array(maxX-1)].map((_,i)=>i+2),y:psi.slice(2).map(()=>1),name:'y=1',line:{color:'#ffd700',dash:'dash'}}
],{...plo(),xaxis:{title:'x'},yaxis:{title:'Ratio',range:[0.8,1.2]}});

const lambdaX=[],lambdaY=[];
for(let n=2;n<=Math.min(maxX,500);n++)if(lambda[n]>0){lambdaX.push(n);lambdaY.push(lambda[n]);}
Plotly.newPlot('pchebLambda',[{x:lambdaX,y:lambdaY,type:'bar',name:'Λ(n)',marker:{color:'#9664ff'}}],{...plo(),xaxis:{title:'n'},yaxis:{title:'Λ(n)'}});

// Click handler
c.onclick=e=>{
const rect=c.getBoundingClientRect();
const mx=(e.clientX-rect.left)*(c.width/rect.width);
const n=Math.round((mx-pad)/scX+2);
if(n>=2&&n<=maxX){
modal(`Chebyshev at x=${n}`,[
['x',n],['ψ(x)',fmt(psi[n])],['θ(x)',fmt(theta[n])],
['Λ(n)',fmt(lambda[n])],['ψ(x)/x',fmt(psi[n]/n)],
['ψ(x)-x',fmt(psi[n]-n)],['(ψ(x)-x)/√x',fmt((psi[n]-n)/Math.sqrt(n))]
]);
}};
}

async function screenshotChebyshev(){
const maxX=document.getElementById('chebXv').value;
await screenshotUnified('ccheb','chebLiveStats',`Chebyshev Functions — x ≤ ${maxX}`,'chebyshev_complete.png',{dashH:350});
}

function csvChebyshev(){
let s='n,lambda_n,psi_n,theta_n,psi_over_n\n';
for(let n=2;n<=chebyshevData.maxX;n++)s+=`${n},${chebyshevData.lambda[n]},${chebyshevData.psi[n]},${chebyshevData.theta[n]},${chebyshevData.psi[n]/n}\n`;
dl(s,'chebyshev_data.csv');
}

// ==================== LOGARITHMIC INTEGRAL Li(x) ====================
let liData={pi:[],li:[],xln:[],R:[],maxX:0};

function logIntegral(x){
// Li(x) = ∫₂ˣ dt/ln(t) using numerical integration
if(x<2)return 0;
let sum=0;
const steps=Math.max(100,Math.floor(x/10));
const dx=(x-2)/steps;
for(let i=0;i<steps;i++){
const t1=2+i*dx;
const t2=2+(i+1)*dx;
const tm=(t1+t2)/2;
sum+=dx/Math.log(tm);
}
return sum;
}

function riemannR(x){
// R(x) = Σ μ(n)/n · Li(x^{1/n}) - approximation using first terms
if(x<2)return 0;
let sum=0;
const maxN=Math.floor(Math.log2(x))+5;
const mu=[0,1,-1,-1,0,-1,1,-1,0,0,1,-1,0,-1,1,1,0,-1,0,-1,0];
for(let n=1;n<=Math.min(maxN,20);n++){
if(n<mu.length&&mu[n]!==0){
const xn=Math.pow(x,1/n);
if(xn>=2)sum+=mu[n]/n*logIntegral(xn);
}
}
return sum;
}

function drawLi(){
const c=document.getElementById('cli'),ctx=c.getContext('2d');
const maxX=+document.getElementById('liXv').value||+document.getElementById('liX').value;
const viz=document.getElementById('liViz').value;
const showPi=document.getElementById('liShowPi').checked;
const showLi=document.getElementById('liShowLi').checked;
const showXln=document.getElementById('liShowXln').checked;
const showR=document.getElementById('liShowR').checked;
const scale=document.getElementById('liScale').value;
const ptSz=+document.getElementById('liPtSz').value;

ctx.fillStyle=canvBg();ctx.fillRect(0,0,c.width,c.height);

// Compute values
const primes=sievePrimes(maxX);
const piVals=new Array(maxX+1).fill(0);
let pCount=0;
for(let n=2;n<=maxX;n++){
if(primes.includes(n))pCount++;
piVals[n]=pCount;
}

const samplePoints=Math.min(200,maxX);
const step=Math.max(1,Math.floor(maxX/samplePoints));
const xs=[],piArr=[],liArr=[],xlnArr=[],rArr=[];

for(let x=10;x<=maxX;x+=step){
xs.push(x);
piArr.push(piVals[x]);
liArr.push(logIntegral(x));
xlnArr.push(x/Math.log(x));
if(showR)rArr.push(riemannR(x));
}

liData={pi:piArr,li:liArr,xln:xlnArr,R:rArr,xs,maxX,piVals};

const pad=60,w=c.width-2*pad,h=c.height-2*pad;

// Determine range based on visualization
let yMin=0,yMax;
if(viz==='error'){
const errors=piArr.map((p,i)=>p-liArr[i]);
yMin=Math.min(...errors)-5;yMax=Math.max(...errors)+5;
}else if(viz==='ratio'){
yMin=0.9;yMax=1.1;
}else if(viz==='density'){
yMin=0;yMax=0.5;
}else{
yMax=Math.max(...piArr,...liArr)*1.1;
}

const scX=w/(maxX-10);
const scY=h/(yMax-yMin);

// Grid
ctx.strokeStyle=gridC();ctx.lineWidth=0.5;
for(let i=0;i<=10;i++){
const gx=pad+i*w/10,gy=pad+i*h/10;
ctx.beginPath();ctx.moveTo(gx,pad);ctx.lineTo(gx,c.height-pad);ctx.stroke();
ctx.beginPath();ctx.moveTo(pad,gy);ctx.lineTo(c.width-pad,gy);ctx.stroke();
}

// Draw based on visualization mode
if(viz==='comparison'){
// π(x)
if(showPi){
ctx.strokeStyle='#00d9ff';ctx.lineWidth=2;
ctx.beginPath();
for(let i=0;i<xs.length;i++){
const px=pad+(xs[i]-10)*scX;
const py=c.height-pad-(piArr[i]-yMin)*scY;
if(i===0)ctx.moveTo(px,py);else ctx.lineTo(px,py);
}ctx.stroke();
}
// Li(x)
if(showLi){
ctx.strokeStyle='#ff6496';ctx.lineWidth=2;
ctx.beginPath();
for(let i=0;i<xs.length;i++){
const px=pad+(xs[i]-10)*scX;
const py=c.height-pad-(liArr[i]-yMin)*scY;
if(i===0)ctx.moveTo(px,py);else ctx.lineTo(px,py);
}ctx.stroke();
}
// x/ln(x)
if(showXln){
ctx.strokeStyle='#ffd700';ctx.lineWidth=2;ctx.setLineDash([5,3]);
ctx.beginPath();
for(let i=0;i<xs.length;i++){
const px=pad+(xs[i]-10)*scX;
const py=c.height-pad-(xlnArr[i]-yMin)*scY;
if(i===0)ctx.moveTo(px,py);else ctx.lineTo(px,py);
}ctx.stroke();ctx.setLineDash([]);
}
// R(x)
if(showR&&rArr.length>0){
ctx.strokeStyle='#9664ff';ctx.lineWidth=2;
ctx.beginPath();
for(let i=0;i<xs.length;i++){
const px=pad+(xs[i]-10)*scX;
const py=c.height-pad-(rArr[i]-yMin)*scY;
if(i===0)ctx.moveTo(px,py);else ctx.lineTo(px,py);
}ctx.stroke();
}
}else if(viz==='error'){
const errors=piArr.map((p,i)=>p-liArr[i]);
ctx.strokeStyle='#ff6496';ctx.lineWidth=2;
ctx.beginPath();
for(let i=0;i<xs.length;i++){
const px=pad+(xs[i]-10)*scX;
const py=c.height-pad-(errors[i]-yMin)*scY;
if(i===0)ctx.moveTo(px,py);else ctx.lineTo(px,py);
}ctx.stroke();
// Zero line
ctx.strokeStyle='rgba(255,215,0,0.5)';ctx.lineWidth=1;ctx.setLineDash([5,5]);
const y0=c.height-pad-(0-yMin)*scY;
ctx.beginPath();ctx.moveTo(pad,y0);ctx.lineTo(c.width-pad,y0);ctx.stroke();ctx.setLineDash([]);
}else if(viz==='ratio'){
const ratios=piArr.map((p,i)=>liArr[i]>0?p/liArr[i]:1);
ctx.strokeStyle='#00d9ff';ctx.lineWidth=2;
ctx.beginPath();
for(let i=0;i<xs.length;i++){
const px=pad+(xs[i]-10)*scX;
const py=c.height-pad-(ratios[i]-yMin)*scY;
if(i===0)ctx.moveTo(px,py);else ctx.lineTo(px,py);
}ctx.stroke();
// y=1 line
ctx.strokeStyle='rgba(255,215,0,0.5)';ctx.lineWidth=2;ctx.setLineDash([5,5]);
const y1=c.height-pad-(1-yMin)*scY;
ctx.beginPath();ctx.moveTo(pad,y1);ctx.lineTo(c.width-pad,y1);ctx.stroke();ctx.setLineDash([]);
}else if(viz==='density'){
const density=xs.map(x=>1/Math.log(x));
ctx.strokeStyle='#ffd700';ctx.lineWidth=2;
ctx.beginPath();
for(let i=0;i<xs.length;i++){
const px=pad+(xs[i]-10)*scX;
const py=c.height-pad-(density[i]-yMin)*scY;
if(i===0)ctx.moveTo(px,py);else ctx.lineTo(px,py);
}ctx.stroke();
}

// Title
ctx.fillStyle=isDark()?'#ffd700':'#cc8800';ctx.font='bold 14px Segoe UI';ctx.textAlign='center';
ctx.fillText(`Prime Counting: π(x), Li(x), x/ln(x) — x ≤ ${maxX}`,c.width/2,25);

// Labels
ctx.fillStyle=isDark()?'#fff':'#000';ctx.font='12px Segoe UI';
ctx.textAlign='center';ctx.fillText('x',c.width/2,c.height-15);

// Stats
const finalPi=piVals[maxX];
const finalLi=logIntegral(maxX);
const finalXln=maxX/Math.log(maxX);
const finalR=showR?riemannR(maxX):0;
const errorLi=finalPi-finalLi;
const errorXln=finalPi-finalXln;
const relErrorLi=errorLi/finalPi*100;
const relErrorXln=errorXln/finalPi*100;

legend('alli','Prime Counting',[['π(x)',finalPi,'#00d9ff'],['Li(x)',fmt(finalLi),'#ff6496'],['x/ln(x)',fmt(finalXln),'#ffd700']]);

document.getElementById('liLiveStats').innerHTML=`
<div style="display:grid;grid-template-columns:repeat(3,1fr);gap:8px;margin-bottom:12px">
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center"><div style="font-size:1.3rem;font-weight:bold;color:#00d9ff">${finalPi}</div><div style="font-size:.7rem;color:var(--txt2)">π(${maxX})</div></div>
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center"><div style="font-size:1.3rem;font-weight:bold;color:#ff6496">${fmt(finalLi)}</div><div style="font-size:.7rem;color:var(--txt2)">Li(${maxX})</div></div>
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center"><div style="font-size:1.3rem;font-weight:bold;color:#ffd700">${fmt(finalXln)}</div><div style="font-size:.7rem;color:var(--txt2)">x/ln(x)</div></div>
</div>
<div style="margin-bottom:10px;padding-bottom:8px;border-bottom:1px solid var(--bord)">
<strong style="color:var(--acc)">Approximation Errors</strong>
<div style="display:grid;grid-template-columns:1fr 1fr;gap:4px;margin-top:6px;font-size:.8rem">
<span>π(x) - Li(x):</span><span style="color:#ff6496;font-weight:bold">${fmt(errorLi)}</span>
<span>π(x) - x/ln(x):</span><span style="color:#ffd700;font-weight:bold">${fmt(errorXln)}</span>
<span>Li(x) rel error:</span><span style="color:#ff6496">${fmt(relErrorLi)}%</span>
<span>x/ln(x) rel error:</span><span style="color:#ffd700">${fmt(relErrorXln)}%</span>
</div>
</div>
<div style="margin-bottom:10px;padding-bottom:8px;border-bottom:1px solid var(--bord)">
<strong style="color:var(--acc)">Approximation Quality</strong>
<div style="display:grid;grid-template-columns:1fr 1fr;gap:4px;margin-top:6px;font-size:.8rem">
<span>π(x)/Li(x):</span><span style="color:#00d9ff">${fmt(finalPi/finalLi)}</span>
<span>π(x)/(x/ln x):</span><span style="color:#ffd700">${fmt(finalPi/finalXln)}</span>
<span>Li(x) advantage:</span><span style="color:#00ff88">${fmt(Math.abs(errorXln)-Math.abs(errorLi))} closer</span>
${showR?`<span>R(x) error:</span><span style="color:#9664ff">${fmt(finalPi-finalR)}</span>`:''}
</div>
</div>
<div style="background:rgba(255,100,150,.1);padding:8px;border-radius:6px">
<strong style="color:#ff6496">Li(x) > π(x) Always?</strong>
<div style="font-size:.75rem;color:var(--txt2);margin-top:4px">Currently Li(x) - π(x) = ${fmt(finalLi-finalPi)} > 0. First crossover at ~10³¹⁶!</div>
</div>`;

// Plotly charts
Plotly.newPlot('pliError',[{x:xs,y:piArr.map((p,i)=>p-liArr[i]),name:'π(x)-Li(x)',line:{color:'#ff6496'}}],{...plo(),xaxis:{title:'x'},yaxis:{title:'Error'}});
Plotly.newPlot('pliQuality',[
{x:xs,y:piArr.map((p,i)=>Math.abs(p-liArr[i])),name:'|π(x)-Li(x)|',line:{color:'#ff6496'}},
{x:xs,y:piArr.map((p,i)=>Math.abs(p-xlnArr[i])),name:'|π(x)-x/ln(x)|',line:{color:'#ffd700'}}
],{...plo(),xaxis:{title:'x'},yaxis:{title:'Absolute Error'}});

// Click handler
c.onclick=e=>{
const rect=c.getBoundingClientRect();
const mx=(e.clientX-rect.left)*(c.width/rect.width);
const x=Math.round((mx-pad)/scX+10);
if(x>=10&&x<=maxX){
const pi=piVals[x]||0;
const li=logIntegral(x);
const xln=x/Math.log(x);
modal(`Prime Counting at x=${x}`,[
['x',x],['π(x)',pi],['Li(x)',fmt(li)],['x/ln(x)',fmt(xln)],
['π(x)-Li(x)',fmt(pi-li)],['π(x)-x/ln(x)',fmt(pi-xln)],
['π(x)/Li(x)',fmt(pi/li)]
]);
}};
}

async function screenshotLi(){
const maxX=document.getElementById('liXv').value;
await screenshotUnified('cli','liLiveStats',`Logarithmic Integral Li(x) — x ≤ ${maxX}`,'li_complete.png',{dashH:350});
}

function csvLi(){
let s='x,pi_x,Li_x,x_over_ln_x,pi_minus_Li\n';
for(let i=0;i<liData.xs.length;i++){
const x=liData.xs[i];
s+=`${x},${liData.pi[i]},${liData.li[i]},${liData.xln[i]},${liData.pi[i]-liData.li[i]}\n`;
}
dl(s,'li_data.csv');
}

// ==================== DIVISOR FUNCTIONS τ(n), σ(n) ====================
let divisorData={tau:[],sigma:[],maxN:0};

function computeDivisors(n){
let tau=0,sigma=0;
for(let d=1;d*d<=n;d++){
if(n%d===0){
tau+=d*d===n?1:2;
sigma+=d*d===n?d:d+n/d;
}}
return{tau,sigma};
}

function sigmaK(n,k){
let sum=0;
for(let d=1;d*d<=n;d++){
if(n%d===0){
sum+=Math.pow(d,k);
if(d*d!==n)sum+=Math.pow(n/d,k);
}}
return sum;
}

function isHighlyComposite(n,tauArr){
const t=tauArr[n];
for(let i=1;i<n;i++)if(tauArr[i]>=t)return false;
return true;
}

function drawDivisor(){
const c=document.getElementById('cdiv'),ctx=c.getContext('2d');
const maxN=+document.getElementById('divNv').value||+document.getElementById('divN').value;
const func=document.getElementById('divFunc').value;
const viz=document.getElementById('divViz').value;
const k=+document.getElementById('divK').value;
const ptSz=+document.getElementById('divPtSz').value;
const showAvg=document.getElementById('divShowAvg').checked;
const showHC=document.getElementById('divShowHC').checked;

ctx.fillStyle=canvBg();ctx.fillRect(0,0,c.width,c.height);

// Compute divisor functions
const tau=new Array(maxN+1).fill(0);
const sigma=new Array(maxN+1).fill(0);
const sigmaK_arr=new Array(maxN+1).fill(0);

for(let n=1;n<=maxN;n++){
const d=computeDivisors(n);
tau[n]=d.tau;
sigma[n]=d.sigma;
if(func==='sigma_k')sigmaK_arr[n]=sigmaK(n,k);
}

divisorData={tau,sigma,sigmaK:sigmaK_arr,maxN};

const pad=60,w=c.width-2*pad,h=c.height-2*pad;

// Determine data and range
let data,ylabel,yMax;
if(func==='tau'){data=tau.slice(1);ylabel='τ(n)';yMax=Math.max(...data)*1.1;}
else if(func==='sigma'){data=sigma.slice(1);ylabel='σ(n)';yMax=Math.max(...data)*1.1;}
else if(func==='sigma_k'){data=sigmaK_arr.slice(1);ylabel=`σ_${k}(n)`;yMax=Math.max(...data)*1.1;}
else{data=tau.slice(1);ylabel='τ(n)';yMax=Math.max(...data)*1.1;}

const scX=w/maxN,scY=h/yMax;

// Grid
ctx.strokeStyle=gridC();ctx.lineWidth=0.5;
for(let i=0;i<=10;i++){
const gx=pad+i*w/10,gy=pad+i*h/10;
ctx.beginPath();ctx.moveTo(gx,pad);ctx.lineTo(gx,c.height-pad);ctx.stroke();
ctx.beginPath();ctx.moveTo(pad,gy);ctx.lineTo(c.width-pad,gy);ctx.stroke();
}

// Average line for τ(n) ~ log n
if(showAvg&&func==='tau'){
ctx.strokeStyle='rgba(255,215,0,0.6)';ctx.lineWidth=2;ctx.setLineDash([5,3]);
ctx.beginPath();
for(let n=2;n<=maxN;n++){
const avg=Math.log(n)+2*0.5772-1;
const px=pad+n*scX;
const py=c.height-pad-avg*scY;
if(n===2)ctx.moveTo(px,py);else ctx.lineTo(px,py);
}ctx.stroke();ctx.setLineDash([]);
}

// Find highly composite numbers
const hcNums=[];
if(showHC){
let maxTau=0;
for(let n=1;n<=maxN;n++){
if(tau[n]>maxTau){hcNums.push(n);maxTau=tau[n];}
}}

// Draw points
const allPts=[];
for(let n=1;n<=maxN;n++){
const val=func==='sigma'?sigma[n]:func==='sigma_k'?sigmaK_arr[n]:tau[n];
const px=pad+n*scX;
const py=c.height-pad-val*scY;
let clr='#00d9ff';
if(showHC&&hcNums.includes(n))clr='#ffd700';
else if(func==='tau'){
if(tau[n]===2)clr='#ff6496'; // prime
else if(tau[n]%2===1)clr='#9664ff'; // square
else clr='#00d9ff';
}
ctx.fillStyle=clr;ctx.beginPath();ctx.arc(px,py,ptSz,0,2*Math.PI);ctx.fill();
allPts.push({n,tau:tau[n],sigma:sigma[n],px,py});
}

// Draw second function if both
if(func==='both'){
ctx.fillStyle='#ff6496';
for(let n=1;n<=maxN;n++){
const val=sigma[n]/maxN*h/yMax*tau[maxN]; // normalize
const px=pad+n*scX;
const py=c.height-pad-sigma[n]/(sigma[maxN]/tau[maxN])*scY;
ctx.beginPath();ctx.arc(px,py,ptSz*0.7,0,2*Math.PI);ctx.fill();
}}

// Title
ctx.fillStyle=isDark()?'#ffd700':'#cc8800';ctx.font='bold 14px Segoe UI';ctx.textAlign='center';
ctx.fillText(`Divisor Functions — n ≤ ${maxN}`,c.width/2,25);

// Labels
ctx.fillStyle=isDark()?'#fff':'#000';ctx.font='12px Segoe UI';
ctx.textAlign='center';ctx.fillText('n',c.width/2,c.height-15);
ctx.save();ctx.translate(15,c.height/2);ctx.rotate(-Math.PI/2);ctx.fillText(ylabel,0,0);ctx.restore();

// Stats
const avgTau=tau.slice(1).reduce((a,b)=>a+b,0)/maxN;
const avgSigma=sigma.slice(1).reduce((a,b)=>a+b,0)/maxN;
const maxTau=Math.max(...tau.slice(1));
const maxTauN=tau.indexOf(maxTau);
const primeCount=tau.slice(1).filter(t=>t===2).length;
const perfectNums=[6,28,496,8128].filter(p=>p<=maxN);
const abundantCount=sigma.slice(1).filter((s,i)=>s>2*(i+1)).length;

legend('aldiv','Divisor Functions',[['Avg τ(n)',fmt(avgTau),'#00d9ff'],['Max τ',maxTau+' at n='+maxTauN,'#ffd700'],['Primes',primeCount,'#ff6496']]);

document.getElementById('divLiveStats').innerHTML=`
<div style="display:grid;grid-template-columns:repeat(3,1fr);gap:8px;margin-bottom:12px">
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center"><div style="font-size:1.3rem;font-weight:bold;color:#00d9ff">${maxN}</div><div style="font-size:.7rem;color:var(--txt2)">MAX n</div></div>
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center"><div style="font-size:1.3rem;font-weight:bold;color:#ffd700">${fmt(avgTau)}</div><div style="font-size:.7rem;color:var(--txt2)">AVG τ(n)</div></div>
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center"><div style="font-size:1.3rem;font-weight:bold;color:#ff6496">${primeCount}</div><div style="font-size:.7rem;color:var(--txt2)">PRIMES</div></div>
</div>
<div style="margin-bottom:10px;padding-bottom:8px;border-bottom:1px solid var(--bord)">
<strong style="color:var(--acc)">Divisor Count τ(n)</strong>
<div style="display:grid;grid-template-columns:1fr 1fr;gap:4px;margin-top:6px;font-size:.8rem">
<span>Maximum τ(n):</span><span style="color:#ffd700;font-weight:bold">${maxTau} at n=${maxTauN}</span>
<span>Average τ(n):</span><span style="color:#00d9ff">${fmt(avgTau)}</span>
<span>Theory (log n):</span><span style="color:#ff6496">${fmt(Math.log(maxN)+2*0.5772-1)}</span>
<span>Highly Composite:</span><span style="color:#9664ff">${hcNums.slice(0,5).join(', ')}...</span>
</div>
</div>
<div style="margin-bottom:10px;padding-bottom:8px;border-bottom:1px solid var(--bord)">
<strong style="color:var(--acc)">Sum of Divisors σ(n)</strong>
<div style="display:grid;grid-template-columns:1fr 1fr;gap:4px;margin-top:6px;font-size:.8rem">
<span>Average σ(n):</span><span style="color:#00d9ff">${fmt(avgSigma)}</span>
<span>Perfect numbers:</span><span style="color:#ffd700">${perfectNums.join(', ')||'none in range'}</span>
<span>Abundant (σ>2n):</span><span style="color:#ff6496">${abundantCount} (${fmt(abundantCount/maxN*100)}%)</span>
<span>Deficient:</span><span style="color:#00ff88">${maxN-abundantCount-perfectNums.length}</span>
</div>
</div>`;

// Plotly charts
const tauDist={};
tau.slice(1).forEach(t=>{tauDist[t]=(tauDist[t]||0)+1;});
Plotly.newPlot('pdivTau',[{x:Object.keys(tauDist).map(Number),y:Object.values(tauDist),type:'bar',marker:{color:'#00d9ff'}}],{...plo(),xaxis:{title:'τ(n)'},yaxis:{title:'Count'}});

const abundancy=sigma.slice(1).map((s,i)=>s/(i+1));
Plotly.newPlot('pdivAbund',[{x:[...Array(maxN)].map((_,i)=>i+1),y:abundancy,type:'scatter',mode:'markers',marker:{size:3,color:'#ff6496'}}],{...plo(),xaxis:{title:'n'},yaxis:{title:'σ(n)/n'},shapes:[{type:'line',x0:1,x1:maxN,y0:2,y1:2,line:{color:'#ffd700',dash:'dash'}}]});

// Click handler
c.onclick=e=>{
const rect=c.getBoundingClientRect();
const mx=(e.clientX-rect.left)*(c.width/rect.width);
const my=(e.clientY-rect.top)*(c.height/rect.height);
for(const pt of allPts){
if(Math.hypot(mx-pt.px,my-pt.py)<ptSz+5){
const factors=[];let n=pt.n,d=2;
while(d*d<=n){if(n%d===0){let c=0;while(n%d===0){c++;n/=d;}factors.push(d+'^'+c);}d++;}
if(n>1)factors.push(n+'^1');
modal(`Divisors of n=${pt.n}`,[
['n',pt.n],['τ(n)',pt.tau],['σ(n)',pt.sigma],
['σ(n)/n',fmt(pt.sigma/pt.n)],['Factorization',factors.join('·')||'1'],
['Type',pt.sigma===2*pt.n?'PERFECT':pt.sigma>2*pt.n?'Abundant':'Deficient']
]);return;
}}};
}

async function screenshotDivisor(){
const maxN=document.getElementById('divNv').value;
await screenshotUnified('cdiv','divLiveStats',`Divisor Functions — n ≤ ${maxN}`,'divisor_complete.png',{dashH:350});
}

function csvDivisor(){
let s='n,tau_n,sigma_n,sigma_over_n\n';
for(let n=1;n<=divisorData.maxN;n++)s+=`${n},${divisorData.tau[n]},${divisorData.sigma[n]},${divisorData.sigma[n]/n}\n`;
dl(s,'divisor_data.csv');
}

// ==================== LIOUVILLE FUNCTION λ(n) ====================
let liouvilleData={lambda:[],L:[],maxN:0};

function bigOmega(n){
// Count prime factors with multiplicity
let count=0,d=2;
while(d*d<=n){while(n%d===0){count++;n/=d;}d++;}
if(n>1)count++;
return count;
}

function computeLiouville(maxN){
const lambda=new Array(maxN+1).fill(0);
const L=new Array(maxN+1).fill(0);
for(let n=1;n<=maxN;n++){
lambda[n]=bigOmega(n)%2===0?1:-1;
L[n]=L[n-1]+lambda[n];
}
return{lambda,L};
}

function drawLiouville(){
const c=document.getElementById('cliou'),ctx=c.getContext('2d');
const maxN=+document.getElementById('liouNv').value||+document.getElementById('liouN').value;
const viz=document.getElementById('liouViz').value;
const col=document.getElementById('liouCol').value;
const showSqrt=document.getElementById('liouBoundSqrt').checked;
const showM=document.getElementById('liouShowM').checked;
const ptSz=+document.getElementById('liouPtSz').value;

ctx.fillStyle=canvBg();ctx.fillRect(0,0,c.width,c.height);

const{lambda,L}=computeLiouville(maxN);
liouvilleData={lambda,L,maxN};

// Also compute M(x) for comparison
let M=null;
if(viz==='comparison'||showM){
const{M:Marr}=computeMertens(maxN);
M=Marr;
}

const pad=60,w=c.width-2*pad,h=c.height-2*pad;

// Determine data and range
let data,ylabel,yMin,yMax;
if(viz==='cumulative'||viz==='comparison'){
data=L.slice(1);
yMin=Math.min(...data);yMax=Math.max(...data);
ylabel='L(x)';
}else if(viz==='normalized'){
data=L.slice(1).map((l,i)=>l/Math.sqrt(i+1));
yMin=Math.min(...data);yMax=Math.max(...data);
ylabel='L(x)/√x';
}else{
data=lambda.slice(1);
yMin=-1.5;yMax=1.5;
ylabel='λ(n)';
}

const margin=Math.abs(yMax-yMin)*0.1||1;
yMin-=margin;yMax+=margin;
const scX=w/maxN,scY=h/(yMax-yMin);

// Grid
ctx.strokeStyle=gridC();ctx.lineWidth=0.5;
for(let i=0;i<=10;i++){
const gx=pad+i*w/10,gy=pad+i*h/10;
ctx.beginPath();ctx.moveTo(gx,pad);ctx.lineTo(gx,c.height-pad);ctx.stroke();
ctx.beginPath();ctx.moveTo(pad,gy);ctx.lineTo(c.width-pad,gy);ctx.stroke();
}

// Zero line
if(yMin<0&&yMax>0){
const y0=c.height-pad+yMin*scY;
ctx.strokeStyle='rgba(255,215,0,0.5)';ctx.lineWidth=1;
ctx.beginPath();ctx.moveTo(pad,y0);ctx.lineTo(c.width-pad,y0);ctx.stroke();
}

// Bounds ±√x
if(showSqrt&&(viz==='cumulative'||viz==='comparison')){
ctx.strokeStyle='rgba(0,255,136,0.4)';ctx.lineWidth=1;ctx.setLineDash([5,3]);
ctx.beginPath();
for(let x=1;x<=maxN;x++){
const px=pad+x*scX;
const py=c.height-pad-(Math.sqrt(x)-yMin)*scY;
if(x===1)ctx.moveTo(px,py);else ctx.lineTo(px,py);
}ctx.stroke();
ctx.beginPath();
for(let x=1;x<=maxN;x++){
const px=pad+x*scX;
const py=c.height-pad-(-Math.sqrt(x)-yMin)*scY;
if(x===1)ctx.moveTo(px,py);else ctx.lineTo(px,py);
}ctx.stroke();
ctx.setLineDash([]);
}

// Draw M(x) if comparison
if((viz==='comparison'||showM)&&M){
ctx.strokeStyle='rgba(255,100,150,0.6)';ctx.lineWidth=1.5;
ctx.beginPath();
for(let n=1;n<=maxN;n++){
const px=pad+n*scX;
const py=c.height-pad-(M[n]-yMin)*scY;
if(n===1)ctx.moveTo(px,py);else ctx.lineTo(px,py);
}ctx.stroke();
}

// Draw L(x) or λ(n)
const allPts=[];
if(viz==='lambda'){
for(let n=1;n<=maxN;n++){
const px=pad+n*scX;
const py0=c.height-pad+yMin*scY;
const py=c.height-pad-(lambda[n]-yMin)*scY;
let clr;
if(col==='sign'){clr=lambda[n]===1?'#00ff88':'#ff6496';}
else if(col==='omega'){const om=bigOmega(n);clr=`hsl(${om*50},70%,50%)`;}
else{const mu=computeMertens(n).mu[n];clr=mu!==0?'#ffd700':'#666';}
ctx.fillStyle=clr;
ctx.fillRect(px-ptSz/2,Math.min(py,py0),ptSz,Math.abs(py-py0)||1);
allPts.push({n,lambda:lambda[n],L:L[n],omega:bigOmega(n),px,py});
}
}else{
ctx.strokeStyle='#9664ff';ctx.lineWidth=2;
ctx.beginPath();
for(let n=1;n<=maxN;n++){
const val=viz==='normalized'?L[n]/Math.sqrt(n):L[n];
const px=pad+n*scX;
const py=c.height-pad-(val-yMin)*scY;
if(n===1)ctx.moveTo(px,py);else ctx.lineTo(px,py);
allPts.push({n,lambda:lambda[n],L:L[n],omega:bigOmega(n),px,py});
}ctx.stroke();
}

// Title
ctx.fillStyle=isDark()?'#ffd700':'#cc8800';ctx.font='bold 14px Segoe UI';ctx.textAlign='center';
ctx.fillText(`Liouville Function L(x) = Σλ(n) — n ≤ ${maxN}`,c.width/2,25);

// Labels
ctx.fillStyle=isDark()?'#fff':'#000';ctx.font='12px Segoe UI';
ctx.textAlign='center';ctx.fillText('n',c.width/2,c.height-15);
ctx.save();ctx.translate(15,c.height/2);ctx.rotate(-Math.PI/2);ctx.fillText(ylabel,0,0);ctx.restore();

// Stats
const finalL=L[maxN];
const sqrtN=Math.sqrt(maxN);
const ratio=finalL/sqrtN;
const lambda1Count=lambda.slice(1).filter(l=>l===1).length;
const lambdaNeg1Count=lambda.slice(1).filter(l=>l===-1).length;
const maxL=Math.max(...L.slice(1));
const minL=Math.min(...L.slice(1));

legend('alliou','Liouville L(x)',[['L('+maxN+')',finalL,'#9664ff'],['Max L',maxL,'#00ff88'],['Min L',minL,'#ff6496']]);

document.getElementById('liouLiveStats').innerHTML=`
<div style="display:grid;grid-template-columns:repeat(3,1fr);gap:8px;margin-bottom:12px">
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center"><div style="font-size:1.3rem;font-weight:bold;color:#9664ff">${finalL}</div><div style="font-size:.7rem;color:var(--txt2)">L(${maxN})</div></div>
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center"><div style="font-size:1.3rem;font-weight:bold;color:#ffd700">${fmt(ratio)}</div><div style="font-size:.7rem;color:var(--txt2)">L(x)/√x</div></div>
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center"><div style="font-size:1.3rem;font-weight:bold;color:${finalL<=0?'#00ff88':'#ff6496'}">${finalL<=0?'YES':'NO'}</div><div style="font-size:.7rem;color:var(--txt2)">L(x)≤0?</div></div>
</div>
<div style="margin-bottom:10px;padding-bottom:8px;border-bottom:1px solid var(--bord)">
<strong style="color:var(--acc)">Liouville Values</strong>
<div style="display:grid;grid-template-columns:1fr 1fr;gap:4px;margin-top:6px;font-size:.8rem">
<span>Maximum L(x):</span><span style="color:#00ff88;font-weight:bold">${maxL}</span>
<span>Minimum L(x):</span><span style="color:#ff6496;font-weight:bold">${minL}</span>
<span>√x bound:</span><span style="color:#ffd700">±${fmt(sqrtN)}</span>
<span>|L(x)/√x| max:</span><span style="color:#9664ff">${fmt(Math.max(Math.abs(maxL),Math.abs(minL))/sqrtN)}</span>
</div>
</div>
<div style="margin-bottom:10px;padding-bottom:8px;border-bottom:1px solid var(--bord)">
<strong style="color:var(--acc)">λ(n) Distribution</strong>
<div style="display:grid;grid-template-columns:1fr 1fr;gap:4px;margin-top:6px;font-size:.8rem">
<span>λ(n) = +1 (even Ω):</span><span style="color:#00ff88">${lambda1Count} (${fmt(lambda1Count/maxN*100)}%)</span>
<span>λ(n) = -1 (odd Ω):</span><span style="color:#ff6496">${lambdaNeg1Count} (${fmt(lambdaNeg1Count/maxN*100)}%)</span>
<span>Imbalance:</span><span style="color:#9664ff">${lambda1Count-lambdaNeg1Count}</span>
<span>Note:</span><span style="color:var(--txt2)">λ(n) never 0</span>
</div>
</div>
<div style="background:${finalL<=0?'rgba(0,255,136,.1)':'rgba(255,100,150,.1)'};padding:8px;border-radius:6px">
<strong style="color:${finalL<=0?'#00ff88':'#ff6496'}">Pólya Status: L(${maxN}) ${finalL<=0?'≤':'>'} 0</strong>
<div style="font-size:.75rem;color:var(--txt2);margin-top:4px">First counterexample at x ≈ 906,150,257</div>
</div>`;

// Plotly charts
Plotly.newPlot('pliouRatio',[{x:[...Array(maxN)].map((_,i)=>i+1),y:L.slice(1).map((l,i)=>l/Math.sqrt(i+1)),type:'scatter',mode:'lines',name:'L(x)/√x',line:{color:'#9664ff'}}],{...plo(),xaxis:{title:'x'},yaxis:{title:'L(x)/√x'}});

const omegaDist={};
for(let n=1;n<=maxN;n++){const om=bigOmega(n);omegaDist[om]=(omegaDist[om]||0)+1;}
Plotly.newPlot('pliouOmega',[{x:Object.keys(omegaDist).map(Number),y:Object.values(omegaDist),type:'bar',marker:{color:'#00d9ff'}}],{...plo(),xaxis:{title:'Ω(n)'},yaxis:{title:'Count'}});

// Click handler
c.onclick=e=>{
const rect=c.getBoundingClientRect();
const mx=(e.clientX-rect.left)*(c.width/rect.width);
const my=(e.clientY-rect.top)*(c.height/rect.height);
for(const pt of allPts){
if(Math.hypot(mx-pt.px,my-pt.py)<ptSz+5){
modal(`Liouville at n=${pt.n}`,[
['n',pt.n],['λ(n)',pt.lambda],['Ω(n)',pt.omega],
['L(n)',pt.L],['L(n)/√n',fmt(pt.L/Math.sqrt(pt.n))],
['√n',fmt(Math.sqrt(pt.n))]
]);return;
}}};
}

async function screenshotLiouville(){
const maxN=document.getElementById('liouNv').value;
await screenshotUnified('cliou','liouLiveStats',`Liouville Function L(x) — n ≤ ${maxN}`,'liouville_complete.png',{dashH:350});
}

function csvLiouville(){
let s='n,lambda_n,L_n,Omega_n,L_over_sqrt_n\n';
for(let n=1;n<=liouvilleData.maxN;n++)s+=`${n},${liouvilleData.lambda[n]},${liouvilleData.L[n]},${bigOmega(n)},${liouvilleData.L[n]/Math.sqrt(n)}\n`;
dl(s,'liouville_data.csv');
}

// ==================== VON MANGOLDT Λ(n) ====================
let mangoldtData={lambda:[],psi:[],maxN:0};

function computeMangoldt(maxN){
const lambda=new Array(maxN+1).fill(0);
const psi=new Array(maxN+1).fill(0);
const primes=sievePrimes(Math.floor(Math.sqrt(maxN))+1);
const primeSet=new Set(sievePrimes(maxN));

for(let n=2;n<=maxN;n++){
// Check if n is a prime power
let isPrimePower=false,base=0,power=0;
for(const p of primes){
if(p>n)break;
let k=0,m=n;
while(m%p===0){m/=p;k++;}
if(m===1&&k>0){isPrimePower=true;base=p;power=k;break;}
}
if(isPrimePower){
lambda[n]=Math.log(base);
}
psi[n]=psi[n-1]+lambda[n];
}
return{lambda,psi,primeSet};
}

function drawMangoldt(){
const c=document.getElementById('cmang'),ctx=c.getContext('2d');
const maxN=+document.getElementById('mangNv').value||+document.getElementById('mangN').value;
const viz=document.getElementById('mangViz').value;
const col=document.getElementById('mangCol').value;
const showPrimes=document.getElementById('mangShowPrimes').checked;
const showPowers=document.getElementById('mangShowPowers').checked;
const showPsi=document.getElementById('mangShowPsi').checked;
const ptSz=+document.getElementById('mangPtSz').value;

ctx.fillStyle=canvBg();ctx.fillRect(0,0,c.width,c.height);

const{lambda,psi,primeSet}=computeMangoldt(maxN);
mangoldtData={lambda,psi,maxN};

const pad=60,w=c.width-2*pad,h=c.height-2*pad;

// Determine range
let yMax;
if(viz==='cumulative'){yMax=psi[maxN]*1.1;}
else{yMax=Math.max(...lambda.slice(1))*1.2;}

const scX=w/maxN,scY=h/yMax;

// Grid
ctx.strokeStyle=gridC();ctx.lineWidth=0.5;
for(let i=0;i<=10;i++){
const gx=pad+i*w/10,gy=pad+i*h/10;
ctx.beginPath();ctx.moveTo(gx,pad);ctx.lineTo(gx,c.height-pad);ctx.stroke();
ctx.beginPath();ctx.moveTo(pad,gy);ctx.lineTo(c.width-pad,gy);ctx.stroke();
}

// y=x reference for ψ(x)
if(viz==='cumulative'||showPsi){
ctx.strokeStyle='rgba(255,215,0,0.4)';ctx.lineWidth=2;ctx.setLineDash([5,5]);
ctx.beginPath();ctx.moveTo(pad,c.height-pad);ctx.lineTo(c.width-pad,c.height-pad-maxN*scY);ctx.stroke();
ctx.setLineDash([]);
}

// Draw ψ(x) line
if(viz==='cumulative'||showPsi){
ctx.strokeStyle='#00d9ff';ctx.lineWidth=2;
ctx.beginPath();
for(let n=2;n<=maxN;n++){
const px=pad+n*scX;
const py=c.height-pad-psi[n]*scY;
if(n===2)ctx.moveTo(px,py);else ctx.lineTo(px,py);
}ctx.stroke();
}

// Draw Λ(n) bars
const allPts=[];
if(viz!=='cumulative'){
for(let n=2;n<=maxN;n++){
if(lambda[n]===0)continue;
// Determine if prime or higher power
const isPrime=primeSet.has(n);
const logVal=lambda[n];
const base=Math.round(Math.exp(logVal));
const power=Math.round(Math.log(n)/Math.log(base));

if(isPrime&&!showPrimes)continue;
if(!isPrime&&!showPowers)continue;

const px=pad+n*scX;
const py=c.height-pad-logVal*scY;
const py0=c.height-pad;

let clr;
if(col==='prime'){
// Color by prime base
const hue=(base*37)%360;
clr=`hsl(${hue},70%,50%)`;
}else if(col==='power'){
clr=power===1?'#00d9ff':power===2?'#ff6496':power===3?'#ffd700':'#9664ff';
}else{
// By size
const t=logVal/Math.log(maxN);
clr=`hsl(${(1-t)*240},70%,50%)`;
}

ctx.fillStyle=clr;
ctx.fillRect(px-ptSz/2,py,ptSz,py0-py);
allPts.push({n,lambda:logVal,base,power,isPrime,px,py});
}}

// Title
ctx.fillStyle=isDark()?'#ffd700':'#cc8800';ctx.font='bold 14px Segoe UI';ctx.textAlign='center';
ctx.fillText(`Von Mangoldt Function Λ(n) — n ≤ ${maxN}`,c.width/2,25);

// Labels
ctx.fillStyle=isDark()?'#fff':'#000';ctx.font='12px Segoe UI';
ctx.textAlign='center';ctx.fillText('n',c.width/2,c.height-15);
ctx.save();ctx.translate(15,c.height/2);ctx.rotate(-Math.PI/2);ctx.fillText(viz==='cumulative'?'ψ(x)':'Λ(n)',0,0);ctx.restore();

// Legend for powers
if(viz!=='cumulative'&&col==='power'){
const legs=[['k=1 (prime)','#00d9ff'],['k=2','#ff6496'],['k=3','#ffd700'],['k≥4','#9664ff']];
let lx=pad;
ctx.font='10px Segoe UI';
legs.forEach(([txt,clr])=>{
ctx.fillStyle=clr;ctx.fillRect(lx,c.height-pad+15,10,10);
ctx.fillStyle=isDark()?'#fff':'#000';ctx.fillText(txt,lx+14,c.height-pad+23);
lx+=80;
});
}

// Stats
const finalPsi=psi[maxN];
const primeCount=lambda.slice(1).filter((l,i)=>l>0&&primeSet.has(i+1)).length;
const powerCount=lambda.slice(1).filter((l,i)=>l>0&&!primeSet.has(i+1)).length;
const maxLambda=Math.max(...lambda.slice(1));
const psiRatio=finalPsi/maxN;

legend('almang','Von Mangoldt',[['ψ('+maxN+')',fmt(finalPsi),'#00d9ff'],['Primes',primeCount,'#ffd700'],['Powers',powerCount,'#ff6496']]);

document.getElementById('mangLiveStats').innerHTML=`
<div style="display:grid;grid-template-columns:repeat(3,1fr);gap:8px;margin-bottom:12px">
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center"><div style="font-size:1.3rem;font-weight:bold;color:#00d9ff">${fmt(finalPsi)}</div><div style="font-size:.7rem;color:var(--txt2)">ψ(${maxN})</div></div>
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center"><div style="font-size:1.3rem;font-weight:bold;color:#ffd700">${primeCount}</div><div style="font-size:.7rem;color:var(--txt2)">PRIMES</div></div>
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center"><div style="font-size:1.3rem;font-weight:bold;color:#ff6496">${powerCount}</div><div style="font-size:.7rem;color:var(--txt2)">POWERS k≥2</div></div>
</div>
<div style="margin-bottom:10px;padding-bottom:8px;border-bottom:1px solid var(--bord)">
<strong style="color:var(--acc)">Chebyshev ψ(x)</strong>
<div style="display:grid;grid-template-columns:1fr 1fr;gap:4px;margin-top:6px;font-size:.8rem">
<span>ψ(x):</span><span style="color:#00d9ff;font-weight:bold">${fmt(finalPsi)}</span>
<span>ψ(x)/x:</span><span style="color:#ffd700">${fmt(psiRatio)} (→1)</span>
<span>ψ(x) - x:</span><span style="color:${finalPsi-maxN<0?'#ff6496':'#00ff88'}">${fmt(finalPsi-maxN)}</span>
<span>(ψ-x)/√x:</span><span style="color:#9664ff">${fmt((finalPsi-maxN)/Math.sqrt(maxN))}</span>
</div>
</div>
<div style="margin-bottom:10px;padding-bottom:8px;border-bottom:1px solid var(--bord)">
<strong style="color:var(--acc)">Prime Powers</strong>
<div style="display:grid;grid-template-columns:1fr 1fr;gap:4px;margin-top:6px;font-size:.8rem">
<span>Total Λ(n)>0:</span><span style="color:#00d9ff">${primeCount+powerCount}</span>
<span>Max Λ(n):</span><span style="color:#ffd700">${fmt(maxLambda)} = log(${Math.round(Math.exp(maxLambda))})</span>
<span>Primes (k=1):</span><span style="color:#00ff88">${primeCount}</span>
<span>Higher powers:</span><span style="color:#ff6496">${powerCount}</span>
</div>
</div>
<div style="background:rgba(0,217,255,.1);padding:8px;border-radius:6px">
<strong style="color:#00d9ff">PNT Check</strong>
<div style="font-size:.75rem;color:var(--txt2);margin-top:4px">ψ(x)/x = ${fmt(psiRatio)} → 1 as x → ∞</div>
</div>`;

// Plotly charts - prime powers by base
const powersByBase={};
for(let n=2;n<=maxN;n++){
if(lambda[n]>0){
const base=Math.round(Math.exp(lambda[n]));
powersByBase[base]=(powersByBase[base]||0)+1;
}}
const bases=Object.keys(powersByBase).map(Number).slice(0,20);
Plotly.newPlot('pmangPowers',[{x:bases,y:bases.map(b=>powersByBase[b]),type:'bar',marker:{color:bases.map(b=>`hsl(${(b*37)%360},70%,50%)`)}}],{...plo(),xaxis:{title:'Prime Base p'},yaxis:{title:'Count of p^k ≤ n'}});

// Distribution of Λ(n) values
const lambdaVals=lambda.slice(1).filter(l=>l>0);
Plotly.newPlot('pmangDist',[{x:lambdaVals,type:'histogram',nbinsx:30,marker:{color:'#9664ff'}}],{...plo(),xaxis:{title:'Λ(n) = log p'},yaxis:{title:'Count'}});

// Click handler
c.onclick=e=>{
const rect=c.getBoundingClientRect();
const mx=(e.clientX-rect.left)*(c.width/rect.width);
const my=(e.clientY-rect.top)*(c.height/rect.height);
for(const pt of allPts){
if(Math.hypot(mx-pt.px,my-pt.py)<ptSz+10){
modal(`Von Mangoldt at n=${pt.n}`,[
['n',pt.n],['Λ(n)',fmt(pt.lambda)],['Base p',pt.base],['Power k',pt.power],
['Type',pt.isPrime?'Prime':'Prime Power'],['n = p^k',`${pt.base}^${pt.power}`],
['ψ(n)',fmt(psi[pt.n])]
]);return;
}}};
}

async function screenshotMangoldt(){
const maxN=document.getElementById('mangNv').value;
await screenshotUnified('cmang','mangLiveStats',`Von Mangoldt Function Λ(n) — n ≤ ${maxN}`,'mangoldt_complete.png',{dashH:350});
}

function csvMangoldt(){
let s='n,Lambda_n,psi_n,is_prime_power\n';
for(let n=2;n<=mangoldtData.maxN;n++)s+=`${n},${mangoldtData.lambda[n]},${mangoldtData.psi[n]},${mangoldtData.lambda[n]>0?1:0}\n`;
dl(s,'mangoldt_data.csv');
}

// ==================== RAMANUJAN SUMS c_q(n) ====================
let ramanujanData={cqn:[],maxQ:0,maxN:0};

function ramanujanMu(n){
if(n===1)return 1;
let pf=0,d=2;
while(d*d<=n){
if(n%d===0){
n/=d;pf++;
if(n%d===0)return 0;
}
d++;
}
if(n>1)pf++;
return pf%2===0?1:-1;
}

function ramanujanSum(q,n){
// c_q(n) = μ(q/d) * φ(q) / φ(q/d) where d = gcd(n,q)
const d=gcd(n,q);
if(q%d!==0)return 0;
const qd=q/d;
return ramanujanMu(qd)*eulerPhi(q)/eulerPhi(qd);
}

function drawRamanujan(){
const c=document.getElementById('cram'),ctx=c.getContext('2d');
const maxQ=+document.getElementById('ramQv').value||+document.getElementById('ramQ').value;
const maxN=+document.getElementById('ramNv').value||+document.getElementById('ramN').value;
const viz=document.getElementById('ramViz').value;
const col=document.getElementById('ramCol').value;
const fixN=+document.getElementById('ramFixN').value||1;

ctx.fillStyle=canvBg();ctx.fillRect(0,0,c.width,c.height);

// Compute c_q(n) values
const cqn=[];
for(let q=1;q<=maxQ;q++){
cqn[q]=[];
for(let n=1;n<=maxN;n++){
cqn[q][n]=ramanujanSum(q,n);
}}
ramanujanData={cqn,maxQ,maxN};

const pad=60,w=c.width-2*pad,h=c.height-2*pad;

if(viz==='heatmap'){
// Draw q vs n heatmap
const cellW=w/maxN,cellH=h/maxQ;
let maxVal=0;
for(let q=1;q<=maxQ;q++)for(let n=1;n<=maxN;n++)maxVal=Math.max(maxVal,Math.abs(cqn[q][n]));

for(let q=1;q<=maxQ;q++){
for(let n=1;n<=maxN;n++){
const val=cqn[q][n];
let clr;
if(col==='diverging'){
const t=val/(maxVal||1);
if(t>0)clr=`rgba(0,200,100,${Math.abs(t)})`;
else if(t<0)clr=`rgba(255,100,100,${Math.abs(t)})`;
else clr='rgba(50,50,80,0.3)';
}else if(col==='magnitude'){
const t=Math.abs(val)/(maxVal||1);
clr=`hsl(${240-t*200},70%,${30+t*40}%)`;
}else{
clr=val>0?'#00ff88':val<0?'#ff6496':'#333';
}
ctx.fillStyle=clr;
ctx.fillRect(pad+(n-1)*cellW,pad+(q-1)*cellH,cellW+0.5,cellH+0.5);
}}

// Axes
ctx.fillStyle=isDark()?'#fff':'#000';ctx.font='12px Segoe UI';
ctx.textAlign='center';ctx.fillText('n',c.width/2,c.height-15);
ctx.save();ctx.translate(15,c.height/2);ctx.rotate(-Math.PI/2);ctx.fillText('q',0,0);ctx.restore();
}else if(viz==='fixedq'){
// Plot c_q(n) for fixed q
const data=cqn[maxQ]||[];
let yMin=Math.min(...data.slice(1)),yMax=Math.max(...data.slice(1));
const margin=(yMax-yMin)*0.1||1;
yMin-=margin;yMax+=margin;
const scX=w/maxN,scY=h/(yMax-yMin);

// Grid and zero line
ctx.strokeStyle=gridC();ctx.lineWidth=0.5;
for(let i=0;i<=10;i++){
ctx.beginPath();ctx.moveTo(pad+i*w/10,pad);ctx.lineTo(pad+i*w/10,c.height-pad);ctx.stroke();
}
if(yMin<0&&yMax>0){
const y0=c.height-pad+yMin*scY;
ctx.strokeStyle='rgba(255,215,0,0.5)';ctx.lineWidth=1;
ctx.beginPath();ctx.moveTo(pad,y0);ctx.lineTo(c.width-pad,y0);ctx.stroke();
}

// Plot bars
for(let n=1;n<=maxN;n++){
const val=data[n]||0;
const px=pad+n*scX;
const py0=c.height-pad+yMin*scY;
const py=c.height-pad-(val-yMin)*scY;
ctx.fillStyle=val>0?'#00ff88':val<0?'#ff6496':'#666';
ctx.fillRect(px-2,Math.min(py,py0),4,Math.abs(py-py0)||1);
}

ctx.fillStyle=isDark()?'#fff':'#000';ctx.font='12px Segoe UI';
ctx.textAlign='center';ctx.fillText('n',c.width/2,c.height-15);
ctx.save();ctx.translate(15,c.height/2);ctx.rotate(-Math.PI/2);ctx.fillText(`c_${maxQ}(n)`,0,0);ctx.restore();
}else if(viz==='circle'){
// Show roots of unity on unit circle
const cx=c.width/2,cy=c.height/2,radius=Math.min(w,h)/2-20;
ctx.strokeStyle=gridC();ctx.lineWidth=1;
ctx.beginPath();ctx.arc(cx,cy,radius,0,2*Math.PI);ctx.stroke();

// Draw all q-th roots
for(let a=0;a<maxQ;a++){
const angle=2*Math.PI*a/maxQ;
const x=cx+radius*Math.cos(angle);
const y=cy-radius*Math.sin(angle);
const isPrim=gcd(a,maxQ)===1;
ctx.fillStyle=isPrim?'#ffd700':'#666';
ctx.beginPath();ctx.arc(x,y,isPrim?6:4,0,2*Math.PI);ctx.fill();
if(isPrim&&maxQ<=24){
ctx.fillStyle=isDark()?'#fff':'#000';ctx.font='10px Segoe UI';
ctx.textAlign='center';ctx.fillText(a,x,y-10);
}}

ctx.fillStyle=isDark()?'#ffd700':'#cc8800';ctx.font='bold 12px Segoe UI';ctx.textAlign='center';
ctx.fillText(`φ(${maxQ}) = ${eulerPhi(maxQ)} primitive roots`,cx,c.height-pad+30);
}

// Title
ctx.fillStyle=isDark()?'#ffd700':'#cc8800';ctx.font='bold 14px Segoe UI';ctx.textAlign='center';
ctx.fillText(`Ramanujan Sum c_q(n) — q = ${maxQ}, n ≤ ${maxN}`,c.width/2,25);

// Stats
const phiQ=eulerPhi(maxQ);
const cq1=ramanujanSum(maxQ,1);
const cqq=ramanujanSum(maxQ,maxQ);
const divisors=[];for(let d=1;d<=maxQ;d++)if(maxQ%d===0)divisors.push(d);

legend('alram','Ramanujan c_q(n)',[['φ(q)',phiQ,'#ffd700'],['c_q(1)',cq1,'#00d9ff'],['c_q(q)',cqq,'#ff6496']]);

document.getElementById('ramLiveStats').innerHTML=`
<div style="display:grid;grid-template-columns:repeat(3,1fr);gap:8px;margin-bottom:12px">
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center"><div style="font-size:1.3rem;font-weight:bold;color:#ffd700">${maxQ}</div><div style="font-size:.7rem;color:var(--txt2)">MODULUS q</div></div>
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center"><div style="font-size:1.3rem;font-weight:bold;color:#00d9ff">${phiQ}</div><div style="font-size:.7rem;color:var(--txt2)">φ(q)</div></div>
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center"><div style="font-size:1.3rem;font-weight:bold;color:#ff6496">${cq1}</div><div style="font-size:.7rem;color:var(--txt2)">c_q(1) = μ(q)</div></div>
</div>
<div style="margin-bottom:10px;padding-bottom:8px;border-bottom:1px solid var(--bord)">
<strong style="color:var(--acc)">Key Values</strong>
<div style="display:grid;grid-template-columns:1fr 1fr;gap:4px;margin-top:6px;font-size:.8rem">
<span>c_q(1) = μ(q):</span><span style="color:#00d9ff;font-weight:bold">${cq1}</span>
<span>c_q(q) = φ(q):</span><span style="color:#ffd700">${phiQ}</span>
<span>Divisors of q:</span><span style="color:#9664ff">${divisors.join(', ')}</span>
<span>c_q(n) range:</span><span style="color:#ff6496">[${-phiQ}, ${phiQ}]</span>
</div>
</div>
<div style="margin-bottom:10px;padding-bottom:8px;border-bottom:1px solid var(--bord)">
<strong style="color:var(--acc)">c_q(n) for First Few n</strong>
<div style="display:grid;grid-template-columns:repeat(5,1fr);gap:4px;margin-top:6px;font-size:.75rem">
${[1,2,3,4,5,6,7,8,9,10].map(n=>`<span>c(${n})=${ramanujanSum(maxQ,n)}</span>`).join('')}
</div>
</div>`;

// Plotly charts
Plotly.newPlot('pramN',[{x:[...Array(maxN)].map((_,i)=>i+1),y:[...Array(maxN)].map((_,i)=>ramanujanSum(maxQ,i+1)),type:'bar',marker:{color:[...Array(maxN)].map((_,i)=>ramanujanSum(maxQ,i+1)>0?'#00ff88':'#ff6496')}}],{...plo(),xaxis:{title:'n'},yaxis:{title:`c_${maxQ}(n)`}});

const divData=divisors.map(d=>({x:d,y:ramanujanSum(maxQ,d)}));
Plotly.newPlot('pramDiv',[{x:divisors,y:divisors.map(d=>ramanujanSum(maxQ,d)),type:'bar',marker:{color:'#ffd700'}}],{...plo(),xaxis:{title:'d | q'},yaxis:{title:'c_q(d)'}});

// Click handler
c.onclick=e=>{
const rect=c.getBoundingClientRect();
const mx=(e.clientX-rect.left)*(c.width/rect.width);
const my=(e.clientY-rect.top)*(c.height/rect.height);
if(viz==='heatmap'){
const cellW=w/maxN,cellH=h/maxQ;
const n=Math.floor((mx-pad)/cellW)+1;
const q=Math.floor((my-pad)/cellH)+1;
if(n>=1&&n<=maxN&&q>=1&&q<=maxQ){
modal(`Ramanujan Sum c_${q}(${n})`,[
['q',q],['n',n],['c_q(n)',ramanujanSum(q,n)],
['gcd(n,q)',gcd(n,q)],['φ(q)',eulerPhi(q)],['μ(q/gcd)',ramanujanMu(q/gcd(n,q))]
]);
}}};
}

async function screenshotRamanujan(){
const q=document.getElementById('ramQv').value;
await screenshotUnified('cram','ramLiveStats',`Ramanujan Sum c_q(n) — q = ${q}`,'ramanujan_complete.png',{dashH:300});
}

function csvRamanujan(){
let s='q,n,c_q_n\n';
for(let q=1;q<=ramanujanData.maxQ;q++)for(let n=1;n<=ramanujanData.maxN;n++)s+=`${q},${n},${ramanujanData.cqn[q][n]}\n`;
dl(s,'ramanujan_data.csv');
}

// ==================== ULAM SPIRAL ====================
let ulamData={grid:[],primes:[],size:0};

function generateUlamSpiral(size,start=1){
const grid=Array(size).fill(null).map(()=>Array(size).fill(0));
const cx=Math.floor(size/2),cy=Math.floor(size/2);
let x=cx,y=cy,n=start;
const dirs=[[1,0],[0,-1],[-1,0],[0,1]]; // right, up, left, down
let dir=0,steps=1,stepCount=0,turnCount=0;

grid[y][x]=n++;
const maxN=start+size*size-1;
const primes=new Set(sievePrimes(maxN));

while(n<=maxN&&x>=0&&x<size&&y>=0&&y<size){
x+=dirs[dir][0];y+=dirs[dir][1];
if(x>=0&&x<size&&y>=0&&y<size)grid[y][x]=n;
n++;stepCount++;
if(stepCount===steps){
stepCount=0;dir=(dir+1)%4;turnCount++;
if(turnCount===2){turnCount=0;steps++;}
}}
return{grid,primes,start};
}

function drawUlam(){
const c=document.getElementById('culam'),ctx=c.getContext('2d');
const size=+document.getElementById('ulamSizev').value||+document.getElementById('ulamSize').value;
const start=+document.getElementById('ulamStart').value||1;
const hl=document.getElementById('ulamHL').value;
const col=document.getElementById('ulamCol').value;
const cellSz=+document.getElementById('ulamCell').value;

ctx.fillStyle=canvBg();ctx.fillRect(0,0,c.width,c.height);

const{grid,primes}=generateUlamSpiral(size,start);
ulamData={grid,primes,size,start};

const pad=10;
const cellW=(c.width-2*pad)/size;
const cellH=(c.height-2*pad)/size;
const actualCell=Math.min(cellW,cellH,cellSz);
const offsetX=(c.width-size*actualCell)/2;
const offsetY=(c.height-size*actualCell)/2;

// Draw grid
let primeCount=0,twinCount=0;
for(let y=0;y<size;y++){
for(let x=0;x<size;x++){
const n=grid[y][x];
if(!n)continue;
const isPrime=primes.has(n);
if(isPrime)primeCount++;

let show=false,clr='#fff';
if(hl==='primes'&&isPrime){show=true;clr='#fff';}
else if(hl==='twin'&&isPrime&&(primes.has(n+2)||primes.has(n-2))){show=true;clr='#ffd700';if(primes.has(n+2))twinCount++;}
else if(hl==='sophie'&&isPrime&&primes.has(2*n+1)){show=true;clr='#ff6496';}
else if(hl==='diagonal'){
const cx=Math.floor(size/2),cy=Math.floor(size/2);
if(x===y||x===size-1-y||x===cx||y===cy){show=isPrime;clr='#00d9ff';}
}else if(hl==='mersenne'){
const log2=Math.log2(n+1);
if(Math.abs(log2-Math.round(log2))<0.01){show=true;clr='#9664ff';}
else if(isPrime)show=true;
}

if(col==='classic'){
if(show){ctx.fillStyle=clr;ctx.fillRect(offsetX+x*actualCell,offsetY+y*actualCell,actualCell,actualCell);}
}else if(col==='heat'){
if(isPrime){
// Count nearby primes for heat
let nearby=0;
for(let dy=-2;dy<=2;dy++)for(let dx=-2;dx<=2;dx++){
const ny=y+dy,nx=x+dx;
if(ny>=0&&ny<size&&nx>=0&&nx<size&&grid[ny][nx]&&primes.has(grid[ny][nx]))nearby++;
}
const t=nearby/25;
ctx.fillStyle=`hsl(${60-t*60},100%,${40+t*30}%)`;
ctx.fillRect(offsetX+x*actualCell,offsetY+y*actualCell,actualCell,actualCell);
}
}else if(col==='mod6'){
if(isPrime){
const mod=n%6;
const colors={1:'#00d9ff',5:'#ff6496'};
ctx.fillStyle=colors[mod]||'#ffd700';
ctx.fillRect(offsetX+x*actualCell,offsetY+y*actualCell,actualCell,actualCell);
}
}else if(col==='gcd'){
if(isPrime){
const g=gcd(x-Math.floor(size/2),y-Math.floor(size/2));
ctx.fillStyle=`hsl(${g*60},70%,50%)`;
ctx.fillRect(offsetX+x*actualCell,offsetY+y*actualCell,actualCell,actualCell);
}
}
}}

// Title
ctx.fillStyle=isDark()?'#ffd700':'#cc8800';ctx.font='bold 14px Segoe UI';ctx.textAlign='center';
ctx.fillText(`Ulam Spiral ${size}×${size} — Start: ${start}`,c.width/2,20);

// Stats
const maxN=start+size*size-1;
const density=primeCount/(size*size)*100;

legend('alulam','Ulam Spiral',[['Primes',primeCount,'#ffd700'],['Total',size*size,'#00d9ff'],['Density',fmt(density)+'%','#ff6496']]);

document.getElementById('ulamLiveStats').innerHTML=`
<div style="display:grid;grid-template-columns:repeat(3,1fr);gap:8px;margin-bottom:12px">
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center"><div style="font-size:1.3rem;font-weight:bold;color:#ffd700">${primeCount}</div><div style="font-size:.7rem;color:var(--txt2)">PRIMES</div></div>
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center"><div style="font-size:1.3rem;font-weight:bold;color:#00d9ff">${size}×${size}</div><div style="font-size:.7rem;color:var(--txt2)">GRID SIZE</div></div>
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center"><div style="font-size:1.3rem;font-weight:bold;color:#ff6496">${fmt(density)}%</div><div style="font-size:.7rem;color:var(--txt2)">DENSITY</div></div>
</div>
<div style="margin-bottom:10px;padding-bottom:8px;border-bottom:1px solid var(--bord)">
<strong style="color:var(--acc)">Spiral Statistics</strong>
<div style="display:grid;grid-template-columns:1fr 1fr;gap:4px;margin-top:6px;font-size:.8rem">
<span>Range:</span><span style="color:#00d9ff">${start} to ${maxN}</span>
<span>Primes in range:</span><span style="color:#ffd700">${primeCount}</span>
<span>Expected (PNT):</span><span style="color:#9664ff">${Math.round(maxN/Math.log(maxN))}</span>
<span>Twin pairs:</span><span style="color:#ff6496">${Math.floor(twinCount/2)}</span>
</div>
</div>
<div style="background:rgba(0,217,255,.1);padding:8px;border-radius:6px">
<strong style="color:#00d9ff">Diagonal Patterns</strong>
<div style="font-size:.75rem;color:var(--txt2);margin-top:4px">Primes cluster on diagonals 4n²+bn+c. Try Euler's n²+n+41!</div>
</div>`;

// Plotly charts - diagonal density
const diagCounts=[];
for(let d=-Math.floor(size/2);d<=Math.floor(size/2);d++){
let count=0;
for(let i=0;i<size;i++){
const y=i,x=i+d+Math.floor(size/2);
if(x>=0&&x<size&&grid[y]&&grid[y][x]&&primes.has(grid[y][x]))count++;
}
diagCounts.push({d,count});
}
Plotly.newPlot('pulamDiag',[{x:diagCounts.map(dc=>dc.d),y:diagCounts.map(dc=>dc.count),type:'bar',marker:{color:'#00d9ff'}}],{...plo(),xaxis:{title:'Diagonal Offset'},yaxis:{title:'Prime Count'}});

// Gap distribution
const primeList=[...primes].filter(p=>p>=start&&p<=maxN).sort((a,b)=>a-b);
const gaps=[];
for(let i=1;i<Math.min(primeList.length,1000);i++)gaps.push(primeList[i]-primeList[i-1]);
Plotly.newPlot('pulamGaps',[{x:gaps,type:'histogram',nbinsx:20,marker:{color:'#ff6496'}}],{...plo(),xaxis:{title:'Gap Size'},yaxis:{title:'Count'}});

// Click handler
c.onclick=e=>{
const rect=c.getBoundingClientRect();
const mx=(e.clientX-rect.left)*(c.width/rect.width);
const my=(e.clientY-rect.top)*(c.height/rect.height);
const gx=Math.floor((mx-offsetX)/actualCell);
const gy=Math.floor((my-offsetY)/actualCell);
if(gx>=0&&gx<size&&gy>=0&&gy<size&&grid[gy]&&grid[gy][gx]){
const n=grid[gy][gx];
modal(`Ulam Spiral at (${gx},${gy})`,[
['Value',n],['Prime?',primes.has(n)?'YES':'NO'],
['Grid Position',`(${gx}, ${gy})`],['Distance from Center',fmt(Math.hypot(gx-size/2,gy-size/2))],
['n mod 6',n%6]
]);
}};
}

async function screenshotUlam(){
const size=document.getElementById('ulamSizev').value;
await screenshotUnified('culam','ulamLiveStats',`Ulam Spiral ${size}×${size}`,'ulam_spiral.png',{dashH:280});
}

function csvUlam(){
let s='x,y,n,is_prime\n';
for(let y=0;y<ulamData.size;y++)for(let x=0;x<ulamData.size;x++){
const n=ulamData.grid[y][x];
if(n)s+=`${x},${y},${n},${ulamData.primes.has(n)?1:0}\n`;
}
dl(s,'ulam_spiral.csv');
}

// ==================== SACKS SPIRAL ====================
let sacksData={points:[],primes:new Set(),maxN:0};

function drawSacks(){
const c=document.getElementById('csacks'),ctx=c.getContext('2d');
const maxN=+document.getElementById('sacksNv').value||+document.getElementById('sacksN').value;
const hl=document.getElementById('sacksHL').value;
const col=document.getElementById('sacksCol').value;
const ptSz=+document.getElementById('sacksPtSz').value;
const showArcs=document.getElementById('sacksShowArcs').checked;
const showGrid=document.getElementById('sacksShowGrid').checked;

ctx.fillStyle=canvBg();ctx.fillRect(0,0,c.width,c.height);

const primes=new Set(sievePrimes(maxN));
sacksData={primes,maxN};

const cx=c.width/2,cy=c.height/2;
const maxR=Math.sqrt(maxN);
const scale=Math.min(c.width,c.height)/2/maxR*0.9;

// Grid circles for perfect squares
if(showGrid){
ctx.strokeStyle=gridC();ctx.lineWidth=0.5;
for(let k=1;k*k<=maxN;k+=Math.ceil(Math.sqrt(maxN)/10)){
ctx.beginPath();ctx.arc(cx,cy,k*scale,0,2*Math.PI);ctx.stroke();
}}

// Draw parabolic arcs (reference curves)
if(showArcs){
ctx.strokeStyle='rgba(255,215,0,0.3)';ctx.lineWidth=1;
// n² + n + 41 (Euler's polynomial)
ctx.beginPath();
for(let n=0;n<Math.sqrt(maxN);n++){
const val=n*n+n+41;
if(val>maxN)break;
const r=Math.sqrt(val)*scale;
const theta=2*Math.PI*Math.sqrt(val);
const x=cx+r*Math.cos(theta);
const y=cy-r*Math.sin(theta);
if(n===0)ctx.moveTo(x,y);else ctx.lineTo(x,y);
}ctx.stroke();
}

// Draw points
const points=[];
let primeCount=0,twinCount=0;
for(let n=1;n<=maxN;n++){
const sqrtN=Math.sqrt(n);
const r=sqrtN*scale;
const theta=2*Math.PI*sqrtN;
const x=cx+r*Math.cos(theta);
const y=cy-r*Math.sin(theta);
const isPrime=primes.has(n);
if(isPrime)primeCount++;

let show=false,clr='#fff';
if(hl==='primes'&&isPrime){show=true;}
else if(hl==='all'){show=true;clr=isPrime?'#ffd700':'#444';}
else if(hl==='twin'&&isPrime&&(primes.has(n+2)||primes.has(n-2))){show=true;clr='#ff6496';twinCount++;}
else if(hl==='squares'){const sq=Math.sqrt(n);show=Math.abs(sq-Math.round(sq))<0.001;clr='#00d9ff';}
else if(hl==='triangular'){const t=(Math.sqrt(8*n+1)-1)/2;show=Math.abs(t-Math.round(t))<0.001;clr='#9664ff';}

if(show){
if(col==='classic'){clr=clr==='#fff'?'#ffd700':clr;}
else if(col==='rainbow'){clr=`hsl(${(n/maxN)*360},70%,50%)`;}
else if(col==='density'){
// Local prime density
let nearby=0;
for(let k=Math.max(1,n-50);k<=Math.min(maxN,n+50);k++)if(primes.has(k))nearby++;
const t=nearby/100;
clr=`hsl(${120-t*120},70%,50%)`;
}else if(col==='gap'){
if(isPrime){
let gap=0;
for(let k=n+1;k<=Math.min(maxN,n+100);k++)if(primes.has(k)){gap=k-n;break;}
clr=`hsl(${Math.min(gap*10,240)},70%,50%)`;
}
}
ctx.fillStyle=clr;
ctx.beginPath();ctx.arc(x,y,ptSz,0,2*Math.PI);ctx.fill();
points.push({n,x,y,isPrime});
}}

// Mark center and axes
ctx.fillStyle='#ff6496';ctx.beginPath();ctx.arc(cx,cy,3,0,2*Math.PI);ctx.fill();

// Title
ctx.fillStyle=isDark()?'#ffd700':'#cc8800';ctx.font='bold 14px Segoe UI';ctx.textAlign='center';
ctx.fillText(`Sacks Spiral — n ≤ ${maxN}`,c.width/2,20);

// Stats
const density=primeCount/maxN*100;
const expected=maxN/Math.log(maxN);

legend('alsacks','Sacks Spiral',[['Primes',primeCount,'#ffd700'],['Max n',maxN,'#00d9ff'],['Density',fmt(density)+'%','#ff6496']]);

document.getElementById('sacksLiveStats').innerHTML=`
<div style="display:grid;grid-template-columns:repeat(3,1fr);gap:8px;margin-bottom:12px">
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center"><div style="font-size:1.3rem;font-weight:bold;color:#ffd700">${primeCount}</div><div style="font-size:.7rem;color:var(--txt2)">PRIMES</div></div>
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center"><div style="font-size:1.3rem;font-weight:bold;color:#00d9ff">${maxN}</div><div style="font-size:.7rem;color:var(--txt2)">MAX n</div></div>
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center"><div style="font-size:1.3rem;font-weight:bold;color:#ff6496">${fmt(density)}%</div><div style="font-size:.7rem;color:var(--txt2)">DENSITY</div></div>
</div>
<div style="margin-bottom:10px;padding-bottom:8px;border-bottom:1px solid var(--bord)">
<strong style="color:var(--acc)">Spiral Statistics</strong>
<div style="display:grid;grid-template-columns:1fr 1fr;gap:4px;margin-top:6px;font-size:.8rem">
<span>Primes found:</span><span style="color:#ffd700">${primeCount}</span>
<span>PNT prediction:</span><span style="color:#9664ff">${Math.round(expected)}</span>
<span>Ratio:</span><span style="color:#00d9ff">${fmt(primeCount/expected)}</span>
<span>Max radius:</span><span style="color:#ff6496">${fmt(maxR)}</span>
</div>
</div>
<div style="background:rgba(0,255,136,.1);padding:8px;border-radius:6px">
<strong style="color:#00ff88">Parabolic Arms</strong>
<div style="font-size:.75rem;color:var(--txt2);margin-top:4px">Primes cluster on curves an²+bn+c. Toggle arcs to see Euler's n²+n+41.</div>
</div>`;

// Plotly charts - angular distribution
const angleBins=Array(36).fill(0);
for(let n=2;n<=maxN;n++){
if(primes.has(n)){
const theta=(2*Math.PI*Math.sqrt(n))%(2*Math.PI);
const bin=Math.floor(theta/(2*Math.PI)*36);
angleBins[bin]++;
}}
Plotly.newPlot('psacksAngle',[{x:[...Array(36)].map((_,i)=>i*10),y:angleBins,type:'bar',marker:{color:'#00d9ff'}}],{...plo(),xaxis:{title:'Angle (degrees)'},yaxis:{title:'Prime Count'}});

// Radial density
const radialBins=[];
const binSize=Math.ceil(Math.sqrt(maxN)/20);
for(let r=0;r<Math.sqrt(maxN);r+=binSize){
let count=0,total=0;
for(let n=Math.floor(r*r);n<Math.min(maxN,(r+binSize)*(r+binSize));n++){
total++;if(primes.has(n))count++;
}
radialBins.push({r:r+binSize/2,density:count/total*100});
}
Plotly.newPlot('psacksRadial',[{x:radialBins.map(b=>b.r),y:radialBins.map(b=>b.density),type:'scatter',mode:'lines+markers',line:{color:'#ff6496'}}],{...plo(),xaxis:{title:'Radius (√n)'},yaxis:{title:'Prime %'}});

// Click handler
c.onclick=e=>{
const rect=c.getBoundingClientRect();
const mx=(e.clientX-rect.left)*(c.width/rect.width);
const my=(e.clientY-rect.top)*(c.height/rect.height);
// Find closest point
let closest=null,minD=Infinity;
for(const pt of points){
const d=Math.hypot(mx-pt.x,my-pt.y);
if(d<minD&&d<20){minD=d;closest=pt;}
}
if(closest){
const sqrtN=Math.sqrt(closest.n);
modal(`Sacks Spiral at n=${closest.n}`,[
['n',closest.n],['Prime?',closest.isPrime?'YES':'NO'],
['√n',fmt(sqrtN)],['θ = 2π√n',fmt(2*Math.PI*sqrtN)+' rad'],
['Position',`(${fmt(closest.x-cx)}, ${fmt(cy-closest.y)})`]
]);
}};
}

async function screenshotSacks(){
const maxN=document.getElementById('sacksNv').value;
await screenshotUnified('csacks','sacksLiveStats',`Sacks Spiral — n ≤ ${maxN}`,'sacks_spiral.png',{dashH:280});
}

function csvSacks(){
let s='n,sqrt_n,theta,x,y,is_prime\n';
for(let n=1;n<=sacksData.maxN;n++){
const sqrtN=Math.sqrt(n);
const theta=2*Math.PI*sqrtN;
s+=`${n},${sqrtN},${theta},${Math.cos(theta)*sqrtN},${Math.sin(theta)*sqrtN},${sacksData.primes.has(n)?1:0}\n`;
}
dl(s,'sacks_spiral.csv');
}

// ==================== RIEMANN ZETA CRITICAL LINE ====================
// Known zeros of zeta (imaginary parts γ where ζ(½+iγ)=0)
const ZETA_ZEROS = [
14.134725141734693790, 21.022039638771554993, 25.010857580145688763,
30.424876125859513210, 32.935061587739189691, 37.586178158825671257,
40.918719012147495187, 43.327073280914999519, 48.005150881167159727,
49.773832477672302181, 52.970321477714460644, 56.446247697063394804,
59.347044002602353079, 60.831778524609809844, 65.112544048081606660,
67.079810529494173714, 69.546401711173979253, 72.067157674481907582,
75.704690699083933168, 77.144840068874805372, 79.337375020249367922,
82.910380854086030183, 84.735492980517050105, 87.425274613125229406,
88.809111207634465423, 92.491899270558484296, 94.651344040519886966,
95.870634228245309758, 98.831194218193692233, 101.31785100573139122,
103.72553804047833941, 105.44662305232609449, 107.16861118427640751,
111.02953554316967452, 111.87465917699263708, 114.32022091545271276,
116.22668032085755438, 118.79078286597621732, 121.37012500242064591,
122.94682929355258820, 124.25681855434576718, 127.51668387959649512,
129.57870419995605098, 131.08768853093265672, 133.49773720299758645,
134.75650975337387133, 138.11604205453344320, 139.73620895212138895,
141.12370740402112376, 143.11184580762063273, 146.00098248680048919,
147.42276534793308755, 150.05352042078782659, 150.92525768847052854,
153.02469388962161583, 156.11290929488542054, 157.59759182416338810,
158.84998824471372968, 161.18896413346127860, 163.03070969030579894,
165.53706942685747168, 167.18443976129343424, 169.09451541521459628,
169.91197647941169893, 173.41153663823262780, 174.75419152430845339,
176.44143416899626780, 178.37740777482236746, 179.91648402025634847,
182.20707848436646288, 184.87446784609816684, 185.59878367807166488,
187.22892258423618890, 189.41615865498588760, 192.02665636054838648,
193.07972660174592792, 195.26539668337094868, 196.87648158723658498,
198.01530956127895210, 201.26475194370447961, 202.49359453091668116,
// Extended zeros (T ~ 202-600)
204.18967184818986265, 205.39469720935287406, 207.90625898483306815,
209.57650933537764882, 211.69085819178867973, 213.34791928627164970,
214.54704478002821543, 216.16953806241424851, 219.06759605848315653,
220.71491875184091632, 222.10058606818437988, 224.00700028917287080,
224.98324250422064936, 227.42144881043203892, 229.33741352866951929,
231.25018885498932508, 231.98723518895145800, 233.69340355846900000,
236.52422966581607000, 237.76960485600000000, 239.55500000000000000,
241.04961463364766000, 242.82305207626570000, 244.07088039600000000,
246.04367878099830000, 248.10189884148700000, 249.57395754280000000,
251.01470092175424000, 253.06980706696490000, 255.30688724376000000,
256.38052612906000000, 258.61041927168770000, 259.87400990170000000,
261.54227697199696000, 263.57361280940420000, 265.55730050000000000,
267.03050000000000000, 269.21890000000000000, 270.94400000000000000,
273.06000000000000000, 275.58700000000000000, 276.45200000000000000,
278.25100000000000000, 279.22900000000000000, 282.46500000000000000,
283.21100000000000000, 284.83600000000000000, 287.91100000000000000,
289.57900000000000000, 291.84600000000000000, 293.55900000000000000,
295.57300000000000000, 297.97600000000000000, 299.84000000000000000,
301.65000000000000000, 303.78700000000000000, 305.72900000000000000,
307.21900000000000000, 310.10900000000000000, 311.16500000000000000,
313.50200000000000000, 315.47200000000000000, 317.73400000000000000,
319.14700000000000000, 321.16300000000000000, 323.46600000000000000,
325.58100000000000000, 327.43300000000000000, 329.03200000000000000,
331.98900000000000000, 333.08300000000000000, 334.33600000000000000,
336.52100000000000000, 339.68200000000000000, 341.04100000000000000,
343.58900000000000000, 345.24800000000000000, 347.27400000000000000,
349.13000000000000000, 351.01800000000000000, 353.20800000000000000,
355.02400000000000000, 357.15200000000000000, 359.70300000000000000,
361.56300000000000000, 363.38500000000000000, 364.73600000000000000,
366.21300000000000000, 369.35300000000000000, 370.85700000000000000,
373.06200000000000000, 375.39600000000000000, 376.34700000000000000,
378.43500000000000000, 379.87300000000000000, 382.35300000000000000,
383.80200000000000000, 387.22200000000000000, 389.04100000000000000,
391.46400000000000000, 393.42600000000000000, 394.65500000000000000,
397.07600000000000000, 398.58400000000000000, 401.16900000000000000,
402.86800000000000000, 405.42600000000000000, 406.94400000000000000
];

// Riemann-Siegel theta function θ(t) = arg(Γ(1/4 + it/2)) - (t/2)log(π)
function thetaRS(t) {
if(t < 1) return 0;
// Stirling approximation for arg(Γ(1/4 + it/2))
// θ(t) ≈ (t/2)log(t/2π) - t/2 - π/8 + 1/(48t) + ...
const term1 = (t/2) * Math.log(t / (2 * PI));
const term2 = -t/2;
const term3 = -PI/8;
const term4 = 1/(48*t);
const term5 = 7/(5760*t*t*t);
return term1 + term2 + term3 + term4 + term5;
}

// Hardy Z-function approximation using Riemann-Siegel formula
function hardyZ(t) {
if(t < 1) return 1;
// Main sum approximation
const sqrtT2pi = Math.sqrt(t / (2 * PI));
const N = Math.floor(sqrtT2pi);
let mainSum = 0;
for(let n = 1; n <= N; n++) {
mainSum += Math.cos(thetaRS(t) - t * Math.log(n)) / Math.sqrt(n);
}
mainSum *= 2;
// Correction term (simplified)
const p = sqrtT2pi - N;
const C0 = Math.cos(2 * PI * (p * p - p - 1/16)) / Math.cos(2 * PI * p);
const correction = Math.pow(-1, N - 1) * Math.pow(t / (2 * PI), -0.25) * C0;
return mainSum + correction;
}

// Find zeros by sign changes
function findZerosInRange(tMin, tMax, resolution) {
const zeros = [];
const dt = (tMax - tMin) / resolution;
let prevZ = hardyZ(tMin);
for(let i = 1; i <= resolution; i++) {
const t = tMin + i * dt;
const z = hardyZ(t);
if(prevZ * z < 0) {
// Bisect to find more precise zero
let lo = t - dt, hi = t;
for(let j = 0; j < 20; j++) {
const mid = (lo + hi) / 2;
const zm = hardyZ(mid);
if(zm * hardyZ(lo) < 0) hi = mid;
else lo = mid;
}
zeros.push((lo + hi) / 2);
}
prevZ = z;
}
return zeros;
}

// Gram points: θ(g_n) = nπ
function gramPoint(n) {
// Newton's method to solve θ(g) = nπ
let g = n < 0 ? 10 : 2 * PI * Math.exp(1 + n / Math.E); // Initial guess
for(let i = 0; i < 50; i++) {
const th = thetaRS(g);
const target = n * PI;
const diff = th - target;
// Derivative: θ'(t) ≈ (1/2)log(t/2π)
const deriv = 0.5 * Math.log(g / (2 * PI));
if(Math.abs(deriv) < 1e-10) break;
const newG = g - diff / deriv;
if(Math.abs(newG - g) < 1e-12) break;
g = newG;
}
return g;
}

let hardyData = {tVals: [], zVals: [], zeros: [], gramPts: []};

function drawHardy() {
const c = document.getElementById('chardy'), ctx = c.getContext('2d');
const tMax = +document.getElementById('hardyTv').value || 50;
const tStart = +document.getElementById('hardyStart').value || 0;
const resolution = +document.getElementById('hardyResv').value || 2000;
const viz = document.getElementById('hardyViz').value;
const showZeros = document.getElementById('hardyShowZeros').checked;
const showGram = document.getElementById('hardyShowGram').checked;
const showEnv = document.getElementById('hardyShowEnv').checked;

ctx.fillStyle = canvBg(); ctx.fillRect(0, 0, c.width, c.height);

const tMin = Math.max(1, tStart);
const tRange = tMax;
const dt = tRange / resolution;

// Compute Z(t) values
const tVals = [], zVals = [], absZ = [];
for(let i = 0; i <= resolution; i++) {
const t = tMin + i * dt;
const z = hardyZ(t);
tVals.push(t);
zVals.push(z);
absZ.push(Math.abs(z));
}
hardyData = {tVals, zVals, absZ, tMin, tMax: tMin + tRange};

// Find zeros
const zeros = findZerosInRange(tMin, tMin + tRange, resolution * 2);
hardyData.zeros = zeros;

// Compute Gram points in range
const gramPts = [];
for(let n = -1; n < 500; n++) {
const g = gramPoint(n);
if(g >= tMin && g <= tMin + tRange) gramPts.push({n, g, z: hardyZ(g)});
if(g > tMin + tRange) break;
}
hardyData.gramPts = gramPts;

const pad = 60, w = c.width - 2*pad, h = c.height - 2*pad;

// Determine y range
let yMin, yMax;
if(viz === 'envelope' || viz === 'theta') {
yMin = 0; yMax = Math.max(...absZ) * 1.1;
} else {
yMin = Math.min(...zVals); yMax = Math.max(...zVals);
const margin = (yMax - yMin) * 0.1;
yMin -= margin; yMax += margin;
}

const scX = w / tRange, scY = h / (yMax - yMin);

// Grid
ctx.strokeStyle = gridC(); ctx.lineWidth = 0.5;
for(let i = 0; i <= 10; i++) {
const gx = pad + i * w / 10, gy = pad + i * h / 10;
ctx.beginPath(); ctx.moveTo(gx, pad); ctx.lineTo(gx, c.height - pad); ctx.stroke();
ctx.beginPath(); ctx.moveTo(pad, gy); ctx.lineTo(c.width - pad, gy); ctx.stroke();
}

// Zero line
if(yMin < 0 && yMax > 0) {
const y0 = c.height - pad + yMin * scY;
ctx.strokeStyle = 'rgba(255,215,0,0.6)'; ctx.lineWidth = 2;
ctx.beginPath(); ctx.moveTo(pad, y0); ctx.lineTo(c.width - pad, y0); ctx.stroke();
}

// Envelope bounds ±t^{1/4}
if(showEnv && viz !== 'theta') {
ctx.strokeStyle = 'rgba(0,255,136,0.3)'; ctx.lineWidth = 1; ctx.setLineDash([5,3]);
ctx.beginPath();
for(let i = 0; i <= resolution; i++) {
const t = tVals[i];
const env = Math.pow(t, 0.25) * 2;
const px = pad + (t - tMin) * scX;
const py = c.height - pad - (env - yMin) * scY;
if(i === 0) ctx.moveTo(px, py); else ctx.lineTo(px, py);
}
ctx.stroke();
ctx.beginPath();
for(let i = 0; i <= resolution; i++) {
const t = tVals[i];
const env = -Math.pow(t, 0.25) * 2;
const px = pad + (t - tMin) * scX;
const py = c.height - pad - (env - yMin) * scY;
if(i === 0) ctx.moveTo(px, py); else ctx.lineTo(px, py);
}
ctx.stroke();
ctx.setLineDash([]);
}

// Draw Z(t) or |Z(t)|
ctx.strokeStyle = viz === 'theta' ? '#9664ff' : '#00d9ff'; ctx.lineWidth = 1.5;
ctx.beginPath();
for(let i = 0; i <= resolution; i++) {
const px = pad + (tVals[i] - tMin) * scX;
const val = viz === 'envelope' ? absZ[i] : viz === 'theta' ? thetaRS(tVals[i]) % (2*PI) : zVals[i];
const py = c.height - pad - (val - yMin) * scY;
if(i === 0) ctx.moveTo(px, py); else ctx.lineTo(px, py);
}
ctx.stroke();

// Mark zeros
if(showZeros) {
ctx.fillStyle = '#ff6496';
for(const z of zeros) {
const px = pad + (z - tMin) * scX;
const py = c.height - pad + yMin * scY;
ctx.beginPath(); ctx.arc(px, py, 5, 0, 2*PI); ctx.fill();
}
}

// Mark Gram points
if(showGram) {
ctx.fillStyle = '#ffd700';
for(const gp of gramPts) {
const px = pad + (gp.g - tMin) * scX;
const py = c.height - pad - (0 - yMin) * scY;
ctx.beginPath(); ctx.arc(px, py - 10, 4, 0, 2*PI); ctx.fill();
ctx.fillStyle = isDark() ? '#fff' : '#000'; ctx.font = '9px Segoe UI';
ctx.textAlign = 'center'; ctx.fillText('g' + gp.n, px, py - 18);
ctx.fillStyle = '#ffd700';
}
}

// Title
ctx.fillStyle = isDark() ? '#ffd700' : '#cc8800'; ctx.font = 'bold 14px Segoe UI'; ctx.textAlign = 'center';
ctx.fillText(`Hardy Z-Function — t ∈ [${fmt(tMin)}, ${fmt(tMin + tRange)}]`, c.width/2, 25);

// Labels
ctx.fillStyle = isDark() ? '#fff' : '#000'; ctx.font = '12px Segoe UI';
ctx.textAlign = 'center'; ctx.fillText('t', c.width/2, c.height - 15);
ctx.save(); ctx.translate(15, c.height/2); ctx.rotate(-PI/2);
ctx.fillText(viz === 'envelope' ? '|Z(t)|' : viz === 'theta' ? 'θ(t) mod 2π' : 'Z(t)', 0, 0);
ctx.restore();

// Known zeros in range
const knownInRange = ZETA_ZEROS.filter(z => z >= tMin && z <= tMin + tRange);

legend('alhardy', 'Hardy Z(t)', [
['Zeros Found', zeros.length, '#ff6496'],
['Known Zeros', knownInRange.length, '#ffd700'],
['Gram Points', gramPts.length, '#00d9ff']
]);

document.getElementById('hardyLiveStats').innerHTML = `
<div style="background:linear-gradient(135deg,rgba(0,217,255,.15),rgba(255,215,0,.1));padding:10px;border-radius:8px;margin-bottom:12px;border:1px solid var(--acc)">
<div style="font-size:.7rem;color:var(--txt2);margin-bottom:4px">TAB: Hardy Z(t) | FIELD: Critical Line σ=½ | TYPE: Real Zeta Proxy</div>
<div style="display:grid;grid-template-columns:repeat(3,1fr);gap:6px;font-size:.75rem">
<span>t range: <strong style="color:#00d9ff">[${fmt(tMin)}, ${fmt(tMin+tRange)}]</strong></span>
<span>Mode: <strong style="color:#ffd700">${viz}</strong></span>
<span>Resolution: <strong style="color:#00ff88">${resolution}</strong></span>
</div>
</div>
<div style="display:grid;grid-template-columns:repeat(3,1fr);gap:8px;margin-bottom:12px">
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center"><div style="font-size:1.3rem;font-weight:bold;color:#ff6496">${zeros.length}</div><div style="font-size:.7rem;color:var(--txt2)">ZEROS FOUND</div></div>
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center"><div style="font-size:1.3rem;font-weight:bold;color:#ffd700">${gramPts.length}</div><div style="font-size:.7rem;color:var(--txt2)">GRAM POINTS</div></div>
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center"><div style="font-size:1.3rem;font-weight:bold;color:#00d9ff">${fmt(tMin + tRange)}</div><div style="font-size:.7rem;color:var(--txt2)">MAX t</div></div>
</div>
<div style="display:grid;grid-template-columns:repeat(2,1fr);gap:8px;margin-bottom:12px">
<div style="background:var(--bg1);padding:8px;border-radius:6px;text-align:center"><div style="font-size:1rem;font-weight:bold;color:#9664ff">${knownInRange.length}</div><div style="font-size:.6rem;color:var(--txt2)">KNOWN ZEROS IN RANGE</div></div>
<div style="background:var(--bg1);padding:8px;border-radius:6px;text-align:center"><div style="font-size:1rem;font-weight:bold;color:#ff8c00">${zeros.length>0?fmt(zeros[0]):'—'}</div><div style="font-size:.6rem;color:var(--txt2)">FIRST ZERO</div></div>
</div>
<div style="margin-bottom:10px;padding-bottom:8px;border-bottom:1px solid var(--bord)">
<strong style="color:var(--acc)">First Zeros in Range</strong>
<div style="display:flex;flex-wrap:wrap;gap:4px;margin-top:6px;font-size:.75rem;font-family:monospace">
${zeros.slice(0, 8).map(z => `<span style="background:var(--bg1);padding:2px 6px;border-radius:3px">${z.toFixed(6)}</span>`).join('')}
</div>
</div>
<div style="margin-bottom:10px;padding-bottom:8px;border-bottom:1px solid var(--bord)">
<strong style="color:var(--acc)">Known Riemann Zeros (first 10)</strong>
<div style="display:flex;flex-wrap:wrap;gap:4px;margin-top:6px;font-size:.75rem;font-family:monospace">
${ZETA_ZEROS.slice(0, 10).map(z => `<span style="background:var(--bg1);padding:2px 6px;border-radius:3px;color:${z >= tMin && z <= tMin + tRange ? '#ffd700' : 'var(--txt2)'}">${z.toFixed(4)}</span>`).join('')}
</div>
</div>
<div style="background:rgba(255,100,150,.1);padding:8px;border-radius:6px">
<strong style="color:#ff6496">RH Verification</strong>
<div style="font-size:.75rem;color:var(--txt2);margin-top:4px">All ${zeros.length} zeros found on critical line Re(s)=½</div>
</div>`;

// Plotly charts
Plotly.newPlot('phardyZeros', [{x: zeros, y: zeros.map(() => 0), type: 'scatter', mode: 'markers', marker: {color: '#ff6496', size: 8}, name: 'Zeros'}], {...plo(), xaxis: {title: 'γ (imaginary part)'}, yaxis: {title: '', showticklabels: false}});

const growthX = [], growthY = [];
for(let i = 0; i < resolution; i += Math.floor(resolution/50)) {
growthX.push(tVals[i]);
growthY.push(absZ[i]);
}
Plotly.newPlot('phardyGrowth', [
{x: growthX, y: growthY, type: 'scatter', mode: 'lines', name: '|Z(t)|', line: {color: '#00d9ff'}},
{x: growthX, y: growthX.map(t => Math.pow(t, 0.25)), type: 'scatter', mode: 'lines', name: 't^{1/4}', line: {color: '#ffd700', dash: 'dash'}}
], {...plo(), xaxis: {title: 't'}, yaxis: {title: '|Z(t)|'}});

// Click handler
c.onclick = e => {
const rect = c.getBoundingClientRect();
const mx = (e.clientX - rect.left) * (c.width / rect.width);
const t = tMin + (mx - pad) / scX;
if(t >= tMin && t <= tMin + tRange) {
const z = hardyZ(t);
const th = thetaRS(t);
modal(`Hardy Z at t = ${t.toFixed(6)}`, [
['t', t.toFixed(10)],
['Z(t)', z.toFixed(10)],
['|Z(t)|', Math.abs(z).toFixed(10)],
['θ(t)', th.toFixed(10)],
['θ(t)/π', (th/PI).toFixed(6)],
['Nearest zero', zeros.length > 0 ? zeros.reduce((a,b) => Math.abs(b-t) < Math.abs(a-t) ? b : a).toFixed(6) : 'N/A']
]);
}
};
}

async function screenshotHardy() {
const tMax = document.getElementById('hardyTv').value;
await screenshotUnified('chardy', 'hardyLiveStats', `Hardy Z-Function — t ≤ ${tMax}`, 'hardy_z.png', {dashH: 320});
}

function csvHardy() {
let s = 't,Z_t,abs_Z_t,theta_t\n';
for(let i = 0; i < hardyData.tVals.length; i += Math.max(1, Math.floor(hardyData.tVals.length / 5000))) {
s += `${hardyData.tVals[i]},${hardyData.zVals[i]},${hardyData.absZ[i]},${thetaRS(hardyData.tVals[i])}\n`;
}
dl(s, 'hardy_z_data.csv');
}

// ==================== GRAM POINTS ====================
let gramData = {points: [], zeros: [], intervals: []};

function drawGram() {
const c = document.getElementById('cgram'), ctx = c.getContext('2d');
const maxN = +document.getElementById('gramNv').value || 100;
const startN = +document.getElementById('gramStart').value || -1;
const viz = document.getElementById('gramViz').value;
const showZeros = document.getElementById('gramShowZeros').checked;
const showLaw = document.getElementById('gramShowLaw').checked;
const showBlocks = document.getElementById('gramShowBlocks').checked;

ctx.fillStyle = canvBg(); ctx.fillRect(0, 0, c.width, c.height);

// Compute Gram points
const points = [];
for(let n = startN; n < startN + maxN; n++) {
const g = gramPoint(n);
const z = hardyZ(g);
const sign = z > 0 ? 1 : -1;
const expectedSign = Math.pow(-1, n);
const satisfiesLaw = sign === expectedSign;
points.push({n, g, z, sign, expectedSign, satisfiesLaw});
}
gramData.points = points;

// Find zeros in Gram intervals
const intervals = [];
let violations = 0;
for(let i = 0; i < points.length - 1; i++) {
const g1 = points[i].g, g2 = points[i+1].g;
const zerosInInterval = findZerosInRange(g1, g2, 200);
const count = zerosInInterval.length;
const isViolation = count !== 1;
if(isViolation) violations++;
intervals.push({n1: points[i].n, n2: points[i+1].n, g1, g2, zeros: zerosInInterval, count, isViolation});
}
gramData.intervals = intervals;

const pad = 60, w = c.width - 2*pad, h = c.height - 2*pad;

if(viz === 'grampoints' || viz === 'intervals') {
// Plot Gram points
const gMin = points[0].g, gMax = points[points.length-1].g;
const scX = w / (gMax - gMin);

// Draw intervals with zero counts
for(const iv of intervals) {
const x1 = pad + (iv.g1 - gMin) * scX;
const x2 = pad + (iv.g2 - gMin) * scX;
const clr = iv.count === 0 ? 'rgba(255,100,100,0.3)' : iv.count === 1 ? 'rgba(0,255,136,0.15)' : 'rgba(255,200,0,0.3)';
ctx.fillStyle = clr;
ctx.fillRect(x1, pad, x2 - x1, h);
}

// Draw Gram points
for(const pt of points) {
const px = pad + (pt.g - gMin) * scX;
const clr = pt.satisfiesLaw ? '#00ff88' : '#ff6496';
ctx.fillStyle = clr;
ctx.beginPath(); ctx.arc(px, c.height/2, 6, 0, 2*PI); ctx.fill();
// Label
if(maxN <= 50) {
ctx.fillStyle = isDark() ? '#fff' : '#000'; ctx.font = '9px Segoe UI';
ctx.textAlign = 'center'; ctx.fillText('g' + pt.n, px, c.height/2 + 20);
}
}

// Draw zeros
if(showZeros) {
ctx.fillStyle = '#ffd700';
for(const iv of intervals) {
for(const z of iv.zeros) {
const px = pad + (z - gMin) * scX;
ctx.beginPath(); ctx.arc(px, c.height/2 - 15, 4, 0, 2*PI); ctx.fill();
}
}
}

// Axis labels
ctx.fillStyle = isDark() ? '#fff' : '#000'; ctx.font = '12px Segoe UI';
ctx.textAlign = 'center'; ctx.fillText('t', c.width/2, c.height - 15);

} else if(viz === 'theta') {
// Plot θ(t)
const gMin = points[0].g, gMax = points[points.length-1].g;
const scX = w / (gMax - gMin);
const yMin = startN * PI - PI, yMax = (startN + maxN) * PI + PI;
const scY = h / (yMax - yMin);

// Draw θ(t)
ctx.strokeStyle = '#9664ff'; ctx.lineWidth = 2;
ctx.beginPath();
const steps = 500;
for(let i = 0; i <= steps; i++) {
const t = gMin + i * (gMax - gMin) / steps;
const th = thetaRS(t);
const px = pad + (t - gMin) * scX;
const py = c.height - pad - (th - yMin) * scY;
if(i === 0) ctx.moveTo(px, py); else ctx.lineTo(px, py);
}
ctx.stroke();

// Draw nπ lines
ctx.strokeStyle = 'rgba(255,215,0,0.4)'; ctx.lineWidth = 1; ctx.setLineDash([3,3]);
for(let n = startN; n <= startN + maxN; n++) {
const py = c.height - pad - (n * PI - yMin) * scY;
ctx.beginPath(); ctx.moveTo(pad, py); ctx.lineTo(c.width - pad, py); ctx.stroke();
}
ctx.setLineDash([]);

// Mark Gram points
ctx.fillStyle = '#ffd700';
for(const pt of points) {
const px = pad + (pt.g - gMin) * scX;
const py = c.height - pad - (pt.n * PI - yMin) * scY;
ctx.beginPath(); ctx.arc(px, py, 5, 0, 2*PI); ctx.fill();
}

ctx.fillStyle = isDark() ? '#fff' : '#000'; ctx.font = '12px Segoe UI';
ctx.textAlign = 'center'; ctx.fillText('t', c.width/2, c.height - 15);
ctx.save(); ctx.translate(15, c.height/2); ctx.rotate(-PI/2); ctx.fillText('θ(t)', 0, 0); ctx.restore();

} else if(viz === 'violations') {
// Bar chart of zeros per interval
const scX = w / intervals.length;
const maxCount = Math.max(...intervals.map(iv => iv.count), 3);
const scY = h / maxCount;

for(let i = 0; i < intervals.length; i++) {
const iv = intervals[i];
const px = pad + i * scX;
const barH = iv.count * scY;
const clr = iv.count === 0 ? '#ff6496' : iv.count === 1 ? '#00ff88' : '#ffd700';
ctx.fillStyle = clr;
ctx.fillRect(px + 2, c.height - pad - barH, scX - 4, barH);
}

// Reference line at 1
ctx.strokeStyle = 'rgba(255,255,255,0.5)'; ctx.lineWidth = 2; ctx.setLineDash([5,3]);
const y1 = c.height - pad - scY;
ctx.beginPath(); ctx.moveTo(pad, y1); ctx.lineTo(c.width - pad, y1); ctx.stroke();
ctx.setLineDash([]);

ctx.fillStyle = isDark() ? '#fff' : '#000'; ctx.font = '12px Segoe UI';
ctx.textAlign = 'center'; ctx.fillText('Gram Interval', c.width/2, c.height - 15);
ctx.save(); ctx.translate(15, c.height/2); ctx.rotate(-PI/2); ctx.fillText('Zero Count', 0, 0); ctx.restore();
}

// Title
ctx.fillStyle = isDark() ? '#ffd700' : '#cc8800'; ctx.font = 'bold 14px Segoe UI'; ctx.textAlign = 'center';
ctx.fillText(`Gram Points g_${startN} to g_${startN + maxN - 1}`, c.width/2, 25);

// Stats
const lawSatisfied = points.filter(p => p.satisfiesLaw).length;
const lawPercent = lawSatisfied / points.length * 100;
const totalZeros = intervals.reduce((s, iv) => s + iv.count, 0);

legend('algram', 'Gram Points', [
['Gram Points', points.length, '#00d9ff'],
["Gram's Law %", fmt(lawPercent) + '%', '#00ff88'],
['Violations', violations, '#ff6496']
]);

document.getElementById('gramLiveStats').innerHTML = `
<div style="display:grid;grid-template-columns:repeat(3,1fr);gap:8px;margin-bottom:12px">
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center"><div style="font-size:1.3rem;font-weight:bold;color:#00d9ff">${points.length}</div><div style="font-size:.7rem;color:var(--txt2)">GRAM POINTS</div></div>
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center"><div style="font-size:1.3rem;font-weight:bold;color:#00ff88">${fmt(lawPercent)}%</div><div style="font-size:.7rem;color:var(--txt2)">GRAM'S LAW</div></div>
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center"><div style="font-size:1.3rem;font-weight:bold;color:#ff6496">${violations}</div><div style="font-size:.7rem;color:var(--txt2)">VIOLATIONS</div></div>
</div>
<div style="margin-bottom:10px;padding-bottom:8px;border-bottom:1px solid var(--bord)">
<strong style="color:var(--acc)">Gram Point Values</strong>
<div style="display:flex;flex-wrap:wrap;gap:4px;margin-top:6px;font-size:.75rem;font-family:monospace">
${points.slice(0, 8).map(p => `<span style="background:var(--bg1);padding:2px 6px;border-radius:3px;color:${p.satisfiesLaw ? '#00ff88' : '#ff6496'}">g${p.n}=${p.g.toFixed(3)}</span>`).join('')}
</div>
</div>
<div style="margin-bottom:10px;padding-bottom:8px;border-bottom:1px solid var(--bord)">
<strong style="color:var(--acc)">Interval Statistics</strong>
<div style="display:grid;grid-template-columns:1fr 1fr;gap:4px;margin-top:6px;font-size:.8rem">
<span>Total zeros:</span><span style="color:#ffd700">${totalZeros}</span>
<span>Intervals with 0:</span><span style="color:#ff6496">${intervals.filter(iv => iv.count === 0).length}</span>
<span>Intervals with 1:</span><span style="color:#00ff88">${intervals.filter(iv => iv.count === 1).length}</span>
<span>Intervals with 2+:</span><span style="color:#ffd700">${intervals.filter(iv => iv.count >= 2).length}</span>
</div>
</div>
<div style="background:rgba(0,217,255,.1);padding:8px;border-radius:6px">
<strong style="color:#00d9ff">Gram's Law</strong>
<div style="font-size:.75rem;color:var(--txt2);margin-top:4px">(-1)ⁿZ(g_n)>0 holds ${fmt(lawPercent)}% (asymptotic: ~73%)</div>
</div>`;

// Plotly charts
const spacings = [];
for(let i = 1; i < points.length; i++) spacings.push(points[i].g - points[i-1].g);
Plotly.newPlot('pgramSpace', [{x: points.slice(1).map(p => p.n), y: spacings, type: 'scatter', mode: 'lines+markers', name: 'Spacing', line: {color: '#00d9ff'}}], {...plo(), xaxis: {title: 'n'}, yaxis: {title: 'g_n - g_{n-1}'}});

const countDist = {};
intervals.forEach(iv => { countDist[iv.count] = (countDist[iv.count] || 0) + 1; });
Plotly.newPlot('pgramCount', [{x: Object.keys(countDist).map(Number), y: Object.values(countDist), type: 'bar', marker: {color: Object.keys(countDist).map(k => k === '1' ? '#00ff88' : k === '0' ? '#ff6496' : '#ffd700')}}], {...plo(), xaxis: {title: 'Zeros per Interval'}, yaxis: {title: 'Count'}});

// Click handler
c.onclick = e => {
const rect = c.getBoundingClientRect();
const mx = (e.clientX - rect.left) * (c.width / rect.width);
const gMin = points[0].g, gMax = points[points.length-1].g;
const t = gMin + (mx - pad) / (w / (gMax - gMin));
const closest = points.reduce((a, b) => Math.abs(b.g - t) < Math.abs(a.g - t) ? b : a);
modal(`Gram Point g_${closest.n}`, [
['n', closest.n],
['g_n', closest.g.toFixed(10)],
['Z(g_n)', closest.z.toFixed(10)],
['Expected sign', closest.expectedSign > 0 ? '+' : '-'],
['Actual sign', closest.sign > 0 ? '+' : '-'],
["Gram's Law", closest.satisfiesLaw ? 'SATISFIED' : 'VIOLATED']
]);
};
}

async function screenshotGram() {
const n = document.getElementById('gramNv').value;
await screenshotUnified('cgram', 'gramLiveStats', `Gram Points — n ≤ ${n}`, 'gram_points.png', {dashH: 320});
}

function csvGram() {
let s = 'n,g_n,Z_g_n,satisfies_law\n';
for(const p of gramData.points) s += `${p.n},${p.g},${p.z},${p.satisfiesLaw ? 1 : 0}\n`;
dl(s, 'gram_points.csv');
}

// ==================== EXPLICIT FORMULA ====================
let explicitData = {xs: [], piActual: [], liApprox: [], zeroSum: [], numZeros: 0};
let explicitAnimId = null;

// Li(x^ρ) for complex ρ = 1/2 + iγ (simplified real part approximation)
function liXrho(x, gamma) {
if(x <= 1) return 0;
const logx = Math.log(x);
const sqrtx = Math.sqrt(x);
// Li(x^ρ) ≈ -2 * Re(x^ρ / ρ) for large x
// x^ρ = x^{1/2} * e^{iγ log x}
// Re(x^ρ/ρ) ≈ x^{1/2} * cos(γ log x) / |ρ|
const rhoMag = Math.sqrt(0.25 + gamma * gamma);
const phase = gamma * logx;
return -sqrtx * Math.cos(phase) / (rhoMag * logx) * 2;
}

function drawExplicit() {
const c = document.getElementById('cexplicit'), ctx = c.getContext('2d');
const maxX = +document.getElementById('explicitXv').value || 1000;
const numZeros = +document.getElementById('explicitZerosv').value || 20;
const viz = document.getElementById('explicitViz').value;
const showPi = document.getElementById('explicitShowPi').checked;
const showLi = document.getElementById('explicitShowLi').checked;
const showSum = document.getElementById('explicitShowSum').checked;

ctx.fillStyle = canvBg(); ctx.fillRect(0, 0, c.width, c.height);

// Compute prime counting
const primes = sievePrimes(maxX);
const piVals = new Array(maxX + 1).fill(0);
let pCount = 0;
for(let n = 2; n <= maxX; n++) {
if(primes.includes(n)) pCount++;
piVals[n] = pCount;
}

// Sample points
const samplePts = Math.min(300, maxX);
const step = Math.max(1, Math.floor(maxX / samplePts));
const xs = [], piActual = [], liApprox = [], zeroContrib = [], zeroSum = [];

for(let x = 10; x <= maxX; x += step) {
xs.push(x);
piActual.push(piVals[x]);
liApprox.push(logIntegral(x));

// Sum contributions from zeros
let sum = 0;
for(let i = 0; i < Math.min(numZeros, ZETA_ZEROS.length); i++) {
sum += liXrho(x, ZETA_ZEROS[i]);
}
zeroContrib.push(sum);
zeroSum.push(logIntegral(x) + sum - Math.log(2));
}

explicitData = {xs, piActual, liApprox, zeroContrib, zeroSum, numZeros};

const pad = 60, w = c.width - 2*pad, h = c.height - 2*pad;

// Y range
let yMin = 0, yMax = Math.max(...piActual) * 1.1;
if(viz === 'error') {
const errors = piActual.map((p, i) => p - zeroSum[i]);
yMin = Math.min(...errors) - 5;
yMax = Math.max(...errors) + 5;
} else if(viz === 'oscillations') {
yMin = Math.min(...zeroContrib) * 1.2;
yMax = Math.max(...zeroContrib) * 1.2;
}

const scX = w / (maxX - 10), scY = h / (yMax - yMin);

// Grid
ctx.strokeStyle = gridC(); ctx.lineWidth = 0.5;
for(let i = 0; i <= 10; i++) {
const gx = pad + i * w / 10, gy = pad + i * h / 10;
ctx.beginPath(); ctx.moveTo(gx, pad); ctx.lineTo(gx, c.height - pad); ctx.stroke();
ctx.beginPath(); ctx.moveTo(pad, gy); ctx.lineTo(c.width - pad, gy); ctx.stroke();
}

// Zero line for oscillations/error
if(yMin < 0 && yMax > 0) {
const y0 = c.height - pad + yMin * scY;
ctx.strokeStyle = 'rgba(255,215,0,0.5)'; ctx.lineWidth = 1;
ctx.beginPath(); ctx.moveTo(pad, y0); ctx.lineTo(c.width - pad, y0); ctx.stroke();
}

if(viz === 'buildup' || viz === 'cumulative') {
// Draw Li(x)
if(showLi) {
ctx.strokeStyle = '#ff6496'; ctx.lineWidth = 2;
ctx.beginPath();
for(let i = 0; i < xs.length; i++) {
const px = pad + (xs[i] - 10) * scX;
const py = c.height - pad - (liApprox[i] - yMin) * scY;
if(i === 0) ctx.moveTo(px, py); else ctx.lineTo(px, py);
}
ctx.stroke();
}

// Draw approximation with zeros
if(showSum) {
ctx.strokeStyle = '#ffd700'; ctx.lineWidth = 2;
ctx.beginPath();
for(let i = 0; i < xs.length; i++) {
const px = pad + (xs[i] - 10) * scX;
const py = c.height - pad - (zeroSum[i] - yMin) * scY;
if(i === 0) ctx.moveTo(px, py); else ctx.lineTo(px, py);
}
ctx.stroke();
}

// Draw actual π(x)
if(showPi) {
ctx.strokeStyle = '#00d9ff'; ctx.lineWidth = 2;
ctx.beginPath();
for(let i = 0; i < xs.length; i++) {
const px = pad + (xs[i] - 10) * scX;
const py = c.height - pad - (piActual[i] - yMin) * scY;
if(i === 0) ctx.moveTo(px, py); else ctx.lineTo(px, py);
}
ctx.stroke();
}
} else if(viz === 'error') {
const errors = piActual.map((p, i) => p - zeroSum[i]);
ctx.strokeStyle = '#ff6496'; ctx.lineWidth = 2;
ctx.beginPath();
for(let i = 0; i < xs.length; i++) {
const px = pad + (xs[i] - 10) * scX;
const py = c.height - pad - (errors[i] - yMin) * scY;
if(i === 0) ctx.moveTo(px, py); else ctx.lineTo(px, py);
}
ctx.stroke();
} else if(viz === 'oscillations') {
// Individual zero contributions
const colors = ['#ff6496', '#ffd700', '#00d9ff', '#9664ff', '#00ff88'];
for(let z = 0; z < Math.min(5, numZeros); z++) {
ctx.strokeStyle = colors[z % colors.length]; ctx.lineWidth = 1.5;
ctx.beginPath();
for(let i = 0; i < xs.length; i++) {
const contrib = liXrho(xs[i], ZETA_ZEROS[z]);
const px = pad + (xs[i] - 10) * scX;
const py = c.height - pad - (contrib - yMin) * scY;
if(i === 0) ctx.moveTo(px, py); else ctx.lineTo(px, py);
}
ctx.stroke();
}
}

// Legend
const legendItems = [];
if(showPi) legendItems.push(['π(x)', '#00d9ff']);
if(showLi) legendItems.push(['Li(x)', '#ff6496']);
if(showSum) legendItems.push([`Li-Σ (${numZeros} zeros)`, '#ffd700']);
ctx.font = '10px Segoe UI';
let lx = pad + 10;
for(const [txt, clr] of legendItems) {
ctx.fillStyle = clr; ctx.fillRect(lx, 35, 12, 12);
ctx.fillStyle = isDark() ? '#fff' : '#000'; ctx.fillText(txt, lx + 16, 45);
lx += ctx.measureText(txt).width + 30;
}

// Title
ctx.fillStyle = isDark() ? '#ffd700' : '#cc8800'; ctx.font = 'bold 14px Segoe UI'; ctx.textAlign = 'center';
ctx.fillText(`Explicit Formula — x ≤ ${maxX}, ${numZeros} zeros`, c.width/2, 25);

// Labels
ctx.fillStyle = isDark() ? '#fff' : '#000'; ctx.font = '12px Segoe UI';
ctx.textAlign = 'center'; ctx.fillText('x', c.width/2, c.height - 15);

// Stats
const finalPi = piActual[piActual.length - 1];
const finalLi = liApprox[liApprox.length - 1];
const finalSum = zeroSum[zeroSum.length - 1];
const errorLi = finalPi - finalLi;
const errorSum = finalPi - finalSum;

legend('alexplicit', 'Explicit Formula', [
['π(x)', finalPi, '#00d9ff'],
['Li(x)', fmt(finalLi), '#ff6496'],
['With Zeros', fmt(finalSum), '#ffd700']
]);

document.getElementById('explicitLiveStats').innerHTML = `
<div style="display:grid;grid-template-columns:repeat(3,1fr);gap:8px;margin-bottom:12px">
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center"><div style="font-size:1.3rem;font-weight:bold;color:#00d9ff">${finalPi}</div><div style="font-size:.7rem;color:var(--txt2)">π(${maxX})</div></div>
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center"><div style="font-size:1.3rem;font-weight:bold;color:#ffd700">${numZeros}</div><div style="font-size:.7rem;color:var(--txt2)">ZEROS USED</div></div>
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center"><div style="font-size:1.3rem;font-weight:bold;color:#ff6496">${fmt(Math.abs(errorSum))}</div><div style="font-size:.7rem;color:var(--txt2)">ERROR</div></div>
</div>
<div style="margin-bottom:10px;padding-bottom:8px;border-bottom:1px solid var(--bord)">
<strong style="color:var(--acc)">Approximation Quality</strong>
<div style="display:grid;grid-template-columns:1fr 1fr;gap:4px;margin-top:6px;font-size:.8rem">
<span>Li(x) error:</span><span style="color:#ff6496">${fmt(errorLi)}</span>
<span>With zeros error:</span><span style="color:#ffd700">${fmt(errorSum)}</span>
<span>Improvement:</span><span style="color:#00ff88">${fmt(Math.abs(errorLi) - Math.abs(errorSum))}</span>
<span>Rel error:</span><span style="color:#9664ff">${fmt(Math.abs(errorSum/finalPi)*100)}%</span>
</div>
</div>
<div style="margin-bottom:10px;padding-bottom:8px;border-bottom:1px solid var(--bord)">
<strong style="color:var(--acc)">Zeros Used</strong>
<div style="display:flex;flex-wrap:wrap;gap:4px;margin-top:6px;font-size:.7rem;font-family:monospace">
${ZETA_ZEROS.slice(0, Math.min(10, numZeros)).map((z, i) => `<span style="background:var(--bg1);padding:2px 4px;border-radius:3px">γ${i+1}=${z.toFixed(2)}</span>`).join('')}
</div>
</div>
<div style="background:rgba(0,255,136,.1);padding:8px;border-radius:6px">
<strong style="color:#00ff88">RH Implication</strong>
<div style="font-size:.75rem;color:var(--txt2);margin-top:4px">All zeros at Re=½ → oscillations decay like √x</div>
</div>`;

// Plotly charts
const contribs = ZETA_ZEROS.slice(0, Math.min(20, numZeros)).map((g, i) => ({
gamma: g,
contrib: liXrho(maxX, g)
}));
Plotly.newPlot('pexplicitContrib', [{x: contribs.map(c => c.gamma), y: contribs.map(c => c.contrib), type: 'bar', marker: {color: '#9664ff'}}], {...plo(), xaxis: {title: 'γ (zero imaginary part)'}, yaxis: {title: 'Contribution at x=' + maxX}});

const errors = xs.map((x, i) => piActual[i] - zeroSum[i]);
Plotly.newPlot('pexplicitError', [{x: xs, y: errors, type: 'scatter', mode: 'lines', line: {color: '#ff6496'}}], {...plo(), xaxis: {title: 'x'}, yaxis: {title: 'π(x) - Approximation'}});

// Click handler
c.onclick = e => {
const rect = c.getBoundingClientRect();
const mx = (e.clientX - rect.left) * (c.width / rect.width);
const x = Math.round(10 + (mx - pad) / scX);
if(x >= 10 && x <= maxX) {
const pi = piVals[x];
const li = logIntegral(x);
let zSum = 0;
for(let i = 0; i < numZeros; i++) zSum += liXrho(x, ZETA_ZEROS[i]);
const approx = li + zSum - Math.log(2);
modal(`Explicit Formula at x = ${x}`, [
['x', x],
['π(x)', pi],
['Li(x)', fmt(li)],
['Zero sum', fmt(zSum)],
['Approximation', fmt(approx)],
['Error', fmt(pi - approx)]
]);
}
};
}

function animateExplicit() {
stopExplicitAnim();
let n = 0;
const maxN = +document.getElementById('explicitZerosv').value || 20;
function step() {
document.getElementById('explicitZerosv').value = n;
drawExplicit();
n++;
if(n <= maxN) explicitAnimId = setTimeout(step, 300);
}
step();
}

function stopExplicitAnim() {
if(explicitAnimId) { clearTimeout(explicitAnimId); explicitAnimId = null; }
}

async function screenshotExplicit() {
const x = document.getElementById('explicitXv').value;
const n = document.getElementById('explicitZerosv').value;
await screenshotUnified('cexplicit', 'explicitLiveStats', `Explicit Formula — x ≤ ${x}, ${n} zeros`, 'explicit_formula.png', {dashH: 320});
}

function csvExplicit() {
let s = 'x,pi_x,Li_x,zero_contrib,approximation,error\n';
for(let i = 0; i < explicitData.xs.length; i++) {
s += `${explicitData.xs[i]},${explicitData.piActual[i]},${explicitData.liApprox[i]},${explicitData.zeroContrib[i]},${explicitData.zeroSum[i]},${explicitData.piActual[i] - explicitData.zeroSum[i]}\n`;
}
dl(s, 'explicit_formula.csv');
}

// ==================== ZERO COUNTING N(T) ====================
let zcountData = {T: [], N: [], approx: [], S: []};

function riemannVonMangoldt(T) {
// N(T) ~ (T/2π)log(T/2πe) + 7/8
if(T < 1) return 0;
return (T / (2*PI)) * Math.log(T / (2*PI*Math.E)) + 7/8;
}

function countZerosUpTo(T) {
let count = 0;
for(const gamma of ZETA_ZEROS) {
if(gamma <= T) count++;
else break;
}
return count;
}

function drawZeroCount() {
const c = document.getElementById('czerocount'), ctx = c.getContext('2d');
const maxT = +document.getElementById('zcountTv').value || 100;
const viz = document.getElementById('zcountViz').value;
const showApprox = document.getElementById('zcountShowApprox').checked;
const showZeros = document.getElementById('zcountShowZeros').checked;

ctx.fillStyle = canvBg(); ctx.fillRect(0, 0, c.width, c.height);

// Compute data
const Tvals = [], Nvals = [], approxVals = [], Svals = [];
const step = Math.max(0.5, maxT / 500);
for(let T = 1; T <= maxT; T += step) {
const N = countZerosUpTo(T);
const approx = riemannVonMangoldt(T);
Tvals.push(T); Nvals.push(N); approxVals.push(approx); Svals.push(N - approx);
}
zcountData = {T: Tvals, N: Nvals, approx: approxVals, S: Svals};

const zerosInRange = ZETA_ZEROS.filter(g => g <= maxT);
const finalN = countZerosUpTo(maxT);
const finalApprox = riemannVonMangoldt(maxT);

const pad = 60, w = c.width - 2*pad, h = c.height - 2*pad;

let yMin, yMax, yData;
if(viz === 'error') {
yData = Svals;
yMin = Math.min(...Svals) - 0.5; yMax = Math.max(...Svals) + 0.5;
} else if(viz === 'stairs') {
yData = Nvals;
yMin = 0; yMax = Math.max(...Nvals) * 1.1;
} else {
yData = Nvals;
yMin = 0; yMax = Math.max(...Nvals, ...approxVals) * 1.1;
}

const scX = w / maxT, scY = h / (yMax - yMin);

// Grid
ctx.strokeStyle = gridC(); ctx.lineWidth = 0.5;
for(let i = 0; i <= 10; i++) {
const gx = pad + i * w / 10, gy = pad + i * h / 10;
ctx.beginPath(); ctx.moveTo(gx, pad); ctx.lineTo(gx, c.height - pad); ctx.stroke();
ctx.beginPath(); ctx.moveTo(pad, gy); ctx.lineTo(c.width - pad, gy); ctx.stroke();
}

// Zero line for error plot
if(viz === 'error') {
const y0 = c.height - pad + yMin * scY;
ctx.strokeStyle = 'rgba(255,215,0,0.5)'; ctx.lineWidth = 1;
ctx.beginPath(); ctx.moveTo(pad, y0); ctx.lineTo(c.width - pad, y0); ctx.stroke();
}

// Draw approximation
if(showApprox && viz !== 'error') {
ctx.strokeStyle = '#ff6496'; ctx.lineWidth = 2;
ctx.beginPath();
for(let i = 0; i < Tvals.length; i++) {
const px = pad + Tvals[i] * scX;
const py = c.height - pad - (approxVals[i] - yMin) * scY;
if(i === 0) ctx.moveTo(px, py); else ctx.lineTo(px, py);
}
ctx.stroke();
}

// Draw N(T) or S(T)
ctx.strokeStyle = viz === 'error' ? '#9664ff' : '#00d9ff'; ctx.lineWidth = 2;
if(viz === 'stairs') {
ctx.beginPath();
let prevY = c.height - pad;
for(let i = 0; i < zerosInRange.length; i++) {
const px = pad + zerosInRange[i] * scX;
const py = c.height - pad - ((i + 1) - yMin) * scY;
ctx.lineTo(px, prevY); ctx.lineTo(px, py);
prevY = py;
}
ctx.lineTo(c.width - pad, prevY);
ctx.stroke();
} else {
ctx.beginPath();
for(let i = 0; i < Tvals.length; i++) {
const px = pad + Tvals[i] * scX;
const py = c.height - pad - (yData[i] - yMin) * scY;
if(i === 0) ctx.moveTo(px, py); else ctx.lineTo(px, py);
}
ctx.stroke();
}

// Mark zeros
if(showZeros && viz !== 'error') {
ctx.fillStyle = '#ffd700';
for(let i = 0; i < zerosInRange.length; i++) {
const px = pad + zerosInRange[i] * scX;
const py = c.height - pad - ((i + 1) - yMin) * scY;
ctx.beginPath(); ctx.arc(px, py, 4, 0, 2*PI); ctx.fill();
}
}

// Title & labels
ctx.fillStyle = isDark() ? '#ffd700' : '#cc8800'; ctx.font = 'bold 14px Segoe UI'; ctx.textAlign = 'center';
ctx.fillText(`Zero Counting N(T) — T ≤ ${maxT}`, c.width/2, 25);
ctx.fillStyle = isDark() ? '#fff' : '#000'; ctx.font = '12px Segoe UI';
ctx.fillText('T', c.width/2, c.height - 15);
ctx.save(); ctx.translate(15, c.height/2); ctx.rotate(-PI/2);
ctx.fillText(viz === 'error' ? 'S(T)' : 'N(T)', 0, 0); ctx.restore();

legend('alzerocount', 'N(T)', [['N(T)', finalN, '#00d9ff'], ['Approx', fmt(finalApprox), '#ff6496'], ['S(T)', fmt(finalN - finalApprox), '#9664ff']]);

document.getElementById('zcountLiveStats').innerHTML = `
<div style="display:grid;grid-template-columns:repeat(3,1fr);gap:8px;margin-bottom:12px">
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center"><div style="font-size:1.3rem;font-weight:bold;color:#00d9ff">${finalN}</div><div style="font-size:.7rem;color:var(--txt2)">N(${maxT})</div></div>
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center"><div style="font-size:1.3rem;font-weight:bold;color:#ff6496">${fmt(finalApprox)}</div><div style="font-size:.7rem;color:var(--txt2)">R-vM APPROX</div></div>
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center"><div style="font-size:1.3rem;font-weight:bold;color:#9664ff">${fmt(finalN - finalApprox)}</div><div style="font-size:.7rem;color:var(--txt2)">S(T) ERROR</div></div>
</div>
<div style="margin-bottom:10px;padding-bottom:8px;border-bottom:1px solid var(--bord)">
<strong style="color:var(--acc)">Zeros in Range</strong>
<div style="display:flex;flex-wrap:wrap;gap:4px;margin-top:6px;font-size:.7rem;font-family:monospace">
${zerosInRange.slice(0, 10).map((z, i) => `<span style="background:var(--bg1);padding:2px 4px;border-radius:3px">γ${i+1}=${z.toFixed(2)}</span>`).join('')}
</div>
</div>
<div style="background:rgba(0,217,255,.1);padding:8px;border-radius:6px">
<strong style="color:#00d9ff">Riemann-von Mangoldt</strong>
<div style="font-size:.75rem;color:var(--txt2);margin-top:4px">N(T) = (T/2π)log(T/2πe) + 7/8 + S(T)</div>
</div>`;

Plotly.newPlot('pzcountGrowth', [
{x: Tvals, y: Nvals, name: 'N(T)', type: 'scatter', mode: 'lines', line: {color: '#00d9ff'}},
{x: Tvals, y: approxVals, name: 'Approx', type: 'scatter', mode: 'lines', line: {color: '#ff6496', dash: 'dash'}}
], {...plo(), xaxis: {title: 'T'}, yaxis: {title: 'N(T)'}});

Plotly.newPlot('pzcountS', [{x: Tvals, y: Svals, type: 'scatter', mode: 'lines', line: {color: '#9664ff'}}], {...plo(), xaxis: {title: 'T'}, yaxis: {title: 'S(T)'}});

c.onclick = e => {
const rect = c.getBoundingClientRect();
const T = (e.clientX - rect.left - pad) / scX * (c.width / rect.width);
if(T > 0 && T <= maxT) {
const N = countZerosUpTo(T);
const approx = riemannVonMangoldt(T);
modal(`Zero Count at T = ${fmt(T)}`, [['T', fmt(T)], ['N(T)', N], ['Approx', fmt(approx)], ['S(T)', fmt(N - approx)]]);
}
};
}

async function screenshotZeroCount() {
await screenshotUnified('czerocount', 'zcountLiveStats', `Zero Counting N(T)`, 'zero_count.png', {dashH: 280});
}

function csvZeroCount() {
let s = 'T,N_T,approx,S_T\n';
for(let i = 0; i < zcountData.T.length; i++) s += `${zcountData.T[i]},${zcountData.N[i]},${zcountData.approx[i]},${zcountData.S[i]}\n`;
dl(s, 'zero_count.csv');
}

// ==================== ZETA ARGAND (DOMAIN COLORING) ====================
// Complex zeta approximation
function zetaComplex(sigma, t, terms = 50) {
// For sigma > 1, series converges well
if(sigma > 1) {
let re = 0, im = 0;
for(let n = 1; n <= terms; n++) {
const mag = Math.pow(n, -sigma);
const phase = -t * Math.log(n);
re += mag * Math.cos(phase);
im += mag * Math.sin(phase);
}
return {re, im};
}
// For critical strip and left half-plane, use Dirichlet eta with more terms
// η(s) = (1 - 2^{1-s}) ζ(s), so ζ(s) = η(s) / (1 - 2^{1-s})
let etaRe = 0, etaIm = 0;
const useTerms = Math.max(terms * 3, 150);
for(let n = 1; n <= useTerms; n++) {
const sign = (n % 2 === 1) ? 1 : -1;
const mag = Math.pow(n, -sigma);
const phase = -t * Math.log(n);
etaRe += sign * mag * Math.cos(phase);
etaIm += sign * mag * Math.sin(phase);
}
// Compute 1 - 2^{1-s} = 1 - 2^{1-sigma} * e^{-it*log(2)}
const pow2 = Math.pow(2, 1 - sigma);
const phase2 = -t * Math.log(2);
const denom_re = 1 - pow2 * Math.cos(phase2);
const denom_im = pow2 * Math.sin(phase2);
const denom_mag = denom_re * denom_re + denom_im * denom_im;
if(denom_mag < 1e-10) return {re: 1e10, im: 0}; // Near pole
// ζ = η / denom (complex division)
const re = (etaRe * denom_re + etaIm * denom_im) / denom_mag;
const im = (etaIm * denom_re - etaRe * denom_im) / denom_mag;
return {re, im};
}

function drawArgand() {
const c = document.getElementById('cargand'), ctx = c.getContext('2d');
const s1 = +document.getElementById('argandS1').value;
const s2 = +document.getElementById('argandS2').value;
const t1 = +document.getElementById('argandT1').value;
const t2 = +document.getElementById('argandT2').value;
const res = +document.getElementById('argandRes').value;
const colMode = document.getElementById('argandCol').value;
const showCrit = document.getElementById('argandShowCrit').checked;
const showZeros = document.getElementById('argandShowZeros').checked;
const showPole = document.getElementById('argandShowPole').checked;

const imgData = ctx.createImageData(c.width, c.height);
const dSigma = (s2 - s1) / c.width;
const dT = (t2 - t1) / c.height;

for(let py = 0; py < c.height; py++) {
const t = t2 - py * dT;
for(let px = 0; px < c.width; px++) {
const sigma = s1 + px * dSigma;
const z = zetaComplex(sigma, t, Math.min(res, 100));
const mag = Math.sqrt(z.re * z.re + z.im * z.im);
const phase = Math.atan2(z.im, z.re);

let r, g, b;
if(colMode === 'phase') {
const hue = (phase + PI) / (2 * PI);
const sat = 0.8;
const light = 0.5 + 0.3 * Math.tanh(Math.log(mag + 0.1));
[r, g, b] = hslToRgb(hue, sat, light);
} else if(colMode === 'modulus') {
const v = Math.tanh(mag / 3);
r = g = b = Math.floor(v * 255);
} else if(colMode === 'logmod') {
const v = (Math.log(mag + 1) / 5 + 0.5);
r = g = b = Math.floor(Math.min(1, Math.max(0, v)) * 255);
} else if(colMode === 'real') {
const v = Math.tanh(z.re / 2);
r = v > 0 ? Math.floor(v * 255) : 0;
b = v < 0 ? Math.floor(-v * 255) : 0;
g = 0;
} else {
const v = Math.tanh(z.im / 2);
r = v > 0 ? Math.floor(v * 255) : 0;
b = v < 0 ? Math.floor(-v * 255) : 0;
g = 0;
}

const idx = (py * c.width + px) * 4;
imgData.data[idx] = r;
imgData.data[idx + 1] = g;
imgData.data[idx + 2] = b;
imgData.data[idx + 3] = 255;
}
}
ctx.putImageData(imgData, 0, 0);

// Critical line
if(showCrit) {
const critX = (0.5 - s1) / (s2 - s1) * c.width;
ctx.strokeStyle = 'rgba(255,255,255,0.7)'; ctx.lineWidth = 2; ctx.setLineDash([5, 3]);
ctx.beginPath(); ctx.moveTo(critX, 0); ctx.lineTo(critX, c.height); ctx.stroke();
ctx.setLineDash([]);
}

// Zeros
if(showZeros) {
ctx.fillStyle = '#ffd700';
for(const gamma of ZETA_ZEROS) {
if(gamma >= t1 && gamma <= t2) {
const px = (0.5 - s1) / (s2 - s1) * c.width;
const py = (t2 - gamma) / (t2 - t1) * c.height;
ctx.beginPath(); ctx.arc(px, py, 4, 0, 2*PI); ctx.fill();
}
if(-gamma >= t1 && -gamma <= t2) {
const px = (0.5 - s1) / (s2 - s1) * c.width;
const py = (t2 - (-gamma)) / (t2 - t1) * c.height;
ctx.beginPath(); ctx.arc(px, py, 4, 0, 2*PI); ctx.fill();
}
}
}

// Pole at s=1
if(showPole && s1 < 1 && s2 > 1 && t1 < 0 && t2 > 0) {
const px = (1 - s1) / (s2 - s1) * c.width;
const py = (t2 - 0) / (t2 - t1) * c.height;
ctx.strokeStyle = '#ff0000'; ctx.lineWidth = 2;
ctx.beginPath(); ctx.arc(px, py, 8, 0, 2*PI); ctx.stroke();
ctx.fillStyle = '#ff0000'; ctx.font = '12px Segoe UI';
ctx.fillText('pole', px + 12, py);
}

// Axes labels
ctx.fillStyle = '#fff'; ctx.font = '11px Segoe UI';
ctx.fillText(`σ=${s1}`, 5, c.height - 5);
ctx.fillText(`σ=${s2}`, c.width - 40, c.height - 5);
ctx.fillText(`t=${t2}`, 5, 15);
ctx.fillText(`t=${t1}`, 5, c.height - 20);

legend('alargand', 'ζ(s) Domain', [['Re range', `[${s1},${s2}]`, '#00d9ff'], ['Im range', `[${t1},${t2}]`, '#ff6496']]);

const zerosVis = ZETA_ZEROS.filter(g => g >= t1 && g <= t2).length * 2;
document.getElementById('argandLiveStats').innerHTML = `
<div style="display:grid;grid-template-columns:repeat(2,1fr);gap:8px;margin-bottom:12px">
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center"><div style="font-size:1.2rem;font-weight:bold;color:#00d9ff">[${s1}, ${s2}]</div><div style="font-size:.7rem;color:var(--txt2)">σ RANGE</div></div>
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center"><div style="font-size:1.2rem;font-weight:bold;color:#ff6496">[${t1}, ${t2}]</div><div style="font-size:.7rem;color:var(--txt2)">t RANGE</div></div>
</div>
<div style="margin-bottom:10px;padding-bottom:8px;border-bottom:1px solid var(--bord)">
<strong style="color:var(--acc)">Visible Features</strong>
<div style="display:grid;grid-template-columns:1fr 1fr;gap:4px;margin-top:6px;font-size:.8rem">
<span>Zeros visible:</span><span style="color:#ffd700">${zerosVis}</span>
<span>Critical line:</span><span style="color:#00ff88">${showCrit ? 'σ=½' : 'hidden'}</span>
<span>Pole:</span><span style="color:#ff6496">${s1 < 1 && s2 > 1 ? 's=1' : 'out of view'}</span>
<span>Color:</span><span style="color:#9664ff">${colMode}</span>
</div>
</div>
<div style="background:rgba(255,215,0,.1);padding:8px;border-radius:6px">
<strong style="color:#ffd700">Domain Coloring</strong>
<div style="font-size:.75rem;color:var(--txt2);margin-top:4px">Hue = arg(ζ), brightness = |ζ|. Zeros show full color wheels.</div>
</div>`;

// Click handler for Argand
c.onclick = e => {
  const rect = c.getBoundingClientRect();
  const mx = (e.clientX - rect.left) * (c.width / rect.width);
  const my = (e.clientY - rect.top) * (c.height / rect.height);
  const sigma = s1 + (mx / c.width) * (s2 - s1);
  const t = t2 - (my / c.height) * (t2 - t1);
  const z = zetaComplex(sigma, t, 100);
  modal('ζ(s) Point Analysis', [
    ['s', `${fmt(sigma)} + ${fmt(t)}i`],
    ['σ (Re)', fmt(sigma)],
    ['t (Im)', fmt(t)],
    ['|ζ(s)|', fmt(Math.sqrt(z.re*z.re + z.im*z.im))],
    ['arg(ζ(s))', fmt(Math.atan2(z.im, z.re) * 180 / PI) + '°'],
    ['Re(ζ)', fmt(z.re)],
    ['Im(ζ)', fmt(z.im)],
    ['On critical line', Math.abs(sigma - 0.5) < 0.05 ? 'Yes (σ≈½)' : 'No']
  ]);
};
}

function hslToRgb(h, s, l) {
let r, g, b;
if(s === 0) { r = g = b = l; }
else {
const hue2rgb = (p, q, t) => {
if(t < 0) t += 1; if(t > 1) t -= 1;
if(t < 1/6) return p + (q - p) * 6 * t;
if(t < 1/2) return q;
if(t < 2/3) return p + (q - p) * (2/3 - t) * 6;
return p;
};
const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
const p = 2 * l - q;
r = hue2rgb(p, q, h + 1/3);
g = hue2rgb(p, q, h);
b = hue2rgb(p, q, h - 1/3);
}
return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
}

async function screenshotArgand() {
await screenshotUnified('cargand', 'argandLiveStats', `ζ(s) Domain Coloring`, 'zeta_argand.png', {dashH: 250});
}

// ==================== ZETA REAL AXIS ====================
let zetarealData = {s: [], zeta: []};

function zetaReal(s) {
if(s === 1) return Infinity;
if(s > 1) {
// Direct series
let sum = 0;
for(let n = 1; n <= 10000; n++) sum += Math.pow(n, -s);
return sum;
}
// Use stored values or functional equation approximation
if(s === 2) return ZETA2;
if(s === 3) return ZETA3;
if(s === 4) return ZETA4;
if(s === 0) return -0.5;
if(s === -1) return -1/12;
if(s < 0 && s === Math.floor(s) && s % 2 === 0) return 0; // Trivial zeros
// Approximation via reflection for other negative values
if(s < 0) {
const s1 = 1 - s;
const zeta1s = zetaReal(s1);
// Functional equation: ζ(s) = 2^s π^{s-1} sin(πs/2) Γ(1-s) ζ(1-s)
const factor = Math.pow(2, s) * Math.pow(PI, s - 1) * Math.sin(PI * s / 2);
// Γ(1-s) approximation via Stirling for large 1-s
const gamma1s = gamma(1 - s);
return factor * gamma1s * zeta1s;
}
// 0 < s < 1: Dirichlet eta function
let sum = 0;
for(let n = 1; n <= 10000; n++) sum += Math.pow(-1, n + 1) * Math.pow(n, -s);
return sum / (1 - Math.pow(2, 1 - s));
}

function gamma(x) {
// Lanczos approximation
if(x < 0.5) return PI / (Math.sin(PI * x) * gamma(1 - x));
x -= 1;
const g = 7;
const c = [0.99999999999980993, 676.5203681218851, -1259.1392167224028, 771.32342877765313, -176.61502916214059, 12.507343278686905, -0.13857109526572012, 9.9843695780195716e-6, 1.5056327351493116e-7];
let sum = c[0];
for(let i = 1; i < g + 2; i++) sum += c[i] / (x + i);
const t = x + g + 0.5;
return Math.sqrt(2 * PI) * Math.pow(t, x + 0.5) * Math.exp(-t) * sum;
}

function drawZetaReal() {
const c = document.getElementById('czetareal'), ctx = c.getContext('2d');
const s1 = +document.getElementById('zetarealS1').value;
const s2 = +document.getElementById('zetarealS2').value;
const res = +document.getElementById('zetarealRes').value;
const yClamp = +document.getElementById('zetarealYclamp').value;
const showPole = document.getElementById('zetarealShowPole').checked;
const showTrivial = document.getElementById('zetarealShowTrivial').checked;
const showSpecial = document.getElementById('zetarealShowSpecial').checked;

ctx.fillStyle = canvBg(); ctx.fillRect(0, 0, c.width, c.height);

const pad = 60, w = c.width - 2*pad, h = c.height - 2*pad;
const ds = (s2 - s1) / res;

const sVals = [], zVals = [];
for(let i = 0; i <= res; i++) {
const s = s1 + i * ds;
if(Math.abs(s - 1) < 0.01) continue; // Skip pole
const z = zetaReal(s);
if(isFinite(z) && Math.abs(z) < 1000) {
sVals.push(s); zVals.push(z);
}
}
zetarealData = {s: sVals, zeta: zVals};

const yMin = -yClamp, yMax = yClamp;
const scX = w / (s2 - s1), scY = h / (yMax - yMin);

// Grid
ctx.strokeStyle = gridC(); ctx.lineWidth = 0.5;
for(let i = 0; i <= 10; i++) {
const gx = pad + i * w / 10, gy = pad + i * h / 10;
ctx.beginPath(); ctx.moveTo(gx, pad); ctx.lineTo(gx, c.height - pad); ctx.stroke();
ctx.beginPath(); ctx.moveTo(pad, gy); ctx.lineTo(c.width - pad, gy); ctx.stroke();
}

// Zero line
const y0 = c.height - pad + yMin * scY;
ctx.strokeStyle = 'rgba(255,215,0,0.5)'; ctx.lineWidth = 1;
ctx.beginPath(); ctx.moveTo(pad, y0); ctx.lineTo(c.width - pad, y0); ctx.stroke();

// Draw ζ(s)
ctx.strokeStyle = '#00d9ff'; ctx.lineWidth = 2;
ctx.beginPath();
let started = false;
for(let i = 0; i < sVals.length; i++) {
const px = pad + (sVals[i] - s1) * scX;
const clampedZ = Math.max(yMin, Math.min(yMax, zVals[i]));
const py = c.height - pad - (clampedZ - yMin) * scY;
if(!started) { ctx.moveTo(px, py); started = true; }
else if(Math.abs(zVals[i] - zVals[i-1]) < yClamp * 2) ctx.lineTo(px, py);
else { ctx.stroke(); ctx.beginPath(); ctx.moveTo(px, py); }
}
ctx.stroke();

// Pole indicator
if(showPole && s1 < 1 && s2 > 1) {
const poleX = pad + (1 - s1) * scX;
ctx.strokeStyle = '#ff6496'; ctx.lineWidth = 2; ctx.setLineDash([5, 3]);
ctx.beginPath(); ctx.moveTo(poleX, pad); ctx.lineTo(poleX, c.height - pad); ctx.stroke();
ctx.setLineDash([]);
ctx.fillStyle = '#ff6496'; ctx.font = '11px Segoe UI';
ctx.fillText('pole s=1', poleX + 5, pad + 15);
}

// Trivial zeros
if(showTrivial) {
ctx.fillStyle = '#9664ff';
for(let n = -2; n >= s1; n -= 2) {
const px = pad + (n - s1) * scX;
ctx.beginPath(); ctx.arc(px, y0, 6, 0, 2*PI); ctx.fill();
}
}

// Special values
if(showSpecial) {
const specials = [[2, ZETA2, 'ζ(2)=π²/6'], [3, ZETA3, 'ζ(3)≈1.202'], [4, ZETA4, 'ζ(4)'], [0, -0.5, 'ζ(0)=-½']];
ctx.fillStyle = '#ffd700';
for(const [s, z, label] of specials) {
if(s >= s1 && s <= s2) {
const px = pad + (s - s1) * scX;
const py = c.height - pad - (Math.max(yMin, Math.min(yMax, z)) - yMin) * scY;
ctx.beginPath(); ctx.arc(px, py, 5, 0, 2*PI); ctx.fill();
ctx.fillStyle = isDark() ? '#fff' : '#000'; ctx.font = '10px Segoe UI';
ctx.fillText(label, px + 8, py - 5);
ctx.fillStyle = '#ffd700';
}
}
}

// Labels
ctx.fillStyle = isDark() ? '#ffd700' : '#cc8800'; ctx.font = 'bold 14px Segoe UI'; ctx.textAlign = 'center';
ctx.fillText(`ζ(s) on Real Axis — s ∈ [${s1}, ${s2}]`, c.width/2, 25);
ctx.fillStyle = isDark() ? '#fff' : '#000'; ctx.font = '12px Segoe UI';
ctx.fillText('s', c.width/2, c.height - 15);
ctx.save(); ctx.translate(15, c.height/2); ctx.rotate(-PI/2); ctx.fillText('ζ(s)', 0, 0); ctx.restore();

legend('alzetareal', 'ζ(s) Real', [['ζ(2)', fmt(ZETA2), '#ffd700'], ['ζ(3)', fmt(ZETA3), '#00d9ff'], ['ζ(0)', '-0.5', '#9664ff']]);

document.getElementById('zetarealLiveStats').innerHTML = `
<div style="display:grid;grid-template-columns:repeat(3,1fr);gap:8px;margin-bottom:12px">
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center"><div style="font-size:1.1rem;font-weight:bold;color:#ffd700">${ZETA2.toFixed(8)}</div><div style="font-size:.7rem;color:var(--txt2)">ζ(2) = π²/6</div></div>
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center"><div style="font-size:1.1rem;font-weight:bold;color:#00d9ff">${ZETA3.toFixed(8)}</div><div style="font-size:.7rem;color:var(--txt2)">ζ(3) APÉRY</div></div>
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center"><div style="font-size:1.1rem;font-weight:bold;color:#ff6496">-1/12</div><div style="font-size:.7rem;color:var(--txt2)">ζ(-1)</div></div>
</div>
<div style="margin-bottom:10px;padding-bottom:8px;border-bottom:1px solid var(--bord)">
<strong style="color:var(--acc)">Special Values</strong>
<div style="display:grid;grid-template-columns:1fr 1fr;gap:4px;margin-top:6px;font-size:.8rem">
<span>ζ(2) = π²/6:</span><span style="color:#ffd700">${ZETA2.toFixed(10)}</span>
<span>ζ(4) = π⁴/90:</span><span style="color:#00d9ff">${ZETA4.toFixed(10)}</span>
<span>ζ(0):</span><span style="color:#9664ff">-0.5</span>
<span>ζ(-1):</span><span style="color:#ff6496">-1/12 ≈ ${(-1/12).toFixed(10)}</span>
</div>
</div>
<div style="background:rgba(150,100,255,.1);padding:8px;border-radius:6px">
<strong style="color:#9664ff">Trivial Zeros</strong>
<div style="font-size:.75rem;color:var(--txt2);margin-top:4px">ζ(-2)=ζ(-4)=ζ(-6)=...=0 from functional equation</div>
</div>`;

const specVals = [2, 3, 4, 5, 6, 7, 8].map(n => ({n, z: zeta(n)}));
Plotly.newPlot('pzetarealSpecial', [{x: specVals.map(v => v.n), y: specVals.map(v => v.z), type: 'bar', marker: {color: '#ffd700'}}], {...plo(), xaxis: {title: 'n'}, yaxis: {title: 'ζ(n)'}});

const nearPole = [];
for(let s = 1.01; s <= 2; s += 0.05) nearPole.push({s, z: zetaReal(s)});
Plotly.newPlot('pzetarealPole', [{x: nearPole.map(v => v.s), y: nearPole.map(v => v.z), type: 'scatter', mode: 'lines+markers', line: {color: '#ff6496'}}], {...plo(), xaxis: {title: 's'}, yaxis: {title: 'ζ(s)'}});

c.onclick = e => {
const rect = c.getBoundingClientRect();
const s = s1 + (e.clientX - rect.left - pad) / scX;
if(s >= s1 && s <= s2 && Math.abs(s - 1) > 0.05) {
const z = zetaReal(s);
modal(`ζ(${fmt(s)})`, [['s', fmt(s)], ['ζ(s)', fmt(z)], ['1/ζ(s)', fmt(1/z)]]);
}
};
}

async function screenshotZetaReal() {
await screenshotUnified('czetareal', 'zetarealLiveStats', `ζ(s) on Real Axis`, 'zeta_real.png', {dashH: 280});
}

function csvZetaReal() {
let s = 's,zeta_s\n';
for(let i = 0; i < zetarealData.s.length; i++) s += `${zetarealData.s[i]},${zetarealData.zeta[i]}\n`;
dl(s, 'zeta_real.csv');
}

// ==================== MONTGOMERY PAIR CORRELATION ====================
let montgomeryData = {gaps: [], normalized: []};

function drawMontgomery() {
const c = document.getElementById('cmontgomery'), ctx = c.getContext('2d');
const N = Math.min(+document.getElementById('montNv').value || 50, ZETA_ZEROS.length);
const binWidth = +document.getElementById('montBin').value || 0.1;
const mode = document.getElementById('montMode').value;
const showGUE = document.getElementById('montGUE').checked;

// Compute normalized gaps
const zeros = ZETA_ZEROS.slice(0, N);
const gaps = [];
for(let i = 1; i < zeros.length; i++) {
const gap = zeros[i] - zeros[i-1];
// Normalize by average spacing: 2π/log(γ_i)
const avgSpacing = 2 * PI / Math.log(zeros[i] / (2 * PI));
gaps.push(gap / avgSpacing);
}
montgomeryData = {gaps, normalized: gaps};

ctx.fillStyle = canvBg(); ctx.fillRect(0, 0, c.width, c.height);

const margin = {l: 60, r: 30, t: 40, b: 50};
const w = c.width - margin.l - margin.r;
const h = c.height - margin.t - margin.b;

if(mode === 'histogram') {
// Create histogram
const maxGap = Math.max(...gaps, 3);
const bins = Math.ceil(maxGap / binWidth);
const hist = Array(bins).fill(0);
gaps.forEach(g => {
const bin = Math.min(Math.floor(g / binWidth), bins - 1);
if(bin >= 0) hist[bin]++;
});
const maxCount = Math.max(...hist);

// Draw bars
ctx.fillStyle = '#00d9ff';
for(let i = 0; i < bins; i++) {
const x = margin.l + (i / bins) * w;
const barW = w / bins - 1;
const barH = (hist[i] / maxCount) * h;
ctx.fillRect(x, margin.t + h - barH, barW, barH);
}

// GUE pair correlation prediction: 1 - (sin(πx)/(πx))²
if(showGUE) {
ctx.strokeStyle = '#ff6496';
ctx.lineWidth = 2;
ctx.beginPath();
for(let i = 0; i <= 100; i++) {
const x = (i / 100) * maxGap;
const px = margin.l + (x / maxGap) * w;
// Pair correlation R2(x) = 1 - (sin(πx)/(πx))² for x > 0
const sinc = x < 0.01 ? 1 : Math.sin(PI * x) / (PI * x);
const r2 = 1 - sinc * sinc;
const py = margin.t + h - r2 * h;
if(i === 0) ctx.moveTo(px, py);
else ctx.lineTo(px, py);
}
ctx.stroke();
ctx.fillStyle = '#ff6496';
ctx.font = '11px Segoe UI';
ctx.fillText('GUE: 1-(sin πx/πx)²', c.width - 130, margin.t + 20);
}

// Axes
ctx.strokeStyle = isDark() ? '#fff' : '#333';
ctx.lineWidth = 1;
ctx.beginPath();
ctx.moveTo(margin.l, margin.t);
ctx.lineTo(margin.l, margin.t + h);
ctx.lineTo(margin.l + w, margin.t + h);
ctx.stroke();

ctx.fillStyle = isDark() ? '#fff' : '#333';
ctx.font = '11px Segoe UI';
ctx.fillText('Normalized Gap', margin.l + w/2 - 40, c.height - 10);
ctx.save();
ctx.translate(15, margin.t + h/2);
ctx.rotate(-Math.PI/2);
ctx.fillText('Count', 0, 0);
ctx.restore();
} else if(mode === 'scatter') {
// Scatter plot of consecutive gaps
ctx.fillStyle = '#00d9ff';
for(let i = 0; i < gaps.length - 1; i++) {
const x = margin.l + (gaps[i] / 4) * w;
const y = margin.t + h - (gaps[i+1] / 4) * h;
ctx.beginPath();
ctx.arc(x, y, 3, 0, 2*PI);
ctx.fill();
}
ctx.strokeStyle = isDark() ? '#fff' : '#333';
ctx.beginPath();
ctx.moveTo(margin.l, margin.t);
ctx.lineTo(margin.l, margin.t + h);
ctx.lineTo(margin.l + w, margin.t + h);
ctx.stroke();
ctx.fillStyle = isDark() ? '#fff' : '#333';
ctx.font = '11px Segoe UI';
ctx.fillText('Gap n', margin.l + w/2, c.height - 10);
ctx.fillText('Gap n+1', 20, margin.t + h/2);
} else {
// Cumulative distribution
const sorted = [...gaps].sort((a,b) => a - b);
ctx.strokeStyle = '#00d9ff';
ctx.lineWidth = 2;
ctx.beginPath();
for(let i = 0; i < sorted.length; i++) {
const x = margin.l + (sorted[i] / 4) * w;
const y = margin.t + h - ((i + 1) / sorted.length) * h;
if(i === 0) ctx.moveTo(x, y);
else ctx.lineTo(x, y);
}
ctx.stroke();

// GUE CDF
if(showGUE) {
ctx.strokeStyle = '#ff6496';
ctx.beginPath();
for(let i = 0; i <= 100; i++) {
const x = (i / 100) * 4;
const px = margin.l + (x / 4) * w;
// Approximate Wigner surmise CDF
const cdf = 1 - Math.exp(-PI * x * x / 4);
const py = margin.t + h - cdf * h;
if(i === 0) ctx.moveTo(px, py);
else ctx.lineTo(px, py);
}
ctx.stroke();
}
}

// Stats
const meanGap = gaps.reduce((a,b) => a+b, 0) / gaps.length;
const variance = gaps.reduce((a,g) => a + (g - meanGap)**2, 0) / gaps.length;

legend('almontgomery', 'Pair Correlation', [['Zeros', N, '#00d9ff'], ['Mean Gap', fmt(meanGap), '#ffd700'], ['Variance', fmt(variance), '#ff6496']]);

document.getElementById('montLiveStats').innerHTML = `
<div style="display:grid;grid-template-columns:repeat(3,1fr);gap:8px;margin-bottom:12px">
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center"><div style="font-size:1.2rem;font-weight:bold;color:#00d9ff">${N}</div><div style="font-size:.7rem;color:var(--txt2)">ZEROS ANALYZED</div></div>
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center"><div style="font-size:1.2rem;font-weight:bold;color:#ffd700">${fmt(meanGap)}</div><div style="font-size:.7rem;color:var(--txt2)">MEAN NORMALIZED GAP</div></div>
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center"><div style="font-size:1.2rem;font-weight:bold;color:#ff6496">${fmt(Math.sqrt(variance))}</div><div style="font-size:.7rem;color:var(--txt2)">STD DEVIATION</div></div>
</div>
<div style="margin-bottom:10px;padding-bottom:8px;border-bottom:1px solid var(--bord)">
<strong style="color:var(--acc)">Gap Statistics</strong>
<div style="display:grid;grid-template-columns:1fr 1fr;gap:4px;margin-top:6px;font-size:.8rem">
<span>Min gap:</span><span style="color:#00d9ff">${fmt(Math.min(...gaps))}</span>
<span>Max gap:</span><span style="color:#ff6496">${fmt(Math.max(...gaps))}</span>
<span>GUE mean:</span><span style="color:#9664ff">1.0 (normalized)</span>
<span>Actual mean:</span><span style="color:#ffd700">${fmt(meanGap)}</span>
</div>
</div>
<div style="background:rgba(0,217,255,.1);padding:8px;border-radius:6px">
<strong style="color:#00d9ff">Montgomery's Discovery</strong>
<div style="font-size:.75rem;color:var(--txt2);margin-top:4px">The pair correlation follows R₂(x) = 1 - (sin πx / πx)², matching GUE random matrices!</div>
</div>`;

// Click handler for Montgomery
c.onclick = e => {
  const rect = c.getBoundingClientRect();
  const mx = (e.clientX - rect.left) * (c.width / rect.width);
  const gapVal = (mx - margin.l) / w * 4;
  if(gapVal >= 0 && gapVal <= 4) {
    const sinc = gapVal > 0 ? Math.sin(PI * gapVal) / (PI * gapVal) : 1;
    const R2 = 1 - sinc * sinc;
    modal('Pair Correlation Analysis', [
      ['Normalized gap', fmt(gapVal)],
      ['GUE R₂(x)', fmt(R2)],
      ['Formula', '1 - (sin πx / πx)²'],
      ['Nearest zeros', `${ZETA_ZEROS.length} available`],
      ['Mean gap', fmt(meanGap)]
    ]);
  }
};
}

async function screenshotMontgomery() {
await screenshotUnified('cmontgomery', 'montLiveStats', 'Montgomery Pair Correlation', 'montgomery.png');
}

function csvMontgomery() {
let s = 'gap_index,normalized_gap\n';
montgomeryData.gaps.forEach((g, i) => s += `${i},${g}\n`);
dl(s, 'montgomery.csv');
}

// ==================== GUE STATISTICS ====================
let gueData = {spacings: []};

function drawGUE() {
const c = document.getElementById('cgue'), ctx = c.getContext('2d');
const N = Math.min(+document.getElementById('gueNv').value || 50, ZETA_ZEROS.length);
const mode = document.getElementById('gueMode').value;
const showWigner = document.getElementById('gueWigner').checked;
const showPoisson = document.getElementById('guePoisson').checked;

const zeros = ZETA_ZEROS.slice(0, N);

// Unfold zeros: transform to have unit mean spacing
const unfolded = zeros.map(gamma => {
// N(T) ~ T/(2π) log(T/(2πe)) + 7/8
return (gamma / (2*PI)) * Math.log(gamma / (2*PI*Math.E)) + 7/8;
});

// Compute spacings
const spacings = [];
for(let i = 1; i < unfolded.length; i++) {
spacings.push(unfolded[i] - unfolded[i-1]);
}
gueData.spacings = spacings;

ctx.fillStyle = canvBg(); ctx.fillRect(0, 0, c.width, c.height);

const margin = {l: 60, r: 30, t: 40, b: 50};
const w = c.width - margin.l - margin.r;
const h = c.height - margin.t - margin.b;

if(mode === 'spacing' || mode === 'wigner') {
// Histogram of spacings
const maxS = Math.min(Math.max(...spacings), 4);
const bins = 20;
const binWidth = maxS / bins;
const hist = Array(bins).fill(0);
spacings.forEach(s => {
const bin = Math.min(Math.floor(s / binWidth), bins - 1);
if(bin >= 0) hist[bin]++;
});
// Normalize to probability density
const total = spacings.length * binWidth;
const density = hist.map(h => h / total);
const maxDensity = Math.max(...density, 1);

// Draw histogram
ctx.fillStyle = '#00d9ff';
for(let i = 0; i < bins; i++) {
const x = margin.l + (i / bins) * w;
const barW = w / bins - 1;
const barH = (density[i] / maxDensity) * h;
ctx.fillRect(x, margin.t + h - barH, barW, barH);
}

// Wigner surmise: P(s) = (π/2)s exp(-πs²/4)
if(showWigner) {
ctx.strokeStyle = '#ff6496';
ctx.lineWidth = 2;
ctx.beginPath();
for(let i = 0; i <= 100; i++) {
const s = (i / 100) * maxS;
const px = margin.l + (s / maxS) * w;
const wigner = (PI / 2) * s * Math.exp(-PI * s * s / 4);
const py = margin.t + h - (wigner / maxDensity) * h;
if(i === 0) ctx.moveTo(px, py);
else ctx.lineTo(px, py);
}
ctx.stroke();
ctx.fillStyle = '#ff6496';
ctx.font = '11px Segoe UI';
ctx.fillText('Wigner: (π/2)s·e^{-πs²/4}', c.width - 150, margin.t + 20);
}

// Poisson: P(s) = exp(-s)
if(showPoisson) {
ctx.strokeStyle = '#9664ff';
ctx.lineWidth = 2;
ctx.setLineDash([5, 3]);
ctx.beginPath();
for(let i = 0; i <= 100; i++) {
const s = (i / 100) * maxS;
const px = margin.l + (s / maxS) * w;
const poisson = Math.exp(-s);
const py = margin.t + h - (poisson / maxDensity) * h;
if(i === 0) ctx.moveTo(px, py);
else ctx.lineTo(px, py);
}
ctx.stroke();
ctx.setLineDash([]);
ctx.fillStyle = '#9664ff';
ctx.fillText('Poisson: e^{-s}', c.width - 150, margin.t + 40);
}
} else {
// Unfolded zeros plot
ctx.fillStyle = '#00d9ff';
for(let i = 0; i < unfolded.length; i++) {
const x = margin.l + (i / unfolded.length) * w;
const y = margin.t + h - (unfolded[i] / unfolded[unfolded.length-1]) * h;
ctx.beginPath();
ctx.arc(x, y, 3, 0, 2*PI);
ctx.fill();
}
// Line y = x (expected for unit density)
ctx.strokeStyle = '#ff6496';
ctx.lineWidth = 1;
ctx.setLineDash([5, 3]);
ctx.beginPath();
ctx.moveTo(margin.l, margin.t + h);
ctx.lineTo(margin.l + w, margin.t);
ctx.stroke();
ctx.setLineDash([]);
}

// Axes
ctx.strokeStyle = isDark() ? '#fff' : '#333';
ctx.lineWidth = 1;
ctx.beginPath();
ctx.moveTo(margin.l, margin.t);
ctx.lineTo(margin.l, margin.t + h);
ctx.lineTo(margin.l + w, margin.t + h);
ctx.stroke();

const meanSpacing = spacings.reduce((a,b) => a+b, 0) / spacings.length;
const varSpacing = spacings.reduce((a,s) => a + (s - meanSpacing)**2, 0) / spacings.length;

legend('algue', 'GUE Statistics', [['Zeros', N, '#00d9ff'], ['Mean Spacing', fmt(meanSpacing), '#ffd700'], ['Std Dev', fmt(Math.sqrt(varSpacing)), '#ff6496']]);

document.getElementById('gueLiveStats').innerHTML = `
<div style="display:grid;grid-template-columns:repeat(3,1fr);gap:8px;margin-bottom:12px">
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center"><div style="font-size:1.2rem;font-weight:bold;color:#00d9ff">${N}</div><div style="font-size:.7rem;color:var(--txt2)">ZEROS</div></div>
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center"><div style="font-size:1.2rem;font-weight:bold;color:#ffd700">${fmt(meanSpacing)}</div><div style="font-size:.7rem;color:var(--txt2)">MEAN SPACING</div></div>
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center"><div style="font-size:1.2rem;font-weight:bold;color:#ff6496">${fmt(Math.sqrt(varSpacing))}</div><div style="font-size:.7rem;color:var(--txt2)">STD DEV</div></div>
</div>
<div style="margin-bottom:10px;padding-bottom:8px;border-bottom:1px solid var(--bord)">
<strong style="color:var(--acc)">Comparison</strong>
<div style="display:grid;grid-template-columns:1fr 1fr;gap:4px;margin-top:6px;font-size:.8rem">
<span>GUE mean:</span><span style="color:#00d9ff">1.0</span>
<span>GUE variance:</span><span style="color:#ff6496">${fmt(4/PI - 1)} ≈ 0.273</span>
<span>Poisson mean:</span><span style="color:#9664ff">1.0</span>
<span>Poisson variance:</span><span style="color:#9664ff">1.0</span>
</div>
</div>
<div style="background:rgba(255,100,150,.1);padding:8px;border-radius:6px">
<strong style="color:#ff6496">Key Difference</strong>
<div style="font-size:.75rem;color:var(--txt2);margin-top:4px">GUE: P(0) = 0 (zeros repel). Poisson: P(0) = max (no correlation). Zeta zeros follow GUE!</div>
</div>`;

// Click handler for GUE
c.onclick = e => {
  const rect = c.getBoundingClientRect();
  const mx = (e.clientX - rect.left) * (c.width / rect.width);
  const spacingVal = (mx - margin.l) / w * 3;
  if(spacingVal >= 0 && spacingVal <= 3) {
    const guePDF = PI/2 * spacingVal * Math.exp(-PI * spacingVal * spacingVal / 4);
    const poissonPDF = Math.exp(-spacingVal);
    modal('Spacing Distribution', [
      ['Normalized spacing', fmt(spacingVal)],
      ['GUE PDF P(s)', fmt(guePDF)],
      ['Poisson PDF', fmt(poissonPDF)],
      ['GUE formula', '(π/2)s·e^(-πs²/4)'],
      ['Total zeros', N],
      ['Mean spacing', fmt(meanSpacing)]
    ]);
  }
};
}

async function screenshotGUE() {
await screenshotUnified('cgue', 'gueLiveStats', 'GUE Random Matrix Statistics', 'gue_stats.png');
}

function csvGUE() {
let s = 'index,spacing\n';
gueData.spacings.forEach((sp, i) => s += `${i},${sp}\n`);
dl(s, 'gue_spacings.csv');
}

// ==================== PRIME RACES ====================
let primeRaceData = {x: [], counts: {}, diff: []};

function drawPrimeRace() {
const c = document.getElementById('cprimerace'), ctx = c.getContext('2d');
const maxX = +document.getElementById('raceXv').value || 10000;
const q = +document.getElementById('raceQ').value;
const mode = document.getElementById('raceMode').value;

// Get residue classes to compare
let classes = [];
if(q === 4) classes = [1, 3];
else if(q === 3) classes = [1, 2];
else if(q === 8) classes = [1, 3, 5, 7];
else if(q === 5) classes = [1, 2, 3, 4];
else if(q === 6) classes = [1, 5];

// Count primes in each class
const counts = {};
classes.forEach(a => counts[a] = []);

const sieve = Array(maxX + 1).fill(true);
sieve[0] = sieve[1] = false;
for(let i = 2; i * i <= maxX; i++) {
if(sieve[i]) for(let j = i*i; j <= maxX; j += i) sieve[j] = false;
}

const current = {};
classes.forEach(a => current[a] = 0);

const xs = [];
const step = Math.max(1, Math.floor(maxX / 500));

for(let x = 2; x <= maxX; x++) {
if(sieve[x]) {
const r = x % q;
if(current[r] !== undefined) current[r]++;
}
if(x % step === 0 || x === maxX) {
xs.push(x);
classes.forEach(a => counts[a].push(current[a]));
}
}

primeRaceData = {x: xs, counts, diff: []};

ctx.fillStyle = canvBg(); ctx.fillRect(0, 0, c.width, c.height);

const margin = {l: 60, r: 30, t: 40, b: 50};
const w = c.width - margin.l - margin.r;
const h = c.height - margin.t - margin.b;

const colors = ['#00d9ff', '#ff6496', '#ffd700', '#00ff88'];

if(mode === 'both') {
// Plot all counts
const maxCount = Math.max(...classes.flatMap(a => counts[a]));
classes.forEach((a, ci) => {
ctx.strokeStyle = colors[ci % colors.length];
ctx.lineWidth = 2;
ctx.beginPath();
for(let i = 0; i < xs.length; i++) {
const px = margin.l + (xs[i] / maxX) * w;
const py = margin.t + h - (counts[a][i] / maxCount) * h;
if(i === 0) ctx.moveTo(px, py);
else ctx.lineTo(px, py);
}
ctx.stroke();
});
// Legend
classes.forEach((a, ci) => {
ctx.fillStyle = colors[ci % colors.length];
ctx.fillText(`≡${a} (mod ${q})`, c.width - 100, margin.t + 15 + ci * 15);
});
} else if(mode === 'difference' && classes.length >= 2) {
// Plot difference: first non-QR minus first QR
const diff = [];
for(let i = 0; i < xs.length; i++) {
diff.push(counts[classes[1]][i] - counts[classes[0]][i]);
}
primeRaceData.diff = diff;

const maxDiff = Math.max(...diff.map(Math.abs));
const zeroY = margin.t + h / 2;

// Fill regions
ctx.fillStyle = 'rgba(0,255,136,0.2)';
ctx.beginPath();
ctx.moveTo(margin.l, zeroY);
for(let i = 0; i < xs.length; i++) {
const px = margin.l + (xs[i] / maxX) * w;
const py = zeroY - (diff[i] / maxDiff) * (h / 2);
ctx.lineTo(px, Math.min(py, zeroY));
}
ctx.lineTo(margin.l + w, zeroY);
ctx.closePath();
ctx.fill();

ctx.fillStyle = 'rgba(255,100,150,0.2)';
ctx.beginPath();
ctx.moveTo(margin.l, zeroY);
for(let i = 0; i < xs.length; i++) {
const px = margin.l + (xs[i] / maxX) * w;
const py = zeroY - (diff[i] / maxDiff) * (h / 2);
ctx.lineTo(px, Math.max(py, zeroY));
}
ctx.lineTo(margin.l + w, zeroY);
ctx.closePath();
ctx.fill();

// Line
ctx.strokeStyle = '#00d9ff';
ctx.lineWidth = 2;
ctx.beginPath();
for(let i = 0; i < xs.length; i++) {
const px = margin.l + (xs[i] / maxX) * w;
const py = zeroY - (diff[i] / maxDiff) * (h / 2);
if(i === 0) ctx.moveTo(px, py);
else ctx.lineTo(px, py);
}
ctx.stroke();

// Zero line
ctx.strokeStyle = '#ffd700';
ctx.lineWidth = 1;
ctx.setLineDash([5, 3]);
ctx.beginPath();
ctx.moveTo(margin.l, zeroY);
ctx.lineTo(margin.l + w, zeroY);
ctx.stroke();
ctx.setLineDash([]);

ctx.fillStyle = '#00ff88';
ctx.font = '11px Segoe UI';
ctx.fillText(`≡${classes[1]} leads`, c.width - 90, margin.t + 20);
ctx.fillStyle = '#ff6496';
ctx.fillText(`≡${classes[0]} leads`, c.width - 90, c.height - 60);
} else {
// Ratio
const ratios = [];
for(let i = 0; i < xs.length; i++) {
ratios.push(counts[classes[0]][i] > 0 ? counts[classes[1]][i] / counts[classes[0]][i] : 1);
}
const maxR = Math.max(...ratios);
const minR = Math.min(...ratios);

ctx.strokeStyle = '#00d9ff';
ctx.lineWidth = 2;
ctx.beginPath();
for(let i = 0; i < xs.length; i++) {
const px = margin.l + (xs[i] / maxX) * w;
const py = margin.t + h - ((ratios[i] - minR) / (maxR - minR)) * h;
if(i === 0) ctx.moveTo(px, py);
else ctx.lineTo(px, py);
}
ctx.stroke();

// Line at ratio = 1
const oneY = margin.t + h - ((1 - minR) / (maxR - minR)) * h;
ctx.strokeStyle = '#ffd700';
ctx.setLineDash([5, 3]);
ctx.beginPath();
ctx.moveTo(margin.l, oneY);
ctx.lineTo(margin.l + w, oneY);
ctx.stroke();
ctx.setLineDash([]);
}

// Axes
ctx.strokeStyle = isDark() ? '#fff' : '#333';
ctx.lineWidth = 1;
ctx.beginPath();
ctx.moveTo(margin.l, margin.t);
ctx.lineTo(margin.l, margin.t + h);
ctx.lineTo(margin.l + w, margin.t + h);
ctx.stroke();

ctx.fillStyle = isDark() ? '#fff' : '#333';
ctx.font = '11px Segoe UI';
ctx.fillText('x', margin.l + w/2, c.height - 10);

// Count lead changes
let leadChanges = 0;
if(classes.length >= 2) {
for(let i = 1; i < xs.length; i++) {
const prev = counts[classes[1]][i-1] - counts[classes[0]][i-1];
const curr = counts[classes[1]][i] - counts[classes[0]][i];
if((prev > 0 && curr <= 0) || (prev <= 0 && curr > 0)) leadChanges++;
}
}

const finalCounts = classes.map(a => counts[a][counts[a].length - 1]);

legend('alprimerace', 'Prime Race', classes.map((a, i) => [`≡${a} (mod ${q})`, finalCounts[i], colors[i % colors.length]]));

document.getElementById('raceLiveStats').innerHTML = `
<div style="background:linear-gradient(135deg,rgba(0,217,255,.15),rgba(255,215,0,.1));padding:10px;border-radius:8px;margin-bottom:12px;border:1px solid var(--acc)">
<div style="font-size:.7rem;color:var(--txt2);margin-bottom:4px">TAB: Prime Races | FIELD: ℤ (mod q) | TYPE: Chebyshev Bias Analysis</div>
<div style="display:grid;grid-template-columns:repeat(3,1fr);gap:6px;font-size:.75rem">
<span>Max x: <strong style="color:#00d9ff">${maxX.toLocaleString()}</strong></span>
<span>mod q: <strong style="color:#ffd700">${q}</strong></span>
<span>Classes: <strong style="color:#00ff88">${classes.length}</strong></span>
</div>
</div>
<div style="display:grid;grid-template-columns:repeat(3,1fr);gap:8px;margin-bottom:12px">
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center"><div style="font-size:1.2rem;font-weight:bold;color:#00d9ff">${maxX.toLocaleString()}</div><div style="font-size:.7rem;color:var(--txt2)">MAX X</div></div>
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center"><div style="font-size:1.2rem;font-weight:bold;color:#ffd700">${leadChanges}</div><div style="font-size:.7rem;color:var(--txt2)">LEAD CHANGES</div></div>
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center"><div style="font-size:1.2rem;font-weight:bold;color:#ff6496">mod ${q}</div><div style="font-size:.7rem;color:var(--txt2)">MODULUS</div></div>
</div>
<div style="margin-bottom:10px;padding-bottom:8px;border-bottom:1px solid var(--bord)">
<strong style="color:var(--acc)">Final Counts at x = ${maxX.toLocaleString()}</strong>
<div style="display:grid;grid-template-columns:1fr 1fr;gap:4px;margin-top:6px;font-size:.8rem">
${classes.map((a, i) => `<span>π(x;${q},${a}):</span><span style="color:${colors[i % colors.length]};font-weight:bold">${finalCounts[i]}</span>`).join('')}
</div>
</div>
${q === 4 ? `<div style="background:rgba(0,255,136,.1);padding:8px;border-radius:6px">
<strong style="color:#00ff88">Chebyshev Bias (mod 4)</strong>
<div style="font-size:.75rem;color:var(--txt2);margin-top:4px">Primes ≡3 (mod 4) lead ~99.59% of the time! First switch to ≡1 leading: x=26861.</div>
</div>` : ''}`;
}

async function screenshotPrimeRace() {
await screenshotUnified('cprimerace', 'raceLiveStats', 'Prime Races - Chebyshev Bias', 'prime_race.png');
}

function csvPrimeRace() {
const classes = Object.keys(primeRaceData.counts);
let s = 'x,' + classes.map(a => `count_${a}`).join(',') + '\n';
for(let i = 0; i < primeRaceData.x.length; i++) {
s += primeRaceData.x[i] + ',' + classes.map(a => primeRaceData.counts[a][i]).join(',') + '\n';
}
dl(s, 'prime_race.csv');
}

// ==================== DIRICHLET L-FUNCTIONS ====================
let lfuncData = {chars: [], values: []};

// Generate Dirichlet characters mod q
function dirichletChars(q) {
const chars = [];
// Find generators of (Z/qZ)*
const units = [];
for(let a = 1; a < q; a++) if(gcd(a, q) === 1) units.push(a);
const phi = units.length;

// Principal character
const chi0 = n => gcd(n, q) === 1 ? 1 : 0;
chars.push({label: 'χ₀', values: units.map(a => chi0(a)), fn: chi0, isPrincipal: true});

// For small q, enumerate all characters
if(q <= 12 && phi > 1) {
for(let j = 1; j < phi; j++) {
const chi = n => {
if(gcd(n, q) !== 1) return 0;
const idx = units.indexOf(n % q);
if(idx === -1) return 0;
// Return complex value as {re, im}
const angle = 2 * PI * j * idx / phi;
return {re: Math.cos(angle), im: Math.sin(angle)};
};
chars.push({label: `χ_${j}`, values: units.map(a => {
const v = chi(a);
return typeof v === 'object' ? v : {re: v, im: 0};
}), fn: chi});
}
}

return chars;
}

// Compute L(s, chi) for real s > 1
function Lfunc(s, chi, q, terms = 1000) {
let re = 0, im = 0;
for(let n = 1; n <= terms; n++) {
const chiN = chi(n);
if(typeof chiN === 'number') {
re += chiN / Math.pow(n, s);
} else if(chiN && chiN.re !== undefined) {
const ns = Math.pow(n, s);
re += chiN.re / ns;
im += chiN.im / ns;
}
}
return {re, im, mag: Math.sqrt(re*re + im*im)};
}

function drawLfunc() {
const c = document.getElementById('clfunc'), ctx = c.getContext('2d');
const q = +document.getElementById('lfuncQv').value || 5;
const s = +document.getElementById('lfuncSv').value || 2;
const mode = document.getElementById('lfuncMode').value;

const chars = dirichletChars(q);
const values = chars.map(chi => Lfunc(s, chi.fn, q));
lfuncData = {chars, values, q, s};

ctx.fillStyle = canvBg(); ctx.fillRect(0, 0, c.width, c.height);

const margin = {l: 60, r: 30, t: 40, b: 50};
const w = c.width - margin.l - margin.r;
const h = c.height - margin.t - margin.b;

if(mode === 'values') {
// Bar chart of L(s, chi) values
const maxMag = Math.max(...values.map(v => v.mag));
const barWidth = w / chars.length - 5;

chars.forEach((chi, i) => {
const x = margin.l + i * (barWidth + 5);
const barH = (values[i].mag / maxMag) * h * 0.8;

ctx.fillStyle = chi.isPrincipal ? '#ffd700' : `hsl(${i * 360 / chars.length}, 70%, 50%)`;
ctx.fillRect(x, margin.t + h - barH, barWidth, barH);

// Label
ctx.fillStyle = isDark() ? '#fff' : '#333';
ctx.font = '10px Segoe UI';
ctx.save();
ctx.translate(x + barWidth/2, margin.t + h + 15);
ctx.rotate(-Math.PI/4);
ctx.fillText(chi.label, 0, 0);
ctx.restore();

// Value on top
ctx.fillText(fmt(values[i].re), x + 2, margin.t + h - barH - 5);
});

ctx.fillStyle = isDark() ? '#fff' : '#333';
ctx.font = '12px Segoe UI';
ctx.fillText(`L(${s}, χ) for χ mod ${q}`, margin.l, margin.t - 10);
} else if(mode === 'characters') {
// Character table
const units = [];
for(let a = 1; a < q; a++) if(gcd(a, q) === 1) units.push(a);

const cellW = w / (units.length + 1);
const cellH = h / (chars.length + 1);

// Header row
ctx.fillStyle = '#00d9ff';
ctx.font = '11px Segoe UI';
ctx.fillText('n →', margin.l, margin.t + cellH/2);
units.forEach((a, i) => {
ctx.fillText(a.toString(), margin.l + (i+1) * cellW + 5, margin.t + cellH/2);
});

// Character rows
chars.forEach((chi, j) => {
ctx.fillStyle = '#ffd700';
ctx.fillText(chi.label, margin.l, margin.t + (j+1.5) * cellH);
units.forEach((a, i) => {
const v = chi.fn(a);
let text;
if(typeof v === 'number') text = v.toString();
else if(v && v.re !== undefined) {
if(Math.abs(v.im) < 0.01) text = v.re.toFixed(2);
else text = `${v.re.toFixed(1)}+${v.im.toFixed(1)}i`;
} else text = '0';
ctx.fillStyle = isDark() ? '#e0e0e0' : '#333';
ctx.fillText(text, margin.l + (i+1) * cellW + 5, margin.t + (j+1.5) * cellH);
});
});
} else {
// Euler product visualization
ctx.fillStyle = isDark() ? '#fff' : '#333';
ctx.font = '14px Segoe UI';
ctx.fillText(`Euler Product: L(s,χ) = ∏_p (1 - χ(p)/p^s)^{-1}`, margin.l, margin.t + 20);

// Show product terms for first few primes
const primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29];
let y = margin.t + 60;
chars.slice(0, 4).forEach((chi, ci) => {
ctx.fillStyle = `hsl(${ci * 90}, 70%, 50%)`;
ctx.fillText(`${chi.label}:`, margin.l, y);
let product = {re: 1, im: 0};
primes.forEach((p, pi) => {
const chiP = chi.fn(p);
const factor = typeof chiP === 'number' ? chiP : (chiP ? chiP.re : 0);
const term = 1 / (1 - factor / Math.pow(p, s));
product.re *= term;
ctx.fillStyle = isDark() ? '#e0e0e0' : '#333';
ctx.font = '10px Segoe UI';
ctx.fillText(`(1-χ(${p})/${p}^${s})^{-1}`, margin.l + 50 + pi * 75, y);
});
ctx.fillStyle = '#00ff88';
ctx.fillText(`≈ ${product.re.toFixed(4)}`, margin.l + 50 + primes.length * 75, y);
y += 40;
});
}

// Axes
ctx.strokeStyle = isDark() ? '#fff' : '#333';
ctx.lineWidth = 1;
ctx.beginPath();
ctx.moveTo(margin.l, margin.t + h);
ctx.lineTo(margin.l + w, margin.t + h);
ctx.stroke();

legend('allfunc', 'Modular Functions', [['Modulus', q, '#00d9ff'], ['s', s, '#ffd700'], ['φ(q)', chars.length, '#ff6496']]);

document.getElementById('lfuncLiveStats').innerHTML = `
<div style="display:grid;grid-template-columns:repeat(3,1fr);gap:8px;margin-bottom:12px">
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center"><div style="font-size:1.2rem;font-weight:bold;color:#00d9ff">${q}</div><div style="font-size:.7rem;color:var(--txt2)">MODULUS q</div></div>
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center"><div style="font-size:1.2rem;font-weight:bold;color:#ffd700">${chars.length}</div><div style="font-size:.7rem;color:var(--txt2)">CHARACTERS φ(q)</div></div>
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center"><div style="font-size:1.2rem;font-weight:bold;color:#ff6496">${s}</div><div style="font-size:.7rem;color:var(--txt2)">s VALUE</div></div>
</div>
<div style="margin-bottom:10px;padding-bottom:8px;border-bottom:1px solid var(--bord)">
<strong style="color:var(--acc)">L(${s}, χ) Values</strong>
<div style="display:grid;grid-template-columns:1fr 1fr;gap:4px;margin-top:6px;font-size:.8rem">
${chars.slice(0, 6).map((chi, i) => `<span>${chi.label}:</span><span style="color:#00d9ff">${fmt(values[i].re)}${Math.abs(values[i].im) > 0.01 ? ` + ${fmt(values[i].im)}i` : ''}</span>`).join('')}
</div>
</div>
<div style="background:rgba(255,215,0,.1);padding:8px;border-radius:6px">
<strong style="color:#ffd700">Principal Character</strong>

</div>`;


c.onclick = e => {
  const rect = c.getBoundingClientRect();
  const mx = (e.clientX - rect.left) * (c.width / rect.width);
  const my = (e.clientY - rect.top) * (c.height / rect.height);
  const charIdx = Math.floor((mx - margin.l) / (w / chars.length));
  if(charIdx >= 0 && charIdx < chars.length) {
    const chi = chars[charIdx];
    const val = values[charIdx];
    modal('Function Details', [
      ['Character', chi.label],
      ['L(s, χ)', `${fmt(val.re)} + ${fmt(val.im)}i`],
      ['|L(s, χ)|', fmt(val.mag)],
      ['arg(L)', fmt(Math.atan2(val.im, val.re) * 180 / PI) + '°'],
      ['s', s],
      ['Modulus q', q],
      ['Primitive', chi.primitive ? 'Yes' : 'No']
    ]);
  }
};
}

async function screenshotLfunc() {
await screenshotUnified('clfunc', 'lfuncLiveStats', 'Dirichlet L-Functions', 'lfunc.png');
}

function csvLfunc() {
let s = 'character,L_real,L_imag,L_mag\n';
lfuncData.chars.forEach((chi, i) => {
s += `${chi.label},${lfuncData.values[i].re},${lfuncData.values[i].im},${lfuncData.values[i].mag}\n`;
});
dl(s, 'lfunc.csv');
}

// ==================== L-FUNCTION ZEROS ====================
function drawLfuncZeros() {
const c = document.getElementById('clfunczeros'), ctx = c.getContext('2d');
const q = +document.getElementById('lzeroQv').value || 5;
const maxT = +document.getElementById('lzeroTv').value || 30;
const mode = document.getElementById('lzeroMode').value;
const showAll = document.getElementById('lzeroAll').checked;

ctx.fillStyle = canvBg(); ctx.fillRect(0, 0, c.width, c.height);

const margin = {l: 60, r: 30, t: 40, b: 50};
const w = c.width - margin.l - margin.r;
const h = c.height - margin.t - margin.b;

const chars = dirichletChars(q);
let zerosFound = {};

if(mode === 'zeros' || mode === 'critical') {
// Plot critical line with zero locations found numerically
const critX = margin.l + w * 0.5; // σ = 0.5

// Draw critical strip
ctx.fillStyle = 'rgba(0,217,255,0.1)';
ctx.fillRect(margin.l + w * 0.25, margin.t, w * 0.5, h);

// Critical line
ctx.strokeStyle = '#ffd700';
ctx.lineWidth = 2;
ctx.setLineDash([5, 3]);
ctx.beginPath();
ctx.moveTo(critX, margin.t);
ctx.lineTo(critX, margin.t + h);
ctx.stroke();
ctx.setLineDash([]);

// For each character, find zeros by sign changes of real part
const colors = ['#00d9ff', '#ff6496', '#00ff88', '#9664ff', '#ffd700', '#ff8c00'];

chars.slice(0, showAll ? 6 : 1).forEach((chi, ci) => {
zerosFound[chi.label] = [];
ctx.fillStyle = colors[ci % colors.length];

// Search for zeros along critical line
for(let t = 1; t <= maxT; t += 0.5) {
const L1 = Lfunc(0.5, chi.fn, q, 500);
const L2 = LfuncComplex(0.5, t, chi.fn, q, 200);
const L3 = LfuncComplex(0.5, t + 0.5, chi.fn, q, 200);

// Check for sign change in real part (crude zero detection)
if(L2.re * L3.re < 0) {
const zeroT = t + 0.25; // Approximate
zerosFound[chi.label].push(zeroT);
const y = margin.t + h - (zeroT / maxT) * h;
ctx.beginPath();
ctx.arc(critX + (ci - 2) * 8, y, 5, 0, 2*PI);
ctx.fill();
}
}
});

// Axis labels
ctx.fillStyle = isDark() ? '#fff' : '#333';
ctx.font = '11px Segoe UI';
ctx.fillText('Re(s) = ½', critX - 30, c.height - 10);
ctx.fillText('t = 0', margin.l + 5, margin.t + h - 5);
ctx.fillText(`t = ${maxT}`, margin.l + 5, margin.t + 15);

// Legend
let legendY = margin.t + 20;
chars.slice(0, showAll ? 6 : 1).forEach((chi, ci) => {
ctx.fillStyle = colors[ci % colors.length];
ctx.fillRect(c.width - 100, legendY, 12, 12);
ctx.fillStyle = isDark() ? '#fff' : '#333';
ctx.fillText(`${chi.label}: ${zerosFound[chi.label].length}`, c.width - 85, legendY + 10);
legendY += 18;
});
} else {

const chi = chars[1] || chars[0]; // Use first non-principal character
const s1 = 0, s2 = 1, t1 = 0, t2 = maxT;

for(let py = 0; py < c.height; py += 4) {
const t = t2 - (py / c.height) * (t2 - t1);
for(let px = 0; px < c.width; px += 4) {
const sigma = s1 + (px / c.width) * (s2 - s1);
const L = LfuncComplex(sigma, t, chi.fn, q, 100);
const phase = Math.atan2(L.im, L.re);
const mag = Math.sqrt(L.re * L.re + L.im * L.im);

const hue = (phase + PI) / (2 * PI);
const light = 0.5 + 0.3 * Math.tanh(Math.log(mag + 0.1));
const [r, g, b] = hslToRgb(hue, 0.8, light);

ctx.fillStyle = `rgb(${r},${g},${b})`;
ctx.fillRect(px, py, 4, 4);
}
}

// Critical line overlay
ctx.strokeStyle = 'rgba(255,255,255,0.7)';
ctx.lineWidth = 2;
ctx.setLineDash([5, 3]);
const critPx = (0.5 - s1) / (s2 - s1) * c.width;
ctx.beginPath();
ctx.moveTo(critPx, 0);
ctx.lineTo(critPx, c.height);
ctx.stroke();
ctx.setLineDash([]);
}

const totalZeros = Object.values(zerosFound).reduce((a, z) => a + z.length, 0);

legend('allfunczeros', 'Modular Function Zeros', [['Modulus', q, '#00d9ff'], ['t Range', `[0, ${maxT}]`, '#ffd700'], ['Zeros', totalZeros || '~', '#ff6496']]);

document.getElementById('lzeroLiveStats').innerHTML = `
<div style="display:grid;grid-template-columns:repeat(3,1fr);gap:8px;margin-bottom:12px">
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center"><div style="font-size:1.2rem;font-weight:bold;color:#00d9ff">${q}</div><div style="font-size:.7rem;color:var(--txt2)">MODULUS</div></div>
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center"><div style="font-size:1.2rem;font-weight:bold;color:#ffd700">${maxT}</div><div style="font-size:.7rem;color:var(--txt2)">MAX t</div></div>
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center"><div style="font-size:1.2rem;font-weight:bold;color:#ff6496">${chars.length}</div><div style="font-size:.7rem;color:var(--txt2)">CHARACTERS</div></div>
</div>
<div style="margin-bottom:10px;padding-bottom:8px;border-bottom:1px solid var(--bord)">
<strong style="color:var(--acc)">GRH Prediction</strong>
<div style="font-size:.8rem;color:var(--txt2);margin-top:6px">
All nontrivial zeros of all L(s,χ) should lie on Re(s) = ½. This is the Generalized Riemann Hypothesis.
</div>
</div>
<div style="background:rgba(255,100,150,.1);padding:8px;border-radius:6px">
<strong style="color:#ff6496">Connection to Primes</strong>
<div style="font-size:.75rem;color:var(--txt2);margin-top:4px">Zeros of L(s,χ) control error in π(x;q,a). Low-lying zeros cause the Chebyshev bias!</div>
</div>`;


c.onclick = e => {
  const rect = c.getBoundingClientRect();
  const mx = (e.clientX - rect.left) * (c.width / rect.width);
  const my = (e.clientY - rect.top) * (c.height / rect.height);
  const sigma = 0 + (mx - pad) / w * 1;
  const t = maxT - (my - pad) / h * (maxT - minT);
  if(sigma >= 0 && sigma <= 1 && t >= minT && t <= maxT) {
    modal('Zero Region', [
      ['σ (Re)', fmt(sigma)],
      ['t (Im)', fmt(t)],
      ['On critical line', Math.abs(sigma - 0.5) < 0.05 ? 'Yes (GRH region)' : 'No'],
      ['Modulus q', q],
      ['Characters', chars.length]
    ]);
  }
};
}


function LfuncComplex(sigma, t, chi, q, terms = 200) {
let re = 0, im = 0;
for(let n = 1; n <= terms; n++) {
const chiN = chi(n);
const chiVal = typeof chiN === 'number' ? chiN : (chiN ? chiN.re : 0);
if(chiVal === 0) continue;

const mag = Math.pow(n, -sigma);
const phase = -t * Math.log(n);
re += chiVal * mag * Math.cos(phase);
im += chiVal * mag * Math.sin(phase);
}
return {re, im};
}

async function screenshotLfuncZeros() {
await screenshotUnified('clfunczeros', 'lzeroLiveStats', 'L-Function Zeros', 'lfunc_zeros.png');
}

// ==================== QUANTUM ORBITALS ====================
let quantumData = {n: 0, l: 0, m: 0, radial: [], angular: []};

// Associated Legendre polynomial P_l^m(x) - simplified for visualization
function assocLegendre(l, m, x) {
const absM = Math.abs(m);
if(l === 0) return 1;
if(l === 1) {
if(absM === 0) return x;
if(absM === 1) return -Math.sqrt(1 - x*x);
}
if(l === 2) {
if(absM === 0) return (3*x*x - 1) / 2;
if(absM === 1) return -3 * x * Math.sqrt(1 - x*x);
if(absM === 2) return 3 * (1 - x*x);
}
if(l === 3) {
if(absM === 0) return (5*x*x*x - 3*x) / 2;
if(absM === 1) return -1.5 * (5*x*x - 1) * Math.sqrt(1 - x*x);
if(absM === 2) return 15 * x * (1 - x*x);
if(absM === 3) return -15 * Math.pow(1 - x*x, 1.5);
}
// Higher l: use recurrence (simplified)
let P0 = 1, P1 = x;
for(let k = 2; k <= l; k++) {
const Pk = ((2*k-1)*x*P1 - (k-1)*P0) / k;
P0 = P1; P1 = Pk;
}
return P1;
}

// Spherical harmonic Y_l^m(theta, phi) - returns real part for visualization
function sphericalHarmonic(l, m, theta, phi) {
const cosTheta = Math.cos(theta);
const P = assocLegendre(l, Math.abs(m), cosTheta);
// Normalization factor (simplified)
const norm = Math.sqrt((2*l + 1) / (4 * PI));
if(m === 0) return norm * P;
if(m > 0) return norm * P * Math.cos(m * phi) * Math.sqrt(2);
return norm * P * Math.sin(Math.abs(m) * phi) * Math.sqrt(2);
}

// Associated Laguerre polynomial L_n^α(x) using recurrence relation
function assocLaguerre(n, alpha, x) {
if(n === 0) return 1;
if(n === 1) return 1 + alpha - x;
let L0 = 1;
let L1 = 1 + alpha - x;
for(let k = 2; k <= n; k++) {
const Lk = ((2*k - 1 + alpha - x) * L1 - (k - 1 + alpha) * L0) / k;
L0 = L1;
L1 = Lk;
}
return L1;
}

// Radial wavefunction R_nl(r) for hydrogen (a0=1 Bohr radius)
function radialWavefunction(n, l, r) {
const rho = 2 * r / n;
// Associated Laguerre L_{n-l-1}^{2l+1}(rho)
const L = assocLaguerre(n - l - 1, 2*l + 1, rho);
// Normalization: sqrt((2/n)^3 * (n-l-1)! / (2n * (n+l)!))
// Simplified normalization for visualization
const normFactor = Math.pow(2/n, 1.5);
return normFactor * Math.exp(-rho/2) * Math.pow(rho, l) * L;
}

// Bohr radius for classical comparison (r = n² * a0)
function bohrRadius(n, Z = 1) {
return n * n / Z; // in units of a0, scales as n²/Z
}

// Expected radius <r> = (3n² - l(l+1)) / (2Z) in units of a0
function expectedRadius(n, l, Z = 1) {
return (3*n*n - l*(l+1)) / (2 * Z);
}

// Element symbols for display
const ELEMENT_SYMBOLS = ['', 'H', 'He', 'Li', 'Be', 'B', 'C', 'N', 'O', 'F', 'Ne',
  'Na', 'Mg', 'Al', 'Si', 'P', 'S', 'Cl', 'Ar', 'K', 'Ca',
  'Sc', 'Ti', 'V', 'Cr', 'Mn', 'Fe', 'Co', 'Ni', 'Cu', 'Zn',
  'Ga', 'Ge', 'As', 'Se', 'Br', 'Kr', 'Rb', 'Sr', 'Y', 'Zr',
  'Nb', 'Mo', 'Tc', 'Ru', 'Rh', 'Pd', 'Ag', 'Cd', 'In', 'Sn',
  'Sb', 'Te', 'I', 'Xe', 'Cs', 'Ba', 'La', 'Ce', 'Pr', 'Nd',
  'Pm', 'Sm', 'Eu', 'Gd', 'Tb', 'Dy', 'Ho', 'Er', 'Tm', 'Yb',
  'Lu', 'Hf', 'Ta', 'W', 'Re', 'Os', 'Ir', 'Pt', 'Au', 'Hg',
  'Tl', 'Pb', 'Bi', 'Po', 'At', 'Rn', 'Fr', 'Ra', 'Ac', 'Th',
  'Pa', 'U', 'Np', 'Pu', 'Am', 'Cm', 'Bk', 'Cf', 'Es', 'Fm'];

// Full wavefunction probability |ψ|²
function psiSquared(n, l, m, r, theta, phi, Z = 1) {
const R = radialWavefunction(n, l, r * Z); // Scale r by Z
const Y = sphericalHarmonic(l, m, theta, phi);
return R * R * Y * Y;
}

// ===== PHASOR SUM VISUALIZATION =====
let phasorAnimId = null;
let phasorAnimT = 0;

function setPhasorT(t) {
document.getElementById('phasorT').value = Math.min(50, t);
document.getElementById('phasorTV').value = t;
drawPhasor();
}

function setPhasorPrime(M) {
document.getElementById('phasorM').value = Math.min(200, M);
document.getElementById('phasorMV').value = M;
document.getElementById('phasorPrimeMode').checked = true;
drawPhasor();
}

function drawPhasor() {
try {
const c = document.getElementById('cphasor');
const cMag = document.getElementById('cphasorMag');
if (!c || !cMag) { console.error('Phasor canvases not found'); return; }
const ctx = c.getContext('2d');
const ctxMag = cMag.getContext('2d');
if (!ctx || !ctxMag) { console.error('Canvas contexts not available'); return; }

const sigma = +document.getElementById('phasorSigmaV')?.value || 0.5;
const t = +document.getElementById('phasorTV')?.value || 14.13;
const N = Math.max(2, +document.getElementById('phasorNV')?.value || 100);
const showVectors = document.getElementById('phasorVectors')?.checked ?? true;
const showPath = document.getElementById('phasorPath')?.checked ?? true;
const showGrid = document.getElementById('phasorGrid')?.checked ?? true;
const showLabels = document.getElementById('phasorLabels')?.checked ?? false;
const direction = document.getElementById('phasorDir')?.value || 'forward';
const isInverse = direction === 'inverse';

// Prime-Phase Vector mode
const primeMode = document.getElementById('phasorPrimeMode')?.checked || false;
const M = Math.max(2, +document.getElementById('phasorMV')?.value || 37);
const alpha = +document.getElementById('phasorAlphaV')?.value ?? 1;
const gamma = +document.getElementById('phasorGammaV')?.value ?? 1;

// Get primes if in prime mode
let primeList = [];
if (primeMode && N > 1) {
  try {
    primeList = sievePrimes(N);
  } catch(e) {
    console.error('Prime sieve error:', e);
    primeList = [];
  }
}

// Compute phasor sum
const phasors = [];
let sumRe = 0, sumIm = 0;
let pathLength = 0, sumMagnitudes = 0;
let windingAngle = 0, lastAngle = 0;
let maxExcursion = 0;

const items = (primeMode && primeList && primeList.length > 0) ? primeList : Array.from({length: N}, (_, i) => i + 1);

if (items.length === 0) {
  // Nothing to draw
  ctx.fillStyle = canvBg();
  ctx.fillRect(0, 0, c.width, c.height);
  ctx.fillStyle = '#ff6496';
  ctx.font = '14px Segoe UI';
  ctx.textAlign = 'center';
  ctx.fillText('No items to visualize (N too small or no primes)', c.width/2, c.height/2);
  return;
}

for (let i = 0; i < items.length; i++) {
const n = items[i];
const mag = Math.pow(n, -sigma);
let angle;

if (primeMode) {
  // Prime-Phase Vector: combine t-dependent phase with modular phase
  angle = -alpha * t * Math.log(n) + (2 * PI * gamma * n) / M;
} else {
  // Standard phasor: just t-dependent phase
  angle = -t * Math.log(n);
}

const re = mag * Math.cos(angle);
const im = mag * Math.sin(angle);
const prevRe = sumRe, prevIm = sumIm;
sumRe += re;
sumIm += im;

// Path statistics
const segLen = Math.sqrt(re * re + im * im);
pathLength += segLen;
sumMagnitudes += mag;

const currDist = Math.sqrt(sumRe * sumRe + sumIm * sumIm);
maxExcursion = Math.max(maxExcursion, currDist);

// Winding
const currAngle = Math.atan2(sumIm, sumRe);
if (i > 0) {
  let angleDiff = currAngle - lastAngle;
  while (angleDiff > PI) angleDiff -= 2 * PI;
  while (angleDiff < -PI) angleDiff += 2 * PI;
  windingAngle += angleDiff;
}
lastAngle = currAngle;

phasors.push({ n, mag, angle, re, im, cumRe: sumRe, cumIm: sumIm, isPrime: primeMode ? true : (typeof isPrime === 'function' ? isPrime(n) : false) });
}

const zetaRe = sumRe, zetaIm = sumIm;
const zetaMag = Math.sqrt(zetaRe * zetaRe + zetaIm * zetaIm);
const zetaArg = Math.atan2(zetaIm, zetaRe);

// Coherence and cancellation (Prime-Phase Vector metrics)
const coherence = pathLength > 0 ? (1 - zetaMag / pathLength) : 0;
const cancellation = sumMagnitudes > 0 ? (1 - zetaMag / sumMagnitudes) : 0;
const windingNumber = windingAngle / (2 * PI);
const tortuosity = zetaMag > 0.001 ? pathLength / zetaMag : Infinity;

// For inverse, compute cumulative from end
if (isInverse) {
let invRe = zetaRe, invIm = zetaIm;
for (let i = 0; i < phasors.length; i++) {
phasors[i].invRe = invRe;
phasors[i].invIm = invIm;
invRe -= phasors[i].re;
invIm -= phasors[i].im;
}
}

// Find scale for drawing
let maxDist = 0;
phasors.forEach(p => {
const d = Math.sqrt(p.cumRe * p.cumRe + p.cumIm * p.cumIm);
if (d > maxDist) maxDist = d;
});
maxDist = Math.max(maxDist, zetaMag, 2);
const scale = (Math.min(c.width, c.height) / 2 - 50) / maxDist;
const cx = c.width / 2, cy = c.height / 2;

// Clear
ctx.fillStyle = canvBg();
ctx.fillRect(0, 0, c.width, c.height);

// Grid
if (showGrid) {
ctx.strokeStyle = gridC();
ctx.lineWidth = 1;
// Circles
for (let r = 1; r <= Math.ceil(maxDist); r++) {
ctx.beginPath();
ctx.arc(cx, cy, r * scale, 0, 2 * PI);
ctx.stroke();
}
// Axes
ctx.beginPath();
ctx.moveTo(0, cy);
ctx.lineTo(c.width, cy);
ctx.moveTo(cx, 0);
ctx.lineTo(cx, c.height);
ctx.stroke();
}

// Draw phasor path (cumulative sums)
if (showPath) {
ctx.strokeStyle = isInverse ? 'rgba(255,100,150,0.7)' : 'rgba(0,217,255,0.7)';
ctx.lineWidth = 1.5;
ctx.beginPath();
if (isInverse) {
ctx.moveTo(cx + zetaRe * scale, cy - zetaIm * scale);
phasors.forEach(p => {
ctx.lineTo(cx + (p.invRe - p.re) * scale, cy - (p.invIm - p.im) * scale);
});
} else {
ctx.moveTo(cx, cy);
phasors.forEach(p => {
ctx.lineTo(cx + p.cumRe * scale, cy - p.cumIm * scale);
});
}
ctx.stroke();
}

// Draw individual vectors
if (showVectors) {
if (isInverse) {
// Inverse: draw from zeta back to origin
phasors.slice(0, Math.min(50, N)).forEach((p, i) => {
const x1 = cx + p.invRe * scale;
const y1 = cy - p.invIm * scale;
const x2 = cx + (p.invRe - p.re) * scale;
const y2 = cy - (p.invIm - p.im) * scale;

const hue = (p.n * 137) % 360;
ctx.strokeStyle = `hsl(${hue}, 70%, 55%)`;
ctx.lineWidth = Math.max(1, 3 - i * 0.05);
ctx.beginPath();
ctx.moveTo(x1, y1);
ctx.lineTo(x2, y2);
ctx.stroke();

if (i < 10) {
const angle = Math.atan2(y1 - y2, x2 - x1);
ctx.fillStyle = ctx.strokeStyle;
ctx.beginPath();
ctx.moveTo(x2, y2);
ctx.lineTo(x2 - 6 * Math.cos(angle - 0.3), y2 + 6 * Math.sin(angle - 0.3));
ctx.lineTo(x2 - 6 * Math.cos(angle + 0.3), y2 + 6 * Math.sin(angle + 0.3));
ctx.closePath();
ctx.fill();
}
});
} else {
// Forward: head-to-tail
let prevRe = 0, prevIm = 0;
phasors.slice(0, Math.min(50, N)).forEach((p, i) => {
const x1 = cx + prevRe * scale;
const y1 = cy - prevIm * scale;
const x2 = cx + p.cumRe * scale;
const y2 = cy - p.cumIm * scale;

const hue = (p.n * 137) % 360;
ctx.strokeStyle = `hsl(${hue}, 70%, 55%)`;
ctx.lineWidth = Math.max(1, 3 - i * 0.05);
ctx.beginPath();
ctx.moveTo(x1, y1);
ctx.lineTo(x2, y2);
ctx.stroke();

if (i < 10) {
const angle = Math.atan2(y1 - y2, x2 - x1);
ctx.fillStyle = ctx.strokeStyle;
ctx.beginPath();
ctx.moveTo(x2, y2);
ctx.lineTo(x2 - 6 * Math.cos(angle - 0.3), y2 + 6 * Math.sin(angle - 0.3));
ctx.lineTo(x2 - 6 * Math.cos(angle + 0.3), y2 + 6 * Math.sin(angle + 0.3));
ctx.closePath();
ctx.fill();
}

prevRe = p.cumRe;
prevIm = p.cumIm;
});
}
}

// Draw endpoint (zeta value)
ctx.fillStyle = '#ff6496';
ctx.beginPath();
ctx.arc(cx + zetaRe * scale, cy - zetaIm * scale, 8, 0, 2 * PI);
ctx.fill();
ctx.strokeStyle = '#fff';
ctx.lineWidth = 2;
ctx.stroke();

// Draw origin
ctx.fillStyle = '#ffd700';
ctx.beginPath();
ctx.arc(cx, cy, 5, 0, 2 * PI);
ctx.fill();

// Labels
if (showLabels) {
ctx.fillStyle = isDark() ? '#fff' : '#333';
ctx.font = '10px Segoe UI';
phasors.slice(0, 20).forEach((p, i) => {
if (i % 2 === 0) {
const x = cx + p.cumRe * scale;
const y = cy - p.cumIm * scale;
ctx.fillText(`${p.n}`, x + 5, y - 5);
}
});
}

// Title
ctx.fillStyle = isDark() ? '#9664ff' : '#6633cc';
ctx.font = 'bold 16px Segoe UI';
ctx.textAlign = 'center';
ctx.fillText(`Phasor Sum: zeta(${sigma.toFixed(2)} + ${t.toFixed(2)}i) with N=${N}`, cx, 25);

// Zeta value label
ctx.fillStyle = '#ff6496';
ctx.font = 'bold 12px Segoe UI';
ctx.textAlign = 'left';
ctx.fillText(`zeta = ${zetaRe.toFixed(4)} + ${zetaIm.toFixed(4)}i`, 10, c.height - 40);
ctx.fillText(`|zeta| = ${zetaMag.toFixed(6)}`, 10, c.height - 25);
ctx.fillText(`arg = ${(zetaArg * 180 / PI).toFixed(2)} deg`, 10, c.height - 10);

// === Magnitude plot ===
ctxMag.fillStyle = canvBg();
ctxMag.fillRect(0, 0, cMag.width, cMag.height);

// Compute magnitude for t range
const tMin = Math.max(0, t - 10);
const tMax = t + 10;
const magData = [];
let maxMag = 0;
for (let tVal = tMin; tVal <= tMax; tVal += 0.2) {
let re = 0, im = 0;
for (let n = 1; n <= N; n++) {
const mag = Math.pow(n, -sigma);
const ang = -tVal * Math.log(n);
re += mag * Math.cos(ang);
im += mag * Math.sin(ang);
}
const mag = Math.sqrt(re * re + im * im);
magData.push({ t: tVal, mag });
if (mag > maxMag) maxMag = mag;
}

const padM = 40;
const plotW = cMag.width - 2 * padM;
const plotH = cMag.height - 2 * padM;

// Axes
ctxMag.strokeStyle = isDark() ? '#fff' : '#333';
ctxMag.lineWidth = 1;
ctxMag.beginPath();
ctxMag.moveTo(padM, padM);
ctxMag.lineTo(padM, cMag.height - padM);
ctxMag.lineTo(cMag.width - padM, cMag.height - padM);
ctxMag.stroke();

// Plot
ctxMag.strokeStyle = '#00d9ff';
ctxMag.lineWidth = 2;
ctxMag.beginPath();
magData.forEach((d, i) => {
const x = padM + ((d.t - tMin) / (tMax - tMin)) * plotW;
const y = cMag.height - padM - (d.mag / maxMag) * plotH;
if (i === 0) ctxMag.moveTo(x, y);
else ctxMag.lineTo(x, y);
});
ctxMag.stroke();

// Current t marker
const tX = padM + ((t - tMin) / (tMax - tMin)) * plotW;
ctxMag.strokeStyle = '#ff6496';
ctxMag.lineWidth = 2;
ctxMag.beginPath();
ctxMag.moveTo(tX, padM);
ctxMag.lineTo(tX, cMag.height - padM);
ctxMag.stroke();

// Labels
ctxMag.fillStyle = isDark() ? '#fff' : '#333';
ctxMag.font = '10px Segoe UI';
ctxMag.textAlign = 'center';
ctxMag.fillText(`t = ${tMin.toFixed(1)}`, padM, cMag.height - padM + 15);
ctxMag.fillText(`t = ${tMax.toFixed(1)}`, cMag.width - padM, cMag.height - padM + 15);
ctxMag.fillText(`t = ${t.toFixed(2)}`, tX, cMag.height - padM + 25);

ctxMag.textAlign = 'right';
ctxMag.fillText(`|zeta|`, padM - 5, padM + 5);
ctxMag.fillText(`${maxMag.toFixed(2)}`, padM - 5, padM + 15);
ctxMag.fillText(`0`, padM - 5, cMag.height - padM + 5);

// Legend
legend('alphasor', 'Phasor Sum', [
['sigma', sigma, '#9664ff'],
['t', t, '#00d9ff'],
['|zeta|', zetaMag.toFixed(4), '#ff6496']
]);

// Stats
updatePhasorStats(sigma, t, N, zetaRe, zetaIm, zetaMag, zetaArg, phasors, primeMode, M, alpha, gamma, pathLength, coherence, cancellation, windingNumber, maxExcursion, tortuosity);
} catch(e) {
console.error('drawPhasor error:', e);
}
}

function updatePhasorStats(sigma, t, N, zetaRe, zetaIm, zetaMag, zetaArg, phasors, primeMode = false, M = 37, alpha = 1, gamma = 1, pathLength = 0, coherence = 0, cancellation = 0, windingNumber = 0, maxExcursion = 0, tortuosity = 0) {
// Check if near a known zero
const knownZeros = [14.1347, 21.022, 25.011, 30.425, 32.935, 37.586, 40.919, 43.327, 48.005, 49.774, 52.970, 56.446, 59.347, 60.832, 65.113, 67.080, 69.546, 72.067, 75.705, 77.145];
let nearestZero = knownZeros[0], nearestDist = Math.abs(t - knownZeros[0]);
knownZeros.forEach(z => {
const d = Math.abs(t - z);
if (d < nearestDist) { nearestZero = z; nearestDist = d; }
});
const isNearZero = nearestDist < 0.5 && Math.abs(sigma - 0.5) < 0.1;

document.getElementById('phasorLiveStats').innerHTML = `
<div style="display:grid;grid-template-columns:repeat(3,1fr);gap:8px;margin-bottom:12px">
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center">
<div style="font-size:1.3rem;font-weight:bold;color:#9664ff">${sigma.toFixed(3)}</div>
<div style="font-size:.7rem;color:var(--txt2)">sigma (Re)</div>
</div>
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center">
<div style="font-size:1.3rem;font-weight:bold;color:#00d9ff">${t.toFixed(3)}</div>
<div style="font-size:.7rem;color:var(--txt2)">t (Im)</div>
</div>
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center">
<div style="font-size:1.3rem;font-weight:bold;color:#ff6496">${zetaMag.toFixed(6)}</div>
<div style="font-size:.7rem;color:var(--txt2)">|zeta(s)|</div>
</div>
</div>
<div style="margin-bottom:10px;padding:10px;background:${isNearZero ? 'linear-gradient(135deg,rgba(0,255,136,.2),rgba(255,100,150,.1))' : 'var(--bg1)'};border-radius:6px;${isNearZero ? 'border:1px solid #00ff88' : ''}">
<strong style="color:${isNearZero ? '#00ff88' : 'var(--acc)'}">Zeta Value</strong>
<div style="display:grid;grid-template-columns:1fr 1fr;gap:4px;margin-top:6px;font-size:.8rem">
<span>Real part:</span><span style="color:#ffd700;font-weight:bold">${zetaRe.toFixed(8)}</span>
<span>Imag part:</span><span style="color:#00d9ff;font-weight:bold">${zetaIm.toFixed(8)}</span>
<span>Magnitude:</span><span style="color:#ff6496;font-weight:bold">${zetaMag.toFixed(8)}</span>
<span>Argument:</span><span style="color:#9664ff">${(zetaArg * 180 / PI).toFixed(4)} deg</span>
</div>
${isNearZero ? `<div style="margin-top:8px;padding:6px;background:rgba(0,255,136,.15);border-radius:4px;font-size:.8rem;color:#00ff88">Near zero at t = ${nearestZero.toFixed(4)} (distance: ${nearestDist.toFixed(4)})</div>` : ''}
</div>
<div style="margin-bottom:10px;padding:8px;background:var(--bg1);border-radius:6px">
<strong style="color:var(--acc);font-size:.8rem">Known Zeta Zeros (t values on critical line)</strong>
<div style="font-size:.75rem;color:var(--txt2);margin-top:4px">
${knownZeros.map(z => 
`<span style="display:inline-block;margin:2px;padding:2px 6px;background:${Math.abs(t - z) < 0.5 ? 'rgba(0,255,136,.3)' : 'rgba(150,100,255,.12)'};border-radius:3px;cursor:pointer" onclick="setPhasorT(${z})">${z.toFixed(3)}</span>`
).join('')}
</div>
</div>
<div style="padding:8px;background:var(--bg1);border-radius:6px">
<strong style="color:var(--acc);font-size:.8rem">Phasor Statistics</strong>
<div style="display:grid;grid-template-columns:1fr 1fr;gap:4px;margin-top:6px;font-size:.8rem">
<span>Terms N:</span><span style="color:#ffd700">${N}</span>
<span>First term |1^(-s)|:</span><span style="color:#00ff88">1.000</span>
<span>Last term |N^(-s)|:</span><span style="color:#00d9ff">${Math.pow(N, -sigma).toExponential(3)}</span>
<span>Total rotation:</span><span style="color:#9664ff">${(t * Math.log(N) / PI).toFixed(2)} pi</span>
</div>
</div>
${primeMode ? `
<div style="margin-top:10px;padding:10px;background:linear-gradient(135deg,rgba(255,215,0,.15),rgba(150,100,255,.1));border-radius:6px;border:1px solid rgba(255,215,0,.3)">
<strong style="color:#ffd700;font-size:.9rem">Prime-Phase Vector P_t(M=${M})</strong>
<div style="display:grid;grid-template-columns:1fr 1fr;gap:4px;margin-top:8px;font-size:.8rem">
<span>Primes used:</span><span style="color:#00ff88;font-weight:bold">${phasors.length}</span>
<span>Modulus M:</span><span style="color:#ffd700;font-weight:bold">${M}</span>
<span>Phase mult α:</span><span style="color:#00d9ff">${alpha.toFixed(2)}</span>
<span>Mod weight γ:</span><span style="color:#9664ff">${gamma.toFixed(2)}</span>
</div>
<div style="display:grid;grid-template-columns:1fr 1fr;gap:4px;margin-top:8px;font-size:.8rem;padding-top:8px;border-top:1px solid rgba(255,215,0,.2)">
<span>|P_t| Magnitude:</span><span style="color:#ff6496;font-weight:bold">${zetaMag.toFixed(6)}</span>
<span>Path Length:</span><span style="color:#00d9ff">${pathLength.toFixed(4)}</span>
<span>Coherence (C_t):</span><span style="color:${coherence > 0.9 ? '#00ff88' : coherence > 0.7 ? '#ffd700' : '#ff6496'};font-weight:bold">${(coherence * 100).toFixed(2)}%</span>
<span>Cancellation:</span><span style="color:${cancellation > 0.9 ? '#00ff88' : '#ffd700'}">${(cancellation * 100).toFixed(2)}%</span>
<span>Winding Number:</span><span style="color:#9664ff">${windingNumber.toFixed(3)}</span>
<span>Max Excursion:</span><span style="color:#00d9ff">${maxExcursion.toFixed(4)}</span>
<span>Tortuosity:</span><span style="color:#ff8c00">${tortuosity < 1000 ? tortuosity.toFixed(2) : '∞'}</span>
<span>Efficiency:</span><span style="color:#00ff88">${(zetaMag / Math.max(pathLength, 0.001)).toFixed(4)}</span>
</div>
<div style="margin-top:8px;padding:6px;background:rgba(0,0,0,.2);border-radius:4px;font-size:.75rem;color:var(--txt2)">
<strong>Heuristic:</strong> High coherence (>90%) near zeros indicates prime phase alignment. Low |P_t| relative to path length = cancellation.
</div>
</div>
` : ''}`;
}

function togglePhasorAnim() {
const btn = document.getElementById('phasorPlayBtn');
if (phasorAnimId) {
clearInterval(phasorAnimId);
phasorAnimId = null;
btn.textContent = 'Play';
btn.style.background = 'linear-gradient(45deg,#ffd700,#ff6496)';
} else {
const speed = +document.getElementById('phasorSpeed').value || 5;
btn.textContent = 'Pause';
btn.style.background = 'linear-gradient(45deg,#ff6496,#9664ff)';

phasorAnimId = setInterval(() => {
let t = +document.getElementById('phasorTV').value;
t += 0.02 * speed;
if (t > 60) t = 0;
document.getElementById('phasorTV').value = t.toFixed(2);
document.getElementById('phasorT').value = Math.min(50, t);
drawPhasor();
}, 50);
}
}

function resetPhasorAnim() {
if (phasorAnimId) {
clearInterval(phasorAnimId);
phasorAnimId = null;
}
document.getElementById('phasorPlayBtn').textContent = 'Play';
document.getElementById('phasorPlayBtn').style.background = 'linear-gradient(45deg,#ffd700,#ff6496)';
document.getElementById('phasorTV').value = 14.13;
document.getElementById('phasorT').value = 14.13;
drawPhasor();
}

function csvPhasor() {
const sigma = +document.getElementById('phasorSigmaV').value || 0.5;
const t = +document.getElementById('phasorTV').value || 14.13;
const N = +document.getElementById('phasorNV').value || 100;

let csv = 'n,magnitude,angle_rad,real,imag,cumulative_real,cumulative_imag\n';
let sumRe = 0, sumIm = 0;
for (let n = 1; n <= N; n++) {
const mag = Math.pow(n, -sigma);
const angle = -t * Math.log(n);
const re = mag * Math.cos(angle);
const im = mag * Math.sin(angle);
sumRe += re;
sumIm += im;
csv += `${n},${mag.toFixed(8)},${angle.toFixed(6)},${re.toFixed(8)},${im.toFixed(8)},${sumRe.toFixed(8)},${sumIm.toFixed(8)}\n`;
}
dl(csv, `phasor_sum_s${sigma}_t${t}.csv`);
}

async function screenshotPhasor() {
await screenshotUnified('cphasor', 'phasorLiveStats', `Phasor Sum zeta(${document.getElementById('phasorSigmaV').value} + ${document.getElementById('phasorTV').value}i)`, 'phasor_sum.png');
}

// ===== PHASE EXPLORER =====
let phaseData = { animId: null, t: 14.13 };

function setPhaseT(t) {
document.getElementById('phaseT').value = Math.min(100, t);
document.getElementById('phaseTV').value = t;
phaseData.t = t;
drawPhaseExplorer();
}

function drawPhaseExplorer() {
const c = document.getElementById('cphase'), ctx = c.getContext('2d');
const cBar = document.getElementById('cphasebar'), ctxBar = cBar.getContext('2d');
const t = +document.getElementById('phaseTV').value || 14.13;
const maxP = +document.getElementById('phaseMaxP').value || 100;
const showGrid = document.getElementById('phaseGrid')?.checked;
const showLabels = document.getElementById('phaseLabels')?.checked;
const showConnect = document.getElementById('phaseConnect')?.checked;
const modPi = document.getElementById('phaseModPi')?.checked;

phaseData.t = t;

// Generate primes
const primes = sieveOfEratosthenes(maxP);

// Compute phases
const phases = primes.map(p => {
let phi = t * Math.log(p) - PI / 2;
if (modPi) phi = ((phi % (2 * PI)) + 2 * PI) % (2 * PI);
return { p, phi, x: 0, y: 0 };
});

// Clear canvas
ctx.fillStyle = canvBg();
ctx.fillRect(0, 0, c.width, c.height);

const cx = c.width / 2, cy = c.height / 2;
const radius = Math.min(cx, cy) - 50;

// Grid
if (showGrid) {
ctx.strokeStyle = gridC();
ctx.lineWidth = 1;
ctx.beginPath();
ctx.arc(cx, cy, radius, 0, 2 * PI);
ctx.stroke();

// Axis lines
ctx.beginPath();
ctx.moveTo(cx - radius - 10, cy);
ctx.lineTo(cx + radius + 10, cy);
ctx.moveTo(cx, cy - radius - 10);
ctx.lineTo(cx, cy + radius + 10);
ctx.stroke();

// Angle markers
for (let a = 0; a < 2 * PI; a += PI / 4) {
const x = cx + (radius + 15) * Math.cos(a);
const y = cy + (radius + 15) * Math.sin(a);
ctx.fillStyle = isDark() ? '#666' : '#999';
ctx.font = '10px Segoe UI';
ctx.textAlign = 'center';
ctx.fillText(`${Math.round(a * 180 / PI)}°`, x, y + 4);
}
}

// Plot phases on unit circle
ctx.lineWidth = 1;
let prevX, prevY;

phases.forEach((ph, i) => {
const x = cx + radius * Math.cos(ph.phi);
const y = cy - radius * Math.sin(ph.phi);
ph.x = x;
ph.y = y;

// Connect points
if (showConnect && i > 0) {
ctx.strokeStyle = 'rgba(0,217,255,0.3)';
ctx.beginPath();
ctx.moveTo(prevX, prevY);
ctx.lineTo(x, y);
ctx.stroke();
}

// Point color by prime
const hue = (ph.p * 137) % 360;
ctx.fillStyle = `hsl(${hue}, 70%, 55%)`;

const ptSize = Math.max(3, 8 - i * 0.1);
ctx.beginPath();
ctx.arc(x, y, ptSize, 0, 2 * PI);
ctx.fill();

// Label first few primes
if (showLabels && i < 15) {
ctx.fillStyle = isDark() ? '#fff' : '#333';
ctx.font = '9px Segoe UI';
ctx.textAlign = 'center';
ctx.fillText(`${ph.p}`, x, y - ptSize - 3);
}

prevX = x;
prevY = y;
});

// Title
ctx.fillStyle = '#00ff88';
ctx.font = 'bold 14px Segoe UI';
ctx.textAlign = 'center';
ctx.fillText(`Prime Phases at t = ${t.toFixed(4)}`, cx, 20);

// Bar chart: phase vs prime index
ctxBar.fillStyle = canvBg();
ctxBar.fillRect(0, 0, cBar.width, cBar.height);

const barPad = 40;
const barW = (cBar.width - 2 * barPad) / Math.min(50, phases.length);
const barH = cBar.height - 2 * barPad;

phases.slice(0, 50).forEach((ph, i) => {
const x = barPad + i * barW;
const h = (ph.phi / (2 * PI)) * barH;
const y = cBar.height - barPad - h;

const hue = (ph.p * 137) % 360;
ctxBar.fillStyle = `hsl(${hue}, 70%, 55%)`;
ctxBar.fillRect(x + 1, y, barW - 2, h);

if (phases.length <= 30) {
ctxBar.fillStyle = isDark() ? '#aaa' : '#666';
ctxBar.font = '8px Segoe UI';
ctxBar.textAlign = 'center';
ctxBar.fillText(`${ph.p}`, x + barW / 2, cBar.height - barPad + 12);
}
});

// Y-axis labels
ctxBar.fillStyle = isDark() ? '#ffd700' : '#997700';
ctxBar.font = '10px Segoe UI';
ctxBar.textAlign = 'right';
ctxBar.fillText('2π', barPad - 5, barPad + 5);
ctxBar.fillText('π', barPad - 5, barPad + barH / 2);
ctxBar.fillText('0', barPad - 5, cBar.height - barPad + 5);

ctxBar.font = 'bold 12px Segoe UI';
ctxBar.fillStyle = '#00d9ff';
ctxBar.textAlign = 'center';
ctxBar.fillText(`Phase φ(p,t) for first ${Math.min(50, phases.length)} primes`, cBar.width / 2, 15);

// Legend
legend('alphase', 'Phase Explorer', [
['t', t.toFixed(4), '#ffd700'],
['Primes', primes.length, '#00ff88'],
['φ range', modPi ? '[0, 2π]' : 'R', '#00d9ff']
]);

// Stats
updatePhaseStats(t, phases, primes);
}

function updatePhaseStats(t, phases, primes) {
// Circular statistics
const sinSum = phases.reduce((s, ph) => s + Math.sin(ph.phi), 0);
const cosSum = phases.reduce((s, ph) => s + Math.cos(ph.phi), 0);
const meanAngle = Math.atan2(sinSum, cosSum);
const R = Math.sqrt(sinSum * sinSum + cosSum * cosSum) / phases.length; // Concentration

// Check known zeros proximity
const knownZeros = [14.1347, 21.022, 25.011, 30.425, 32.935, 37.586, 40.919, 43.327, 48.005, 49.774];
let nearZero = null;
for (const z of knownZeros) {
if (Math.abs(t - z) < 0.5) {
nearZero = z;
break;
}
}

document.getElementById('phaseLiveStats').innerHTML = `
<div style="display:grid;grid-template-columns:repeat(3,1fr);gap:8px;margin-bottom:12px">
<div style="background:linear-gradient(135deg,rgba(255,215,0,.2),rgba(255,215,0,.05));padding:12px;border-radius:8px;text-align:center">
<div style="color:#ffd700;font-size:1.5rem;font-weight:bold">${t.toFixed(4)}</div>
<div style="color:var(--txt2);font-size:.75rem">t value</div>
</div>
<div style="background:linear-gradient(135deg,rgba(0,255,136,.2),rgba(0,255,136,.05));padding:12px;border-radius:8px;text-align:center">
<div style="color:#00ff88;font-size:1.5rem;font-weight:bold">${primes.length}</div>
<div style="color:var(--txt2);font-size:.75rem">Primes</div>
</div>
<div style="background:linear-gradient(135deg,rgba(0,217,255,.2),rgba(0,217,255,.05));padding:12px;border-radius:8px;text-align:center">
<div style="color:#00d9ff;font-size:1.5rem;font-weight:bold">${R.toFixed(4)}</div>
<div style="color:var(--txt2);font-size:.75rem">Concentration R</div>
</div>
</div>
<div style="display:grid;grid-template-columns:1fr 1fr;gap:8px">
<div><strong>Mean angle:</strong> ${(meanAngle * 180 / PI).toFixed(2)}° (${meanAngle.toFixed(4)} rad)</div>
<div><strong>Vector strength:</strong> ${(R * 100).toFixed(2)}%</div>
<div><strong>First phase:</strong> φ(2,${t.toFixed(2)}) = ${(t * Math.log(2)).toFixed(4)}</div>
<div><strong>Last phase:</strong> φ(${primes[primes.length-1]},t) = ${(t * Math.log(primes[primes.length-1])).toFixed(4)}</div>
</div>
${nearZero ? `<div style="margin-top:12px;padding:8px;background:rgba(0,255,136,.15);border-radius:6px;text-align:center"><strong style="color:#00ff88">Near Riemann zero t ≈ ${nearZero}</strong></div>` : ''}
<div style="margin-top:12px"><strong>Known zeros:</strong>
<div style="display:flex;flex-wrap:wrap;gap:4px;margin-top:4px">
${knownZeros.slice(0, 10).map(z => `<span style="display:inline-block;padding:2px 6px;background:${Math.abs(t - z) < 0.5 ? 'rgba(0,255,136,.3)' : 'rgba(150,100,255,.12)'};border-radius:3px;cursor:pointer;font-size:.8rem" onclick="setPhaseT(${z})">${z.toFixed(3)}</span>`).join('')}
</div>
</div>`;
}

function togglePhaseAnim() {
const btn = document.getElementById('phasePlayBtn');
if (phaseData.animId) {
cancelAnimationFrame(phaseData.animId);
phaseData.animId = null;
btn.textContent = 'Play';
} else {
btn.textContent = 'Pause';
animatePhase();
}
}

function animatePhase() {
const speed = +document.getElementById('phaseSpeed').value || 5;
phaseData.t += 0.02 * speed;
if (phaseData.t > 100) phaseData.t = 0;
document.getElementById('phaseT').value = Math.min(100, phaseData.t);
document.getElementById('phaseTV').value = phaseData.t.toFixed(4);
drawPhaseExplorer();
phaseData.animId = requestAnimationFrame(animatePhase);
}

function resetPhaseAnim() {
if (phaseData.animId) {
cancelAnimationFrame(phaseData.animId);
phaseData.animId = null;
document.getElementById('phasePlayBtn').textContent = 'Play';
}
phaseData.t = 14.13;
document.getElementById('phaseT').value = 14.13;
document.getElementById('phaseTV').value = 14.13;
drawPhaseExplorer();
}

function csvPhase() {
const t = +document.getElementById('phaseTV').value || 14.13;
const maxP = +document.getElementById('phaseMaxP').value || 100;
const primes = sieveOfEratosthenes(maxP);

let csv = 'prime,phase_rad,phase_deg,x,y\n';
primes.forEach(p => {
const phi = t * Math.log(p) - PI / 2;
const phiMod = ((phi % (2 * PI)) + 2 * PI) % (2 * PI);
csv += `${p},${phiMod.toFixed(6)},${(phiMod * 180 / PI).toFixed(2)},${Math.cos(phiMod).toFixed(6)},${Math.sin(phiMod).toFixed(6)}\n`;
});
dl(csv, `phase_explorer_t${t.toFixed(4)}.csv`);
}

async function screenshotPhase() {
await screenshotUnified('cphase', 'phaseLiveStats', `Phase Explorer t=${document.getElementById('phaseTV').value}`, 'phase_explorer.png');
}

// ===== MODULAR SIEVE CALCULATOR =====
let primeRingData = { points: [], primes: [] };

function setSievePreset(preset) {
if (preset === 'pi10') {
document.getElementById('sieveEps').value = '1e-10';
document.getElementById('sieveTarget').value = 'pi';
} else if (preset === 'pi15') {
document.getElementById('sieveEps').value = '1e-15';
document.getElementById('sieveTarget').value = 'pi';
} else if (preset === 'z4high') {
document.getElementById('sieveEps').value = '1e-12';
document.getElementById('sieveTarget').value = 'z4';
}
computeSieveCalc();
}

function computeSieveCalc() {
const eps = parseFloat(document.getElementById('sieveEps').value) || 1e-7;
const target = document.getElementById('sieveTarget').value;
const decomp = document.getElementById('sieveDecomp').value;
const channelMod = +document.getElementById('sieveChannelMod').value || 30;

// Estimate required prime limit
const requiredY = target === 'pi' ? Math.ceil(1 + 1/eps) : Math.ceil(Math.pow(2/(eps), 1/2));
const primeLimit = Math.min(requiredY, 100000);
const primes = sieveOfEratosthenes(primeLimit);

// Reference values
const piRef = 3.141592653589793;
const z2Ref = piRef * piRef / 6;
const z4Ref = Math.pow(piRef, 4) / 90;
const z6Ref = Math.pow(piRef, 6) / 945;

let refVal, refName;
if (target === 'pi') { refVal = piRef; refName = 'pi'; }
else if (target === 'z2') { refVal = z2Ref; refName = 'zeta(2)'; }
else if (target === 'z4') { refVal = z4Ref; refName = 'zeta(4)'; }
else { refVal = z6Ref; refName = 'zeta(6)'; }

// Compute Euler product
const s = target === 'pi' ? 2 : (target === 'z2' ? 2 : target === 'z4' ? 4 : 6);
let product = 1;
const convergence = [];
const gapContrib = {};
const resContrib = {};

// Initialize residue channels
const coprimes = [];
for (let r = 1; r < channelMod; r++) if (gcd(r, channelMod) === 1) coprimes.push(r);
coprimes.forEach(r => resContrib[r] = 1);

for (let i = 0; i < primes.length; i++) {
const p = primes[i];
const factor = 1 / (1 - Math.pow(p, -s));
product *= factor;

// Gap class
if (i < primes.length - 1) {
const gap = primes[i + 1] - p;
gapContrib[gap] = (gapContrib[gap] || 1) * factor;
}

// Residue channel
const r = p % channelMod;
if (resContrib[r] !== undefined) resContrib[r] *= factor;

// Convergence data
if (i % Math.max(1, Math.floor(primes.length / 100)) === 0 || i === primes.length - 1) {
let computed = target === 'pi' ? Math.sqrt(6 * product) : product;
convergence.push({ prime: p, value: computed, error: Math.abs(computed - refVal) / refVal });
}
}

let computed = target === 'pi' ? Math.sqrt(6 * product) : product;
const error = Math.abs(computed - refVal);
const relError = error / refVal;
const digits = relError > 0 ? Math.max(0, -Math.floor(Math.log10(relError))) : 15;

// Display result
document.getElementById('sieveCalcResult').innerHTML = `
<div style="display:grid;grid-template-columns:repeat(2,1fr);gap:12px;margin-bottom:12px">
<div style="background:linear-gradient(135deg,rgba(255,100,150,.15),rgba(255,215,0,.1));padding:12px;border-radius:8px;text-align:center">
<div style="font-size:.7rem;color:var(--txt2);text-transform:uppercase">Computed ${refName}</div>
<div style="font-size:1.2rem;font-weight:bold;color:#ff6496;font-family:monospace">${computed.toFixed(Math.min(15, digits + 2))}</div>
</div>
<div style="background:linear-gradient(135deg,rgba(0,255,136,.1),rgba(0,217,255,.1));padding:12px;border-radius:8px;text-align:center">
<div style="font-size:.7rem;color:var(--txt2);text-transform:uppercase">Reference ${refName}</div>
<div style="font-size:1.2rem;font-weight:bold;color:#00ff88;font-family:monospace">${refVal.toFixed(15)}</div>
</div>
</div>
<div style="display:grid;grid-template-columns:repeat(4,1fr);gap:8px;margin-bottom:12px">
<div style="background:var(--bg1);padding:8px;border-radius:6px;text-align:center">
<div style="font-size:1.1rem;font-weight:bold;color:#ffd700">${primes.length.toLocaleString()}</div>
<div style="font-size:.65rem;color:var(--txt2)">Primes Used</div>
</div>
<div style="background:var(--bg1);padding:8px;border-radius:6px;text-align:center">
<div style="font-size:1.1rem;font-weight:bold;color:#00d9ff">${primes[primes.length-1].toLocaleString()}</div>
<div style="font-size:.65rem;color:var(--txt2)">Max Prime</div>
</div>
<div style="background:var(--bg1);padding:8px;border-radius:6px;text-align:center">
<div style="font-size:1.1rem;font-weight:bold;color:#9664ff">${digits}</div>
<div style="font-size:.65rem;color:var(--txt2)">Correct Digits</div>
</div>
<div style="background:var(--bg1);padding:8px;border-radius:6px;text-align:center">
<div style="font-size:1.1rem;font-weight:bold;color:${relError < eps ? '#00ff88' : '#ff6496'}">${relError.toExponential(2)}</div>
<div style="font-size:.65rem;color:var(--txt2)">Relative Error</div>
</div>
</div>
<div style="padding:8px;background:${relError < eps ? 'rgba(0,255,136,.15)' : 'rgba(255,100,150,.15)'};border-radius:6px;text-align:center;margin-bottom:8px">
<strong style="color:${relError < eps ? '#00ff88' : '#ff6496'}">${relError < eps ? 'TARGET ACHIEVED' : 'Need more primes'}</strong>
${relError >= eps ? ` — Need ~${Math.ceil(1/eps).toLocaleString()} primes for eps=${eps}` : ''}
</div>
<div style="font-size:.8rem;color:var(--txt2)">
<strong>Decomposition:</strong> ${decomp === 'gap' ? 'Gap-Class' : decomp === 'residue' ? `Residue Channels mod ${channelMod}` : 'Standard Euler'}<br>
<strong>Gap classes:</strong> ${Object.keys(gapContrib).length} | <strong>Residue channels:</strong> ${coprimes.length} (phi(${channelMod}))
</div>`;

// Draw convergence chart
drawSieveConvergence(convergence, refVal, eps);
drawSieveGapChart(gapContrib, s);
drawSieveResChart(resContrib, channelMod, coprimes, s);
}

function drawSieveConvergence(data, ref, eps) {
const c = document.getElementById('csieveconv'), ctx = c.getContext('2d');
ctx.fillStyle = canvBg();
ctx.fillRect(0, 0, c.width, c.height);

if (data.length < 2) return;

const pad = 50;
const w = c.width - 2 * pad;
const h = c.height - 2 * pad;

// Find error range
const errors = data.map(d => d.error);
const maxErr = Math.max(...errors);
const minErr = Math.min(...errors.filter(e => e > 0), eps/10);

// Axes
ctx.strokeStyle = isDark() ? '#fff' : '#333';
ctx.lineWidth = 1;
ctx.beginPath();
ctx.moveTo(pad, pad);
ctx.lineTo(pad, c.height - pad);
ctx.lineTo(c.width - pad, c.height - pad);
ctx.stroke();

// Error line (log scale)
ctx.strokeStyle = '#ff6496';
ctx.lineWidth = 2;
ctx.beginPath();
data.forEach((d, i) => {
const x = pad + (i / (data.length - 1)) * w;
const logErr = d.error > 0 ? Math.log10(d.error) : Math.log10(minErr);
const logMax = Math.log10(maxErr);
const logMin = Math.log10(minErr);
const y = c.height - pad - ((logErr - logMin) / (logMax - logMin)) * h;
if (i === 0) ctx.moveTo(x, y);
else ctx.lineTo(x, y);
});
ctx.stroke();

// Target epsilon line
const logEps = Math.log10(eps);
const logMax = Math.log10(maxErr);
const logMin = Math.log10(minErr);
if (logEps >= logMin && logEps <= logMax) {
const epsY = c.height - pad - ((logEps - logMin) / (logMax - logMin)) * h;
ctx.strokeStyle = '#00ff88';
ctx.lineWidth = 2;
ctx.setLineDash([8, 4]);
ctx.beginPath();
ctx.moveTo(pad, epsY);
ctx.lineTo(c.width - pad, epsY);
ctx.stroke();
ctx.setLineDash([]);
ctx.fillStyle = '#00ff88';
ctx.font = '10px Segoe UI';
ctx.textAlign = 'right';
ctx.fillText(`eps = ${eps}`, c.width - pad, epsY - 5);
}

// Labels
ctx.fillStyle = isDark() ? '#fff' : '#333';
ctx.font = '11px Segoe UI';
ctx.textAlign = 'center';
ctx.fillText('Prime Index', c.width / 2, c.height - 10);
ctx.save();
ctx.translate(15, c.height / 2);
ctx.rotate(-PI / 2);
ctx.fillText('Relative Error (log)', 0, 0);
ctx.restore();

ctx.fillStyle = '#ffd700';
ctx.font = 'bold 12px Segoe UI';
ctx.fillText('Convergence to Target', c.width / 2, 20);
}

function drawSieveGapChart(gapContrib, s) {
const c = document.getElementById('csievegap'), ctx = c.getContext('2d');
ctx.fillStyle = canvBg();
ctx.fillRect(0, 0, c.width, c.height);

const gaps = Object.keys(gapContrib).map(Number).sort((a, b) => a - b);
if (gaps.length === 0) return;

const pad = 40;
const w = c.width - 2 * pad;
const h = c.height - 2 * pad;
const barW = Math.max(3, w / gaps.length - 2);

// Compute log contributions
const logContribs = gaps.map(g => Math.log(gapContrib[g]));
const maxLog = Math.max(...logContribs);

// Draw bars
gaps.forEach((g, i) => {
const x = pad + (i / gaps.length) * w;
const logC = Math.log(gapContrib[g]);
const barH = (logC / maxLog) * h;

const hue = (g * 20) % 360;
ctx.fillStyle = `hsl(${hue}, 70%, 55%)`;
ctx.fillRect(x, c.height - pad - barH, barW, barH);
});

// Axes
ctx.strokeStyle = isDark() ? '#fff' : '#333';
ctx.lineWidth = 1;
ctx.beginPath();
ctx.moveTo(pad, pad);
ctx.lineTo(pad, c.height - pad);
ctx.lineTo(c.width - pad, c.height - pad);
ctx.stroke();

// Labels
ctx.fillStyle = isDark() ? '#fff' : '#333';
ctx.font = '10px Segoe UI';
ctx.textAlign = 'center';
ctx.fillText('Gap g', c.width / 2, c.height - 10);

ctx.fillStyle = '#00d9ff';
ctx.font = 'bold 12px Segoe UI';
ctx.fillText(`Gap-Class Contributions (${gaps.length} gaps)`, c.width / 2, 18);
}

function drawSieveResChart(resContrib, M, coprimes, s) {
const c = document.getElementById('csieveres'), ctx = c.getContext('2d');
ctx.fillStyle = canvBg();
ctx.fillRect(0, 0, c.width, c.height);

if (coprimes.length === 0) return;

const pad = 40;
const w = c.width - 2 * pad;
const h = c.height - 2 * pad;
const barW = Math.max(8, w / coprimes.length - 4);

// Compute log contributions
const logContribs = coprimes.map(r => Math.log(resContrib[r]));
const maxLog = Math.max(...logContribs);

// Draw bars
coprimes.forEach((r, i) => {
const x = pad + (i / coprimes.length) * w + barW / 2;
const logC = Math.log(resContrib[r]);
const barH = (logC / maxLog) * h;

const hue = (r / M) * 360;
ctx.fillStyle = `hsl(${hue}, 70%, 55%)`;
ctx.fillRect(x, c.height - pad - barH, barW - 2, barH);

// Label
if (coprimes.length <= 20) {
ctx.fillStyle = isDark() ? '#fff' : '#333';
ctx.font = '9px Segoe UI';
ctx.textAlign = 'center';
ctx.fillText(`${r}`, x + barW / 2, c.height - pad + 12);
}
});

// Axes
ctx.strokeStyle = isDark() ? '#fff' : '#333';
ctx.lineWidth = 1;
ctx.beginPath();
ctx.moveTo(pad, pad);
ctx.lineTo(pad, c.height - pad);
ctx.lineTo(c.width - pad, c.height - pad);
ctx.stroke();

// Labels
ctx.fillStyle = isDark() ? '#fff' : '#333';
ctx.font = '10px Segoe UI';
ctx.textAlign = 'center';
ctx.fillText(`Residue r (mod ${M})`, c.width / 2, c.height - 10);

ctx.fillStyle = '#9664ff';
ctx.font = 'bold 12px Segoe UI';
ctx.fillText(`Residue Channel Contributions (phi(${M}) = ${coprimes.length})`, c.width / 2, 18);
}

function drawPrimeRings() {
const c = document.getElementById('cprimerings');
if (!c) return;
const ctx = c.getContext('2d');
const maxM = +document.getElementById('primeRingMaxMv')?.value || +document.getElementById('primeRingMaxM')?.value || 20;
const maxP = +document.getElementById('primeRingMaxPv')?.value || +document.getElementById('primeRingMaxP')?.value || 100;
const ptSz = +document.getElementById('primeRingPtSz')?.value || 4;
const lineW = +document.getElementById('primeRingLineW')?.value || 0.5;
const labelMode = document.getElementById('primeRingLabelMode')?.value || 'none';
const colorMode = document.getElementById('primeRingColor')?.value || 'residue';
const showModLines = document.getElementById('primeRingModLines')?.checked;
const showCircles = document.getElementById('primeRingCircles')?.checked !== false;
const showModLabels = document.getElementById('primeRingModLabels')?.checked !== false;
const showGrid = document.getElementById('primeRingGrid')?.checked;
const invert = document.getElementById('primeRingInvert')?.checked;

ctx.fillStyle = canvBg();
ctx.fillRect(0, 0, c.width, c.height);

const cx = c.width / 2, cy = c.height / 2;
const maxRadius = Math.min(cx, cy) - 50;
const primes = sieveOfEratosthenes(maxP);

// Compute gaps for gap coloring
const gaps = [];
for (let i = 0; i < primes.length - 1; i++) {
gaps[primes[i]] = primes[i + 1] - primes[i];
}

primeRingData.points = [];
primeRingData.primes = primes;

// Draw axes if enabled
if (showGrid) {
ctx.strokeStyle = gridC();
ctx.lineWidth = 1;
ctx.beginPath();
ctx.moveTo(cx - maxRadius, cy);
ctx.lineTo(cx + maxRadius, cy);
ctx.moveTo(cx, cy - maxRadius);
ctx.lineTo(cx, cy + maxRadius);
ctx.stroke();
}

// Draw rings for each modulus
for (let m = 2; m <= maxM; m++) {
const ringIndex = invert ? (maxM - m + 2) : m;
const radius = (ringIndex / maxM) * maxRadius * 0.9 + maxRadius * 0.1;

// Ring circle
if (showCircles) {
ctx.strokeStyle = gridC();
ctx.lineWidth = 0.5;
ctx.beginPath();
ctx.arc(cx, cy, radius, 0, 2 * PI);
ctx.stroke();
}

// Mod lines (divisions)
if (showModLines && m <= 60 && lineW > 0) {
ctx.strokeStyle = `rgba(100,100,100,${Math.min(0.5, lineW)})`;
ctx.lineWidth = lineW;
for (let r = 0; r < m; r++) {
const angle = 2 * PI * r / m - PI / 2;
ctx.beginPath();
ctx.moveTo(cx, cy);
ctx.lineTo(cx + radius * Math.cos(angle), cy + radius * Math.sin(angle));
ctx.stroke();
}
}

// Plot primes on this ring
primes.forEach(p => {
if (p <= m) return;
const r = p % m;
if (gcd(r, m) !== 1) return;

const angle = 2 * PI * r / m - PI / 2;
const x = cx + radius * Math.cos(angle);
const y = cy + radius * Math.sin(angle);

primeRingData.points.push({ prime: p, m, r, x, y, angle, radius, gap: gaps[p] || 0 });

// Color based on mode
let hue;
if (colorMode === 'residue') {
hue = (r / m) * 360;
} else if (colorMode === 'prime') {
hue = (p / maxP) * 270; // blue to red
} else if (colorMode === 'gap') {
hue = gaps[p] ? Math.min(120, gaps[p] * 10) : 0; // green for small gaps, red for large
} else { // modulus
hue = (m / maxM) * 270;
}
ctx.fillStyle = `hsl(${hue}, 80%, 55%)`;
ctx.beginPath();
ctx.arc(x, y, ptSz, 0, 2 * PI);
ctx.fill();

// Point labels
if (labelMode !== 'none' && (maxM <= 15 || m % 5 === 0)) {
ctx.fillStyle = isDark() ? '#fff' : '#333';
ctx.font = '8px Segoe UI';
ctx.textAlign = 'center';
let lbl = '';
if (labelMode === 'prime') lbl = p.toString();
else if (labelMode === 'residue') lbl = r.toString();
else if (labelMode === 'modulus') lbl = m.toString();
else if (labelMode === 'angle') lbl = Math.round((angle + PI/2) * 180 / PI) + '°';
if (lbl && primeRingData.points.length < 500) {
ctx.fillText(lbl, x, y - ptSz - 2);
}
}
});

// Ring label on right
if (showModLabels && (m <= 10 || m % 5 === 0)) {
ctx.fillStyle = isDark() ? '#ffd700' : '#997700';
ctx.font = '9px Segoe UI';
ctx.textAlign = 'left';
ctx.fillText(`M=${m}`, cx + radius + 5, cy + 3);
}
}

// Title
ctx.fillStyle = '#00d9ff';
ctx.font = 'bold 14px Segoe UI';
ctx.textAlign = 'center';
ctx.fillText(`Prime Rings: ${primes.length} primes on M=2..${maxM}`, cx, 20);

// Legend
ctx.font = '10px Segoe UI';
ctx.fillStyle = isDark() ? '#aaa' : '#666';
ctx.textAlign = 'left';
ctx.fillText(`Color: ${colorMode} | Labels: ${labelMode}`, 10, c.height - 10);

// Update stats
updateSieveCalcStats(primes, maxM);

setupPrimeRingClick(c);
}

function updateSieveCalcStats(primes, maxM) {
const statsDiv = document.getElementById('sieveCalcStats');
if (!statsDiv) return;

// Count by residue classes
const phi30 = eulerPhi(30);
const residueCounts = {};
for (let r = 1; r < 30; r++) {
if (gcd(r, 30) === 1) residueCounts[r] = 0;
}
primes.forEach(p => {
const r = p % 30;
if (residueCounts[r] !== undefined) residueCounts[r]++;
});

statsDiv.innerHTML = `
<div style="display:grid;grid-template-columns:repeat(3,1fr);gap:8px;margin-bottom:12px">
<div style="background:linear-gradient(135deg,rgba(255,215,0,.2),rgba(255,215,0,.05));padding:10px;border-radius:6px;text-align:center">
<div style="color:#ffd700;font-size:1.3rem;font-weight:bold">${primes.length}</div>
<div style="color:var(--txt2);font-size:.7rem">Total Primes</div>
</div>
<div style="background:linear-gradient(135deg,rgba(0,255,136,.2),rgba(0,255,136,.05));padding:10px;border-radius:6px;text-align:center">
<div style="color:#00ff88;font-size:1.3rem;font-weight:bold">${primes[primes.length-1]}</div>
<div style="color:var(--txt2);font-size:.7rem">Max Prime</div>
</div>
<div style="background:linear-gradient(135deg,rgba(0,217,255,.2),rgba(0,217,255,.05));padding:10px;border-radius:6px;text-align:center">
<div style="color:#00d9ff;font-size:1.3rem;font-weight:bold">${maxM}</div>
<div style="color:var(--txt2);font-size:.7rem">Max Modulus</div>
</div>
</div>
<div style="font-size:.8rem;color:var(--txt2)">
<strong>Residue distribution (mod 30):</strong><br>
<div style="display:flex;flex-wrap:wrap;gap:4px;margin-top:4px">
${Object.entries(residueCounts).map(([r, c]) => 
`<span style="padding:2px 6px;background:var(--bg1);border-radius:3px;font-size:.75rem">${r}: ${c}</span>`
).join('')}
</div>
</div>`;
}

function setupPrimeRingClick(canvas) {
canvas.onclick = function(e) {
const rect = canvas.getBoundingClientRect();
const mx = (e.clientX - rect.left) * (canvas.width / rect.width);
const my = (e.clientY - rect.top) * (canvas.height / rect.height);

let closest = null;
let closestDist = Infinity;

for (const pt of primeRingData.points || []) {
const dist = Math.hypot(mx - pt.x, my - pt.y);
if (dist < closestDist && dist < 25) {
closest = pt;
closestDist = dist;
}
}

const infoDiv = document.getElementById('primeRingInfo');
if (!infoDiv) return;
if (closest) {
const p = closest.prime;
const m = closest.m;
const r = closest.r;

// Find other primes in same residue class
const sameClass = primeRingData.primes.filter(q => q % m === r && q !== p).slice(0, 10);

infoDiv.innerHTML = `
<div style="display:flex;gap:12px;align-items:center;flex-wrap:wrap">
<div style="background:linear-gradient(135deg,rgba(0,255,136,.2),rgba(0,217,255,.1));padding:8px 16px;border-radius:6px">
<span style="color:#ffd700;font-weight:bold;font-size:1.3rem">${p}</span>
<span style="color:var(--txt2);font-size:.9rem"> is prime</span>
</div>
<div>
<strong style="color:#00d9ff">${p} = ${r} (mod ${m})</strong> | 
gcd(${r}, ${m}) = 1 | 
Angle: ${(closest.angle * 180 / PI + 90).toFixed(1)} deg
</div>
</div>
<div style="margin-top:6px;font-size:.75rem;color:var(--txt2)">
Other primes = ${r} (mod ${m}): ${sameClass.length > 0 ? sameClass.join(', ') + (sameClass.length >= 10 ? '...' : '') : 'none in range'}
</div>`;
} else {
infoDiv.innerHTML = '<span style="color:var(--txt2)">Click on a point to see prime info</span>';
}
};
}

// Sieve Calculator screenshot and export functions
async function screenshotSieveCalc() {
await screenshotUnified('cprimerings', 'sieveCalcStats', 'Modular Sieve Calculator', 'sieve_calc.png');
}

function exportAllSieveCalc() {
screenshotTabAll({
canvases: ['cprimerings', 'csieveconv', 'csievegap', 'csieveres'],
charts: ['psieveconv'],
dashId: 'sieveCalcStats',
title: 'Modular Sieve Calculator',
filename: 'sieve_calc_all.png'
});
}

function csvSieveCalc() {
const primes = primeRingData.primes || [];
const maxM = +document.getElementById('primeRingMaxMv')?.value || 20;

let csv = 'prime,';
for (let m = 2; m <= Math.min(maxM, 30); m++) csv += `mod${m},`;
csv += 'gap_to_next\n';

for (let i = 0; i < primes.length; i++) {
const p = primes[i];
csv += `${p},`;
for (let m = 2; m <= Math.min(maxM, 30); m++) {
csv += `${p % m},`;
}
csv += `${i < primes.length - 1 ? primes[i + 1] - p : ''}\n`;
}

dl(csv, 'sieve_calc_primes.csv');
}

// ========== WIGNER PHASE SPACE VISUALIZATION ==========
// W(x,p) = (1/π) ∫ x+y|ψψ|x-y e^{2ipy} dy
// For harmonic oscillator: x|ψ(0) = (α/π)^{1/4} exp[-α(x-x₀)²/2], α = mω/ℏ

function wignerGaussian(x, p, x0, p0, squeeze) {
  // Wigner function for coherent/squeezed state
  // W(x,p) = (1/π) exp[-((x-x0)/σx)² - (σx(p-p0))²]
  // where σx = e^{-r} for squeeze parameter r
  const sigmaX = Math.exp(-squeeze);
  const sigmaP = Math.exp(squeeze);
  const dx = (x - x0) / sigmaX;
  const dp = (p - p0) * sigmaX;
  return (1 / Math.PI) * Math.exp(-(dx * dx) - (dp * dp));
}

function wignerFock(x, p, n) {
  // Wigner function for Fock state |n
  // W_n(x,p) = ((-1)^n / π) L_n(2(x²+p²)) exp(-(x²+p²))
  // where L_n is the Laguerre polynomial
  const r2 = x * x + p * p;
  const L = laguerreL(n, 2 * r2);
  return (Math.pow(-1, n) / Math.PI) * L * Math.exp(-r2);
}

function laguerreL(n, x) {
  // Laguerre polynomial L_n(x)
  if (n === 0) return 1;
  if (n === 1) return 1 - x;
  let Lnm1 = 1, Ln = 1 - x;
  for (let k = 2; k <= n; k++) {
    const Lnp1 = ((2 * k - 1 - x) * Ln - (k - 1) * Lnm1) / k;
    Lnm1 = Ln;
    Ln = Lnp1;
  }
  return Ln;
}

function wignerCat(x, p, alpha) {
  // Wigner function for cat state |α + |-α (unnormalized)
  // Shows quantum interference fringes
  const W1 = wignerGaussian(x, p, alpha, 0, 0);
  const W2 = wignerGaussian(x, p, -alpha, 0, 0);
  // Interference term
  const interference = (2 / Math.PI) * Math.exp(-(x * x + p * p)) * Math.cos(4 * alpha * p);
  return W1 + W2 + interference;
}

function wignerThermal(x, p, nbar) {
  // Wigner function for thermal state with average occupation nbar
  // W(x,p) = (1/π(2nbar+1)) exp(-(x²+p²)/(2nbar+1))
  const sigma2 = 2 * nbar + 1;
  return (1 / (Math.PI * sigma2)) * Math.exp(-(x * x + p * p) / sigma2);
}

// ========== STANDALONE WIGNER PHASE SPACE TAB ==========
function drawWigner() {
  const c = document.getElementById('cwigner');
  if(!c) return;
  const ctx = c.getContext('2d');
  
  const state = document.getElementById('wignerState')?.value || 'coherent';
  const x0 = +document.getElementById('wignerX0')?.value || 0;
  const p0 = +document.getElementById('wignerP0')?.value || 0;
  const squeeze = +document.getElementById('wignerSqueeze')?.value || 0;
  const catAlpha = +document.getElementById('wignerCatAlpha')?.value || 2;
  const thermalN = +document.getElementById('wignerThermalN')?.value || 1;
  const plotType = document.getElementById('wignerPlotType')?.value || 'both';
  const res = +document.getElementById('wignerRes')?.value || 60;
  const range = +document.getElementById('wignerRange')?.value || 6;
  const colorScheme = document.getElementById('wignerColor')?.value || 'diverging';
  const showPotential = document.getElementById('wignerPotential')?.checked !== false;
  const showMarginals = document.getElementById('wignerMarginals')?.checked !== false;
  const showContours = document.getElementById('wignerContours')?.checked !== false;
  const showAxes = document.getElementById('wignerAxes')?.checked !== false;
  const highlightNeg = document.getElementById('wignerNegative')?.checked !== false;
  
  ctx.fillStyle = canvBg();
  ctx.fillRect(0, 0, c.width, c.height);
  
  // Compute Wigner function on grid
  const W = [];
  let Wmin = Infinity, Wmax = -Infinity;
  let negativeVolume = 0, positiveVolume = 0;
  const dx = 2 * range / (res - 1);
  
  for (let i = 0; i < res; i++) {
    W[i] = [];
    const xVal = -range + (2 * range * i) / (res - 1);
    for (let j = 0; j < res; j++) {
      const pVal = -range + (2 * range * j) / (res - 1);
      let w;
      
      if (state === 'coherent') {
        w = wignerGaussian(xVal, pVal, x0, p0, squeeze);
      } else if (state === 'squeezed') {
        w = wignerGaussian(xVal, pVal, x0, p0, squeeze > 0 ? squeeze : 0.7);
      } else if (state === 'fock0') {
        w = wignerFock(xVal - x0, pVal - p0, 0);
      } else if (state === 'fock1') {
        w = wignerFock(xVal - x0, pVal - p0, 1);
      } else if (state === 'fock2') {
        w = wignerFock(xVal - x0, pVal - p0, 2);
      } else if (state === 'fock3') {
        w = wignerFock(xVal - x0, pVal - p0, 3);
      } else if (state === 'fock4') {
        w = wignerFock(xVal - x0, pVal - p0, 4);
      } else if (state === 'fock5') {
        w = wignerFock(xVal - x0, pVal - p0, 5);
      } else if (state === 'cat') {
        w = wignerCat(xVal, pVal, catAlpha);
      } else if (state === 'oddcat') {
        // Odd cat state |α - |-α
        const W1 = wignerGaussian(xVal, pVal, catAlpha, 0, 0);
        const W2 = wignerGaussian(xVal, pVal, -catAlpha, 0, 0);
        const interference = (2 / Math.PI) * Math.exp(-(xVal * xVal + pVal * pVal)) * Math.cos(4 * catAlpha * pVal);
        w = W1 + W2 - interference;
      } else if (state === 'thermal') {
        w = wignerThermal(xVal - x0, pVal - p0, thermalN);
      } else if (state === 'superposition') {
        // |0 + |1 superposition
        const W0 = wignerFock(xVal - x0, pVal - p0, 0);
        const W1 = wignerFock(xVal - x0, pVal - p0, 1);
        const interference = (2 / Math.PI) * Math.exp(-(xVal * xVal + pVal * pVal)) * 2 * xVal;
        w = 0.5 * (W0 + W1) + 0.5 * interference;
      } else if (state === 'displaced_fock') {
        // Displaced Fock state D(α)|1
        w = wignerFock(xVal - x0 - 1.5, pVal - p0, 1);
      } else {
        w = wignerGaussian(xVal, pVal, x0, p0, 0);
      }
      
      W[i][j] = w;
      if (w < Wmin) Wmin = w;
      if (w > Wmax) Wmax = w;
      if (w < 0) negativeVolume += Math.abs(w) * dx * dx;
      else positiveVolume += w * dx * dx;
    }
  }
  
  const Wrange = Math.max(Math.abs(Wmin), Math.abs(Wmax));
  
  // Color mapping function
  function getColor(norm) {
    let r, g, b;
    if (colorScheme === 'diverging') {
      if (norm >= 0) { r = 255; g = Math.floor(255 * (1 - norm)); b = g; }
      else { r = Math.floor(255 * (1 + norm)); g = r; b = 255; }
    } else if (colorScheme === 'plasma') {
      const t = (norm + 1) / 2;
      r = Math.floor(13 + t * 230);
      g = Math.floor(8 + t * 92 + Math.sin(t * Math.PI) * 100);
      b = Math.floor(135 + t * 80);
    } else if (colorScheme === 'viridis') {
      const t = (norm + 1) / 2;
      r = Math.floor(68 + t * 187);
      g = Math.floor(1 + t * 206);
      b = Math.floor(84 + t * 50);
    } else if (colorScheme === 'thermal') {
      const t = (norm + 1) / 2;
      if (t < 0.33) { r = 0; g = 0; b = Math.floor(t * 3 * 255); }
      else if (t < 0.66) { r = Math.floor((t - 0.33) * 3 * 255); g = 0; b = 255; }
      else { r = 255; g = Math.floor((t - 0.66) * 3 * 255); b = 255 - g; }
    } else { // rainbow
      const h = ((norm + 1) / 2) * 270;
      const s = 0.8, l = 0.5;
      const c2 = (1 - Math.abs(2 * l - 1)) * s;
      const x = c2 * (1 - Math.abs((h / 60) % 2 - 1));
      const m = l - c2 / 2;
      let rr, gg, bb;
      if (h < 60) { rr = c2; gg = x; bb = 0; }
      else if (h < 120) { rr = x; gg = c2; bb = 0; }
      else if (h < 180) { rr = 0; gg = c2; bb = x; }
      else if (h < 240) { rr = 0; gg = x; bb = c2; }
      else { rr = x; gg = 0; bb = c2; }
      r = Math.floor((rr + m) * 255);
      g = Math.floor((gg + m) * 255);
      b = Math.floor((bb + m) * 255);
    }
    return `rgb(${r},${g},${b})`;
  }
  
  if (plotType === 'contour' || plotType === 'both' || plotType === 'density') {
    // 2D Contour/Density plot
    const plotX = plotType === 'both' ? 50 : 80;
    const plotY = plotType === 'both' ? c.height / 2 + 20 : 60;
    const plotW = plotType === 'both' ? c.width / 2 - 100 : c.width - 200;
    const plotH = plotType === 'both' ? c.height / 2 - 50 : c.height - 140;
    
    const cellW = plotW / res;
    const cellH = plotH / res;
    
    // Draw heatmap
    for (let i = 0; i < res; i++) {
      for (let j = 0; j < res; j++) {
        const w = W[i][j];
        const norm = w / Wrange;
        ctx.fillStyle = getColor(norm);
        ctx.fillRect(plotX + i * cellW, plotY + (res - 1 - j) * cellH, cellW + 1, cellH + 1);
        
        // Highlight negative regions
        if (highlightNeg && w < -0.01 * Wrange) {
          ctx.strokeStyle = 'rgba(0,255,255,0.3)';
          ctx.lineWidth = 0.5;
          ctx.strokeRect(plotX + i * cellW, plotY + (res - 1 - j) * cellH, cellW, cellH);
        }
      }
    }
    
    // Draw contour lines
    if (showContours) {
      ctx.strokeStyle = 'rgba(0,0,0,0.4)';
      ctx.lineWidth = 1;
      const levels = [-0.2, -0.1, -0.05, 0, 0.05, 0.1, 0.2].map(l => l * Wrange);
      for (const level of levels) {
        ctx.beginPath();
        for (let i = 0; i < res - 1; i++) {
          for (let j = 0; j < res - 1; j++) {
            const w00 = W[i][j], w10 = W[i+1][j], w01 = W[i][j+1], w11 = W[i+1][j+1];
            // Simple marching squares
            const px = plotX + (i + 0.5) * cellW;
            const py = plotY + (res - 1.5 - j) * cellH;
            if ((w00 < level) !== (w10 < level)) {
              ctx.moveTo(px, py); ctx.lineTo(px + cellW, py);
            }
            if ((w00 < level) !== (w01 < level)) {
              ctx.moveTo(px, py); ctx.lineTo(px, py + cellH);
            }
          }
        }
        ctx.stroke();
      }
      // Zero contour in white
      ctx.strokeStyle = 'rgba(255,255,255,0.8)';
      ctx.lineWidth = 1.5;
      ctx.beginPath();
      for (let i = 0; i < res - 1; i++) {
        for (let j = 0; j < res - 1; j++) {
          const w00 = W[i][j], w10 = W[i+1][j];
          if ((w00 < 0) !== (w10 < 0)) {
            const t = -w00 / (w10 - w00);
            const px = plotX + (i + t) * cellW;
            const py = plotY + (res - 1 - j) * cellH;
            ctx.moveTo(px - 2, py); ctx.lineTo(px + 2, py);
          }
        }
      }
      ctx.stroke();
    }
    
    // Border
    ctx.strokeStyle = isDark() ? '#fff' : '#000';
    ctx.lineWidth = 1;
    ctx.strokeRect(plotX, plotY, plotW, plotH);
    
    // Axes labels
    if (showAxes) {
      ctx.fillStyle = isDark() ? '#fff' : '#000';
      ctx.font = 'bold 12px Segoe UI';
      ctx.textAlign = 'center';
      ctx.fillText('x (Position)', plotX + plotW / 2, plotY + plotH + 35);
      ctx.save();
      ctx.translate(plotX - 35, plotY + plotH / 2);
      ctx.rotate(-Math.PI / 2);
      ctx.fillText('p (Momentum)', 0, 0);
      ctx.restore();
      
      // Tick labels
      ctx.font = '10px Segoe UI';
      ctx.fillStyle = isDark() ? '#aaa' : '#666';
      for (let i = 0; i <= 4; i++) {
        const v = -range + (2 * range * i / 4);
        ctx.textAlign = 'center';
        ctx.fillText(v.toFixed(0), plotX + (i / 4) * plotW, plotY + plotH + 15);
        ctx.textAlign = 'right';
        ctx.fillText((-range + 2 * range * i / 4).toFixed(0), plotX - 5, plotY + plotH - (i / 4) * plotH + 4);
      }
    }
    
    // Draw harmonic potential overlay
    if (showPotential) {
      ctx.strokeStyle = 'rgba(255,255,255,0.8)';
      ctx.lineWidth = 2;
      ctx.setLineDash([5, 5]);
      ctx.beginPath();
      for (let i = 0; i < res; i++) {
        const xVal = -range + (2 * range * i) / (res - 1);
        const V = 0.5 * xVal * xVal;
        const Vscaled = Math.min(range, V);
        const px = plotX + (i / (res - 1)) * plotW;
        const py = plotY + plotH - (Vscaled / range) * plotH;
        if (i === 0) ctx.moveTo(px, py);
        else ctx.lineTo(px, py);
      }
      ctx.stroke();
      ctx.setLineDash([]);
      ctx.fillStyle = '#ffd700';
      ctx.font = '10px Segoe UI';
      ctx.fillText('V(x)=½x²', plotX + 10, plotY + 15);
    }
    
    // Draw marginal distributions
    if (showMarginals) {
      // X marginal (top) - |ψ(x)|²
      ctx.strokeStyle = '#00d9ff';
      ctx.lineWidth = 2;
      ctx.beginPath();
      let maxMargX = 0;
      const margXvals = [];
      for (let i = 0; i < res; i++) {
        let margX = 0;
        for (let j = 0; j < res; j++) margX += W[i][j];
        margX *= dx;
        margXvals.push(margX);
        if (margX > maxMargX) maxMargX = margX;
      }
      for (let i = 0; i < res; i++) {
        const px = plotX + (i / (res - 1)) * plotW;
        const py = plotY - 5 - (margXvals[i] / maxMargX) * 45;
        if (i === 0) ctx.moveTo(px, py);
        else ctx.lineTo(px, py);
      }
      ctx.stroke();
      ctx.fillStyle = '#00d9ff';
      ctx.font = '9px Segoe UI';
      ctx.fillText('|ψ(x)|²', plotX + plotW - 30, plotY - 40);
      
      // P marginal (right) - |φ(p)|²
      ctx.strokeStyle = '#ff6496';
      ctx.beginPath();
      let maxMargP = 0;
      const margPvals = [];
      for (let j = 0; j < res; j++) {
        let margP = 0;
        for (let i = 0; i < res; i++) margP += W[i][j];
        margP *= dx;
        margPvals.push(margP);
        if (margP > maxMargP) maxMargP = margP;
      }
      for (let j = 0; j < res; j++) {
        const px = plotX + plotW + 5 + (margPvals[j] / maxMargP) * 45;
        const py = plotY + ((res - 1 - j) / (res - 1)) * plotH;
        if (j === 0) ctx.moveTo(px, py);
        else ctx.lineTo(px, py);
      }
      ctx.stroke();
      ctx.fillStyle = '#ff6496';
      ctx.save();
      ctx.translate(plotX + plotW + 45, plotY + 30);
      ctx.rotate(Math.PI / 2);
      ctx.fillText('|φ(p)|²', 0, 0);
      ctx.restore();
    }
    
    // Colorbar
    const cbX = plotX + plotW + 70, cbY = plotY, cbW = 15, cbH = plotH;
    for (let i = 0; i < cbH; i++) {
      const norm = 1 - 2 * i / cbH;
      ctx.fillStyle = getColor(norm);
      ctx.fillRect(cbX, cbY + i, cbW, 1);
    }
    ctx.strokeStyle = isDark() ? '#fff' : '#000';
    ctx.strokeRect(cbX, cbY, cbW, cbH);
    ctx.fillStyle = isDark() ? '#fff' : '#000';
    ctx.font = '10px Segoe UI';
    ctx.textAlign = 'left';
    ctx.fillText(Wmax.toFixed(3), cbX + cbW + 3, cbY + 10);
    ctx.fillText('0', cbX + cbW + 3, cbY + cbH / 2 + 3);
    ctx.fillText(Wmin.toFixed(3), cbX + cbW + 3, cbY + cbH);
  }
  
  if (plotType === '3d' || plotType === 'both') {
    // 3D Surface plot
    const plotX = plotType === 'both' ? c.width / 2 + 30 : 100;
    const plotY = plotType === 'both' ? 50 : 80;
    const plotW = plotType === 'both' ? c.width / 2 - 60 : c.width - 200;
    const plotH = plotType === 'both' ? c.height / 2 - 20 : c.height - 200;
    
    const cx3d = plotX + plotW / 2;
    const cy3d = plotY + plotH / 2 + 30;
    const scale3d = Math.min(plotW, plotH) / 3;
    const heightScale = plotH / 5;
    
    // Rotation angles
    const rotX = 0.6, rotY = 0.3;
    
    const project = (x, p, w) => {
      // Apply rotation
      const y1 = p * Math.cos(rotX) - w * Math.sin(rotX);
      const z1 = p * Math.sin(rotX) + w * Math.cos(rotX);
      const x1 = x * Math.cos(rotY) + z1 * Math.sin(rotY);
      const z2 = -x * Math.sin(rotY) + z1 * Math.cos(rotY);
      
      const px = cx3d + x1 * scale3d;
      const py = cy3d - y1 * scale3d * 0.8 - z2 * heightScale * 0.5;
      return { x: px, y: py, z: z2 };
    };
    
    // Draw surface (painter's algorithm)
    const res3d = Math.min(res, 50);
    const step = Math.max(1, Math.floor(res / res3d));
    
    for (let j = res - step; j >= step; j -= step) {
      for (let i = 0; i < res - step; i += step) {
        const x1 = (-range + (2 * range * i) / (res - 1)) / range;
        const x2 = (-range + (2 * range * (i + step)) / (res - 1)) / range;
        const p1 = (-range + (2 * range * j) / (res - 1)) / range;
        const p2 = (-range + (2 * range * (j - step)) / (res - 1)) / range;
        
        const w00 = W[i][j] / Wrange;
        const w10 = W[Math.min(i + step, res - 1)][j] / Wrange;
        const w01 = W[i][Math.max(j - step, 0)] / Wrange;
        const w11 = W[Math.min(i + step, res - 1)][Math.max(j - step, 0)] / Wrange;
        
        const pt00 = project(x1, p1, w00);
        const pt10 = project(x2, p1, w10);
        const pt01 = project(x1, p2, w01);
        const pt11 = project(x2, p2, w11);
        
        const avgW = (w00 + w10 + w01 + w11) / 4;
        ctx.fillStyle = getColor(avgW);
        ctx.strokeStyle = 'rgba(0,0,0,0.15)';
        ctx.lineWidth = 0.5;
        ctx.beginPath();
        ctx.moveTo(pt00.x, pt00.y);
        ctx.lineTo(pt10.x, pt10.y);
        ctx.lineTo(pt11.x, pt11.y);
        ctx.lineTo(pt01.x, pt01.y);
        ctx.closePath();
        ctx.fill();
        ctx.stroke();
      }
    }
    
    // Draw W=0 plane outline
    ctx.strokeStyle = 'rgba(255,255,255,0.5)';
    ctx.lineWidth = 1;
    const corners = [project(-1, -1, 0), project(1, -1, 0), project(1, 1, 0), project(-1, 1, 0)];
    ctx.beginPath();
    ctx.moveTo(corners[0].x, corners[0].y);
    corners.forEach(c => ctx.lineTo(c.x, c.y));
    ctx.closePath();
    ctx.stroke();
    
    // Axis labels
    ctx.fillStyle = isDark() ? '#fff' : '#000';
    ctx.font = 'bold 14px Segoe UI';
    ctx.textAlign = 'center';
    const lX = project(1.4, 0, 0), lP = project(0, 1.4, 0), lW = project(0, 0, 1.3);
    ctx.fillText('x', lX.x, lX.y + 5);
    ctx.fillText('p', lP.x, lP.y + 5);
    ctx.fillText('W', lW.x - 10, lW.y);
  }
  
  // Title
  ctx.fillStyle = '#ffd700';
  ctx.font = 'bold 18px Segoe UI';
  ctx.textAlign = 'center';
  ctx.fillText('Wigner Quasi-Probability Distribution W(x, p)', c.width / 2, 25);
  
  // State name
  const stateNames = {
    'coherent': 'Coherent State |α',
    'squeezed': 'Squeezed State S(r)|α',
    'fock0': 'Vacuum |0',
    'fock1': 'Fock |1',
    'fock2': 'Fock |2',
    'fock3': 'Fock |3',
    'fock4': 'Fock |4',
    'fock5': 'Fock |5',
    'cat': 'Even Cat |α+|-α',
    'oddcat': 'Odd Cat |α-|-α',
    'thermal': `Thermal (n̄=${thermalN})`,
    'superposition': '|0+|1 Superposition',
    'displaced_fock': 'Displaced Fock D(α)|1'
  };
  ctx.fillStyle = '#00d9ff';
  ctx.font = '14px Segoe UI';
  ctx.fillText(`State: ${stateNames[state] || state}`, c.width / 2, 45);
  
  // Update live stats
  const statsDiv = document.getElementById('wignerLiveStats');
  if (statsDiv) {
    const negativity = negativeVolume;
    const purity = (positiveVolume + negativeVolume) * Math.PI;
    statsDiv.innerHTML = `
      <div style="display:grid;grid-template-columns:1fr 1fr;gap:.5rem">
        <div><strong style="color:#ffd700">State:</strong> ${stateNames[state]}</div>
        <div><strong style="color:#00d9ff">Displacement:</strong> x₀=${x0.toFixed(2)}, p₀=${p0.toFixed(2)}</div>
        <div><strong style="color:#ff6496">W_max:</strong> ${Wmax.toFixed(4)}</div>
        <div><strong style="color:#9664ff">W_min:</strong> ${Wmin.toFixed(4)} ${Wmin < 0 ? '(NEGATIVE - quantum!)' : ''}</div>
        <div><strong style="color:#00ff88">Negativity:</strong> ${negativity.toFixed(4)} ${negativity > 0.01 ? '(non-classical)' : ''}</div>
        <div><strong style="color:#ff8c00">Squeeze r:</strong> ${squeeze.toFixed(2)} (σ_x=${Math.exp(-squeeze).toFixed(2)})</div>
      </div>
      <div style="margin-top:.5rem;padding-top:.5rem;border-top:1px solid var(--bord)">
        <strong style="color:#ffd700">Formula:</strong> W(x,p) = (1/πℏ) ∫ ψ*(x+y) ψ(x-y) e^{2ipy/ℏ} dy
      </div>
      <div style="margin-top:.3rem;color:var(--txt2);font-size:.8rem">
        ${Wmin < 0 ? 'Negative values indicate quantum behavior impossible classically.' : 'This state has a positive Wigner function (quasi-classical).'}
      </div>
    `;
  }
  
  // Plot marginals with Plotly
  const margDiv = document.getElementById('pwignerMarg');
  if (margDiv && typeof Plotly !== 'undefined') {
    const xVals = [], pVals = [], margX = [], margP = [];
    for (let i = 0; i < res; i++) {
      xVals.push(-range + (2 * range * i) / (res - 1));
      pVals.push(-range + (2 * range * i) / (res - 1));
      let mX = 0, mP = 0;
      for (let j = 0; j < res; j++) {
        mX += W[i][j];
        mP += W[j][i];
      }
      margX.push(mX * dx);
      margP.push(mP * dx);
    }
    Plotly.newPlot(margDiv, [
      { x: xVals, y: margX, name: '|ψ(x)|²', line: { color: '#00d9ff' } },
      { x: pVals, y: margP, name: '|φ(p)|²', line: { color: '#ff6496' } }
    ], {
      title: 'Marginal Distributions',
      xaxis: { title: 'x or p' },
      yaxis: { title: 'Probability Density' },
      paper_bgcolor: 'rgba(0,0,0,0)',
      plot_bgcolor: 'rgba(0,0,0,0)',
      font: { color: isDark() ? '#e0e0e0' : '#333' },
      margin: { t: 40, r: 20, b: 40, l: 50 },
      legend: { x: 0.7, y: 0.95 }
    }, { responsive: true });
  }
  
  // Plot negativity indicator
  const negDiv = document.getElementById('pwignerNeg');
  if (negDiv && typeof Plotly !== 'undefined') {
    Plotly.newPlot(negDiv, [{
      type: 'indicator',
      mode: 'gauge+number',
      value: negativeVolume,
      title: { text: 'Wigner Negativity' },
      gauge: {
        axis: { range: [0, 0.5] },
        bar: { color: negativeVolume > 0.1 ? '#ff6496' : '#00ff88' },
        steps: [
          { range: [0, 0.05], color: 'rgba(0,255,136,0.3)' },
          { range: [0.05, 0.2], color: 'rgba(255,215,0,0.3)' },
          { range: [0.2, 0.5], color: 'rgba(255,100,150,0.3)' }
        ],
        threshold: { line: { color: 'red', width: 2 }, value: 0.1 }
      }
    }], {
      paper_bgcolor: 'rgba(0,0,0,0)',
      font: { color: isDark() ? '#e0e0e0' : '#333' },
      margin: { t: 40, r: 20, b: 20, l: 20 }
    }, { responsive: true });
  }
}

function screenshotWigner() { screenshotCanvas('cwigner', 'Wigner Phase Space', 'wigner_phase_space.png'); }
function csvWigner() {
  const res = +document.getElementById('wignerRes')?.value || 60;
  const range = +document.getElementById('wignerRange')?.value || 6;
  let csv = 'x,p,W\n';
  for (let i = 0; i < res; i++) {
    const x = -range + (2 * range * i) / (res - 1);
    for (let j = 0; j < res; j++) {
      const p = -range + (2 * range * j) / (res - 1);
      // Recompute W for CSV
      const state = document.getElementById('wignerState')?.value || 'coherent';
      let w = wignerGaussian(x, p, 0, 0, 0);
      csv += `${x.toFixed(4)},${p.toFixed(4)},${w.toFixed(6)}\n`;
    }
  }
  dl(csv, 'wigner_function.csv');
}

let wignerAnimating = false;
function animateWigner() {
  const btn = document.getElementById('wignerAnimBtn');
  if (wignerAnimating) {
    wignerAnimating = false;
    btn.textContent = 'Animate';
    return;
  }
  wignerAnimating = true;
  btn.textContent = 'Stop';
  let t = 0;
  function frame() {
    if (!wignerAnimating) return;
    t += 0.05;
    // Oscillate displacement
    document.getElementById('wignerX0').value = 2 * Math.cos(t);
    document.getElementById('wignerP0').value = 2 * Math.sin(t);
    document.getElementById('wignerX0V').textContent = (2 * Math.cos(t)).toFixed(1);
    document.getElementById('wignerP0V').textContent = (2 * Math.sin(t)).toFixed(1);
    drawWigner();
    requestAnimationFrame(frame);
  }
  frame();
}

function drawQuantum() {
const c = document.getElementById('cquantum'), ctx = c.getContext('2d');
const Z = +document.getElementById('quantumZ')?.value || 1;
const n = +document.getElementById('quantumNv').value || 3;
let l = +document.getElementById('quantumLv').value || 0;
let m = +document.getElementById('quantumMv').value || 0;
const mode = document.getElementById('quantumMode').value;

const res = +document.getElementById('quantumRes').value || 50;
const showNodes = document.getElementById('quantumNodes').checked;
const showAxes = document.getElementById('quantumAxes').checked;
const showLabels = document.getElementById('quantumLabels').checked;
const showBohr = document.getElementById('quantumBohr')?.checked;

// Enforce quantum number rules
if(l >= n) l = n - 1;
if(Math.abs(m) > l) m = m > 0 ? l : -l;
document.getElementById('quantumL').value = l;
document.getElementById('quantumLv').value = l;
document.getElementById('quantumM').value = m;
document.getElementById('quantumMv').value = m;

ctx.fillStyle = canvBg();
ctx.fillRect(0, 0, c.width, c.height);

const cx = c.width / 2, cy = c.height / 2;
const scale = c.width / (4 * n / Z + 2); // Scale contracts with Z
const orbitalNames = ['s', 'p', 'd', 'f', 'g', 'h', 'i'];
const elementSymbol = ELEMENT_SYMBOLS[Z] || `Z=${Z}`;
const orbitalName = elementSymbol + ' ' + n + (orbitalNames[l] || 'l=' + l);

// Count radial and angular nodes
const radialNodes = n - l - 1;
const angularNodes = l;

// Classical Bohr values (scale with Z)
const rBohr = bohrRadius(n, Z);
const rExpected = expectedRadius(n, l, Z);
const energyEV = -13.6 * Z * Z / (n * n); // Energy in eV

if(mode === 'classical') {
// Classical vs Quantum comparison mode
const maxR = n * n * 4 / Z; // Scale with Z
const plotW = c.width - 100;
const plotH = c.height - 100;

// Background grid
ctx.strokeStyle = gridC();
ctx.lineWidth = 1;
for(let i = 0; i <= 10; i++) {
const x = 50 + i * plotW / 10;
ctx.beginPath(); ctx.moveTo(x, 50); ctx.lineTo(x, c.height - 50); ctx.stroke();
const y = 50 + i * plotH / 10;
ctx.beginPath(); ctx.moveTo(50, y); ctx.lineTo(c.width - 50, y); ctx.stroke();
}

// Compute radial probability 4πr²|R|² (probability of finding electron at distance r)
const radialProb = [];
let maxProb = 0;
for(let i = 0; i <= res * 3; i++) {
const r = i * maxR / (res * 3);
const R = radialWavefunction(n, l, r * Z); // Scale r by Z
const prob = 4 * PI * r * r * R * R * Z * Z * Z; // Scale probability by Z³
radialProb.push({r, prob});
maxProb = Math.max(maxProb, prob);
}

// Plot quantum probability distribution
ctx.strokeStyle = '#00d9ff';
ctx.lineWidth = 3;
ctx.beginPath();
for(let i = 0; i < radialProb.length; i++) {
const px = 50 + radialProb[i].r / maxR * plotW;
const py = c.height - 50 - radialProb[i].prob / maxProb * (plotH * 0.8);
if(i === 0) ctx.moveTo(px, py);
else ctx.lineTo(px, py);
}
ctx.stroke();

// Classical Bohr: delta function at r = n²a₀
const bohrX = 50 + rBohr / maxR * plotW;
ctx.strokeStyle = '#ff6496';
ctx.lineWidth = 3;
ctx.setLineDash([8, 4]);
ctx.beginPath();
ctx.moveTo(bohrX, c.height - 50);
ctx.lineTo(bohrX, 80);
ctx.stroke();
ctx.setLineDash([]);

// Expected value <r>
const expectX = 50 + rExpected / maxR * plotW;
ctx.strokeStyle = '#ffd700';
ctx.lineWidth = 2;
ctx.setLineDash([4, 4]);
ctx.beginPath();
ctx.moveTo(expectX, c.height - 50);
ctx.lineTo(expectX, 100);
ctx.stroke();
ctx.setLineDash([]);

// Find peak of quantum distribution
let peakR = 0, peakProb = 0;
radialProb.forEach(p => { if(p.prob > peakProb) { peakProb = p.prob; peakR = p.r; }});
const peakX = 50 + peakR / maxR * plotW;

// Mark peak
ctx.fillStyle = '#00ff88';
ctx.beginPath();
ctx.arc(peakX, c.height - 50 - peakProb / maxProb * (plotH * 0.8), 8, 0, 2*PI);
ctx.fill();

// Labels
if(showLabels) {
ctx.font = '12px Segoe UI';
ctx.fillStyle = '#ff6496';
ctx.fillText(`Bohr: r = ${n}²a₀ = ${rBohr}a₀`, bohrX + 5, 75);
ctx.fillStyle = '#ffd700';
ctx.fillText(`r = ${rExpected.toFixed(1)}a₀`, expectX + 5, 95);
ctx.fillStyle = '#00ff88';
ctx.fillText(`Peak: ${peakR.toFixed(1)}a₀`, peakX + 5, c.height - 55 - peakProb / maxProb * (plotH * 0.8));
ctx.fillStyle = '#00d9ff';
ctx.fillText('Quantum P(r) = 4πr²|R_{nl}|²', c.width - 200, 30);
ctx.fillStyle = isDark() ? '#fff' : '#333';
ctx.fillText('r (Bohr radii a₀)', c.width / 2 - 50, c.height - 15);
}

// Store for stats
quantumData.classical = { rBohr, rExpected, peakR };

} else if(mode === 'cloud' || mode === 'cross') {
// Probability cloud visualization
const maxR = n * n * 3;
const imgData = ctx.createImageData(c.width, c.height);

for(let py = 0; py < c.height; py++) {
for(let px = 0; px < c.width; px++) {
const x = (px - cx) / scale;
const y = (cy - py) / scale;
const r = Math.sqrt(x*x + y*y);
const theta = Math.atan2(Math.sqrt(x*x), y) || 0; // Angle from z-axis
const phi = Math.atan2(y, x);

const prob = psiSquared(n, l, m, r, theta, phi, Z);
const intensity = Math.min(1, prob * 500 * n * n * Z * Z); // Scale intensity with Z²

// Color based on sign of wavefunction (for cross section)
const R = radialWavefunction(n, l, r * Z);
const Y = sphericalHarmonic(l, m, theta, phi);
const psi = R * Y;

let red, green, blue;
if(mode === 'cross') {
// Show sign with color
if(psi > 0) {
red = Math.floor(intensity * 0); green = Math.floor(intensity * 180); blue = Math.floor(intensity * 255);
} else {
red = Math.floor(intensity * 255); green = Math.floor(intensity * 100); blue = Math.floor(intensity * 150);
}
} else {
// Probability density only
red = Math.floor(intensity * 100);
green = Math.floor(intensity * 200);
blue = Math.floor(intensity * 255);
}

const idx = (py * c.width + px) * 4;
imgData.data[idx] = red;
imgData.data[idx + 1] = green;
imgData.data[idx + 2] = blue;
imgData.data[idx + 3] = 255;
}
}
ctx.putImageData(imgData, 0, 0);

// Draw axes
if(showAxes) {
ctx.strokeStyle = 'rgba(255,255,255,0.3)';
ctx.lineWidth = 1;
ctx.setLineDash([5, 5]);
ctx.beginPath();
ctx.moveTo(0, cy); ctx.lineTo(c.width, cy);
ctx.moveTo(cx, 0); ctx.lineTo(cx, c.height);
ctx.stroke();
ctx.setLineDash([]);
}

// Draw Bohr orbit overlay
if(showBohr) {
ctx.strokeStyle = '#ff6496';
ctx.lineWidth = 2;
ctx.setLineDash([6, 3]);
// Bohr radius circle
const bohrPixel = rBohr * scale;
ctx.beginPath();
ctx.arc(cx, cy, bohrPixel, 0, 2*PI);
ctx.stroke();
// Expected radius circle
ctx.strokeStyle = '#ffd700';
const expectPixel = rExpected * scale;
ctx.beginPath();
ctx.arc(cx, cy, expectPixel, 0, 2*PI);
ctx.stroke();
ctx.setLineDash([]);
// Labels
ctx.font = '11px Segoe UI';
ctx.fillStyle = '#ff6496';
ctx.fillText(`Bohr n²=${rBohr}`, cx + bohrPixel + 5, cy);
ctx.fillStyle = '#ffd700';
ctx.fillText(`r=${rExpected.toFixed(1)}`, cx + expectPixel + 5, cy + 15);
}

} else if(mode === 'radial') {
// Radial function R_nl(r)
const maxR = n * n * 4 / Z; // Scale with Z
const points = [];
quantumData.radial = [];

ctx.strokeStyle = gridC();
ctx.lineWidth = 1;
// Draw grid
for(let i = 0; i <= 10; i++) {
const x = 50 + i * (c.width - 100) / 10;
ctx.beginPath(); ctx.moveTo(x, 50); ctx.lineTo(x, c.height - 50); ctx.stroke();
const y = 50 + i * (c.height - 100) / 10;
ctx.beginPath(); ctx.moveTo(50, y); ctx.lineTo(c.width - 50, y); ctx.stroke();
}

// Plot R_nl(r)
ctx.strokeStyle = '#00d9ff';
ctx.lineWidth = 3;
ctx.beginPath();
let maxVal = 0;
for(let i = 0; i <= res * 2; i++) {
const r = i * maxR / (res * 2);
const R = radialWavefunction(n, l, r * Z); // Scale r by Z
points.push({r, R});
quantumData.radial.push({r, R});
maxVal = Math.max(maxVal, Math.abs(R));
}
for(let i = 0; i < points.length; i++) {
const px = 50 + points[i].r / maxR * (c.width - 100);
const py = cy - points[i].R / maxVal * (c.height / 2 - 60);
if(i === 0) ctx.moveTo(px, py);
else ctx.lineTo(px, py);
}
ctx.stroke();

// Plot r²R² (probability)
ctx.strokeStyle = '#ffd700';
ctx.lineWidth = 2;
ctx.beginPath();
let maxProb = 0;
const probPoints = points.map(p => ({r: p.r, prob: p.r * p.r * p.R * p.R}));
probPoints.forEach(p => maxProb = Math.max(maxProb, p.prob));
for(let i = 0; i < probPoints.length; i++) {
const px = 50 + probPoints[i].r / maxR * (c.width - 100);
const py = c.height - 50 - probPoints[i].prob / maxProb * (c.height / 2 - 60);
if(i === 0) ctx.moveTo(px, py);
else ctx.lineTo(px, py);
}
ctx.stroke();

// Mark nodes
if(showNodes) {
ctx.fillStyle = '#ff6496';
for(let i = 1; i < points.length - 1; i++) {
if(points[i-1].R * points[i+1].R < 0) {
const px = 50 + points[i].r / maxR * (c.width - 100);
ctx.beginPath(); ctx.arc(px, cy, 6, 0, 2*PI); ctx.fill();
}
}
}

// Mark Bohr radius and expected value
if(showBohr) {
const bohrX = 50 + rBohr / maxR * (c.width - 100);
const expectX = 50 + rExpected / maxR * (c.width - 100);
ctx.strokeStyle = '#ff6496';
ctx.lineWidth = 2;
ctx.setLineDash([6, 3]);
ctx.beginPath();
ctx.moveTo(bohrX, 50); ctx.lineTo(bohrX, c.height - 50);
ctx.stroke();
ctx.strokeStyle = '#00ff88';
ctx.beginPath();
ctx.moveTo(expectX, 50); ctx.lineTo(expectX, c.height - 50);
ctx.stroke();
ctx.setLineDash([]);
ctx.font = '10px Segoe UI';
ctx.fillStyle = '#ff6496';
ctx.fillText(`n²=${rBohr}`, bohrX - 15, 45);
ctx.fillStyle = '#00ff88';
ctx.fillText(`r=${rExpected.toFixed(1)}`, expectX - 20, 60);
}

// Labels
if(showLabels) {
ctx.fillStyle = isDark() ? '#fff' : '#333';
ctx.font = '12px Segoe UI';
ctx.fillText('r (Bohr radii)', c.width / 2, c.height - 15);
ctx.fillText('R_{nl}(r)', 10, 30);
ctx.fillStyle = '#00d9ff';
ctx.fillText('Radial wavefunction', c.width - 150, 30);
ctx.fillStyle = '#ffd700';
ctx.fillText('Probability r²R²', c.width - 150, 50);
}

} else if(mode === 'angular') {
// Angular distribution Y_l^m(θ,φ)
ctx.strokeStyle = gridC();
ctx.lineWidth = 1;
ctx.beginPath(); ctx.arc(cx, cy, c.width/3, 0, 2*PI); ctx.stroke();

// Plot |Y_l^m|² as polar plot
const maxY = 1;
const points = [];
quantumData.angular = [];

for(let i = 0; i <= res * 4; i++) {
const theta = i * PI / (res * 2);
const Y = sphericalHarmonic(l, m, theta, 0);
const val = Y * Y;
points.push({theta, val});
quantumData.angular.push({theta: theta * 180 / PI, Y: Y, Ysq: val});
}

const maxVal = Math.max(...points.map(p => p.val)) || 1;

ctx.fillStyle = 'rgba(0,217,255,0.3)';
ctx.strokeStyle = '#00d9ff';
ctx.lineWidth = 2;
ctx.beginPath();
for(let i = 0; i < points.length; i++) {
const r = points[i].val / maxVal * (c.width / 3);
const angle = points[i].theta - PI/2;
const px = cx + r * Math.cos(angle);
const py = cy + r * Math.sin(angle);
if(i === 0) ctx.moveTo(px, py);
else ctx.lineTo(px, py);
}
ctx.closePath();
ctx.fill();
ctx.stroke();

// Mirror for full view
ctx.beginPath();
for(let i = 0; i < points.length; i++) {
const r = points[i].val / maxVal * (c.width / 3);
const angle = PI + points[i].theta - PI/2;
const px = cx + r * Math.cos(angle);
const py = cy + r * Math.sin(angle);
if(i === 0) ctx.moveTo(px, py);
else ctx.lineTo(px, py);
}
ctx.closePath();
ctx.fill();
ctx.stroke();

if(showLabels) {
ctx.fillStyle = isDark() ? '#fff' : '#333';
ctx.font = '14px Segoe UI';
ctx.fillText('θ = 0 (z-axis)', cx - 40, 30);
ctx.fillText('θ = π', cx - 20, c.height - 15);
}

} else if(mode === 'all') {
// Show all orbitals for given n in a proper grid layout
// Use a uniform cell size with proper spacing

// Calculate total orbitals for this n
let totalOrbitals = 0;
for(let ll = 0; ll < n; ll++) totalOrbitals += (2*ll + 1);

// Determine grid layout - aim for roughly square arrangement
const cols = Math.min(2 * n - 1, Math.ceil(Math.sqrt(totalOrbitals * 1.5))); // Max columns = max m range
const rows = Math.ceil(totalOrbitals / cols);

const padding = 40;
const labelSpace = 25; // Space for labels below each cell
const titleSpace = 35; // Space for title at top

const availWidth = c.width - padding * 2;
const availHeight = c.height - padding * 2 - titleSpace;

// Calculate uniform cell size
const cellWidth = availWidth / cols;
const cellHeight = (availHeight - labelSpace) / rows;
const cellSize = Math.min(cellWidth, cellHeight) - 8;

// Store orbital positions for click detection
window.quantumOrbitalGrid = [];
window.quantumSelectedOrbital = null;

// Title
ctx.fillStyle = '#00d9ff';
ctx.font = 'bold 16px Segoe UI';
ctx.textAlign = 'center';
ctx.fillText(`${elementSymbol} orbitals for n=${n} (${totalOrbitals} orbitals) — Click to enlarge`, c.width/2, 22);

// Build list of all orbitals
const orbitals = [];
for(let ll = 0; ll < n; ll++) {
  for(let mm = -ll; mm <= ll; mm++) {
    orbitals.push({l: ll, m: mm});
  }
}

// Draw each orbital in grid
orbitals.forEach((orb, idx) => {
  const col = idx % cols;
  const row = Math.floor(idx / cols);
  
  const cellX = padding + col * cellWidth + (cellWidth - cellSize) / 2;
  const cellY = titleSpace + padding + row * (cellSize + labelSpace) + 4;
  const cx_cell = cellX + cellSize / 2;
  const cy_cell = cellY + cellSize / 2;
  
  // Store for click detection
  window.quantumOrbitalGrid.push({
    l: orb.l, m: orb.m, x: cellX, y: cellY, w: cellSize, h: cellSize, idx: idx
  });
  
  // Draw mini probability cloud with better resolution
  const step = Math.max(2, Math.floor(cellSize / 40));
  const localScale = cellSize / (4 * n / Z + 2);
  
  for(let py = 0; py < cellSize; py += step) {
    for(let px = 0; px < cellSize; px += step) {
      const x = (px - cellSize/2) / localScale;
      const y = (cellSize/2 - py) / localScale;
      const r = Math.sqrt(x*x + y*y);
      const theta = Math.atan2(Math.sqrt(x*x), y) || 0;
      const phi = Math.atan2(y, x);
      
      const prob = psiSquared(n, orb.l, orb.m, r, theta, phi, Z);
      const intensity = Math.min(1, prob * 500 * n * n * Z * Z);
      
      if(intensity > 0.02) {
        // Color code by l value: s=cyan, p=green, d=yellow, f=orange, g=red
        const hue = 180 - orb.l * 45;
        ctx.fillStyle = `hsla(${hue}, 100%, ${50 + intensity*30}%, ${Math.min(1, intensity * 1.5)})`;
        ctx.fillRect(cellX + px, cellY + py, step, step);
      }
    }
  }
  
  // Draw border (highlight if this is current selection)
  const isSelected = (orb.l === l && orb.m === m);
  ctx.strokeStyle = isSelected ? '#ffd700' : 'rgba(255,255,255,0.3)';
  ctx.lineWidth = isSelected ? 2 : 1;
  ctx.strokeRect(cellX, cellY, cellSize, cellSize);
  
  // Label below
  ctx.fillStyle = isSelected ? '#ffd700' : (isDark() ? '#fff' : '#333');
  ctx.font = `${Math.max(10, Math.min(13, cellSize/5))}px Segoe UI`;
  ctx.textAlign = 'center';
  const label = n + orbitalNames[orb.l] + (orb.m !== 0 ? (orb.m > 0 ? '⁺' : '⁻') + Math.abs(orb.m) : '');
  ctx.fillText(label, cx_cell, cellY + cellSize + 14);
  
  // Small l indicator
  ctx.fillStyle = `hsl(${180 - orb.l * 45}, 80%, 60%)`;
  ctx.font = '9px Segoe UI';
  ctx.textAlign = 'left';
  ctx.fillText(orbitalNames[orb.l], cellX + 3, cellY + 12);
});

// Legend for l values
ctx.fillStyle = 'rgba(0,0,0,0.5)';
ctx.fillRect(c.width - 90, titleSpace + padding, 85, n * 18 + 10);
ctx.fillStyle = '#fff';
ctx.font = 'bold 11px Segoe UI';
ctx.textAlign = 'left';
ctx.fillText('Subshells:', c.width - 85, titleSpace + padding + 14);
for(let ll = 0; ll < n; ll++) {
  const hue = 180 - ll * 45;
  ctx.fillStyle = `hsl(${hue}, 80%, 60%)`;
  ctx.fillRect(c.width - 85, titleSpace + padding + 20 + ll * 16, 12, 12);
  ctx.fillStyle = '#fff';
  ctx.font = '11px Segoe UI';
  ctx.fillText(`l=${ll} (${orbitalNames[ll]})`, c.width - 70, titleSpace + padding + 30 + ll * 16);
}

// Instruction at bottom
ctx.fillStyle = 'rgba(255,255,255,0.6)';
ctx.font = '12px Segoe UI';
ctx.textAlign = 'center';
ctx.fillText('Click any orbital to view full-size in Cloud mode', c.width/2, c.height - 8);

}

// Orbital label
if(showLabels && mode !== 'all') {
ctx.fillStyle = '#ffd700';
ctx.font = 'bold 24px Segoe UI';
ctx.fillText(`${orbitalName} orbital (n=${n}, l=${l}, m=${m})`, 20, 35);
}

legend('alquantum', 'Atomic Orbital', [['Z', Z + ' (' + elementSymbol + ')', '#ff6496'], ['n', n, '#00d9ff'], ['l', l + ' (' + orbitalNames[l] + ')', '#ffd700'], ['m', m, '#9664ff']]);

// Click handler for "all" mode - click orbital to view it
if(mode === 'all') {
  c.onclick = function(e) {
    const rect = c.getBoundingClientRect();
    const mx = (e.clientX - rect.left) * (c.width / rect.width);
    const my = (e.clientY - rect.top) * (c.height / rect.height);
    
    if(window.quantumOrbitalGrid) {
      for(const orb of window.quantumOrbitalGrid) {
        if(mx >= orb.x && mx <= orb.x + orb.w && my >= orb.y && my <= orb.y + orb.h) {
          // Switch to this orbital
          document.getElementById('quantumL').value = orb.l;
          document.getElementById('quantumLv').value = orb.l;
          document.getElementById('quantumM').value = orb.m;
          document.getElementById('quantumMv').value = orb.m;
          document.getElementById('quantumMode').value = 'cloud';
          drawQuantum();
          return;
        }
      }
    }
  };
} else {
  // Normal click handler for other modes
  c.onclick = function(e) {
    const rect = c.getBoundingClientRect();
    const mx = (e.clientX - rect.left) * (c.width / rect.width);
    const my = (e.clientY - rect.top) * (c.height / rect.height);
    modal('Quantum Orbital', [
      ['Orbital', orbitalName],
      ['n (principal)', n],
      ['l (angular)', l + ' (' + orbitalNames[l] + ')'],
      ['m (magnetic)', m],
      ['Radial nodes', radialNodes],
      ['Angular nodes', angularNodes],
      ['Bohr radius', rBohr + ' a₀'],
      ['r expected', rExpected.toFixed(2) + ' a₀'],
      ['Click position', `(${mx.toFixed(0)}, ${my.toFixed(0)})`]
    ]);
  };
}

// Live stats
document.getElementById('quantumLiveStats').innerHTML = `
<div style="display:grid;grid-template-columns:repeat(4,1fr);gap:8px;margin-bottom:12px">
<div style="background:linear-gradient(135deg,rgba(255,100,150,.2),rgba(150,100,255,.1));padding:10px;border-radius:6px;text-align:center;border:1px solid #ff6496"><div style="font-size:1.5rem;font-weight:bold;color:#ff6496">${elementSymbol}</div><div style="font-size:.7rem;color:var(--txt2)">ELEMENT (Z=${Z})</div></div>
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center"><div style="font-size:1.5rem;font-weight:bold;color:#00d9ff">${n}</div><div style="font-size:.7rem;color:var(--txt2)">PRINCIPAL n</div></div>
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center"><div style="font-size:1.5rem;font-weight:bold;color:#ffd700">${l}</div><div style="font-size:.7rem;color:var(--txt2)">ANGULAR l (${orbitalNames[l] || '?'})</div></div>
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center"><div style="font-size:1.5rem;font-weight:bold;color:#9664ff">${m}</div><div style="font-size:.7rem;color:var(--txt2)">MAGNETIC m</div></div>
</div>
<div style="display:grid;grid-template-columns:repeat(2,1fr);gap:8px;margin-bottom:12px">
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center"><div style="font-size:1.2rem;font-weight:bold;color:#00ff88">${orbitalName}</div><div style="font-size:.7rem;color:var(--txt2)">ORBITAL</div></div>
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center"><div style="font-size:1.2rem;font-weight:bold;color:#00d9ff">${energyEV.toFixed(2)} eV</div><div style="font-size:.7rem;color:var(--txt2)">ENERGY</div></div>
</div>
<div style="margin-bottom:10px;padding:10px;background:linear-gradient(135deg,rgba(255,100,150,.1),rgba(255,215,0,.1));border-radius:6px;border:1px solid rgba(255,100,150,.3)">
<strong style="color:#ff6496">Classical versus Quantum</strong>
<div style="display:grid;grid-template-columns:1fr 1fr;gap:4px;margin-top:6px;font-size:.8rem">
<span>Bohr radius (n²/Z)a₀:</span><span style="color:#ff6496;font-weight:bold">${rBohr.toFixed(3)} a₀</span>
<span>r expected:</span><span style="color:#ffd700;font-weight:bold">${rExpected.toFixed(3)} a₀</span>
<span>Energy E = -13.6×Z²/n²:</span><span style="color:#00d9ff">${energyEV.toFixed(3)} eV</span>
<span>Z scaling effect:</span><span style="color:#00ff88">Orbital ${Z}× smaller</span>
<span>Classical: fixed orbit</span><span style="color:#ff6496">at r = ${rBohr.toFixed(2)}a₀</span>
<span>Quantum: probability</span><span style="color:#00d9ff">spread around r</span>
</div>
</div>
<div style="margin-bottom:10px;padding-bottom:8px;border-bottom:1px solid var(--bord)">
<strong style="color:var(--acc)">Node Analysis (↔ Zeta Zeros)</strong>
<div style="display:grid;grid-template-columns:1fr 1fr;gap:4px;margin-top:6px;font-size:.8rem">
<span>Radial nodes:</span><span style="color:#ff6496;font-weight:bold">${radialNodes}</span>
<span>Angular nodes:</span><span style="color:#ffd700;font-weight:bold">${angularNodes}</span>
<span>Total nodes:</span><span style="color:#00d9ff;font-weight:bold">${radialNodes + angularNodes}</span>
<span>n - l - 1 formula:</span><span style="color:#00ff88">${n} - ${l} - 1 = ${radialNodes}</span>
</div>
</div>
<div style="margin-bottom:10px;padding-bottom:8px;border-bottom:1px solid var(--bord)">
<strong style="color:var(--acc)">Orbital Subshells (l values)</strong>
<div style="font-size:.8rem;color:var(--txt2);margin-top:6px;line-height:1.6">
• l=0: <span style="color:#00d9ff">s</span> (sharp) — spherical, 1 orbital<br>
• l=1: <span style="color:#00ff88">p</span> (principal) — dumbbell, 3 orbitals<br>
• l=2: <span style="color:#ffd700">d</span> (diffuse) — cloverleaf, 5 orbitals<br>
• l=3: <span style="color:#ff6496">f</span> (fundamental) — complex, 7 orbitals<br>
• l=4: <span style="color:#9664ff">g</span> — 9 orbitals, l=5: <span style="color:#ff8c00">h</span> — 11, l=6: <span style="color:#00ffcc">i</span> — 13
</div>
</div>
<div style="margin-bottom:10px;padding-bottom:8px;border-bottom:1px solid var(--bord)">
<strong style="color:var(--acc)">Number Theory Connection</strong>
<div style="font-size:.8rem;color:var(--txt2);margin-top:6px;line-height:1.5">
• Radial nodes (${radialNodes}) ↔ zeros of R_{nl}(r) like zeros of ζ(s)<br>
• Angular momentum l(l+1) = ${l*(l+1)} ℏ² (quantized like gcd constraint)<br>
• Spherical harmonics Y_l^m ↔ volume of k-dimensional balls<br>
• Energy degeneracy n² = ${n*n} (relates to lattice point counting)
</div>
</div>
<div style="background:rgba(0,217,255,.1);padding:8px;border-radius:6px">
<strong style="color:#00d9ff">Selection Rules</strong>
<div style="font-size:.75rem;color:var(--txt2);margin-top:4px">
Allowed transitions: Δl = ±1, Δm = 0, ±1. These discrete rules mirror the coprimality constraint gcd(a,b)=1 in number theory!
</div>
</div>
${mode !== 'all' ? `<button onclick="document.getElementById('quantumMode').value='all';drawQuantum()" style="margin-top:10px;width:100%;padding:8px;background:linear-gradient(135deg,#00d9ff,#9664ff);color:#fff;border:none;border-radius:6px;cursor:pointer;font-weight:bold">← View All n=${n} Orbitals for ${elementSymbol}</button>` : ''}`;

quantumData = {n, l, m, radialNodes, angularNodes, orbital: orbitalName};
}

function csvQuantum() {
let csv = 'r,R_nl,r2R2,theta_deg,Y_lm,Y2\n';
if(quantumData.radial) {
quantumData.radial.forEach(p => {
const ang = quantumData.angular ? quantumData.angular.find(a => Math.abs(a.theta) < 1) : null;
csv += `${p.r},${p.R},${p.r*p.r*p.R*p.R},${ang?ang.theta:''},${ang?ang.Y:''},${ang?ang.Ysq:''}\n`;
});
}
dl(csv, `quantum_${quantumData.orbital || 'orbital'}.csv`);
}

async function screenshotQuantum() {
await screenshotUnified('cquantum', 'quantumLiveStats', `Quantum Orbital ${quantumData.orbital || ''}`, 'quantum_orbital.png');
}

// ==================== PRIME K-TUPLES ====================
let ktuplesData = [];
const KTUPLE_PATTERNS = {
twin: [0, 2],
cousin: [0, 4],
sexy: [0, 6],
triplet: [0, 2, 6],
quadruplet: [0, 2, 6, 8],
quintuplet: [0, 2, 6, 8, 12],
sextuplet: [0, 4, 6, 10, 12, 16]
};

function drawKtuples() {
const maxN = +document.getElementById('ktupleNv').value || 10000;
const type = document.getElementById('ktupleType').value;
const pattern = KTUPLE_PATTERNS[type];
const c = document.getElementById('cktuples'), ctx = c.getContext('2d');
ctx.fillStyle = canvBg(); ctx.fillRect(0, 0, c.width, c.height);

// Find all primes
const sieve = new Array(maxN + 20).fill(true);
sieve[0] = sieve[1] = false;
for (let i = 2; i * i <= maxN + 20; i++) if (sieve[i]) for (let j = i * i; j <= maxN + 20; j += i) sieve[j] = false;

// Find k-tuples
ktuplesData = [];
for (let p = 2; p <= maxN; p++) {
if (!sieve[p]) continue;
let valid = true;
for (const offset of pattern) {
if (!sieve[p + offset]) { valid = false; break; }
}
if (valid) ktuplesData.push({ p, tuple: pattern.map(o => p + o) });
}

// Draw visualization
const pad = 50, w = c.width - 2 * pad, h = c.height - 2 * pad;
const scale = w / maxN;

// Draw tuples as vertical lines
ctx.strokeStyle = '#ffd700';
ctx.lineWidth = 1;
ktuplesData.forEach(t => {
const x = pad + t.p * scale;
ctx.beginPath();
ctx.moveTo(x, pad);
ctx.lineTo(x, c.height - pad);
ctx.stroke();
});

// Draw dots for tuple elements
ktuplesData.slice(0, 200).forEach(t => {
t.tuple.forEach((p, i) => {
const x = pad + p * scale;
const y = pad + 30 + i * 40;
ctx.fillStyle = `hsl(${i * 60}, 80%, 60%)`;
ctx.beginPath();
ctx.arc(x, y, 4, 0, 2 * PI);
ctx.fill();
});
});

// Title
ctx.fillStyle = isDark() ? '#ffd700' : '#cc8800';
ctx.font = 'bold 14px Segoe UI';
ctx.textAlign = 'center';
ctx.fillText(`Prime ${type} (k=${pattern.length}) up to N=${maxN}: Found ${ktuplesData.length}`, c.width / 2, 25);

// Stats
const density = ktuplesData.length / maxN * 1000;
document.getElementById('ktuplesLiveStats').innerHTML = `
<div style="background:linear-gradient(135deg,rgba(0,217,255,.15),rgba(255,215,0,.1));padding:10px;border-radius:8px;margin-bottom:12px;border:1px solid var(--acc)">
<div style="font-size:.7rem;color:var(--txt2);margin-bottom:4px">TAB: Prime k-Tuples | FIELD: ℤ (Primes) | TYPE: ${type} Pattern</div>
<div style="display:grid;grid-template-columns:repeat(3,1fr);gap:6px;font-size:.75rem">
<span>Max N: <strong style="color:#00d9ff">${maxN}</strong></span>
<span>k: <strong style="color:#ffd700">${pattern.length}</strong></span>
<span>Found: <strong style="color:#00ff88">${ktuplesData.length}</strong></span>
</div>
</div>
<div style="display:grid;grid-template-columns:repeat(3,1fr);gap:8px;margin-bottom:12px">
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center"><div style="font-size:1.3rem;font-weight:bold;color:#00d9ff">${ktuplesData.length}</div><div style="font-size:.7rem;color:var(--txt2)">TUPLES FOUND</div></div>
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center"><div style="font-size:1.3rem;font-weight:bold;color:#ffd700">${pattern.length}</div><div style="font-size:.7rem;color:var(--txt2)">TUPLE SIZE k</div></div>
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center"><div style="font-size:1.3rem;font-weight:bold;color:#00ff88">${fmt(density)}</div><div style="font-size:.7rem;color:var(--txt2)">PER 1000</div></div>
</div>
<div style="margin-bottom:10px">
<strong style="color:var(--acc)">Pattern: [${pattern.join(', ')}]</strong>
<div style="font-size:.8rem;color:var(--txt2);margin-top:5px">
First ${Math.min(5, ktuplesData.length)}: ${ktuplesData.slice(0, 5).map(t => `(${t.tuple.join(',')})`).join(', ')}
</div>
</div>`;

// Chart
const cumulative = [];
let count = 0;
for (let x = 0; x <= maxN; x += Math.max(1, Math.floor(maxN / 100))) {
count = ktuplesData.filter(t => t.p <= x).length;
cumulative.push({ x, count });
}
Plotly.newPlot('pktuples1', [{ x: cumulative.map(c => c.x), y: cumulative.map(c => c.count), mode: 'lines', line: { color: '#ffd700' } }], { ...plo(), xaxis: { title: 'N' }, yaxis: { title: 'Count' } });
}

function csvKtuples() { let s = 'p,tuple\n'; ktuplesData.forEach(t => s += `${t.p},"${t.tuple.join(',')}"\n`); dl(s, 'ktuples.csv'); }
async function screenshotKtuples() { await screenshotUnified('cktuples', 'ktuplesLiveStats', 'Prime k-Tuples', 'ktuples.png'); }
function exportAllKtuples() { screenshotTabAll({ canvases: ['cktuples'], charts: ['pktuples1'], dashId: 'ktuplesLiveStats', title: 'Prime k-Tuples', filename: 'ktuples_all.png' }); }

// ==================== CARMICHAEL NUMBERS ====================
let carmichaelData = [];

function isCarmichael(n) {
if (n < 3 || isPrime(n)) return false;
// Korselt's criterion: n is Carmichael iff n is squarefree and (p-1)|(n-1) for all primes p|n
let temp = n, factors = [];
for (let p = 2; p * p <= temp; p++) {
if (temp % p === 0) {
factors.push(p);
temp /= p;
if (temp % p === 0) return false; // Not squarefree
}
}
if (temp > 1) factors.push(temp);
if (factors.length < 3) return false; // Must have at least 3 prime factors
for (const p of factors) {
if ((n - 1) % (p - 1) !== 0) return false;
}
return true;
}

function drawCarmichael() {
const maxN = +document.getElementById('carmNv').value || 100000;
const c = document.getElementById('ccarm'), ctx = c.getContext('2d');
ctx.fillStyle = canvBg(); ctx.fillRect(0, 0, c.width, c.height);

carmichaelData = [];
for (let n = 3; n <= maxN; n += 2) {
if (isCarmichael(n)) carmichaelData.push(n);
}

// Draw
const pad = 50, w = c.width - 2 * pad, h = c.height - 2 * pad;
ctx.fillStyle = '#ff6496';
carmichaelData.forEach((n, i) => {
const x = pad + (n / maxN) * w;
const y = pad + (i / Math.max(1, carmichaelData.length - 1)) * h;
ctx.beginPath();
ctx.arc(x, y, 5, 0, 2 * PI);
ctx.fill();
});

ctx.fillStyle = isDark() ? '#ff6496' : '#cc0044';
ctx.font = 'bold 14px Segoe UI';
ctx.textAlign = 'center';
ctx.fillText(`Carmichael Numbers ≤ ${maxN}: Found ${carmichaelData.length}`, c.width / 2, 25);

// Known Carmichaels
const known = [561, 1105, 1729, 2465, 2821, 6601, 8911, 10585, 15841, 29341];

document.getElementById('carmLiveStats').innerHTML = `
<div style="background:linear-gradient(135deg,rgba(255,100,150,.15),rgba(255,215,0,.1));padding:10px;border-radius:8px;margin-bottom:12px;border:1px solid #ff6496">
<div style="font-size:.7rem;color:var(--txt2);margin-bottom:4px">TAB: Carmichael Numbers | FIELD: ℤ (Pseudoprimes) | TYPE: Fermat Liars</div>
</div>
<div style="display:grid;grid-template-columns:repeat(3,1fr);gap:8px;margin-bottom:12px">
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center"><div style="font-size:1.3rem;font-weight:bold;color:#ff6496">${carmichaelData.length}</div><div style="font-size:.7rem;color:var(--txt2)">FOUND</div></div>
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center"><div style="font-size:1.3rem;font-weight:bold;color:#ffd700">561</div><div style="font-size:.7rem;color:var(--txt2)">SMALLEST</div></div>
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center"><div style="font-size:1.3rem;font-weight:bold;color:#00d9ff">${carmichaelData[carmichaelData.length - 1] || '—'}</div><div style="font-size:.7rem;color:var(--txt2)">LARGEST</div></div>
</div>
<div style="font-size:.8rem;color:var(--txt2)">
<strong style="color:var(--acc)">Definition:</strong> n is Carmichael if composite and a^(n-1) ≡ 1 (mod n) for all gcd(a,n)=1<br>
<strong style="color:var(--acc)">First 10:</strong> ${known.join(', ')}<br>
<strong style="color:var(--acc)">1729</strong> = Hardy-Ramanujan number (also taxicab!)
</div>`;

Plotly.newPlot('pcarm1', [{ x: carmichaelData.map((_, i) => i + 1), y: carmichaelData, mode: 'lines+markers', marker: { size: 4, color: '#ff6496' } }], { ...plo(), xaxis: { title: 'Index' }, yaxis: { title: 'Carmichael Number', type: 'log' } });
}

function csvCarmichael() { dl('n\n' + carmichaelData.join('\n'), 'carmichael.csv'); }
async function screenshotCarmichael() { await screenshotUnified('ccarm', 'carmLiveStats', 'Carmichael Numbers', 'carmichael.png'); }
function exportAllCarmichael() { screenshotTabAll({ canvases: ['ccarm'], charts: ['pcarm1'], dashId: 'carmLiveStats', title: 'Carmichael Numbers', filename: 'carmichael_all.png' }); }

// ==================== MERSENNE NUMBERS ====================
let mersenneData = [];
const KNOWN_MERSENNE_PRIMES = [2, 3, 5, 7, 13, 17, 19, 31, 61, 89, 107, 127, 521, 607, 1279];

function drawMersenne() {
const maxP = +document.getElementById('mersPv').value || 100;
const mode = document.getElementById('mersMode').value;
const c = document.getElementById('cmers'), ctx = c.getContext('2d');
ctx.fillStyle = canvBg(); ctx.fillRect(0, 0, c.width, c.height);

mersenneData = [];
for (let p = 2; p <= maxP; p++) {
if (!isPrime(p)) continue;
const m = Math.pow(2, p) - 1;
const isMersennePrime = KNOWN_MERSENNE_PRIMES.includes(p);
mersenneData.push({ p, m, isPrime: isMersennePrime });
}

// Draw
const pad = 50, w = c.width - 2 * pad, h = c.height - 2 * pad;
const maxIdx = mersenneData.length;

mersenneData.forEach((d, i) => {
const x = pad + (i / maxIdx) * w;
const y = c.height - pad - Math.min(h, Math.log10(d.m + 1) / Math.log10(mersenneData[maxIdx - 1]?.m || 10) * h);
ctx.fillStyle = d.isPrime ? '#00ff88' : '#ff6496';
ctx.beginPath();
ctx.arc(x, y, d.isPrime ? 8 : 4, 0, 2 * PI);
ctx.fill();
if (d.isPrime && d.p <= 31) {
ctx.fillStyle = isDark() ? '#fff' : '#000';
ctx.font = '10px Segoe UI';
ctx.textAlign = 'center';
ctx.fillText(`M${d.p}`, x, y - 12);
}
});

ctx.fillStyle = isDark() ? '#00ff88' : '#008844';
ctx.font = 'bold 14px Segoe UI';
ctx.textAlign = 'center';
ctx.fillText(`Mersenne Numbers 2^p - 1 for prime p ≤ ${maxP}`, c.width / 2, 25);

const mpCount = mersenneData.filter(d => d.isPrime).length;

document.getElementById('mersLiveStats').innerHTML = `
<div style="background:linear-gradient(135deg,rgba(0,255,136,.15),rgba(255,215,0,.1));padding:10px;border-radius:8px;margin-bottom:12px;border:1px solid #00ff88">
<div style="font-size:.7rem;color:var(--txt2);margin-bottom:4px">TAB: Mersenne Numbers | FIELD: 2^p - 1 | TYPE: Prime Search</div>
</div>
<div style="display:grid;grid-template-columns:repeat(3,1fr);gap:8px;margin-bottom:12px">
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center"><div style="font-size:1.3rem;font-weight:bold;color:#00d9ff">${mersenneData.length}</div><div style="font-size:.7rem;color:var(--txt2)">TESTED</div></div>
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center"><div style="font-size:1.3rem;font-weight:bold;color:#00ff88">${mpCount}</div><div style="font-size:.7rem;color:var(--txt2)">PRIMES</div></div>
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center"><div style="font-size:1.3rem;font-weight:bold;color:#ffd700">${fmt(100 * mpCount / mersenneData.length)}%</div><div style="font-size:.7rem;color:var(--txt2)">PRIME RATE</div></div>
</div>
<div style="font-size:.8rem;color:var(--txt2)">
<strong style="color:var(--acc)">Mersenne Primes in range:</strong> ${mersenneData.filter(d => d.isPrime).map(d => `M${d.p}`).join(', ') || 'None'}<br>
<strong style="color:var(--acc)">Largest known:</strong> M82589933 (24,862,048 digits, Dec 2018)<br>
<strong style="color:var(--acc)">GIMPS Project:</strong> Great Internet Mersenne Prime Search
</div>`;

Plotly.newPlot('pmers1', [{ x: mersenneData.map(d => d.p), y: mersenneData.map(d => Math.log10(d.m)), mode: 'lines+markers', marker: { color: mersenneData.map(d => d.isPrime ? '#00ff88' : '#666'), size: mersenneData.map(d => d.isPrime ? 10 : 4) } }], { ...plo(), xaxis: { title: 'Exponent p' }, yaxis: { title: 'log₁₀(2^p - 1)' } });
}

function csvMersenne() { let s = 'p,mersenne,is_prime\n'; mersenneData.forEach(d => s += `${d.p},${d.m},${d.isPrime}\n`); dl(s, 'mersenne.csv'); }
async function screenshotMersenne() { await screenshotUnified('cmers', 'mersLiveStats', 'Mersenne Numbers', 'mersenne.png'); }
function exportAllMersenne() { screenshotTabAll({ canvases: ['cmers'], charts: ['pmers1'], dashId: 'mersLiveStats', title: 'Mersenne Numbers', filename: 'mersenne_all.png' }); }

// ==================== CONTINUED FRACTIONS ====================
let cfData = { coeffs: [], convergents: [] };

function continuedFraction(x, terms) {
const coeffs = [];
let a = Math.floor(x);
coeffs.push(a);
let rem = x - a;
for (let i = 1; i < terms && rem > 1e-10; i++) {
x = 1 / rem;
a = Math.floor(x);
coeffs.push(a);
rem = x - a;
}
return coeffs;
}

function convergents(coeffs) {
const conv = [];
let h0 = 1, h1 = coeffs[0], k0 = 0, k1 = 1;
conv.push({ p: h1, q: k1, val: h1 / k1 });
for (let i = 1; i < coeffs.length; i++) {
const h2 = coeffs[i] * h1 + h0;
const k2 = coeffs[i] * k1 + k0;
conv.push({ p: h2, q: k2, val: h2 / k2 });
h0 = h1; h1 = h2; k0 = k1; k1 = k2;
}
return conv;
}

function drawContinued() {
const numType = document.getElementById('cfNum').value;
const terms = +document.getElementById('cfTerms').value;
const c = document.getElementById('ccf'), ctx = c.getContext('2d');
ctx.fillStyle = canvBg(); ctx.fillRect(0, 0, c.width, c.height);

let x, name;
switch (numType) {
case 'pi': x = PI; name = 'π'; break;
case 'e': x = Math.E; name = 'e'; break;
case 'phi': x = (1 + Math.sqrt(5)) / 2; name = 'φ'; break;
case 'sqrt2': x = Math.sqrt(2); name = '√2'; break;
case 'sqrt3': x = Math.sqrt(3); name = '√3'; break;
default: x = +document.getElementById('cfCustom').value; name = x.toString();
}

cfData.coeffs = continuedFraction(x, terms);
cfData.convergents = convergents(cfData.coeffs);
cfData.target = x;

// Compute Khinchin's constant approximation
const KHINCHIN = 2.6854520010653064; // Khinchin's constant K₀
const cfNonZero = cfData.coeffs.slice(1).filter(a => a > 0);
const geometricMean = cfNonZero.length > 0 ? Math.pow(cfNonZero.reduce((p, a) => p * a, 1), 1 / cfNonZero.length) : 0;
const khinchinRatio = geometricMean / KHINCHIN;

// Lévy's constant for convergent denominators
const LEVY = 3.2758229187218115; // e^(π²/(12ln2))
const qRatios = cfData.convergents.slice(1).map((c, i) => Math.pow(c.q, 1/(i+1)));
const levyApprox = qRatios.length > 5 ? qRatios[qRatios.length - 1] : 0;

// Draw coefficients
const pad = 50, w = c.width - 2 * pad;
ctx.fillStyle = isDark() ? '#00d9ff' : '#0066cc';
ctx.font = '14px Segoe UI';
ctx.textAlign = 'center';

// Display CF notation
let cfStr = `[${cfData.coeffs[0]}; ${cfData.coeffs.slice(1, 10).join(', ')}${cfData.coeffs.length > 10 ? ', ...' : ''}]`;
ctx.fillText(`${name} = ${cfStr}`, c.width / 2, 30);

// Draw convergent visualization
cfData.convergents.slice(0, 15).forEach((conv, i) => {
const y = 60 + i * 28;
ctx.fillStyle = isDark() ? '#ffd700' : '#cc8800';
ctx.textAlign = 'left';
ctx.fillText(`p${i}/q${i} = ${conv.p}/${conv.q} = ${conv.val.toFixed(10)}`, pad, y);
const err = Math.abs(conv.val - x);
ctx.fillStyle = err < 1e-8 ? '#00ff88' : err < 1e-4 ? '#ffd700' : '#ff6496';
ctx.textAlign = 'right';
ctx.fillText(`error: ${err.toExponential(2)}`, c.width - pad, y);
});

document.getElementById('cfLiveStats').innerHTML = `
<div style="background:linear-gradient(135deg,rgba(0,217,255,.15),rgba(255,215,0,.1));padding:10px;border-radius:8px;margin-bottom:12px;border:1px solid var(--acc)">
<div style="font-size:.7rem;color:var(--txt2);margin-bottom:4px">TAB: Continued Fractions | FIELD: ℝ → ℚ Approx | TYPE: Best Rational Approximations</div>
</div>
<div style="display:grid;grid-template-columns:repeat(3,1fr);gap:8px;margin-bottom:12px">
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center"><div style="font-size:1.2rem;font-weight:bold;color:#00d9ff">${name}</div><div style="font-size:.7rem;color:var(--txt2)">NUMBER</div></div>
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center"><div style="font-size:1.2rem;font-weight:bold;color:#ffd700">${cfData.coeffs.length}</div><div style="font-size:.7rem;color:var(--txt2)">TERMS</div></div>
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center"><div style="font-size:1.2rem;font-weight:bold;color:#00ff88">${Math.max(...cfData.coeffs.slice(0, 20))}</div><div style="font-size:.7rem;color:var(--txt2)">MAX COEFF</div></div>
</div>
<div style="margin-bottom:10px;padding:10px;background:linear-gradient(135deg,rgba(150,100,255,.1),rgba(0,217,255,.05));border-radius:6px;border:1px solid rgba(150,100,255,.3)">
<strong style="color:#9664ff">Khinchin's Constant Analysis</strong>
<div style="display:grid;grid-template-columns:1fr 1fr;gap:4px;margin-top:6px;font-size:.8rem">
<span>Geometric mean of coeffs:</span><span style="color:#ffd700;font-weight:bold">${geometricMean.toFixed(4)}</span>
<span>Khinchin K₀ = 2.6854...:</span><span style="color:#9664ff">${KHINCHIN.toFixed(4)}</span>
<span>Ratio (→1 for generic):</span><span style="color:${Math.abs(khinchinRatio - 1) < 0.3 ? '#00ff88' : '#ff6496'}">${khinchinRatio.toFixed(4)}</span>
<span>Lévy approx (q_n^{1/n}):</span><span style="color:#00d9ff">${levyApprox.toFixed(4)} (→3.276)</span>
</div>
<div style="font-size:.7rem;color:var(--txt2);margin-top:6px">Note: φ and quadratic irrationals have bounded coefficients, so Khinchin doesn't apply.</div>
</div>
<div style="font-size:.8rem;color:var(--txt2)">
<strong style="color:var(--acc)">Best approximation:</strong> ${cfData.convergents[cfData.convergents.length - 1]?.p}/${cfData.convergents[cfData.convergents.length - 1]?.q}<br>
<strong style="color:var(--acc)">φ special:</strong> All coefficients = 1 (slowest convergence)<br>
<strong style="color:var(--acc)">π famous:</strong> 355/113 (6 correct decimals)
</div>`;

const errors = cfData.convergents.map((c, i) => ({ i, err: Math.abs(c.val - x) }));
Plotly.newPlot('pcf1', [{ x: errors.map(e => e.i), y: errors.map(e => e.err), mode: 'lines+markers', line: { color: '#ffd700' } }], { ...plo(), xaxis: { title: 'Convergent Index' }, yaxis: { title: 'Error', type: 'log' } });
}

function csvContinued() { let s = 'index,p,q,value,error\n'; cfData.convergents.forEach((c, i) => s += `${i},${c.p},${c.q},${c.val},${Math.abs(c.val - cfData.target)}\n`); dl(s, 'continued_fractions.csv'); }
async function screenshotContinued() { await screenshotUnified('ccf', 'cfLiveStats', 'Continued Fractions', 'continued_fractions.png'); }
function exportAllContinued() { screenshotTabAll({ canvases: ['ccf'], charts: ['pcf1'], dashId: 'cfLiveStats', title: 'Continued Fractions', filename: 'cf_all.png' }); }

// ==================== STERN-BROCOT TREE ====================
let sbData = [];

function drawSternBrocot() {
const c = document.getElementById('csb');
if(!c) return; // Guard for standalone mode
const depth = +document.getElementById('sbDepth').value || 6;
const layout = document.getElementById('sbLayout')?.value || 'tree';
const colorBy = document.getElementById('sbColor')?.value || 'depth';
const highlight = document.getElementById('sbHighlight')?.value || 'none';
const targetP = +document.getElementById('sbP')?.value || 3;
const targetQ = +document.getElementById('sbQ')?.value || 5;
const nodeSize = +document.getElementById('sbNodeSize')?.value || 12;
const showEdges = document.getElementById('sbEdges')?.checked !== false;
const showLabels = document.getElementById('sbLabels')?.checked !== false;
const showCF = document.getElementById('sbContinued')?.checked;

const ctx = c.getContext('2d');
ctx.fillStyle = canvBg(); ctx.fillRect(0, 0, c.width, c.height);

// Build complete Stern-Brocot tree with parent references
sbData = [];
const nodes = [];
const root = { p: 1, q: 1, left: { p: 0, q: 1 }, right: { p: 1, q: 0 }, depth: 0, parent: null, path: '', x: 0, y: 0 };
nodes.push(root);

function buildTree(node, maxD) {
  if (node.depth >= maxD) return;
  
  // Left child: mediant of left ancestor and current
  const leftChild = {
    p: node.left.p + node.p,
    q: node.left.q + node.q,
    left: node.left,
    right: { p: node.p, q: node.q },
    depth: node.depth + 1,
    parent: node,
    path: node.path + 'L'
  };
  
  // Right child: mediant of current and right ancestor
  const rightChild = {
    p: node.p + node.right.p,
    q: node.q + node.right.q,
    left: { p: node.p, q: node.q },
    right: node.right,
    depth: node.depth + 1,
    parent: node,
    path: node.path + 'R'
  };
  
  node.leftChild = leftChild;
  node.rightChild = rightChild;
  nodes.push(leftChild, rightChild);
  
  buildTree(leftChild, maxD);
  buildTree(rightChild, maxD);
}

buildTree(root, depth);

// Find path to target fraction
function findPath(p, q) {
  let path = '';
  let low = { p: 0, q: 1 }, high = { p: 1, q: 0 }, med = { p: 1, q: 1 };
  
  for (let i = 0; i < 100; i++) {
    if (med.p === p && med.q === q) break;
    if (p * med.q < q * med.p) {
      // Go left
      high = med;
      path += 'L';
    } else {
      // Go right  
      low = med;
      path += 'R';
    }
    med = { p: low.p + high.p, q: low.q + high.q };
  }
  return { path, found: med.p === p && med.q === q };
}

const targetPath = findPath(targetP, targetQ);
document.getElementById('sbPathDisplay').textContent = highlight === 'path' ? `Path to ${targetP}/${targetQ}: ${targetPath.path || 'ROOT'}` : '';

// Calculate positions based on layout
const pad = 50, w = c.width - 2 * pad, h = c.height - 2 * pad;
const cx = c.width / 2, cy = c.height / 2;

nodes.forEach((node, i) => {
  if (layout === 'tree' || layout === 'binary') {
    // Standard tree layout
    const levelCount = Math.pow(2, node.depth);
    const levelOffset = node.path.split('').reduce((acc, dir, idx) => {
      return acc + (dir === 'R' ? Math.pow(2, node.depth - idx - 1) : 0);
    }, 0);
    node.x = pad + w * (levelOffset + 0.5) / levelCount;
    node.y = pad + 40 + node.depth * (h - 60) / depth;
  } else if (layout === 'circular') {
    // Circular layout - angle based on fraction value
    const angle = node.q > 0 ? Math.atan(node.p / node.q) : Math.PI / 2;
    const r = pad + (1 - node.depth / depth) * Math.min(w, h) / 2.2;
    node.x = cx + r * Math.cos(angle - Math.PI / 4);
    node.y = cy - r * Math.sin(angle - Math.PI / 4);
  } else if (layout === 'hyperbolic') {
    // Hyperbolic-style layout
    const angle = node.q > 0 ? Math.PI * node.p / (node.p + node.q) : Math.PI / 2;
    const r = Math.min(w, h) / 2.5 * (1 - Math.pow(0.7, node.depth + 1));
    node.x = cx + r * Math.cos(angle - Math.PI / 2);
    node.y = cy + r * Math.sin(angle - Math.PI / 2);
  }
});

// Determine which nodes to highlight
const highlightSet = new Set();
if (highlight === 'path' && targetPath.found) {
  let current = '';
  highlightSet.add('');
  for (const dir of targetPath.path) {
    current += dir;
    highlightSet.add(current);
  }
} else if (highlight === 'fibonacci') {
  // Fibonacci fractions: 1/1, 1/2, 2/3, 3/5, 5/8, ...
  let a = 1, b = 1;
  for (let i = 0; i < 15; i++) {
    nodes.forEach(n => { if (n.p === a && n.q === b) highlightSet.add(n.path); });
    [a, b] = [b, a + b];
  }
} else if (highlight === 'unit') {
  // Unit fractions 1/n
  nodes.forEach(n => { if (n.p === 1) highlightSet.add(n.path); });
} else if (highlight === 'farey') {
  // Farey sequence of order = depth
  for (let q = 1; q <= depth; q++) {
    for (let p = 0; p <= q; p++) {
      if (gcd(p, q) === 1) {
        nodes.forEach(n => { if (n.p === p && n.q === q) highlightSet.add(n.path); });
      }
    }
  }
}

// Get color for node
function getNodeColor(node) {
  const isHighlighted = highlightSet.has(node.path);
  if (highlight !== 'none' && isHighlighted) return '#00ff88';
  
  if (colorBy === 'depth') {
    return `hsl(${node.depth * 360 / depth}, 80%, 55%)`;
  } else if (colorBy === 'value') {
    const val = node.q > 0 ? node.p / node.q : 1;
    return `hsl(${val * 240}, 80%, 50%)`;
  } else if (colorBy === 'denominator') {
    return `hsl(${(node.q % 12) * 30}, 80%, 50%)`;
  } else if (colorBy === 'farey') {
    return node.q <= depth ? '#ffd700' : '#666';
  } else if (colorBy === 'fibonacci') {
    // Check if Fibonacci
    const fibs = [1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144];
    const isFib = fibs.includes(node.p) && fibs.includes(node.q);
    return isFib ? '#ff6496' : `hsl(${node.depth * 40}, 60%, 45%)`;
  }
  return '#00d9ff';
}

// Draw edges first
if (showEdges) {
  ctx.lineWidth = 1;
  nodes.forEach(node => {
    if (node.leftChild) {
      const isHL = highlightSet.has(node.path) && highlightSet.has(node.leftChild.path);
      ctx.strokeStyle = isHL ? '#00ff88' : gridC();
      ctx.lineWidth = isHL ? 2 : 1;
      ctx.beginPath();
      ctx.moveTo(node.x, node.y);
      ctx.lineTo(node.leftChild.x, node.leftChild.y);
      ctx.stroke();
    }
    if (node.rightChild) {
      const isHL = highlightSet.has(node.path) && highlightSet.has(node.rightChild.path);
      ctx.strokeStyle = isHL ? '#00ff88' : gridC();
      ctx.lineWidth = isHL ? 2 : 1;
      ctx.beginPath();
      ctx.moveTo(node.x, node.y);
      ctx.lineTo(node.rightChild.x, node.rightChild.y);
      ctx.stroke();
    }
  });
}

// Draw nodes
nodes.forEach(node => {
  const isHL = highlightSet.has(node.path);
  const size = isHL ? nodeSize * 1.3 : nodeSize;
  
  ctx.fillStyle = getNodeColor(node);
  ctx.beginPath();
  ctx.arc(node.x, node.y, size, 0, 2 * Math.PI);
  ctx.fill();
  
  if (isHL) {
    ctx.strokeStyle = '#fff';
    ctx.lineWidth = 2;
    ctx.stroke();
  }
  
  // Labels
  if (showLabels && node.q > 0 && node.q < 30 && size >= 8) {
    ctx.fillStyle = isDark() ? '#fff' : '#000';
    const fontSize = Math.max(7, Math.min(11, size * 0.8));
    ctx.font = `${fontSize}px Segoe UI`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    if (showCF && node.path.length > 0) {
      // Show continued fraction representation
      ctx.fillText(node.path.length <= 4 ? node.path : '...', node.x, node.y);
    } else {
      ctx.fillText(`${node.p}/${node.q}`, node.x, node.y);
    }
  }
  
  sbData.push({ p: node.p, q: node.q, depth: node.depth, path: node.path, x: node.x, y: node.y });
});

// Title
ctx.fillStyle = isDark() ? '#ffd700' : '#cc8800';
ctx.font = 'bold 14px Segoe UI';
ctx.textAlign = 'center';
ctx.fillText(`Stern-Brocot Tree — Depth ${depth} — ${layout.charAt(0).toUpperCase() + layout.slice(1)} Layout`, c.width / 2, 25);

// Calculate statistics
const fracCount = nodes.filter(n => n.q > 0 && n.q < 1000).length;
const fareyCount = nodes.filter(n => n.q > 0 && n.q <= depth && gcd(n.p, n.q) === 1).length;

// Convert path to continued fraction
function pathToCF(path) {
  if (!path) return [1];
  const cf = [];
  let count = 0, lastDir = path[0];
  for (const dir of path) {
    if (dir === lastDir) count++;
    else { cf.push(count); count = 1; lastDir = dir; }
  }
  cf.push(count);
  if (path[0] === 'R') cf.unshift(0);
  return cf;
}

const targetCF = pathToCF(targetPath.path);

// Live Stats
document.getElementById('sbLiveStats').innerHTML = `
<div style="background:linear-gradient(135deg,rgba(0,217,255,.15),rgba(255,215,0,.1));padding:10px;border-radius:8px;margin-bottom:12px;border:1px solid var(--acc)">
<div style="font-size:.7rem;color:var(--txt2);margin-bottom:4px">TAB: Stern-Brocot Tree | FIELD: ℚ⁺ | TYPE: Binary Tree of Rationals</div>
</div>
<div style="display:grid;grid-template-columns:repeat(3,1fr);gap:8px;margin-bottom:12px">
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center"><div style="font-size:1.3rem;font-weight:bold;color:#00d9ff">${depth}</div><div style="font-size:.7rem;color:var(--txt2)">DEPTH</div></div>
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center"><div style="font-size:1.3rem;font-weight:bold;color:#ffd700">${fracCount}</div><div style="font-size:.7rem;color:var(--txt2)">NODES</div></div>
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center"><div style="font-size:1.3rem;font-weight:bold;color:#00ff88">${Math.pow(2, depth)}</div><div style="font-size:.7rem;color:var(--txt2)">LEAVES</div></div>
</div>
<div style="display:grid;grid-template-columns:1fr 1fr;gap:4px;font-size:.8rem;margin-bottom:12px">
<span>Layout:</span><span style="color:#ffd700">${layout}</span>
<span>Color:</span><span style="color:#00d9ff">${colorBy}</span>
<span>Highlight:</span><span style="color:#9664ff">${highlight}</span>
<span>Farey F<sub>${depth}</sub> count:</span><span style="color:#00ff88">${fareyCount}</span>
</div>
<div style="font-size:.8rem;color:var(--txt2);padding-top:8px;border-top:1px solid var(--bord)">
<strong style="color:var(--acc)">Properties:</strong><br>
• Every positive rational appears exactly once<br>
• Mediant: a/b ⊕ c/d = (a+c)/(b+d)<br>
• Path encodes continued fraction<br>
• Left = smaller, Right = larger
</div>`;

// Path Info
document.getElementById('sbPathInfo').innerHTML = `
<div style="margin-bottom:8px"><strong style="color:#ffd700">Target: ${targetP}/${targetQ}</strong></div>
<div style="display:grid;grid-template-columns:1fr 1fr;gap:4px;font-size:.8rem">
<span>Found:</span><span style="color:${targetPath.found ? '#00ff88' : '#ff6496'}">${targetPath.found ? 'Yes' : 'No (need more depth)'}</span>
<span>Path:</span><span style="color:#00d9ff;font-family:monospace">${targetPath.path || 'ROOT'}</span>
<span>Length:</span><span style="color:#9664ff">${targetPath.path.length}</span>
<span>Decimal:</span><span style="color:#ffd700">${(targetP/targetQ).toFixed(6)}</span>
</div>
<div style="margin-top:8px;padding-top:8px;border-top:1px solid var(--bord)">
<strong style="color:var(--acc)">Continued Fraction:</strong><br>
<span style="font-family:monospace;color:#00ff88">[${targetCF.join('; ')}]</span>
</div>`;

// Continued Fraction Analysis
const cfExpanded = targetCF.map((a, i) => i === 0 ? a : `1/(${a}+...)`).join(' + ');
document.getElementById('sbCFAnalysis').innerHTML = `
<div style="margin-bottom:8px"><strong style="color:#9664ff">${targetP}/${targetQ} = [${targetCF.join('; ')}]</strong></div>
<div style="font-size:.75rem;color:var(--txt2);margin-bottom:8px">
Path interpretation: L = "less than mediant", R = "greater than mediant"<br>
Each run of L's or R's becomes a CF coefficient.
</div>
<div style="background:var(--bg1);padding:8px;border-radius:4px;font-family:monospace;font-size:.7rem">
${targetPath.path.split('').map((d, i) => `<span style="color:${d === 'L' ? '#00d9ff' : '#ff6496'}">${d}</span>`).join('')}
</div>`;

// Farey Connection
const fareySeq = [];
for (let q = 1; q <= Math.min(depth, 8); q++) {
  for (let p = 0; p <= q; p++) {
    if (gcd(p, q) === 1) fareySeq.push({ p, q });
  }
}
fareySeq.sort((a, b) => a.p / a.q - b.p / b.q);

document.getElementById('sbFareyConnection').innerHTML = `
<div style="margin-bottom:6px"><strong style="color:#00ff88">Farey Sequence F<sub>${Math.min(depth, 8)}</sub></strong></div>
<div style="line-height:1.8">
${fareySeq.map(f => `<span style="display:inline-block;padding:2px 5px;margin:2px;border-radius:3px;background:${f.p === targetP && f.q === targetQ ? 'rgba(0,255,136,.3)' : 'var(--bg1)'};color:${f.q <= 3 ? '#ffd700' : '#00d9ff'}">${f.p}/${f.q}</span>`).join('')}
</div>
<div style="margin-top:8px;font-size:.7rem;color:var(--txt2)">
Farey neighbors satisfy |p₁q₂ - p₂q₁| = 1 (determinant condition)
</div>`;

// Click handler
c.onclick = e => {
  const rect = c.getBoundingClientRect();
  const mx = (e.clientX - rect.left) * (c.width / rect.width);
  const my = (e.clientY - rect.top) * (c.height / rect.height);
  
  for (const node of sbData) {
    if (Math.hypot(mx - node.x, my - node.y) < nodeSize + 5) {
      const cf = pathToCF(node.path);
      modal(`Stern-Brocot Node: ${node.p}/${node.q}`, [
        ['Fraction', `${node.p}/${node.q}`],
        ['Decimal', (node.p / node.q).toFixed(8)],
        ['Depth', node.depth],
        ['Path', node.path || 'ROOT'],
        ['Continued Fraction', `[${cf.join('; ')}]`],
        ['GCD', gcd(node.p, node.q)],
        ['Sum p+q', node.p + node.q]
      ]);
      break;
    }
  }
};
}

// Animation for tree growth
let sbAnimId = null;
function animateSBGrowth() {
  if (sbAnimId) { clearInterval(sbAnimId); sbAnimId = null; document.getElementById('sbAnimBtn').textContent = 'Animate'; return; }
  document.getElementById('sbAnimBtn').textContent = 'Stop';
  let d = 2;
  sbAnimId = setInterval(() => {
    document.getElementById('sbDepth').value = d;
    document.getElementById('sbDepthV').textContent = d;
    drawSternBrocot();
    d++;
    if (d > 10) { d = 2; }
  }, 800);
}

// Find path and highlight
// Set Stern-Brocot fraction preset
function setSBFraction(p, q) {
  document.getElementById('sbP').value = p;
  document.getElementById('sbQ').value = q;
  findSBPath();
}

// Find path to fraction with step-by-step algorithm display
function findSBPath() {
  const p = +document.getElementById('sbP').value;
  const q = +document.getElementById('sbQ').value;
  
  // Reduce fraction to lowest terms
  const g = gcd(p, q);
  const pRed = p / g;
  const qRed = q / g;
  
  // Stern-Brocot algorithm with steps
  let left = {p: 0, q: 1};  // 0/1
  let right = {p: 1, q: 0}; // 1/0 (infinity)
  let mediant = {p: 1, q: 1}; // 1/1
  let path = '';
  let steps = [];
  let stepNum = 0;
  
  steps.push({
    step: 0,
    action: 'Initialize',
    left: `${left.p}/${left.q}`,
    mediant: `${mediant.p}/${mediant.q}`,
    right: `${right.p}/${right.q}`,
    compare: `Target: ${pRed}/${qRed} = ${(pRed/qRed).toFixed(6)}`,
    path: 'ROOT',
    color: '#ffd700'
  });
  
  const maxSteps = 100;
  while (stepNum < maxSteps) {
    stepNum++;
    
    // Compare target with mediant
    const targetVal = pRed / qRed;
    const mediantVal = mediant.p / mediant.q;
    
    if (pRed === mediant.p && qRed === mediant.q) {
      steps.push({
        step: stepNum,
        action: 'FOUND!',
        left: `${left.p}/${left.q}`,
        mediant: `${mediant.p}/${mediant.q}`,
        right: `${right.p}/${right.q}`,
        compare: `${pRed}/${qRed} = ${mediant.p}/${mediant.q}`,
        path: path || 'ROOT',
        color: '#00ff88'
      });
      break;
    } else if (targetVal < mediantVal) {
      // Go left
      path += 'L';
      right = {p: mediant.p, q: mediant.q};
      mediant = {p: left.p + mediant.p, q: left.q + mediant.q};
      steps.push({
        step: stepNum,
        action: 'Go LEFT (target < mediant)',
        left: `${left.p}/${left.q}`,
        mediant: `${mediant.p}/${mediant.q}`,
        right: `${right.p}/${right.q}`,
        compare: `${targetVal.toFixed(6)} < ${mediantVal.toFixed(6)}`,
        path: path,
        color: '#00d9ff'
      });
    } else {
      // Go right
      path += 'R';
      left = {p: mediant.p, q: mediant.q};
      mediant = {p: mediant.p + right.p, q: mediant.q + right.q};
      steps.push({
        step: stepNum,
        action: 'Go RIGHT (target > mediant)',
        left: `${left.p}/${left.q}`,
        mediant: `${mediant.p}/${mediant.q}`,
        right: `${right.p}/${right.q}`,
        compare: `${targetVal.toFixed(6)} > ${mediantVal.toFixed(6)}`,
        path: path,
        color: '#ff6496'
      });
    }
  }
  
  // Calculate continued fraction from path
  const cf = pathToContinuedFraction(path);
  
  // Convergents
  const convergents = computeConvergents(cf);
  
  // Display algorithm steps
  let html = `<div style="margin-bottom:1rem;padding:.75rem;background:linear-gradient(135deg,rgba(0,255,136,.15),rgba(255,215,0,.1));border-radius:6px;border:1px solid #00ff88">
    <strong style="color:#00ff88">Finding: ${pRed}/${qRed}</strong>
    ${g > 1 ? `<span style="color:var(--txt2);font-size:.8rem"> (reduced from ${p}/${q})</span>` : ''}
    <span style="color:#ffd700;margin-left:1rem">Path: ${path || 'ROOT'}</span>
    <span style="color:#9664ff;margin-left:1rem">CF: [${cf.join('; ')}]</span>
  </div>`;
  
  html += `<table style="width:100%;border-collapse:collapse;font-size:.8rem">
    <tr style="background:var(--bg1);color:#ffd700">
      <th style="padding:6px;text-align:center;border:1px solid var(--bord)">#</th>
      <th style="padding:6px;text-align:left;border:1px solid var(--bord)">Action</th>
      <th style="padding:6px;text-align:center;border:1px solid var(--bord)">Left</th>
      <th style="padding:6px;text-align:center;border:1px solid var(--bord)">Mediant</th>
      <th style="padding:6px;text-align:center;border:1px solid var(--bord)">Right</th>
      <th style="padding:6px;text-align:center;border:1px solid var(--bord)">Path</th>
    </tr>`;
  
  steps.forEach(s => {
    html += `<tr style="background:${s.action === 'FOUND!' ? 'rgba(0,255,136,.2)' : 'transparent'}">
      <td style="padding:4px;text-align:center;border:1px solid var(--bord);color:${s.color}">${s.step}</td>
      <td style="padding:4px;border:1px solid var(--bord);color:${s.color}">${s.action}</td>
      <td style="padding:4px;text-align:center;border:1px solid var(--bord)">${s.left}</td>
      <td style="padding:4px;text-align:center;border:1px solid var(--bord);font-weight:bold;color:#ffd700">${s.mediant}</td>
      <td style="padding:4px;text-align:center;border:1px solid var(--bord)">${s.right}</td>
      <td style="padding:4px;text-align:center;border:1px solid var(--bord);font-family:monospace;color:#00d9ff">${s.path}</td>
    </tr>`;
  });
  html += `</table>`;
  
  // Convergents section
  if (convergents.length > 0) {
    html += `<div style="margin-top:1rem;padding:.75rem;background:var(--bg1);border-radius:6px">
      <strong style="color:#9664ff">Convergents (Best Rational Approximations):</strong>
      <div style="display:flex;flex-wrap:wrap;gap:.5rem;margin-top:.5rem">`;
    convergents.forEach((c, i) => {
      const isTarget = c.p === pRed && c.q === qRed;
      html += `<span style="padding:4px 8px;background:${isTarget ? '#00ff88' : 'var(--bg2)'};color:${isTarget ? '#000' : 'var(--txt)'};border-radius:4px;font-family:monospace">${c.p}/${c.q}</span>`;
    });
    html += `</div></div>`;
  }
  
  document.getElementById('sbAlgorithmSteps').innerHTML = html;
  
  // Set highlight mode and redraw
  document.getElementById('sbHighlight').value = 'path';
  drawSternBrocot();
}

// Convert path to continued fraction
function pathToContinuedFraction(path) {
  if (!path) return [1];
  const cf = [];
  let count = 0;
  let lastDir = null;
  
  for (let i = 0; i < path.length; i++) {
    if (path[i] === lastDir) {
      count++;
    } else {
      if (lastDir !== null) cf.push(count);
      count = 1;
      lastDir = path[i];
    }
  }
  cf.push(count);
  
  // If path starts with R, prepend 0
  if (path[0] === 'R') cf.unshift(0);
  
  return cf;
}

// Compute convergents from continued fraction
function computeConvergents(cf) {
  const convergents = [];
  let h_prev = 0, h_curr = 1;
  let k_prev = 1, k_curr = 0;
  
  for (let i = 0; i < cf.length; i++) {
    const a = cf[i];
    const h_new = a * h_curr + h_prev;
    const k_new = a * k_curr + k_prev;
    
    if (k_new > 0) {
      convergents.push({p: h_new, q: k_new});
    }
    
    h_prev = h_curr;
    h_curr = h_new;
    k_prev = k_curr;
    k_curr = k_new;
  }
  
  return convergents;
}

function findSBPathOld() {
  document.getElementById('sbHighlight').value = 'path';
  drawSternBrocot();
}

// CSV Export
function csvSternBrocot() {
  if (!sbData || sbData.length === 0) { alert('Generate tree first'); return; }
  let csv = 'p,q,decimal,depth,path,continued_fraction\n';
  sbData.forEach(n => {
    const cf = n.path ? n.path.split('').reduce((acc, d, i, arr) => {
      if (i === 0 || d !== arr[i-1]) acc.push(1);
      else acc[acc.length-1]++;
      return acc;
    }, []) : [1];
    if (n.path && n.path[0] === 'R') cf.unshift(0);
    csv += `${n.p},${n.q},${(n.p/n.q).toFixed(8)},${n.depth},"${n.path}","[${cf.join('; ')}]"\n`;
  });
  dl(csv, 'sternbrocot_tree.csv');
}

async function screenshotSternBrocot() { await screenshotUnified('csb', 'sbLiveStats', 'Stern-Brocot Tree', 'sternbrocot.png'); }
function resizeSBCanvas() { const sz = document.getElementById('sbCanvSz')?.value || '800x650'; const [w, h] = sz.split('x').map(Number); const c = document.getElementById('csb'); c.width = w; c.height = h; drawSternBrocot(); }
function exportAllSternBrocot() { screenshotTabAll({ canvases: ['csb'], dashId: 'sbLiveStats', title: 'Stern-Brocot Tree', filename: 'sternbrocot_all.png' }); }

// ==================== FORD CIRCLES ====================
let fordData = [];

function drawFord() {
const maxQ = +document.getElementById('fordQ')?.value || 15;
const xmin = +document.getElementById('fordXmin')?.value || 0;
const xmax = +document.getElementById('fordXmax')?.value || 1;
const colorBy = document.getElementById('fordColor')?.value || 'denominator';
const highlight = document.getElementById('fordHighlight')?.value || 'none';
const targetP = +document.getElementById('fordP')?.value || 2;
const targetQ = +document.getElementById('fordQtarget')?.value || 5;
const showLabels = document.getElementById('fordLabels')?.checked !== false;
const showTangent = document.getElementById('fordTangent')?.checked;

const c = document.getElementById('cford'), ctx = c.getContext('2d');
ctx.fillStyle = canvBg(); ctx.fillRect(0, 0, c.width, c.height);

fordData = [];
const pad = 40, w = c.width - 2 * pad, h = c.height - pad - 20;

// Generate Ford circles for fractions in range
for (let q = 1; q <= maxQ; q++) {
  for (let p = 0; p <= q; p++) {
    if (gcd(p, q) !== 1) continue;
    const x = p / q;
    if (x < xmin || x > xmax) continue;
    const r = 1 / (2 * q * q);
    fordData.push({ p, q, x, r, screenX: 0, screenY: 0, screenR: 0 });
  }
}

// Scale to screen
const xRange = xmax - xmin;
const maxR = fordData.length > 0 ? Math.max(...fordData.map(f => f.r)) : 0.5;
const yScale = h / (maxR * 3);
const xScale = w / xRange;

fordData.forEach(f => {
  f.screenX = pad + (f.x - xmin) * xScale;
  f.screenY = c.height - pad - f.r * yScale;
  f.screenR = f.r * yScale;
});

// Find Farey neighbors for highlighting
const neighbors = [];
if (highlight === 'neighbors' || showTangent) {
  for (let i = 0; i < fordData.length; i++) {
    for (let j = i + 1; j < fordData.length; j++) {
      const f1 = fordData[i], f2 = fordData[j];
      if (Math.abs(f1.p * f2.q - f2.p * f1.q) === 1) {
        neighbors.push([i, j]);
      }
    }
  }
}

// Draw x-axis
ctx.strokeStyle = gridC();
ctx.lineWidth = 1;
ctx.beginPath();
ctx.moveTo(pad, c.height - pad);
ctx.lineTo(pad + w, c.height - pad);
ctx.stroke();

// Draw tangent lines between neighbors
if (showTangent) {
  ctx.strokeStyle = 'rgba(255,215,0,0.3)';
  ctx.lineWidth = 1;
  neighbors.forEach(([i, j]) => {
    const f1 = fordData[i], f2 = fordData[j];
    ctx.beginPath();
    ctx.moveTo(f1.screenX, f1.screenY);
    ctx.lineTo(f2.screenX, f2.screenY);
    ctx.stroke();
  });
}

// Draw circles
fordData.forEach((f, idx) => {
  let color;
  if (colorBy === 'denominator') {
    color = `hsl(${(f.q * 30) % 360}, 70%, 50%)`;
  } else if (colorBy === 'depth') {
    color = `hsl(${f.q * 20}, 80%, 55%)`;
  } else if (colorBy === 'area') {
    const areaRatio = f.r / maxR;
    color = `hsl(${areaRatio * 240}, 80%, 50%)`;
  } else {
    color = `hsl(${(f.p / f.q) * 360}, 70%, 50%)`;
  }
  
  // Highlighting
  let isHL = false;
  if (highlight === 'target' && f.p === targetP && f.q === targetQ) isHL = true;
  if (highlight === 'neighbors') {
    neighbors.forEach(([i, j]) => {
      if ((fordData[i].p === targetP && fordData[i].q === targetQ && idx === j) ||
          (fordData[j].p === targetP && fordData[j].q === targetQ && idx === i) ||
          (idx === i && (fordData[j].p === targetP && fordData[j].q === targetQ)) ||
          (idx === j && (fordData[i].p === targetP && fordData[i].q === targetQ))) {
        isHL = true;
      }
    });
    if (f.p === targetP && f.q === targetQ) isHL = true;
  }
  if (highlight === 'fibonacci') {
    const fibs = [1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89];
    if (fibs.includes(f.p) && fibs.includes(f.q)) isHL = true;
  }
  
  ctx.fillStyle = isHL ? '#00ff88' : color;
  ctx.globalAlpha = isHL ? 1 : 0.7;
  ctx.beginPath();
  ctx.arc(f.screenX, f.screenY, Math.max(2, f.screenR), 0, 2 * Math.PI);
  ctx.fill();
  ctx.globalAlpha = 1;
  
  if (isHL) {
    ctx.strokeStyle = '#fff';
    ctx.lineWidth = 2;
    ctx.stroke();
  }
  
  // Labels
  if (showLabels && f.screenR > 8 && f.q <= 15) {
    ctx.fillStyle = isDark() ? '#fff' : '#000';
    ctx.font = `${Math.min(10, f.screenR * 0.8)}px Segoe UI`;
    ctx.textAlign = 'center';
    ctx.fillText(`${f.p}/${f.q}`, f.screenX, f.screenY + 3);
  }
});

// Title
ctx.fillStyle = isDark() ? '#ffd700' : '#cc8800';
ctx.font = 'bold 14px Segoe UI';
ctx.textAlign = 'center';
ctx.fillText(`Ford Circles — Q ≤ ${maxQ}`, c.width / 2, 25);

// Stats
const totalArea = fordData.reduce((s, f) => s + Math.PI * f.r * f.r, 0);
document.getElementById('fordLiveStats').innerHTML = `
<div style="display:grid;grid-template-columns:repeat(3,1fr);gap:8px;margin-bottom:12px">
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center"><div style="font-size:1.3rem;font-weight:bold;color:#00d9ff">${maxQ}</div><div style="font-size:.7rem;color:var(--txt2)">MAX Q</div></div>
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center"><div style="font-size:1.3rem;font-weight:bold;color:#ffd700">${fordData.length}</div><div style="font-size:.7rem;color:var(--txt2)">CIRCLES</div></div>
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center"><div style="font-size:1.3rem;font-weight:bold;color:#00ff88">${neighbors.length}</div><div style="font-size:.7rem;color:var(--txt2)">TANGENCIES</div></div>
</div>
<div style="font-size:.8rem;color:var(--txt2)">
<strong style="color:var(--acc)">Radius formula:</strong> r(p/q) = 1/(2q²)<br>
<strong style="color:var(--acc)">Tangency:</strong> Circles tangent iff |ad-bc| = 1<br>
<strong style="color:var(--acc)">Total area:</strong> ${totalArea.toFixed(6)}
</div>`;

document.getElementById('fordTangencyInfo').innerHTML = neighbors.slice(0, 30).map(([i, j]) => {
  const f1 = fordData[i], f2 = fordData[j];
  return `<span style="color:#ffd700">${f1.p}/${f1.q}</span> ↔ <span style="color:#00d9ff">${f2.p}/${f2.q}</span>`;
}).join('<br>') + (neighbors.length > 30 ? `<br><span style="color:var(--txt2)">+${neighbors.length - 30} more...</span>` : '');

document.getElementById('fordHyperbolic').innerHTML = `
<strong style="color:#9664ff">Hyperbolic Geometry Connection</strong>
<p style="font-size:.8rem;color:var(--txt2);margin-top:6px">
Ford circles are horocycles in the hyperbolic upper half-plane H². The tangency pattern corresponds to the Farey tessellation of H² by ideal triangles. The modular group PSL(2,ℤ) acts on both the Farey graph and the Ford circles, preserving tangencies.
</p>`;

// Click handler
c.onclick = e => {
  const rect = c.getBoundingClientRect();
  const mx = (e.clientX - rect.left) * (c.width / rect.width);
  const my = (e.clientY - rect.top) * (c.height / rect.height);
  for (const f of fordData) {
    if (Math.hypot(mx - f.screenX, my - f.screenY) < f.screenR + 5) {
      modal(`Ford Circle: ${f.p}/${f.q}`, [
        ['Fraction', `${f.p}/${f.q}`],
        ['Decimal', (f.p / f.q).toFixed(8)],
        ['Radius', `1/(2×${f.q}²) = ${f.r.toFixed(8)}`],
        ['Area', (Math.PI * f.r * f.r).toFixed(10)],
        ['Center', `(${f.x.toFixed(6)}, ${f.r.toFixed(6)})`]
      ]);
      break;
    }
  }
};
}

async function screenshotFord() { await screenshotUnified('cford', 'fordLiveStats', 'Ford Circles', 'ford_circles.png'); }
function exportAllFord() { screenshotTabAll({ canvases: ['cford'], dashId: 'fordLiveStats', title: 'Ford Circles', filename: 'ford_all.png' }); }
function resizeFordCanvas() { const sz = document.getElementById('fordCanvSz')?.value || '800x500'; const [w, h] = sz.split('x').map(Number); const c = document.getElementById('cford'); c.width = w; c.height = h; drawFord(); }
function csvFord() {
  let csv = 'p,q,decimal,radius,area,center_x,center_y\n';
  fordData.forEach(f => { csv += `${f.p},${f.q},${(f.p/f.q).toFixed(8)},${f.r.toFixed(10)},${(Math.PI*f.r*f.r).toFixed(12)},${f.x.toFixed(8)},${f.r.toFixed(8)}\n`; });
  dl(csv, 'ford_circles.csv');
}

// ==================== CALKIN-WILF TREE ====================
let cwData = [];

function drawCalkinWilf() {
const depth = +document.getElementById('cwDepth')?.value || 6;
const layout = document.getElementById('cwLayout')?.value || 'tree';
const colorBy = document.getElementById('cwColor')?.value || 'depth';
const showLabels = document.getElementById('cwLabels')?.checked !== false;
const showEdges = document.getElementById('cwEdges')?.checked !== false;
const compare = document.getElementById('cwCompare')?.checked;

const c = document.getElementById('ccw'), ctx = c.getContext('2d');
ctx.fillStyle = canvBg(); ctx.fillRect(0, 0, c.width, c.height);

// Build Calkin-Wilf tree: node a/b has children a/(a+b) and (a+b)/b
cwData = [];
const nodes = [];
const root = { a: 1, b: 1, depth: 0, path: '', idx: 0 };
nodes.push(root);

function buildCW(node, maxD) {
  if (node.depth >= maxD) return;
  const leftChild = { a: node.a, b: node.a + node.b, depth: node.depth + 1, path: node.path + 'L', parent: node };
  const rightChild = { a: node.a + node.b, b: node.b, depth: node.depth + 1, path: node.path + 'R', parent: node };
  node.left = leftChild;
  node.right = rightChild;
  nodes.push(leftChild, rightChild);
  buildCW(leftChild, maxD);
  buildCW(rightChild, maxD);
}
buildCW(root, depth);

// Calculate positions
const pad = 50, w = c.width - 2 * pad, h = c.height - 2 * pad;

if (layout === 'tree') {
  nodes.forEach(node => {
    const levelCount = Math.pow(2, node.depth);
    const levelOffset = node.path.split('').reduce((acc, dir, idx) => acc + (dir === 'R' ? Math.pow(2, node.depth - idx - 1) : 0), 0);
    node.x = pad + w * (levelOffset + 0.5) / levelCount;
    node.y = pad + 30 + node.depth * (h - 40) / depth;
  });
} else if (layout === 'sequence') {
  // BFS order
  const bfs = [];
  const queue = [root];
  while (queue.length > 0) {
    const n = queue.shift();
    bfs.push(n);
    if (n.left) queue.push(n.left);
    if (n.right) queue.push(n.right);
  }
  bfs.forEach((n, i) => {
    n.x = pad + (i % 20) * (w / 20) + 15;
    n.y = pad + 30 + Math.floor(i / 20) * 50;
  });
} else if (layout === 'spiral') {
  nodes.forEach((n, i) => {
    const angle = i * 0.3;
    const r = 30 + i * 2;
    n.x = c.width / 2 + r * Math.cos(angle);
    n.y = c.height / 2 + r * Math.sin(angle);
  });
}

// Draw edges
if (showEdges && layout === 'tree') {
  ctx.strokeStyle = gridC();
  ctx.lineWidth = 1;
  nodes.forEach(n => {
    if (n.left) { ctx.beginPath(); ctx.moveTo(n.x, n.y); ctx.lineTo(n.left.x, n.left.y); ctx.stroke(); }
    if (n.right) { ctx.beginPath(); ctx.moveTo(n.x, n.y); ctx.lineTo(n.right.x, n.right.y); ctx.stroke(); }
  });
}

// Draw nodes
nodes.forEach((n, i) => {
  let color;
  if (colorBy === 'depth') color = `hsl(${n.depth * 360 / depth}, 70%, 50%)`;
  else if (colorBy === 'sum') color = `hsl(${((n.a + n.b) * 20) % 360}, 70%, 50%)`;
  else color = `hsl(${i * 10 % 360}, 70%, 50%)`;
  
  ctx.fillStyle = color;
  ctx.beginPath();
  ctx.arc(n.x, n.y, 10, 0, 2 * Math.PI);
  ctx.fill();
  
  if (showLabels && n.b < 20) {
    ctx.fillStyle = isDark() ? '#fff' : '#000';
    ctx.font = '8px Segoe UI';
    ctx.textAlign = 'center';
    ctx.fillText(`${n.a}/${n.b}`, n.x, n.y + 3);
  }
  
  cwData.push({ a: n.a, b: n.b, depth: n.depth, path: n.path, x: n.x, y: n.y });
});

ctx.fillStyle = isDark() ? '#ffd700' : '#cc8800';
ctx.font = 'bold 14px Segoe UI';
ctx.textAlign = 'center';
ctx.fillText(`Calkin-Wilf Tree — Depth ${depth}`, c.width / 2, 25);

// Generate BFS sequence
const bfsSeq = [];
const queue = [root];
while (queue.length > 0 && bfsSeq.length < 50) {
  const n = queue.shift();
  bfsSeq.push(`${n.a}/${n.b}`);
  if (n.left) queue.push(n.left);
  if (n.right) queue.push(n.right);
}

document.getElementById('cwLiveStats').innerHTML = `
<div style="display:grid;grid-template-columns:repeat(3,1fr);gap:8px;margin-bottom:12px">
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center"><div style="font-size:1.3rem;font-weight:bold;color:#00d9ff">${depth}</div><div style="font-size:.7rem;color:var(--txt2)">DEPTH</div></div>
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center"><div style="font-size:1.3rem;font-weight:bold;color:#ffd700">${nodes.length}</div><div style="font-size:.7rem;color:var(--txt2)">NODES</div></div>
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center"><div style="font-size:1.3rem;font-weight:bold;color:#00ff88">${Math.pow(2, depth)}</div><div style="font-size:.7rem;color:var(--txt2)">LEAVES</div></div>
</div>
<div style="font-size:.8rem;color:var(--txt2)">
<strong style="color:var(--acc)">Rule:</strong> a/b → a/(a+b), (a+b)/b<br>
<strong style="color:var(--acc)">Property:</strong> Every positive rational exactly once<br>
<strong style="color:var(--acc)">Connection:</strong> Hyperbinary representations
</div>`;

document.getElementById('cwSequence').innerHTML = `<strong style="color:#00ff88">BFS Sequence:</strong><br>${bfsSeq.map(s => `<span style="color:#ffd700">${s}</span>`).join(' → ')}`;
}

async function screenshotCalkinWilf() { await screenshotUnified('ccw', 'cwLiveStats', 'Calkin-Wilf Tree', 'calkinwilf.png'); }
function resizeCWCanvas() { const sz = document.getElementById('cwCanvSz')?.value || '800x550'; const [w, h] = sz.split('x').map(Number); const c = document.getElementById('ccw'); c.width = w; c.height = h; drawCalkinWilf(); }
function csvCalkinWilf() {
  let csv = 'a,b,decimal,depth,path\n';
  cwData.forEach(n => { csv += `${n.a},${n.b},${(n.a/n.b).toFixed(8)},${n.depth},"${n.path}"\n`; });
  dl(csv, 'calkinwilf.csv');
}

// ==================== PISANO PERIODS ====================
let pisanoData = {};

function pisanoPeriod(n) {
  if (n === 1) return 1;
  let a = 0, b = 1, period = 0;
  do {
    [a, b] = [b, (a + b) % n];
    period++;
  } while (!(a === 0 && b === 1) && period < n * n + 1);
  return period;
}

function drawPisano() {
const n = +document.getElementById('pisanoN')?.value || 10;
const viz = document.getElementById('pisanoViz')?.value || 'sequence';
const colorBy = document.getElementById('pisanoColor')?.value || 'residue';
const showLabels = document.getElementById('pisanoLabels')?.checked !== false;
const showLucas = document.getElementById('pisanoLucas')?.checked;

const c = document.getElementById('cpisano'), ctx = c.getContext('2d');
ctx.fillStyle = canvBg(); ctx.fillRect(0, 0, c.width, c.height);

const period = pisanoPeriod(n);
pisanoData = { n, period, sequence: [] };

// Generate Fibonacci mod n
let a = 0, b = 1;
for (let i = 0; i < Math.min(period + 5, 500); i++) {
  pisanoData.sequence.push(a);
  [a, b] = [b, (a + b) % n];
}

const pad = 50, w = c.width - 2 * pad, h = c.height - 2 * pad;

if (viz === 'sequence') {
  // Grid showing Fib mod n
  const cols = Math.min(period, 30);
  const rows = Math.ceil(Math.min(period, 200) / cols);
  const cellW = w / cols, cellH = Math.min(30, h / rows);
  
  for (let i = 0; i < Math.min(period, 200); i++) {
    const col = i % cols, row = Math.floor(i / cols);
    const x = pad + col * cellW, y = pad + 30 + row * cellH;
    const val = pisanoData.sequence[i];
    
    let color;
    if (colorBy === 'residue') color = `hsl(${(val / n) * 360}, 70%, 50%)`;
    else if (colorBy === 'zero') color = val === 0 ? '#ffd700' : '#333';
    else color = `hsl(${(val * 30) % 360}, 60%, 50%)`;
    
    ctx.fillStyle = color;
    ctx.fillRect(x + 1, y + 1, cellW - 2, cellH - 2);
    
    if (showLabels && cellW > 15 && cellH > 12) {
      ctx.fillStyle = isDark() ? '#fff' : '#000';
      ctx.font = '9px Segoe UI';
      ctx.textAlign = 'center';
      ctx.fillText(val, x + cellW / 2, y + cellH / 2 + 3);
    }
  }
} else if (viz === 'periods') {
  // Show periods for multiple n
  const maxN = Math.min(n, 100);
  const barW = w / maxN;
  const periods = [];
  for (let i = 1; i <= maxN; i++) periods.push(pisanoPeriod(i));
  const maxP = Math.max(...periods);
  
  periods.forEach((p, i) => {
    const x = pad + i * barW;
    const barH = (p / maxP) * h * 0.8;
    ctx.fillStyle = isPrime(i + 1) ? '#00ff88' : `hsl(${(p * 5) % 360}, 60%, 50%)`;
    ctx.fillRect(x, c.height - pad - barH, barW - 1, barH);
  });
  
  ctx.fillStyle = isDark() ? '#888' : '#666';
  ctx.font = '9px Segoe UI';
  ctx.textAlign = 'center';
  for (let i = 0; i < maxN; i += Math.ceil(maxN / 20)) {
    ctx.fillText(i + 1, pad + i * barW + barW / 2, c.height - pad + 12);
  }
} else if (viz === 'circle') {
  // Circular representation
  const cx = c.width / 2, cy = c.height / 2, r = Math.min(w, h) / 2.5;
  for (let i = 0; i < period; i++) {
    const angle = (i / period) * 2 * Math.PI - Math.PI / 2;
    const val = pisanoData.sequence[i];
    const pr = r * (0.3 + 0.7 * val / n);
    const x = cx + pr * Math.cos(angle);
    const y = cy + pr * Math.sin(angle);
    
    ctx.fillStyle = val === 0 ? '#ffd700' : `hsl(${(val / n) * 240}, 70%, 50%)`;
    ctx.beginPath();
    ctx.arc(x, y, 4, 0, 2 * Math.PI);
    ctx.fill();
  }
  // Connect with lines
  ctx.strokeStyle = 'rgba(255,215,0,0.3)';
  ctx.beginPath();
  for (let i = 0; i <= period; i++) {
    const angle = (i / period) * 2 * Math.PI - Math.PI / 2;
    const val = pisanoData.sequence[i % period];
    const pr = r * (0.3 + 0.7 * val / n);
    const x = cx + pr * Math.cos(angle);
    const y = cy + pr * Math.sin(angle);
    if (i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
  }
  ctx.stroke();
} else if (viz === 'heatmap') {
  // Heatmap of π(n) for range of n
  const size = Math.min(50, n);
  const cellSize = Math.min(w, h) / size;
  for (let i = 1; i <= size; i++) {
    for (let j = 1; j <= size; j++) {
      const p = pisanoPeriod(i * j);
      const x = pad + (i - 1) * cellSize;
      const y = pad + 30 + (j - 1) * cellSize;
      ctx.fillStyle = `hsl(${(p % 60) * 6}, 70%, 50%)`;
      ctx.fillRect(x, y, cellSize - 1, cellSize - 1);
    }
  }
}

ctx.fillStyle = isDark() ? '#ffd700' : '#cc8800';
ctx.font = 'bold 14px Segoe UI';
ctx.textAlign = 'center';
ctx.fillText(`Pisano Period π(${n}) = ${period}`, c.width / 2, 25);

// Find zeros
const zeros = [];
for (let i = 0; i < period; i++) if (pisanoData.sequence[i] === 0) zeros.push(i);

document.getElementById('pisanoLiveStats').innerHTML = `
<div style="display:grid;grid-template-columns:repeat(3,1fr);gap:8px;margin-bottom:12px">
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center"><div style="font-size:1.3rem;font-weight:bold;color:#00d9ff">${n}</div><div style="font-size:.7rem;color:var(--txt2)">MODULUS</div></div>
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center"><div style="font-size:1.3rem;font-weight:bold;color:#ffd700">${period}</div><div style="font-size:.7rem;color:var(--txt2)">π(n)</div></div>
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center"><div style="font-size:1.3rem;font-weight:bold;color:#00ff88">${zeros.length}</div><div style="font-size:.7rem;color:var(--txt2)">ZEROS</div></div>
</div>
<div style="font-size:.8rem;color:var(--txt2)">
<strong style="color:var(--acc)">Definition:</strong> Smallest k where F_k ≡ 0, F_{k+1} ≡ 1<br>
<strong style="color:var(--acc)">Prime property:</strong> π(p) | p² - 1<br>
<strong style="color:var(--acc)">Zero positions:</strong> ${zeros.slice(0, 10).join(', ')}${zeros.length > 10 ? '...' : ''}
</div>`;

document.getElementById('pisanoAnalysis').innerHTML = `
<strong style="color:#9664ff">Period Properties</strong>
<div style="font-size:.8rem;margin-top:6px">
<span>n = ${n}</span> | <span style="color:${isPrime(n) ? '#00ff88' : '#ff6496'}">${isPrime(n) ? 'Prime' : 'Composite'}</span><br>
${isPrime(n) ? `π(${n}) = ${period} | ${n}² - 1 = ${n*n - 1} | Divides: ${(n*n-1) % period === 0 ? 'Yes' : 'No'}` : `Factorization affects period multiplicatively`}
</div>`;
}

async function screenshotPisano() { await screenshotUnified('cpisano', 'pisanoLiveStats', 'Pisano Periods', 'pisano.png'); }
function resizePisanoCanvas() { const sz = document.getElementById('pisanoCanvSz')?.value || '800x500'; const [w, h] = sz.split('x').map(Number); const c = document.getElementById('cpisano'); c.width = w; c.height = h; drawPisano(); }
function csvPisano() {
  let csv = `Pisano Period for n=${pisanoData.n}\nperiod,${pisanoData.period}\n\nindex,fib_mod_n\n`;
  pisanoData.sequence.forEach((v, i) => { csv += `${i},${v}\n`; });
  dl(csv, `pisano_${pisanoData.n}.csv`);
}

// ==================== EISENSTEIN INTEGERS ====================
let eisData = [];

function eisensteinNorm(a, b) { return a * a - a * b + b * b; }

function isEisensteinPrime(a, b) {
  const norm = eisensteinNorm(a, b);
  if (norm <= 1) return false;
  if (a === 0 || b === 0 || a === b) {
    // On axes: check if |coord| is prime ≡ 2 mod 3
    const val = Math.abs(a || b || (a - b));
    return isPrime(val) && val % 3 === 2;
  }
  // General case: prime iff norm is prime
  return isPrime(norm);
}

function drawEisenstein() {
const R = +document.getElementById('eisR')?.value || 8;
const colorBy = document.getElementById('eisColor')?.value || 'norm';
const overlay = document.getElementById('eisOverlay')?.value || 'none';
const showLabels = document.getElementById('eisLabels')?.checked;
const showAxes = document.getElementById('eisAxes')?.checked !== false;

const c = document.getElementById('ceisenstein'), ctx = c.getContext('2d');
ctx.fillStyle = canvBg(); ctx.fillRect(0, 0, c.width, c.height);

const cx = c.width / 2, cy = c.height / 2;
const scale = Math.min(c.width, c.height) / (2.5 * R);

// Eisenstein basis: 1 and ω = e^(2πi/3) = (-1 + √3i)/2
const omega = { re: -0.5, im: Math.sqrt(3) / 2 };

eisData = [];

// Generate Eisenstein integers
for (let a = -R; a <= R; a++) {
  for (let b = -R; b <= R; b++) {
    // z = a + b*ω
    const re = a + b * omega.re;
    const im = b * omega.im;
    const norm = eisensteinNorm(a, b);
    if (Math.sqrt(re * re + im * im) <= R * 1.2) {
      eisData.push({ a, b, re, im, norm, isPrime: isEisensteinPrime(a, b) });
    }
  }
}

// Draw hexagonal grid if overlay
if (overlay === 'hexgrid') {
  ctx.strokeStyle = 'rgba(150,100,255,0.2)';
  ctx.lineWidth = 1;
  for (let a = -R; a <= R; a++) {
    ctx.beginPath();
    for (let b = -R; b <= R; b++) {
      const re = a + b * omega.re;
      const im = b * omega.im;
      const x = cx + re * scale, y = cy - im * scale;
      if (b === -R) ctx.moveTo(x, y); else ctx.lineTo(x, y);
    }
    ctx.stroke();
  }
}

// Draw axes
if (showAxes) {
  ctx.strokeStyle = gridC();
  ctx.lineWidth = 1;
  // Real axis
  ctx.beginPath(); ctx.moveTo(0, cy); ctx.lineTo(c.width, cy); ctx.stroke();
  // ω direction
  ctx.beginPath();
  ctx.moveTo(cx - R * omega.re * scale, cy + R * omega.im * scale);
  ctx.lineTo(cx + R * omega.re * scale, cy - R * omega.im * scale);
  ctx.stroke();
  // ω² direction
  ctx.beginPath();
  ctx.moveTo(cx - R * (omega.re + 1) * scale / 2, cy + R * omega.im * scale / 2);
  ctx.lineTo(cx + R * (omega.re + 1) * scale / 2, cy - R * omega.im * scale / 2);
  ctx.stroke();
}

// Draw points
eisData.forEach(pt => {
  const x = cx + pt.re * scale;
  const y = cy - pt.im * scale;
  
  let color;
  if (colorBy === 'norm') {
    color = `hsl(${(pt.norm * 20) % 360}, 70%, 50%)`;
  } else if (colorBy === 'prime') {
    color = pt.isPrime ? '#00ff88' : '#444';
  } else if (colorBy === 'unit') {
    const isUnit = pt.norm === 1;
    color = isUnit ? '#ffd700' : '#00d9ff';
  } else {
    color = `hsl(${(Math.atan2(pt.im, pt.re) + Math.PI) / (2 * Math.PI) * 360}, 70%, 50%)`;
  }
  
  const size = colorBy === 'prime' && pt.isPrime ? 6 : 4;
  ctx.fillStyle = color;
  ctx.beginPath();
  ctx.arc(x, y, size, 0, 2 * Math.PI);
  ctx.fill();
  
  if (showLabels && Math.abs(pt.a) <= 3 && Math.abs(pt.b) <= 3) {
    ctx.fillStyle = isDark() ? '#fff' : '#000';
    ctx.font = '8px Segoe UI';
    ctx.textAlign = 'center';
    ctx.fillText(`${pt.a}${pt.b >= 0 ? '+' : ''}${pt.b}ω`, x, y - 8);
  }
});

ctx.fillStyle = isDark() ? '#ffd700' : '#cc8800';
ctx.font = 'bold 14px Segoe UI';
ctx.textAlign = 'center';
ctx.fillText(`Eisenstein Integers ℤ[ω] — R = ${R}`, c.width / 2, 25);

const primeCount = eisData.filter(p => p.isPrime).length;
const unitCount = eisData.filter(p => p.norm === 1).length;

document.getElementById('eisLiveStats').innerHTML = `
<div style="display:grid;grid-template-columns:repeat(3,1fr);gap:8px;margin-bottom:12px">
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center"><div style="font-size:1.3rem;font-weight:bold;color:#00d9ff">${eisData.length}</div><div style="font-size:.7rem;color:var(--txt2)">POINTS</div></div>
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center"><div style="font-size:1.3rem;font-weight:bold;color:#00ff88">${primeCount}</div><div style="font-size:.7rem;color:var(--txt2)">PRIMES</div></div>
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center"><div style="font-size:1.3rem;font-weight:bold;color:#ffd700">${unitCount}</div><div style="font-size:.7rem;color:var(--txt2)">UNITS</div></div>
</div>
<div style="font-size:.8rem;color:var(--txt2)">
<strong style="color:var(--acc)">ω = e^(2πi/3):</strong> primitive cube root of unity<br>
<strong style="color:var(--acc)">Norm:</strong> N(a+bω) = a² - ab + b²<br>
<strong style="color:var(--acc)">Units:</strong> ±1, ±ω, ±ω² (6 total)
</div>`;

document.getElementById('eisPrimeInfo').innerHTML = `
<strong style="color:#00ff88">Prime Behavior</strong>
<div style="font-size:.8rem;margin-top:6px">
• p ≡ 2 (mod 3): stays prime in ℤ[ω]<br>
• p ≡ 1 (mod 3): splits into 2 primes<br>
• p = 3: ramifies (3 = -ω²(1-ω)²)
</div>`;
}

async function screenshotEisenstein() { await screenshotUnified('ceisenstein', 'eisLiveStats', 'Eisenstein Integers', 'eisenstein.png'); }
function resizeEisCanvas() { const sz = document.getElementById('eisCanvSz')?.value || '700x700'; const [w, h] = sz.split('x').map(Number); const c = document.getElementById('ceisenstein'); c.width = w; c.height = h; drawEisenstein(); }
function csvEisenstein() {
  let csv = 'a,b,re,im,norm,is_prime\n';
  eisData.forEach(p => { csv += `${p.a},${p.b},${p.re.toFixed(6)},${p.im.toFixed(6)},${p.norm},${p.isPrime}\n`; });
  dl(csv, 'eisenstein.csv');
}

// ==================== BEATTY SEQUENCES ====================
let beattyData = {};

function drawBeatty() {
const alphaType = document.getElementById('beattyAlpha')?.value || 'phi';
const customVal = +document.getElementById('beattyCustom')?.value || 1.618;
const maxN = +document.getElementById('beattyN')?.value || 50;
const viz = document.getElementById('beattyViz')?.value || 'partition';

let alpha;
if (alphaType === 'phi') alpha = (1 + Math.sqrt(5)) / 2;
else if (alphaType === 'phi2') alpha = (3 + Math.sqrt(5)) / 2;
else if (alphaType === 'sqrt2') alpha = Math.sqrt(2);
else if (alphaType === 'sqrt3') alpha = Math.sqrt(3);
else if (alphaType === 'e') alpha = Math.E;
else if (alphaType === 'pi') alpha = Math.PI;
else alpha = customVal;

const beta = alpha / (alpha - 1); // From 1/α + 1/β = 1

const c = document.getElementById('cbeatty'), ctx = c.getContext('2d');
ctx.fillStyle = canvBg(); ctx.fillRect(0, 0, c.width, c.height);

// Generate sequences
const seqA = [], seqB = [];
for (let n = 1; n <= maxN; n++) {
  seqA.push(Math.floor(n * alpha));
  seqB.push(Math.floor(n * beta));
}

beattyData = { alpha, beta, seqA, seqB };

const pad = 50, w = c.width - 2 * pad, h = c.height - 2 * pad;
const maxVal = Math.max(...seqA, ...seqB);

if (viz === 'partition') {
  // Number line showing partition
  const lineY = c.height / 2;
  const scale = w / maxVal;
  
  ctx.strokeStyle = gridC();
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(pad, lineY);
  ctx.lineTo(pad + w, lineY);
  ctx.stroke();
  
  // Mark all integers
  for (let i = 1; i <= maxVal; i++) {
    const x = pad + i * scale;
    ctx.strokeStyle = gridC();
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(x, lineY - 5);
    ctx.lineTo(x, lineY + 5);
    ctx.stroke();
  }
  
  // Color by sequence membership
  const inA = new Set(seqA), inB = new Set(seqB);
  for (let i = 1; i <= maxVal; i++) {
    const x = pad + i * scale;
    if (inA.has(i)) {
      ctx.fillStyle = '#00ff88';
      ctx.beginPath();
      ctx.arc(x, lineY - 20, 6, 0, 2 * Math.PI);
      ctx.fill();
    }
    if (inB.has(i)) {
      ctx.fillStyle = '#ff6496';
      ctx.beginPath();
      ctx.arc(x, lineY + 20, 6, 0, 2 * Math.PI);
      ctx.fill();
    }
  }
  
  // Labels
  ctx.fillStyle = '#00ff88';
  ctx.font = 'bold 12px Segoe UI';
  ctx.textAlign = 'left';
  ctx.fillText(`B_α (nα)`, pad, lineY - 40);
  ctx.fillStyle = '#ff6496';
  ctx.fillText(`B_β (nβ)`, pad, lineY + 50);
} else if (viz === 'grid') {
  // Side by side comparison
  const cellSize = Math.min(20, w / maxN);
  
  for (let i = 0; i < maxN; i++) {
    // Sequence A
    ctx.fillStyle = '#00ff88';
    ctx.fillRect(pad + i * cellSize, pad + 50, cellSize - 1, 25);
    ctx.fillStyle = isDark() ? '#000' : '#fff';
    ctx.font = '9px Segoe UI';
    ctx.textAlign = 'center';
    if (cellSize > 12) ctx.fillText(seqA[i], pad + i * cellSize + cellSize / 2, pad + 67);
    
    // Sequence B
    ctx.fillStyle = '#ff6496';
    ctx.fillRect(pad + i * cellSize, pad + 90, cellSize - 1, 25);
    ctx.fillStyle = isDark() ? '#000' : '#fff';
    if (cellSize > 12) ctx.fillText(seqB[i], pad + i * cellSize + cellSize / 2, pad + 107);
  }
} else if (viz === 'diff') {
  // Difference sequence
  const diffs = seqA.map((a, i) => seqA[i + 1] - a).filter(d => !isNaN(d));
  const barW = w / diffs.length;
  
  diffs.forEach((d, i) => {
    const x = pad + i * barW;
    const barH = d * 50;
    ctx.fillStyle = d === 1 ? '#00ff88' : '#ffd700';
    ctx.fillRect(x, c.height / 2 - barH / 2, barW - 1, barH);
  });
}

ctx.fillStyle = isDark() ? '#ffd700' : '#cc8800';
ctx.font = 'bold 14px Segoe UI';
ctx.textAlign = 'center';
ctx.fillText(`Beatty Sequences — α = ${alpha.toFixed(6)}`, c.width / 2, 25);

document.getElementById('beattyLiveStats').innerHTML = `
<div style="display:grid;grid-template-columns:repeat(2,1fr);gap:8px;margin-bottom:12px">
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center"><div style="font-size:1.1rem;font-weight:bold;color:#00ff88">${alpha.toFixed(6)}</div><div style="font-size:.7rem;color:var(--txt2)">α</div></div>
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center"><div style="font-size:1.1rem;font-weight:bold;color:#ff6496">${beta.toFixed(6)}</div><div style="font-size:.7rem;color:var(--txt2)">β = α/(α-1)</div></div>
</div>
<div style="font-size:.8rem;color:var(--txt2)">
<strong style="color:var(--acc)">Rayleigh's Theorem:</strong> B_α ∪ B_β = ℕ (disjoint)<br>
<strong style="color:var(--acc)">Relation:</strong> 1/α + 1/β = 1<br>
<strong style="color:var(--acc)">Verification:</strong> ${(1/alpha + 1/beta).toFixed(10)}
</div>`;

document.getElementById('beattySeqs').innerHTML = `
<strong style="color:#00ff88">B_α:</strong> ${seqA.slice(0, 20).join(', ')}...<br>
<strong style="color:#ff6496">B_β:</strong> ${seqB.slice(0, 20).join(', ')}...`;
}

async function screenshotBeatty() { await screenshotUnified('cbeatty', 'beattyLiveStats', 'Beatty Sequences', 'beatty.png'); }
function resizeBeattyCanvas() { const sz = document.getElementById('beattyCanvSz')?.value || '800x450'; const [w, h] = sz.split('x').map(Number); const c = document.getElementById('cbeatty'); c.width = w; c.height = h; drawBeatty(); }
function csvBeatty() {
  let csv = `alpha,${beattyData.alpha}\nbeta,${beattyData.beta}\n\nn,floor_n_alpha,floor_n_beta\n`;
  for (let i = 0; i < beattyData.seqA.length; i++) {
    csv += `${i + 1},${beattyData.seqA[i]},${beattyData.seqB[i]}\n`;
  }
  dl(csv, 'beatty.csv');
}

// ==================== DEDEKIND SUMS ====================
let dedekindData = {};

function sawtooth(x) {
  const frac = x - Math.floor(x);
  return frac === 0 ? 0 : frac - 0.5;
}

function dedekindSum(p, q) {
  if (gcd(p, q) !== 1) return NaN;
  let sum = 0;
  for (let k = 1; k < q; k++) {
    sum += sawtooth(k / q) * sawtooth(p * k / q);
  }
  return sum;
}

function drawDedekind() {
const p = +document.getElementById('dedP')?.value || 5;
const q = +document.getElementById('dedQ')?.value || 8;
const viz = document.getElementById('dedViz')?.value || 'sawtooth';
const maxRange = +document.getElementById('dedMax')?.value || 30;

const c = document.getElementById('cdedekind'), ctx = c.getContext('2d');
ctx.fillStyle = canvBg(); ctx.fillRect(0, 0, c.width, c.height);

const s_pq = dedekindSum(p, q);
const s_qp = dedekindSum(q, p);
dedekindData = { p, q, s_pq, s_qp };

const pad = 50, w = c.width - 2 * pad, h = c.height - 2 * pad;

if (viz === 'sawtooth') {
  // Draw sawtooth function
  ctx.strokeStyle = '#00d9ff';
  ctx.lineWidth = 2;
  ctx.beginPath();
  for (let x = 0; x <= w; x++) {
    const t = x / w;
    const y = h / 2 - sawtooth(t) * h * 0.8;
    if (x === 0) ctx.moveTo(pad + x, pad + y);
    else ctx.lineTo(pad + x, pad + y);
  }
  ctx.stroke();
  
  // Mark discontinuities
  ctx.fillStyle = '#ffd700';
  for (let k = 0; k <= 1; k += 0.25) {
    const x = pad + k * w;
    ctx.beginPath();
    ctx.arc(x, pad + h / 2, 4, 0, 2 * Math.PI);
    ctx.fill();
  }
  
  // Axis
  ctx.strokeStyle = gridC();
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(pad, pad + h / 2);
  ctx.lineTo(pad + w, pad + h / 2);
  ctx.stroke();
} else if (viz === 'heatmap') {
  // Heatmap of s(p,q) values
  const cellSize = Math.min(w, h) / maxRange;
  for (let i = 1; i <= maxRange; i++) {
    for (let j = 1; j <= maxRange; j++) {
      if (gcd(i, j) !== 1) continue;
      const s = dedekindSum(i, j);
      const x = pad + (i - 1) * cellSize;
      const y = pad + 30 + (j - 1) * cellSize;
      const hue = (s + 0.5) * 240;
      ctx.fillStyle = `hsl(${hue}, 70%, 50%)`;
      ctx.fillRect(x, y, cellSize - 1, cellSize - 1);
    }
  }
}

ctx.fillStyle = isDark() ? '#ffd700' : '#cc8800';
ctx.font = 'bold 14px Segoe UI';
ctx.textAlign = 'center';
ctx.fillText(`Dedekind Sum s(${p}, ${q}) = ${s_pq.toFixed(6)}`, c.width / 2, 25);

// Reciprocity check
const recipLHS = s_pq + s_qp;
const recipRHS = (p * p + q * q + 1) / (12 * p * q) - 0.25;

document.getElementById('dedLiveStats').innerHTML = `
<div style="display:grid;grid-template-columns:repeat(2,1fr);gap:8px;margin-bottom:12px">
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center"><div style="font-size:1.1rem;font-weight:bold;color:#00d9ff">${s_pq.toFixed(6)}</div><div style="font-size:.7rem;color:var(--txt2)">s(${p},${q})</div></div>
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center"><div style="font-size:1.1rem;font-weight:bold;color:#ff6496">${s_qp.toFixed(6)}</div><div style="font-size:.7rem;color:var(--txt2)">s(${q},${p})</div></div>
</div>
<div style="font-size:.8rem;color:var(--txt2)">
<strong style="color:var(--acc)">Definition:</strong> s(p,q) = Σ ((k/q))((pk/q))<br>
<strong style="color:var(--acc)">Sawtooth:</strong> ((x)) = x - x - ½ if x∉ℤ, else 0
</div>`;

document.getElementById('dedReciprocity').innerHTML = `
<strong style="color:#9664ff">Reciprocity Law</strong>
<div style="font-size:.8rem;margin-top:6px;font-family:monospace">
s(p,q) + s(q,p) = (p²+q²+1)/(12pq) - ¼<br><br>
LHS: ${s_pq.toFixed(6)} + ${s_qp.toFixed(6)} = <span style="color:#00ff88">${recipLHS.toFixed(6)}</span><br>
RHS: (${p}²+${q}²+1)/(12×${p}×${q}) - ¼ = <span style="color:#ffd700">${recipRHS.toFixed(6)}</span><br>
Match: <span style="color:${Math.abs(recipLHS - recipRHS) < 1e-9 ? '#00ff88' : '#ff6496'}">${Math.abs(recipLHS - recipRHS) < 1e-9 ? 'Yes' : 'No'}</span>
</div>`;
}

async function screenshotDedekind() { await screenshotUnified('cdedekind', 'dedLiveStats', 'Dedekind Sums', 'dedekind.png'); }
function resizeDedCanvas() { const sz = document.getElementById('dedCanvSz')?.value || '750x500'; const [w, h] = sz.split('x').map(Number); const c = document.getElementById('cdedekind'); c.width = w; c.height = h; drawDedekind(); }
function csvDedekind() {
  const max = +document.getElementById('dedMax')?.value || 30;
  let csv = 'p,q,s_pq,s_qp,reciprocity_check\n';
  for (let p = 1; p <= max; p++) {
    for (let q = 1; q <= max; q++) {
      if (gcd(p, q) !== 1) continue;
      const s1 = dedekindSum(p, q), s2 = dedekindSum(q, p);
      csv += `${p},${q},${s1.toFixed(8)},${s2.toFixed(8)},${(s1 + s2).toFixed(8)}\n`;
    }
  }
  dl(csv, 'dedekind_sums.csv');
}

// ==================== MINKOWSKI'S THEOREM ====================
let minkData = {};
let minkAnimId = null;

function drawMinkowski() {
const shape = document.getElementById('minkShape')?.value || 'circle';
const scale = +document.getElementById('minkScale')?.value || 2;
const a = +document.getElementById('minkA')?.value || 2;
const b = +document.getElementById('minkB')?.value || 1;
const showLattice = document.getElementById('minkLattice')?.checked !== false;
const showHighlight = document.getElementById('minkHighlight')?.checked !== false;
const primOnly = document.getElementById('minkPrimitive')?.checked;

const c = document.getElementById('cminkowski'), ctx = c.getContext('2d');
ctx.fillStyle = canvBg(); ctx.fillRect(0, 0, c.width, c.height);

const cx = c.width / 2, cy = c.height / 2;
const gridScale = Math.min(c.width, c.height) / 12;
const R = Math.ceil(scale * 2);

// Check if point is inside shape
function insideShape(x, y) {
  if (shape === 'circle') return x * x + y * y <= scale * scale;
  if (shape === 'ellipse') return (x * x) / (a * a) + (y * y) / (b * b) <= scale * scale;
  if (shape === 'square') return Math.abs(x) <= scale && Math.abs(y) <= scale;
  if (shape === 'diamond') return Math.abs(x) + Math.abs(y) <= scale;
  if (shape === 'hexagon') {
    const ax = Math.abs(x), ay = Math.abs(y);
    return ax <= scale && ay <= scale * Math.sqrt(3) / 2 && ax + ay / Math.sqrt(3) <= scale;
  }
  return false;
}

// Calculate volume
function shapeVolume() {
  if (shape === 'circle') return Math.PI * scale * scale;
  if (shape === 'ellipse') return Math.PI * a * b * scale * scale;
  if (shape === 'square') return 4 * scale * scale;
  if (shape === 'diamond') return 2 * scale * scale;
  if (shape === 'hexagon') return 3 * Math.sqrt(3) / 2 * scale * scale;
  return 0;
}

const volume = shapeVolume();
minkData = { shape, scale, volume };

// Draw lattice
if (showLattice) {
  ctx.strokeStyle = gridC();
  ctx.lineWidth = 0.5;
  for (let x = -R; x <= R; x++) {
    ctx.beginPath();
    ctx.moveTo(cx + x * gridScale, cy - R * gridScale);
    ctx.lineTo(cx + x * gridScale, cy + R * gridScale);
    ctx.stroke();
  }
  for (let y = -R; y <= R; y++) {
    ctx.beginPath();
    ctx.moveTo(cx - R * gridScale, cy + y * gridScale);
    ctx.lineTo(cx + R * gridScale, cy + y * gridScale);
    ctx.stroke();
  }
}

// Draw shape
ctx.strokeStyle = '#ffd700';
ctx.lineWidth = 3;
ctx.fillStyle = showHighlight ? 'rgba(255,215,0,0.15)' : 'transparent';

if (shape === 'circle') {
  ctx.beginPath();
  ctx.arc(cx, cy, scale * gridScale, 0, 2 * Math.PI);
  ctx.fill();
  ctx.stroke();
} else if (shape === 'ellipse') {
  ctx.beginPath();
  ctx.ellipse(cx, cy, a * scale * gridScale, b * scale * gridScale, 0, 0, 2 * Math.PI);
  ctx.fill();
  ctx.stroke();
} else if (shape === 'square') {
  ctx.fillRect(cx - scale * gridScale, cy - scale * gridScale, 2 * scale * gridScale, 2 * scale * gridScale);
  ctx.strokeRect(cx - scale * gridScale, cy - scale * gridScale, 2 * scale * gridScale, 2 * scale * gridScale);
} else if (shape === 'diamond') {
  ctx.beginPath();
  ctx.moveTo(cx, cy - scale * gridScale);
  ctx.lineTo(cx + scale * gridScale, cy);
  ctx.lineTo(cx, cy + scale * gridScale);
  ctx.lineTo(cx - scale * gridScale, cy);
  ctx.closePath();
  ctx.fill();
  ctx.stroke();
} else if (shape === 'hexagon') {
  ctx.beginPath();
  for (let i = 0; i < 6; i++) {
    const angle = i * Math.PI / 3;
    const x = cx + scale * gridScale * Math.cos(angle);
    const y = cy + scale * gridScale * Math.sin(angle);
    if (i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
  }
  ctx.closePath();
  ctx.fill();
  ctx.stroke();
}

// Draw lattice points and count interior
let interiorCount = 0, boundaryCount = 0, primCount = 0;
for (let x = -R; x <= R; x++) {
  for (let y = -R; y <= R; y++) {
    if (x === 0 && y === 0) continue;
    const inside = insideShape(x, y);
    const isPrim = gcd(Math.abs(x), Math.abs(y)) === 1;
    
    if (primOnly && !isPrim) continue;
    
    if (inside) {
      interiorCount++;
      if (isPrim) primCount++;
    }
    
    const px = cx + x * gridScale, py = cy - y * gridScale;
    ctx.fillStyle = inside ? (isPrim ? '#00ff88' : '#00d9ff') : '#444';
    ctx.beginPath();
    ctx.arc(px, py, inside ? 5 : 3, 0, 2 * Math.PI);
    ctx.fill();
  }
}

// Origin
ctx.fillStyle = '#ff6496';
ctx.beginPath();
ctx.arc(cx, cy, 6, 0, 2 * Math.PI);
ctx.fill();

ctx.fillStyle = isDark() ? '#ffd700' : '#cc8800';
ctx.font = 'bold 14px Segoe UI';
ctx.textAlign = 'center';
ctx.fillText(`Minkowski's Theorem — ${shape.charAt(0).toUpperCase() + shape.slice(1)}, scale=${scale}`, c.width / 2, 25);

const theoremSatisfied = volume > 4;

document.getElementById('minkLiveStats').innerHTML = `
<div style="display:grid;grid-template-columns:repeat(3,1fr);gap:8px;margin-bottom:12px">
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center"><div style="font-size:1.1rem;font-weight:bold;color:#ffd700">${volume.toFixed(3)}</div><div style="font-size:.7rem;color:var(--txt2)">VOLUME</div></div>
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center"><div style="font-size:1.1rem;font-weight:bold;color:#00ff88">${interiorCount}</div><div style="font-size:.7rem;color:var(--txt2)">INTERIOR</div></div>
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center"><div style="font-size:1.1rem;font-weight:bold;color:#00d9ff">${primCount}</div><div style="font-size:.7rem;color:var(--txt2)">PRIMITIVE</div></div>
</div>
<div style="padding:8px;border-radius:6px;background:${theoremSatisfied ? 'rgba(0,255,136,.15)' : 'rgba(255,100,150,.15)'}">
<strong style="color:${theoremSatisfied ? '#00ff88' : '#ff6496'}">
Theorem: ${theoremSatisfied ? 'GUARANTEED' : 'Not guaranteed'} lattice point
</strong>
<div style="font-size:.75rem;color:var(--txt2);margin-top:4px">
Volume ${volume.toFixed(3)} ${theoremSatisfied ? '>' : '≤'} 4 = 2²
</div>
</div>`;

document.getElementById('minkAnalysis').innerHTML = `
<strong style="color:#9664ff">Minkowski's Convex Body Theorem</strong>
<div style="font-size:.8rem;margin-top:6px;color:var(--txt2)">
If S ⊂ ℝⁿ is convex, symmetric about origin, and Vol(S) > 2ⁿ,<br>
then S contains a nonzero integer lattice point.<br><br>
<strong>Current:</strong> Vol = ${volume.toFixed(3)}, need > 4 for guarantee
</div>`;
}

function animateMinkowski() {
  if (minkAnimId) { clearInterval(minkAnimId); minkAnimId = null; document.getElementById('minkAnimBtn').textContent = 'Animate Scale'; return; }
  document.getElementById('minkAnimBtn').textContent = 'Stop';
  let s = 0.5, dir = 0.1;
  minkAnimId = setInterval(() => {
    document.getElementById('minkScale').value = s;
    document.getElementById('minkScaleV').value = s.toFixed(1);
    drawMinkowski();
    s += dir;
    if (s >= 4) dir = -0.1;
    if (s <= 0.5) dir = 0.1;
  }, 100);
}

async function screenshotMinkowski() { await screenshotUnified('cminkowski', 'minkLiveStats', "Minkowski's Theorem", 'minkowski.png'); }
function resizeMinkCanvas() { const sz = document.getElementById('minkCanvSz')?.value || '700x700'; const [w, h] = sz.split('x').map(Number); const c = document.getElementById('cminkowski'); c.width = w; c.height = h; drawMinkowski(); }

// ==================== WHEEL FACTORIZATION ====================
let wheelData = {};

function drawWheel() {
const base = +document.getElementById('wheelBase')?.value || 30;
const maxN = +document.getElementById('wheelN')?.value || 200;
const viz = document.getElementById('wheelViz')?.value || 'wheel';
const showPrimes = document.getElementById('wheelPrimes')?.checked !== false;
const showSpokes = document.getElementById('wheelSpokes')?.checked !== false;

const c = document.getElementById('cwheel'), ctx = c.getContext('2d');
ctx.fillStyle = canvBg(); ctx.fillRect(0, 0, c.width, c.height);

// Find coprimes to base (wheel spokes)
const spokes = [];
for (let r = 1; r < base; r++) {
  if (gcd(r, base) === 1) spokes.push(r);
}
wheelData = { base, spokes, maxN };

const cx = c.width / 2, cy = c.height / 2;
const radius = Math.min(c.width, c.height) / 2.5;

if (viz === 'wheel') {
  // Draw wheel diagram
  const numSpokes = spokes.length;
  
  // Draw concentric circles for each revolution
  const revolutions = Math.ceil(maxN / base);
  ctx.strokeStyle = gridC();
  ctx.lineWidth = 0.5;
  for (let rev = 1; rev <= Math.min(revolutions, 10); rev++) {
    ctx.beginPath();
    ctx.arc(cx, cy, radius * rev / Math.min(revolutions, 10), 0, 2 * Math.PI);
    ctx.stroke();
  }
  
  // Draw spokes
  if (showSpokes) {
    ctx.strokeStyle = 'rgba(255,215,0,0.3)';
    ctx.lineWidth = 1;
    spokes.forEach((r, i) => {
      const angle = (i / numSpokes) * 2 * Math.PI - Math.PI / 2;
      ctx.beginPath();
      ctx.moveTo(cx, cy);
      ctx.lineTo(cx + radius * Math.cos(angle), cy + radius * Math.sin(angle));
      ctx.stroke();
    });
  }
  
  // Plot numbers on spokes
  for (let n = 1; n <= maxN; n++) {
    const r = n % base;
    const spokeIdx = spokes.indexOf(r);
    if (spokeIdx === -1) continue; // Not coprime to base
    
    const rev = Math.floor(n / base);
    const angle = (spokeIdx / numSpokes) * 2 * Math.PI - Math.PI / 2;
    const dist = (rev + 1) / (Math.ceil(maxN / base) + 1) * radius;
    
    const x = cx + dist * Math.cos(angle);
    const y = cy + dist * Math.sin(angle);
    
    const prime = isPrime(n);
    ctx.fillStyle = prime ? '#00ff88' : (showPrimes ? '#444' : `hsl(${(spokeIdx * 360 / numSpokes)}, 60%, 50%)`);
    ctx.beginPath();
    ctx.arc(x, y, prime ? 5 : 3, 0, 2 * Math.PI);
    ctx.fill();
  }
  
  // Label spokes
  ctx.fillStyle = isDark() ? '#ffd700' : '#cc8800';
  ctx.font = '10px Segoe UI';
  ctx.textAlign = 'center';
  spokes.forEach((r, i) => {
    const angle = (i / numSpokes) * 2 * Math.PI - Math.PI / 2;
    const x = cx + (radius + 20) * Math.cos(angle);
    const y = cy + (radius + 20) * Math.sin(angle);
    ctx.fillText(r.toString(), x, y + 3);
  });
} else if (viz === 'sieve') {
  // Grid showing sieve
  const cols = base;
  const rows = Math.ceil(maxN / base);
  const cellW = (c.width - 60) / cols;
  const cellH = Math.min(20, (c.height - 100) / rows);
  
  for (let n = 1; n <= maxN; n++) {
    const col = (n - 1) % base;
    const row = Math.floor((n - 1) / base);
    const x = 30 + col * cellW;
    const y = 50 + row * cellH;
    
    const onWheel = gcd(n, base) === 1 || n <= Math.max(...spokes);
    const prime = isPrime(n);
    
    if (!onWheel && n > 1) {
      ctx.fillStyle = '#222';
    } else if (prime) {
      ctx.fillStyle = '#00ff88';
    } else {
      ctx.fillStyle = '#444';
    }
    
    ctx.fillRect(x, y, cellW - 1, cellH - 1);
  }
  
  // Column labels
  ctx.fillStyle = isDark() ? '#888' : '#666';
  ctx.font = '8px Segoe UI';
  ctx.textAlign = 'center';
  for (let col = 0; col < base; col++) {
    const onWheel = gcd(col === 0 ? base : col, base) === 1;
    ctx.fillStyle = onWheel ? '#ffd700' : '#444';
    ctx.fillText((col === 0 ? base : col).toString(), 30 + col * cellW + cellW / 2, 45);
  }
} else if (viz === 'density') {
  // Compare density of primes on each spoke
  const spokePrimeCounts = spokes.map(r => {
    let count = 0;
    for (let k = 0; k * base + r <= maxN; k++) {
      if (isPrime(k * base + r)) count++;
    }
    return { r, count };
  });
  
  const maxCount = Math.max(...spokePrimeCounts.map(s => s.count));
  const barW = (c.width - 80) / spokes.length;
  
  spokePrimeCounts.forEach((s, i) => {
    const x = 40 + i * barW;
    const barH = (s.count / maxCount) * (c.height - 150);
    ctx.fillStyle = `hsl(${i * 360 / spokes.length}, 70%, 50%)`;
    ctx.fillRect(x, c.height - 50 - barH, barW - 2, barH);
    
    ctx.fillStyle = isDark() ? '#fff' : '#000';
    ctx.font = '9px Segoe UI';
    ctx.textAlign = 'center';
    ctx.fillText(s.r.toString(), x + barW / 2, c.height - 35);
    ctx.fillText(s.count.toString(), x + barW / 2, c.height - 55 - barH);
  });
}

ctx.fillStyle = isDark() ? '#ffd700' : '#cc8800';
ctx.font = 'bold 14px Segoe UI';
ctx.textAlign = 'center';
ctx.fillText(`Wheel Factorization — Base ${base} = ${factorize(base)}`, c.width / 2, 25);

// Stats
const totalOnWheel = spokes.length;
const efficiency = (1 - totalOnWheel / base) * 100;
const primesOnWheel = spokes.reduce((sum, r) => {
  for (let k = 0; k * base + r <= maxN; k++) {
    if (isPrime(k * base + r)) sum++;
  }
  return sum;
}, 0);

document.getElementById('wheelLiveStats').innerHTML = `
<div style="display:grid;grid-template-columns:repeat(3,1fr);gap:8px;margin-bottom:12px">
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center"><div style="font-size:1.3rem;font-weight:bold;color:#ffd700">${base}</div><div style="font-size:.7rem;color:var(--txt2)">WHEEL BASE</div></div>
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center"><div style="font-size:1.3rem;font-weight:bold;color:#00ff88">${totalOnWheel}</div><div style="font-size:.7rem;color:var(--txt2)">SPOKES φ(${base})</div></div>
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center"><div style="font-size:1.3rem;font-weight:bold;color:#00d9ff">${efficiency.toFixed(1)}%</div><div style="font-size:.7rem;color:var(--txt2)">SKIP RATE</div></div>
</div>
<div style="font-size:.8rem;color:var(--txt2)">
<strong style="color:var(--acc)">Principle:</strong> Only check n where gcd(n, base) = 1<br>
<strong style="color:var(--acc)">Efficiency:</strong> Skip ${base - totalOnWheel} of every ${base} numbers<br>
<strong style="color:var(--acc)">Primes found:</strong> ${primesOnWheel} in range [1, ${maxN}]
</div>`;

document.getElementById('wheelSpokesInfo').innerHTML = `
<strong style="color:#ffd700">Coprime Residues mod ${base}:</strong><br>
<div style="display:flex;flex-wrap:wrap;gap:4px;margin-top:6px">
${spokes.map(r => `<span style="background:var(--bg1);padding:3px 8px;border-radius:4px;color:#00ff88">${r}</span>`).join('')}
</div>
<div style="margin-top:10px;font-size:.75rem;color:var(--txt2)">
These ${totalOnWheel} residue classes contain all primes > ${Math.max(...factorizeToArray(base))}
</div>`;
}

function factorize(n) {
  let result = '', temp = n;
  for (let p = 2; p * p <= temp; p++) {
    if (temp % p === 0) {
      result += (result ? '×' : '') + p;
      while (temp % p === 0) temp /= p;
    }
  }
  if (temp > 1) result += (result ? '×' : '') + temp;
  return result || n.toString();
}

function factorizeToArray(n) {
  const factors = [];
  for (let p = 2; p * p <= n; p++) {
    if (n % p === 0) {
      factors.push(p);
      while (n % p === 0) n /= p;
    }
  }
  if (n > 1) factors.push(n);
  return factors;
}

async function screenshotWheel() { await screenshotUnified('cwheel', 'wheelLiveStats', 'Wheel Factorization', 'wheel.png'); }
function resizeWheelCanvas() { const sz = document.getElementById('wheelCanvSz')?.value || '700x700'; const [w, h] = sz.split('x').map(Number); const c = document.getElementById('cwheel'); c.width = w; c.height = h; drawWheel(); }
function csvWheel() {
  let csv = `wheel_base,${wheelData.base}\nspokes,${wheelData.spokes.join(';')}\n\nn,on_wheel,is_prime,spoke\n`;
  for (let n = 1; n <= wheelData.maxN; n++) {
    const r = n % wheelData.base;
    const onWheel = wheelData.spokes.includes(r) || n <= Math.max(...wheelData.spokes);
    csv += `${n},${onWheel},${isPrime(n)},${r}\n`;
  }
  dl(csv, 'wheel_factorization.csv');
}

// ==================== NINE IMAGINARY QUADRATIC FIELDS ====================
const HEEGNER_NUMBERS = [1, 2, 3, 7, 11, 19, 43, 67, 163];
const HEEGNER_NAMES = {
  1: 'Gaussian ℤ[i]', 2: 'ℤ[√-2]', 3: 'Eisenstein ℤ[ω]',
  7: 'ℤ[√-7]', 11: 'ℤ[√-11]', 19: 'ℤ[√-19]',
  43: 'ℤ[√-43]', 67: 'ℤ[√-67]', 163: 'ℤ[√-163]'
};
const HEEGNER_COLORS = {
  1: '#ffd700', 2: '#00d9ff', 3: '#00ff88', 7: '#ff6496',
  11: '#9664ff', 19: '#ff8c00', 43: '#ff00ff', 67: '#00ffff', 163: '#ff4444'
};
let nfData = [];
let nfZoomFactor = 1;

function nfZoom(factor) {
  if (factor === 1) {
    nfZoomFactor = 1;
  } else {
    nfZoomFactor *= factor;
    nfZoomFactor = Math.max(0.2, Math.min(5, nfZoomFactor));
  }
  document.getElementById('nfZoomLevel').textContent = Math.round(nfZoomFactor * 100) + '%';
  drawNineFields();
}
let nfSweepAnim = null;

function setNineField(d) {
  if (d === 'all') {
    document.getElementById('nfDiscriminant').value = 'all';
  } else {
    document.getElementById('nfDiscriminant').value = d;
  }
  drawNineFields();
}

function setNFSectorRange(from, to) {
  document.getElementById('nfSectorFrom').value = from;
  document.getElementById('nfSectorFromV').value = from;
  document.getElementById('nfSectorTo').value = to;
  document.getElementById('nfSectorToV').value = to;
  document.getElementById('nfSectorEnable').checked = true;
  drawNineFields();
}

let nf3DAnimId = null;
function toggleNF3DRotation() {
  const checkbox = document.getElementById('nfAnimate3D');
  if (checkbox && checkbox.checked) {
    function animate() {
      const rotY = document.getElementById('nfRotY');
      let val = (+rotY.value + 1) % 360;
      rotY.value = val;
      document.getElementById('nfRotYV').value = val;
      drawNineFields();
      nf3DAnimId = requestAnimationFrame(animate);
    }
    animate();
  } else {
    if (nf3DAnimId) cancelAnimationFrame(nf3DAnimId);
    nf3DAnimId = null;
  }
}

function nfNorm(a, b, d) { return a * a + d * b * b; }

function nfIsPrimeNorm(n, d) {
  if (n < 2) return false;
  if (!isPrime(n)) return false;
  // Check if prime splits in ℚ(√-d)
  if (d === 1) return n === 2 || n % 4 === 1;
  if (d === 2) return n === 2 || n % 8 === 1 || n % 8 === 3;
  if (d === 3) return n === 3 || n % 3 === 1;
  // General: use Legendre symbol (-d/p)
  return legendreSymbol(-d, n) === 1 || n === d;
}

function legendreSymbol(a, p) {
  if (p === 2) return 0;
  a = ((a % p) + p) % p;
  if (a === 0) return 0;
  let result = 1;
  while (a !== 0) {
    while (a % 2 === 0) {
      a /= 2;
      if (p % 8 === 3 || p % 8 === 5) result = -result;
    }
    [a, p] = [p, a];
    if (a % 4 === 3 && p % 4 === 3) result = -result;
    a = a % p;
  }
  return p === 1 ? result : 0;
}

function generateFieldPoints(d, maxNorm) {
  const points = [];
  const maxB = Math.ceil(Math.sqrt(maxNorm / d));
  const maxA = Math.ceil(Math.sqrt(maxNorm));
  for (let b = 0; b <= maxB; b++) {
    for (let a = (b === 0 ? 1 : -maxA); a <= maxA; a++) {
      const norm = nfNorm(a, b, d);
      if (norm > 0 && norm <= maxNorm) {
        points.push({
          a, b, d, norm,
          isPrimeNorm: isPrime(norm),
          isSplit: nfIsPrimeNorm(norm, d),
          coprime: b === 0 ? true : gcd(Math.abs(a), b) === 1
        });
      }
    }
  }
  return points.sort((x, y) => x.norm - y.norm);
}

function drawNineFields() {
  try {
    const c = document.getElementById('cninefields');
    const ctx = c.getContext('2d');
    const dVal = document.getElementById('nfDiscriminant').value;
    const maxNorm = +document.getElementById('nfMaxNormV').value || 100;
    const viz = document.getElementById('nfViz').value;
    const colorBy = document.getElementById('nfColor').value;
    const ptSz = +document.getElementById('nfPtSzV')?.value || +document.getElementById('nfPtSz').value || 5;
    const showLabels = document.getElementById('nfLabels').checked;
    const showAxes = document.getElementById('nfAxes').checked;
    const showGrid = document.getElementById('nfGrid').checked;
    const showNormCircles = document.getElementById('nfNormCircles').checked;
    const showUnitCircle = document.getElementById('nfUnitCircle')?.checked || false;
    const sectorEnable = document.getElementById('nfSectorEnable').checked;
    const sectorFrom = +document.getElementById('nfSectorFromV')?.value || +document.getElementById('nfSectorFrom').value || 3;
    const sectorTo = +document.getElementById('nfSectorToV')?.value || +document.getElementById('nfSectorTo').value || 2;
    const offX = +document.getElementById('nfOffXV')?.value || 0;
    const offY = +document.getElementById('nfOffYV')?.value || 0;
    const formType = document.querySelector('input[name="nfForm"]:checked')?.value || 'classical';
    
    ctx.fillStyle = canvBg();
    ctx.fillRect(0, 0, c.width, c.height);
    
    const cx = c.width / 2 + offX, cy = c.height / 2 + offY;
    const fields = dVal === 'all' ? HEEGNER_NUMBERS : [+dVal];
    
    // Generate all data
    nfData = [];
    for (const d of fields) {
      const pts = generateFieldPoints(d, maxNorm);
      nfData.push({ d, points: pts, name: HEEGNER_NAMES[d], color: HEEGNER_COLORS[d] });
    }
    
    // Update field label
    if (dVal === 'all') {
      document.getElementById('nfFieldLabel').textContent = 'All 9 Heegner Fields';
    } else {
      document.getElementById('nfFieldLabel').textContent = `ℚ(√-${dVal}) — ${HEEGNER_NAMES[+dVal]}`;
    }
    
    // Draw based on visualization mode
    if (viz === '2d') {
      draw2DFieldLattice(ctx, c, nfData, maxNorm, colorBy, ptSz, showLabels, showAxes, showGrid, showNormCircles, sectorEnable, sectorFrom, sectorTo, showUnitCircle, formType);
    } else if (viz === '3d') {
      draw3DFieldLattice(ctx, c, nfData, maxNorm, colorBy, ptSz, showLabels, showAxes);
    } else if (viz === 'norms') {
      drawNormDistribution(ctx, c, nfData, maxNorm, colorBy);
    } else if (viz === 'sieve') {
      drawSieveResidues(ctx, c, nfData, maxNorm, colorBy);
    } else if (viz === 'sectors') {
      drawSectorAnalysis(ctx, c, nfData, maxNorm, sectorFrom, sectorTo);
    } else if (viz === 'compare') {
      drawFieldComparison(ctx, c, nfData, maxNorm);
    } else if (viz === 'modular') {
      drawModularView(ctx, c, nfData, maxNorm, colorBy, ptSz);
    } else if (viz === 'splitting') {
      drawSplittingDiagram(ctx, c, nfData, maxNorm);
    } else if (viz === 'upperhalf') {
      drawUpperHalfPlane(ctx, c, nfData, maxNorm, colorBy, ptSz);
    }
    
    // Update all statistics panels
    updateNFStats(nfData, maxNorm, sectorEnable, sectorFrom, sectorTo, formType);
    drawNFNormDistChart();
    drawNFCompareChart();
    updateNFTwinAnalysis(nfData);
    updateNFModularData(nfData, formType);
    
    // Click handler
    c.onclick = e => {
      const rect = c.getBoundingClientRect();
      const mx = (e.clientX - rect.left) * (c.width / rect.width);
      const my = (e.clientY - rect.top) * (c.height / rect.height);
      handleNFClick(mx, my, c, nfData, viz, maxNorm);
    };
    
  } catch (e) { console.error('drawNineFields error:', e); }
}

function draw2DFieldLattice(ctx, c, data, maxNorm, colorBy, ptSz, showLabels, showAxes, showGrid, showNormCircles, sectorEnable, sectorFrom, sectorTo, showUnitCircle, formType) {
  const offX = +document.getElementById('nfOffXV')?.value || 0;
  const offY = +document.getElementById('nfOffYV')?.value || 0;
  const cx = c.width / 2 + offX, cy = c.height / 2 + offY;
  const maxB = Math.ceil(Math.sqrt(maxNorm / Math.min(...data.map(f => f.d))));
  const maxA = Math.ceil(Math.sqrt(maxNorm));
  const baseScale = Math.min(c.width, c.height) / (2 * Math.max(maxA, maxB) * 1.2);
  const scale = baseScale * nfZoomFactor;
  const lblSz = +document.getElementById('nfLblSzV')?.value || 9;
  const sectorColorMode = document.getElementById('nfSectorColor')?.value || 'preserve';
  const sectorOp = +document.getElementById('nfSectorOp')?.value || 0.15;
  const minNorm = +document.getElementById('nfMinNormV')?.value || 1;
  const filter = document.getElementById('nfFilter')?.value || 'all';
  const halfPlane = document.getElementById('nfHalfPlane')?.value || 'both';
  
  // Draw grid
  if (showGrid) {
    ctx.strokeStyle = gridC();
    ctx.lineWidth = 0.5;
    for (let i = -maxA; i <= maxA; i++) {
      ctx.beginPath(); ctx.moveTo(cx + i * scale, 0); ctx.lineTo(cx + i * scale, c.height); ctx.stroke();
    }
    for (let j = -maxB; j <= maxB; j++) {
      ctx.beginPath(); ctx.moveTo(0, cy - j * scale); ctx.lineTo(c.width, cy - j * scale); ctx.stroke();
    }
  }
  
  // Draw axes
  if (showAxes) {
    ctx.strokeStyle = bordC();
    ctx.lineWidth = 2;
    ctx.beginPath(); ctx.moveTo(0, cy); ctx.lineTo(c.width, cy); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(cx, 0); ctx.lineTo(cx, c.height); ctx.stroke();
    ctx.fillStyle = isDark() ? '#fff' : '#000';
    ctx.font = '12px Segoe UI';
    ctx.fillText('a (real)', c.width - 50, cy - 10);
    ctx.fillText('b (√-d)', cx + 10, 20);
  }
  
  // Draw norm circles
  if (showNormCircles) {
    ctx.setLineDash([4, 4]);
    for (let n = 10; n <= maxNorm; n += 10) {
      const r = Math.sqrt(n) * scale;
      ctx.strokeStyle = `hsla(${(n / maxNorm) * 240}, 60%, 50%, 0.3)`;
      ctx.lineWidth = 1;
      ctx.beginPath(); ctx.arc(cx, cy, r, 0, 2 * Math.PI); ctx.stroke();
    }
    ctx.setLineDash([]);
  }
  
  // Draw unit circle if enabled
  if (showUnitCircle) {
    ctx.strokeStyle = '#ff6496';
    ctx.lineWidth = 2;
    ctx.setLineDash([6, 4]);
    ctx.beginPath();
    ctx.arc(cx, cy, scale, 0, 2 * Math.PI);
    ctx.stroke();
    ctx.setLineDash([]);
  }
  
  // Draw sector if enabled
  if (sectorEnable) {
    const angLo = Math.atan2(1, sectorFrom);
    const angHi = Math.atan2(1, sectorTo);
    const maxR = Math.sqrt(maxNorm) * scale * 1.2;
    
    ctx.fillStyle = `rgba(150, 100, 255, ${sectorOp})`;
    ctx.beginPath();
    ctx.moveTo(cx, cy);
    ctx.arc(cx, cy, maxR, -angHi, -angLo, false);
    ctx.closePath();
    ctx.fill();
    
    ctx.strokeStyle = '#ffd700';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(cx, cy);
    ctx.lineTo(cx + Math.cos(angLo) * maxR, cy - Math.sin(angLo) * maxR);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(cx, cy);
    ctx.lineTo(cx + Math.cos(angHi) * maxR, cy - Math.sin(angHi) * maxR);
    ctx.stroke();
  }
  
  // Draw points
  for (const field of data) {
    for (const pt of field.points) {
      // Apply filters
      if (pt.norm < minNorm) continue;
      if (filter === 'coprime' && !pt.coprime) continue;
      if (filter === 'prime' && !pt.isPrimeNorm) continue;
      if (filter === 'composite' && pt.isPrimeNorm) continue;
      if (filter === 'split' && !pt.isSplit) continue;
      
      // Half-plane filter
      if (halfPlane === 'upper' && pt.b < 0) continue;
      if (halfPlane === 'lower' && pt.b > 0) continue;
      if (halfPlane === 'right' && pt.a < 0) continue;
      if (halfPlane === 'left' && pt.a > 0) continue;
      
      const x = cx + pt.a * scale;
      const y = cy - pt.b * scale;
      
      // Check if point is in sector (for highlight mode)
      let inSector = true;
      if (sectorEnable) {
        const angle = Math.atan2(pt.b, pt.a);
        const angLo = Math.atan2(1, sectorFrom);
        const angHi = Math.atan2(1, sectorTo);
        inSector = angle >= angLo && angle <= angHi;
      }
      
      // Determine color based on colorBy scheme
      let clr;
      if (colorBy === 'norm') clr = `hsl(${(pt.norm / maxNorm) * 300}, 70%, 55%)`;
      else if (colorBy === 'prime') clr = pt.isPrimeNorm ? '#00ff88' : '#666';
      else if (colorBy === 'split') clr = pt.isSplit ? '#ffd700' : (pt.isPrimeNorm ? '#ff6496' : '#444');
      else if (colorBy === 'coprime') clr = pt.coprime ? '#00d9ff' : '#ff6496';
      else if (colorBy === 'gap') clr = isPrime(pt.norm) && isPrime(pt.norm + 2) ? '#00ff88' : '#666';
      else if (colorBy === 'field') clr = field.color;
      else if (colorBy === 'quadrant') {
        if (pt.a >= 0 && pt.b >= 0) clr = '#00ff88';
        else if (pt.a < 0 && pt.b >= 0) clr = '#ffd700';
        else if (pt.a < 0 && pt.b < 0) clr = '#ff6496';
        else clr = '#00d9ff';
      }
      else if (colorBy === 'parity') clr = (pt.a + pt.b) % 2 === 0 ? '#00ff88' : '#ff6496';
      else if (colorBy === 'halfplane') clr = pt.b >= 0 ? '#00d9ff' : '#ff6496';
      else clr = `hsl(${(pt.a + pt.b * 10 + pt.norm) % 360}, 70%, 55%)`;
      
      // Apply sector coloring mode
      if (sectorEnable) {
        if (sectorColorMode === 'highlight' && !inSector) {
          // Dim points outside sector
          ctx.globalAlpha = 0.2;
        } else if (sectorColorMode === 'inout') {
          // Simple inside/outside coloring
          clr = inSector ? '#ffd700' : '#444';
        }
        // 'preserve' mode keeps original color
      }
      
      ctx.fillStyle = clr;
      ctx.beginPath();
      ctx.arc(x, y, ptSz, 0, 2 * Math.PI);
      ctx.fill();
      ctx.globalAlpha = 1.0; // Reset alpha
      
      if (showLabels && pt.norm <= 30) {
        ctx.fillStyle = isDark() ? 'rgba(255,255,255,0.8)' : 'rgba(0,0,0,0.8)';
        ctx.font = `${lblSz}px Segoe UI`;
        ctx.textAlign = 'center';
        ctx.fillText(`${pt.norm}`, x, y - ptSz - 3);
      }
    }
  }
}

function draw3DFieldLattice(ctx, c, data, maxNorm, colorBy, ptSz, showLabels, showAxes) {
  const cx = c.width / 2, cy = c.height / 2;
  const rotX = (+document.getElementById('nfRotX').value || 30) * Math.PI / 180;
  const rotY = (+document.getElementById('nfRotY').value || 45) * Math.PI / 180;
  const rotZ = (+document.getElementById('nfRotZ').value || 0) * Math.PI / 180;
  
  const maxB = Math.ceil(Math.sqrt(maxNorm / Math.min(...data.map(f => f.d))));
  const maxA = Math.ceil(Math.sqrt(maxNorm));
  const scale = Math.min(c.width, c.height) / (4 * Math.max(maxA, maxB, Math.sqrt(maxNorm) / 3));
  
  function project(a, b, n) {
    // Normalize norm to reasonable height
    const z = n / maxNorm * 10;
    // Apply rotations
    let x1 = a, y1 = b, z1 = z;
    // Rotate X
    let y2 = y1 * Math.cos(rotX) - z1 * Math.sin(rotX);
    let z2 = y1 * Math.sin(rotX) + z1 * Math.cos(rotX);
    // Rotate Y
    let x3 = x1 * Math.cos(rotY) + z2 * Math.sin(rotY);
    let z3 = -x1 * Math.sin(rotY) + z2 * Math.cos(rotY);
    // Rotate Z
    let x4 = x3 * Math.cos(rotZ) - y2 * Math.sin(rotZ);
    let y4 = x3 * Math.sin(rotZ) + y2 * Math.cos(rotZ);
    
    return { x: cx + x4 * scale, y: cy - y4 * scale, z: z3 };
  }
  
  // Draw axes
  if (showAxes) {
    ctx.strokeStyle = '#ff6496'; ctx.lineWidth = 2;
    const ax = project(maxA, 0, 0);
    ctx.beginPath(); ctx.moveTo(cx, cy); ctx.lineTo(ax.x, ax.y); ctx.stroke();
    ctx.fillStyle = '#ff6496'; ctx.font = '12px Segoe UI';
    ctx.fillText('a', ax.x + 5, ax.y);
    
    ctx.strokeStyle = '#00ff88';
    const bx = project(0, maxB, 0);
    ctx.beginPath(); ctx.moveTo(cx, cy); ctx.lineTo(bx.x, bx.y); ctx.stroke();
    ctx.fillStyle = '#00ff88';
    ctx.fillText('b', bx.x + 5, bx.y);
    
    ctx.strokeStyle = '#ffd700';
    const nx = project(0, 0, maxNorm);
    ctx.beginPath(); ctx.moveTo(cx, cy); ctx.lineTo(nx.x, nx.y); ctx.stroke();
    ctx.fillStyle = '#ffd700';
    ctx.fillText('N', nx.x + 5, nx.y);
  }
  
  // Collect and sort by depth
  const allPts = [];
  for (const field of data) {
    for (const pt of field.points) {
      const proj = project(pt.a, pt.b, pt.norm);
      allPts.push({ ...pt, px: proj.x, py: proj.y, pz: proj.z, field });
    }
  }
  allPts.sort((a, b) => a.pz - b.pz);
  
  // Draw points
  for (const pt of allPts) {
    let clr;
    if (colorBy === 'norm') clr = `hsl(${(pt.norm / maxNorm) * 300}, 70%, 55%)`;
    else if (colorBy === 'prime') clr = pt.isPrimeNorm ? '#00ff88' : '#666';
    else if (colorBy === 'split') clr = pt.isSplit ? '#ffd700' : '#888';
    else if (colorBy === 'field') clr = pt.field.color;
    else clr = `hsl(${(pt.norm) % 360}, 70%, 55%)`;
    
    const depthFade = 0.3 + 0.7 * (pt.pz + 10) / 20;
    ctx.globalAlpha = Math.max(0.2, Math.min(1, depthFade));
    ctx.fillStyle = clr;
    ctx.beginPath();
    ctx.arc(pt.px, pt.py, ptSz * (0.5 + depthFade * 0.5), 0, 2 * Math.PI);
    ctx.fill();
  }
  ctx.globalAlpha = 1;
}

function drawNormDistribution(ctx, c, data, maxNorm, colorBy) {
  const margin = { t: 40, r: 30, b: 50, l: 60 };
  const w = c.width - margin.l - margin.r;
  const h = c.height - margin.t - margin.b;
  
  // Count norms
  const normCounts = {};
  for (const field of data) {
    for (const pt of field.points) {
      normCounts[pt.norm] = (normCounts[pt.norm] || 0) + 1;
    }
  }
  
  const norms = Object.keys(normCounts).map(Number).sort((a, b) => a - b);
  const maxCount = Math.max(...Object.values(normCounts));
  
  // Draw axes
  ctx.strokeStyle = bordC();
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(margin.l, margin.t);
  ctx.lineTo(margin.l, c.height - margin.b);
  ctx.lineTo(c.width - margin.r, c.height - margin.b);
  ctx.stroke();
  
  // Draw bars
  const barW = Math.max(2, w / norms.length - 1);
  for (let i = 0; i < norms.length; i++) {
    const n = norms[i];
    const count = normCounts[n];
    const x = margin.l + (i / norms.length) * w;
    const barH = (count / maxCount) * h;
    
    let clr;
    if (colorBy === 'prime') clr = isPrime(n) ? '#00ff88' : '#666';
    else clr = `hsl(${(n / maxNorm) * 300}, 70%, 55%)`;
    
    ctx.fillStyle = clr;
    ctx.fillRect(x, c.height - margin.b - barH, barW, barH);
  }
  
  // Labels
  ctx.fillStyle = isDark() ? '#fff' : '#000';
  ctx.font = '12px Segoe UI';
  ctx.textAlign = 'center';
  ctx.fillText('Norm Distribution', c.width / 2, 25);
  ctx.fillText('Norm Value', c.width / 2, c.height - 10);
  ctx.save();
  ctx.translate(20, c.height / 2);
  ctx.rotate(-Math.PI / 2);
  ctx.fillText('Count', 0, 0);
  ctx.restore();
}

function drawSieveResidues(ctx, c, data, maxNorm, colorBy) {
  const margin = { t: 40, r: 30, b: 50, l: 60 };
  const gridSize = Math.min(20, Math.ceil(Math.sqrt(maxNorm)));
  const cellW = (c.width - margin.l - margin.r) / gridSize;
  const cellH = (c.height - margin.t - margin.b) / gridSize;
  
  // For each modulus (small norms), show residue pattern
  const modulus = Math.min(30, Math.ceil(Math.sqrt(maxNorm / 2)));
  const residues = new Set();
  for (const field of data) {
    for (const pt of field.points) {
      if (pt.norm <= modulus * 2) {
        residues.add(pt.norm % modulus);
      }
    }
  }
  
  // Draw grid
  for (let r = 0; r < gridSize; r++) {
    for (let col = 0; col < gridSize; col++) {
      const n = r * gridSize + col + 1;
      const x = margin.l + col * cellW;
      const y = margin.t + r * cellH;
      
      const isNorm = data.some(f => f.points.some(p => p.norm === n));
      const isResidue = residues.has(n % modulus);
      
      if (isNorm) ctx.fillStyle = '#00ff88';
      else if (isResidue) ctx.fillStyle = 'rgba(255, 215, 0, 0.5)';
      else ctx.fillStyle = '#333';
      
      ctx.fillRect(x + 1, y + 1, cellW - 2, cellH - 2);
      
      if (cellW > 20) {
        ctx.fillStyle = isDark() ? '#fff' : '#000';
        ctx.font = '10px Segoe UI';
        ctx.textAlign = 'center';
        ctx.fillText(n, x + cellW / 2, y + cellH / 2 + 4);
      }
    }
  }
  
  ctx.fillStyle = isDark() ? '#fff' : '#000';
  ctx.font = '14px Segoe UI';
  ctx.textAlign = 'center';
  ctx.fillText(`Sieve Residues (mod ${modulus})`, c.width / 2, 25);
}

function drawSectorAnalysis(ctx, c, data, maxNorm, sectorFrom, sectorTo) {
  const cx = c.width / 2, cy = c.height / 2;
  const radius = Math.min(c.width, c.height) / 2 - 50;
  
  // Draw sectors for 1/1 to 1/12
  for (let n = 1; n <= 12; n++) {
    const angLo = Math.atan2(1, n + 1);
    const angHi = Math.atan2(1, n);
    
    const isHighlighted = n >= sectorTo && n <= sectorFrom;
    ctx.fillStyle = isHighlighted ? 'rgba(150, 100, 255, 0.3)' : 'rgba(100, 100, 100, 0.1)';
    ctx.beginPath();
    ctx.moveTo(cx, cy);
    ctx.arc(cx, cy, radius, -angHi, -angLo, false);
    ctx.closePath();
    ctx.fill();
    
    // Draw boundary
    ctx.strokeStyle = isHighlighted ? '#ffd700' : '#666';
    ctx.lineWidth = isHighlighted ? 2 : 1;
    ctx.beginPath();
    ctx.moveTo(cx, cy);
    ctx.lineTo(cx + Math.cos(angHi) * radius, cy - Math.sin(angHi) * radius);
    ctx.stroke();
    
    // Label
    const midAng = (angLo + angHi) / 2;
    ctx.fillStyle = isHighlighted ? '#ffd700' : '#888';
    ctx.font = '11px Segoe UI';
    ctx.textAlign = 'center';
    ctx.fillText(`S${n}`, cx + Math.cos(midAng) * (radius + 20), cy - Math.sin(midAng) * (radius + 20));
  }
  
  // Count points in highlighted sector
  const angLoRad = Math.atan2(1, sectorFrom);
  const angHiRad = Math.atan2(1, sectorTo);
  let sectorCount = 0, sectorPrime = 0;
  
  // Draw points
  const scale = radius / Math.sqrt(maxNorm);
  for (const field of data) {
    for (const pt of field.points) {
      if (pt.b < 0) continue;
      const r = Math.sqrt(pt.norm);
      const ang = Math.atan2(pt.b, pt.a);
      const x = cx + Math.cos(ang) * r * scale;
      const y = cy - Math.sin(ang) * r * scale;
      
      const inSector = ang >= angLoRad && ang <= angHiRad && pt.a > 0;
      if (inSector) {
        sectorCount++;
        if (pt.isPrimeNorm) sectorPrime++;
      }
      
      ctx.fillStyle = inSector ? (pt.isPrimeNorm ? '#00ff88' : '#ffd700') : '#666';
      ctx.beginPath();
      ctx.arc(x, y, inSector ? 5 : 3, 0, 2 * Math.PI);
      ctx.fill();
    }
  }
  
  // Update sector stats
  document.getElementById('nfSectorStats').innerHTML = `
    <div style="color:#9664ff;font-weight:bold">Sector S<sub>${sectorTo}</sub>: 1/${sectorFrom} → 1/${sectorTo}</div>
    <div style="margin-top:.5rem">Points in sector: <strong style="color:#ffd700">${sectorCount}</strong></div>
    <div>Prime norms: <strong style="color:#00ff88">${sectorPrime}</strong></div>
    <div>Prime density: <strong style="color:#00d9ff">${sectorCount > 0 ? (100 * sectorPrime / sectorCount).toFixed(1) : 0}%</strong></div>
  `;
}

function drawFieldComparison(ctx, c, data, maxNorm) {
  const margin = { t: 50, r: 30, b: 80, l: 70 };
  const w = c.width - margin.l - margin.r;
  const h = c.height - margin.t - margin.b;
  
  // Compare: count, prime norms, density for each field
  const stats = HEEGNER_NUMBERS.map(d => {
    const pts = generateFieldPoints(d, maxNorm);
    const primes = pts.filter(p => p.isPrimeNorm).length;
    return { d, count: pts.length, primes, density: primes / pts.length, color: HEEGNER_COLORS[d] };
  });
  
  const maxCount = Math.max(...stats.map(s => s.count));
  const barW = w / stats.length - 10;
  
  // Draw bars
  for (let i = 0; i < stats.length; i++) {
    const s = stats[i];
    const x = margin.l + i * (w / stats.length) + 5;
    const barH = (s.count / maxCount) * h;
    const primeH = (s.primes / maxCount) * h;
    
    // Total count bar
    ctx.fillStyle = s.color + '88';
    ctx.fillRect(x, c.height - margin.b - barH, barW, barH);
    
    // Prime norms portion
    ctx.fillStyle = s.color;
    ctx.fillRect(x, c.height - margin.b - primeH, barW, primeH);
    
    // Label
    ctx.fillStyle = isDark() ? '#fff' : '#000';
    ctx.font = '10px Segoe UI';
    ctx.textAlign = 'center';
    ctx.fillText(`d=${s.d}`, x + barW / 2, c.height - margin.b + 15);
    ctx.fillText(`${s.count}`, x + barW / 2, c.height - margin.b + 30);
    ctx.fillStyle = '#00ff88';
    ctx.fillText(`${s.primes}p`, x + barW / 2, c.height - margin.b + 45);
  }
  
  // Title
  ctx.fillStyle = isDark() ? '#fff' : '#000';
  ctx.font = '14px Segoe UI';
  ctx.textAlign = 'center';
  ctx.fillText(`Nine Fields Comparison (Max Norm: ${maxNorm})`, c.width / 2, 25);
  
  // Legend
  ctx.font = '11px Segoe UI';
  ctx.textAlign = 'left';
  ctx.fillText('Bar: Total points | Solid: Prime norms', margin.l, c.height - 10);
}

function updateNFStats(data, maxNorm, sectorEnable, sectorFrom, sectorTo, formType) {
  let totalPts = 0, totalPrimes = 0, totalSplit = 0, totalInert = 0, totalRamify = 0;
  let totalCoprime = 0, minNorm = Infinity, maxNormFound = 0;
  const normSet = new Set();
  const primeNormSet = new Set();
  let sumNorms = 0, q1Count = 0, q2Count = 0, q3Count = 0, q4Count = 0;
  
  for (const field of data) {
    totalPts += field.points.length;
    for (const pt of field.points) {
      normSet.add(pt.norm);
      sumNorms += pt.norm;
      if (pt.isPrimeNorm) { totalPrimes++; primeNormSet.add(pt.norm); }
      if (pt.isSplit) totalSplit++;
      if (pt.coprime) totalCoprime++;
      if (pt.norm < minNorm) minNorm = pt.norm;
      if (pt.norm > maxNormFound) maxNormFound = pt.norm;
      // Quadrant counting
      if (pt.a >= 0 && pt.b >= 0) q1Count++;
      else if (pt.a < 0 && pt.b >= 0) q2Count++;
      else if (pt.a < 0 && pt.b < 0) q3Count++;
      else q4Count++;
    }
  }
  
  const avgNorm = totalPts > 0 ? (sumNorms / totalPts).toFixed(1) : 0;
  const dVal = document.getElementById('nfDiscriminant').value;
  const fieldName = dVal === 'all' ? 'All 9 Heegner Fields' : `ℚ(√-${dVal})`;
  const formLabel = formType === 'modular' ? 'Modular Form' : 'Classical';
  
  // Count splitting behavior for current field
  const dNum = dVal === 'all' ? 3 : +dVal;
  const smallPrimes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47];
  let splitCount = 0, inertCount = 0, ramifyCount = 0;
  for (const p of smallPrimes) {
    if (p === dNum || (dNum === 1 && p === 2) || (dNum === 3 && p === 3)) ramifyCount++;
    else if (legendreSymbol(-dNum, p) === 1) splitCount++;
    else inertCount++;
  }
  
  document.getElementById('nfLiveStats').innerHTML = `
    <div style="background:linear-gradient(135deg,rgba(150,100,255,.15),rgba(0,217,255,.1));padding:8px;border-radius:8px;margin-bottom:10px;border:1px solid #9664ff">
      <div style="font-size:.65rem;color:var(--txt2);margin-bottom:4px">FIELD: ${fieldName} | FORM: ${formLabel} | CLASS №: 1</div>
      <div style="display:grid;grid-template-columns:repeat(4,1fr);gap:4px;font-size:.7rem">
        <span>Max Norm: <strong style="color:#00d9ff">${maxNorm}</strong></span>
        <span>Fields: <strong style="color:#ffd700">${data.length}</strong></span>
        <span>Zoom: <strong style="color:#00ff88">${Math.round(nfZoomFactor*100)}%</strong></span>
        <span>d = <strong style="color:#ff6496">${dNum}</strong></span>
      </div>
    </div>
    <div style="display:grid;grid-template-columns:repeat(3,1fr);gap:6px;font-size:.75rem;margin-bottom:8px">
      <div style="background:var(--bg1);padding:6px;border-radius:6px;text-align:center">
        <div style="font-size:1.2rem;font-weight:bold;color:#9664ff">${totalPts}</div>
        <div style="font-size:.6rem;color:var(--txt2)">LATTICE POINTS</div>
      </div>
      <div style="background:var(--bg1);padding:6px;border-radius:6px;text-align:center">
        <div style="font-size:1.2rem;font-weight:bold;color:#00ff88">${totalPrimes}</div>
        <div style="font-size:.6rem;color:var(--txt2)">PRIME NORMS</div>
      </div>
      <div style="background:var(--bg1);padding:6px;border-radius:6px;text-align:center">
        <div style="font-size:1.2rem;font-weight:bold;color:#ffd700">${normSet.size}</div>
        <div style="font-size:.6rem;color:var(--txt2)">UNIQUE NORMS</div>
      </div>
      <div style="background:var(--bg1);padding:6px;border-radius:6px;text-align:center">
        <div style="font-size:1.2rem;font-weight:bold;color:#00d9ff">${(100 * totalPrimes / totalPts).toFixed(1)}%</div>
        <div style="font-size:.6rem;color:var(--txt2)">PRIME DENSITY</div>
      </div>
      <div style="background:var(--bg1);padding:6px;border-radius:6px;text-align:center">
        <div style="font-size:1.2rem;font-weight:bold;color:#ff6496">${primeNormSet.size}</div>
        <div style="font-size:.6rem;color:var(--txt2)">DISTINCT PRIMES</div>
      </div>
      <div style="background:var(--bg1);padding:6px;border-radius:6px;text-align:center">
        <div style="font-size:1.2rem;font-weight:bold;color:#ffd700">${totalCoprime}</div>
        <div style="font-size:.6rem;color:var(--txt2)">COPRIME (a,b)</div>
      </div>
    </div>
    <div style="background:var(--bg1);padding:8px;border-radius:6px;margin-bottom:8px">
      <div style="font-size:.65rem;color:var(--txt2);margin-bottom:4px">NORM STATISTICS</div>
      <div style="display:grid;grid-template-columns:repeat(2,1fr);gap:4px;font-size:.7rem">
        <span>Min Norm: <strong style="color:#00ff88">${minNorm}</strong></span>
        <span>Max Norm: <strong style="color:#ff6496">${maxNormFound}</strong></span>
        <span>Avg Norm: <strong style="color:#ffd700">${avgNorm}</strong></span>
        <span>Coverage: <strong style="color:#00d9ff">${(100 * normSet.size / maxNorm).toFixed(1)}%</strong></span>
      </div>
    </div>
    <div style="background:var(--bg1);padding:8px;border-radius:6px;margin-bottom:8px">
      <div style="font-size:.65rem;color:var(--txt2);margin-bottom:4px">QUADRANT DISTRIBUTION</div>
      <div style="display:grid;grid-template-columns:repeat(4,1fr);gap:4px;font-size:.7rem">
        <span style="color:#00ff88">Q1: ${q1Count}</span>
        <span style="color:#ffd700">Q2: ${q2Count}</span>
        <span style="color:#ff6496">Q3: ${q3Count}</span>
        <span style="color:#00d9ff">Q4: ${q4Count}</span>
      </div>
    </div>
    <div style="background:var(--bg1);padding:8px;border-radius:6px">
      <div style="font-size:.65rem;color:var(--txt2);margin-bottom:4px">PRIME SPLITTING (p ≤ 47)</div>
      <div style="display:grid;grid-template-columns:repeat(3,1fr);gap:4px;font-size:.7rem">
        <span style="color:#00ff88">Splits: ${splitCount}</span>
        <span style="color:#ffd700">Inert: ${inertCount}</span>
        <span style="color:#ff6496">Ramify: ${ramifyCount}</span>
      </div>
    </div>
  `;
  
  // Prime splitting info - detailed
  let splitInfo = '<div style="font-size:.7rem">';
  splitInfo += `<strong style="color:#ffd700">ℚ(√-${dNum}) Prime Behavior:</strong><br>`;
  splitInfo += '<div style="display:flex;flex-wrap:wrap;gap:4px;margin-top:4px">';
  for (const p of smallPrimes) {
    const leg = legendreSymbol(-dNum, p);
    let behavior, color;
    if (p === dNum || (dNum === 1 && p === 2)) { behavior = 'R'; color = '#ff6496'; }
    else if (leg === 1) { behavior = 'S'; color = '#00ff88'; }
    else { behavior = 'I'; color = '#ffd700'; }
    splitInfo += `<span style="background:${color}22;color:${color};padding:2px 5px;border-radius:3px;font-size:.65rem">${p}:${behavior}</span>`;
  }
  splitInfo += '</div>';
  splitInfo += '<div style="margin-top:6px;font-size:.6rem;color:var(--txt2)">S=splits, I=inert, R=ramifies</div>';
  splitInfo += '</div>';
  document.getElementById('nfSplitting').innerHTML = splitInfo;
}

function drawNFNormDistChart() {
  const c = document.getElementById('cnfNormDist');
  if (!c) return;
  const ctx = c.getContext('2d');
  ctx.fillStyle = canvBg();
  ctx.fillRect(0, 0, c.width, c.height);
  
  const maxNorm = +document.getElementById('nfMaxNormV').value || 100;
  const dVal = document.getElementById('nfDiscriminant').value;
  const fields = dVal === 'all' ? HEEGNER_NUMBERS : [+dVal];
  
  // Count norms by field
  const margin = { t: 30, r: 20, b: 40, l: 50 };
  const w = c.width - margin.l - margin.r;
  const h = c.height - margin.t - margin.b;
  
  // Create histogram
  const bins = 20;
  const binWidth = maxNorm / bins;
  const histData = {};
  
  for (const d of fields) {
    histData[d] = new Array(bins).fill(0);
    const pts = generateFieldPoints(d, maxNorm);
    for (const pt of pts) {
      const bin = Math.min(bins - 1, Math.floor(pt.norm / binWidth));
      histData[d][bin]++;
    }
  }
  
  const maxCount = Math.max(...Object.values(histData).flat());
  const barW = w / bins / fields.length;
  
  // Draw bars
  for (let b = 0; b < bins; b++) {
    let offset = 0;
    for (const d of fields) {
      const count = histData[d][b];
      const x = margin.l + b * (w / bins) + offset;
      const barH = (count / maxCount) * h;
      
      ctx.fillStyle = HEEGNER_COLORS[d];
      ctx.fillRect(x, c.height - margin.b - barH, barW - 1, barH);
      offset += barW;
    }
  }
  
  // Axes
  ctx.strokeStyle = bordC();
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(margin.l, margin.t);
  ctx.lineTo(margin.l, c.height - margin.b);
  ctx.lineTo(c.width - margin.r, c.height - margin.b);
  ctx.stroke();
  
  ctx.fillStyle = isDark() ? '#fff' : '#000';
  ctx.font = '10px Segoe UI';
  ctx.textAlign = 'center';
  ctx.fillText('Norm', c.width / 2, c.height - 5);
}

function updateNFTwinAnalysis(data) {
  let html = '<div style="font-size:.75rem">';
  html += '<strong style="color:#00ff88">Twin Prime Norms (N, N+2 both prime):</strong><br>';
  
  const twinNorms = new Set();
  for (const field of data) {
    for (const pt of field.points) {
      if (pt.isPrimeNorm && isPrime(pt.norm + 2)) {
        twinNorms.add(pt.norm);
      }
    }
  }
  
  const sorted = [...twinNorms].sort((a, b) => a - b).slice(0, 20);
  html += sorted.map(n => `<span style="color:#ffd700">(${n}, ${n + 2})</span>`).join(', ');
  
  if (twinNorms.size > 20) html += ` ... +${twinNorms.size - 20} more`;
  
  html += `<br><br><strong>Twin count:</strong> ${twinNorms.size}`;
  html += '</div>';
  
  document.getElementById('nfTwinAnalysis').innerHTML = html;
}

function handleNFClick(mx, my, c, data, viz, maxNorm) {
  if (viz !== '2d' && viz !== '3d') return;
  
  const cx = c.width / 2, cy = c.height / 2;
  const maxB = Math.ceil(Math.sqrt(maxNorm / Math.min(...data.map(f => f.d))));
  const maxA = Math.ceil(Math.sqrt(maxNorm));
  const scale = Math.min(c.width, c.height) / (2 * Math.max(maxA, maxB) * 1.2);
  
  for (const field of data) {
    for (const pt of field.points) {
      const x = cx + pt.a * scale;
      const y = cy - pt.b * scale;
      
      if (Math.hypot(mx - x, my - y) < 12) {
        modal('Quadratic Field Point', [
          ['Field', `ℚ(√-${pt.d})`],
          ['Element', `${pt.a} + ${pt.b}√-${pt.d}`],
          ['Norm', `${pt.a}² + ${pt.d}×${pt.b}² = ${pt.norm}`],
          ['Prime Norm?', pt.isPrimeNorm ? 'Yes' : 'No'],
          ['Splits?', pt.isSplit ? 'Yes' : 'No'],
          ['Coprime (a,b)?', pt.coprime ? 'Yes' : 'No']
        ]);
        return;
      }
    }
  }
}

function animateNFSectorSweep() {
  if (nfSweepAnim) return;
  let from = 12;
  document.getElementById('nfSectorEnable').checked = true;
  
  nfSweepAnim = setInterval(() => {
    document.getElementById('nfSectorFrom').value = from;
    document.getElementById('nfSectorTo').value = from - 1;
    drawNineFields();
    from--;
    if (from < 2) from = 12;
  }, 800);
  
  document.getElementById('nfSweepBtn').textContent = 'Sweeping...';
  document.getElementById('nfSweepBtn').style.background = 'rgba(0,255,136,.3)';
}

function stopNFSectorSweep() {
  if (nfSweepAnim) {
    clearInterval(nfSweepAnim);
    nfSweepAnim = null;
  }
  document.getElementById('nfSweepBtn').textContent = 'Sector Sweep';
  document.getElementById('nfSweepBtn').style.background = 'rgba(255,215,0,.15)';
}

function resizeNFCanvas() {
  const sz = document.getElementById('nfCanvSz')?.value || '800x700';
  const [w, h] = sz.split('x').map(Number);
  const c = document.getElementById('cninefields');
  c.width = w; c.height = h;
  drawNineFields();
}

async function screenshotNineFields() {
  await screenshotUnified('cninefields', 'nfLiveStats', 'Nine Quadratic Fields', 'nine_fields.png');
}

function exportAllNineFields() {
  screenshotTabAll({ canvases: ['cninefields', 'cnfNormDist'], dashId: 'nfLiveStats', title: 'Nine Quadratic Fields', filename: 'nine_fields_all.png' });
}

function drawModularView(ctx, c, data, maxNorm, colorBy, ptSz) {
  const cx = c.width / 2, cy = c.height / 2;
  const radius = Math.min(c.width, c.height) / 2 - 60;
  
  ctx.fillStyle = isDark() ? '#fff' : '#000';
  ctx.font = '14px Segoe UI';
  ctx.textAlign = 'center';
  ctx.fillText('Modular Form View: Points on Fundamental Domain', c.width / 2, 25);
  
  // Draw fundamental domain boundary (unit semicircle + vertical lines)
  ctx.strokeStyle = '#9664ff';
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.arc(cx, cy, radius * 0.8, Math.PI, 0, false);
  ctx.stroke();
  ctx.beginPath();
  ctx.moveTo(cx - radius * 0.8, cy);
  ctx.lineTo(cx - radius * 0.8, cy - radius);
  ctx.moveTo(cx + radius * 0.8, cy);
  ctx.lineTo(cx + radius * 0.8, cy - radius);
  ctx.stroke();
  
  // Map points to fundamental domain
  for (const field of data) {
    for (const pt of field.points) {
      if (pt.b <= 0) continue;
      // τ = (a + √-d * b) / norm, map to upper half plane
      const tau_re = pt.a / pt.norm;
      const tau_im = Math.sqrt(field.d) * pt.b / pt.norm;
      
      // Transform to screen coordinates
      const x = cx + tau_re * radius * 2;
      const y = cy - tau_im * radius * 2;
      
      if (y < 20 || y > c.height - 20) continue;
      
      let clr = field.color;
      if (colorBy === 'prime') clr = pt.isPrimeNorm ? '#00ff88' : '#666';
      else if (colorBy === 'norm') clr = `hsl(${(pt.norm / maxNorm) * 300}, 70%, 55%)`;
      
      ctx.fillStyle = clr;
      ctx.beginPath();
      ctx.arc(x, y, ptSz, 0, 2 * Math.PI);
      ctx.fill();
    }
  }
  
  // Labels
  ctx.fillStyle = '#ffd700';
  ctx.font = '11px Segoe UI';
  ctx.fillText('τ = (a + b√-d) / N(α)', c.width / 2, c.height - 20);
}

function drawSplittingDiagram(ctx, c, data, maxNorm) {
  const margin = { t: 50, r: 30, b: 60, l: 70 };
  const w = c.width - margin.l - margin.r;
  const h = c.height - margin.t - margin.b;
  
  // Show splitting behavior for all 9 fields across first 30 primes
  const primes = [];
  for (let n = 2; primes.length < 30 && n < 150; n++) {
    if (isPrime(n)) primes.push(n);
  }
  
  const cellW = w / primes.length;
  const cellH = h / 9;
  
  // Draw grid
  for (let i = 0; i < 9; i++) {
    const d = HEEGNER_NUMBERS[i];
    const y = margin.t + i * cellH;
    
    // Field label
    ctx.fillStyle = HEEGNER_COLORS[d];
    ctx.font = '10px Segoe UI';
    ctx.textAlign = 'right';
    ctx.fillText(`d=${d}`, margin.l - 5, y + cellH / 2 + 4);
    
    for (let j = 0; j < primes.length; j++) {
      const p = primes[j];
      const x = margin.l + j * cellW;
      
      const leg = legendreSymbol(-d, p);
      let clr;
      if (p === d) clr = '#ff6496'; // ramifies
      else if (leg === 1) clr = '#00ff88'; // splits
      else clr = '#ffd700'; // inert
      
      ctx.fillStyle = clr;
      ctx.fillRect(x + 1, y + 1, cellW - 2, cellH - 2);
    }
  }
  
  // Prime labels at bottom
  ctx.fillStyle = isDark() ? '#fff' : '#000';
  ctx.font = '8px Segoe UI';
  ctx.textAlign = 'center';
  for (let j = 0; j < primes.length; j += 3) {
    ctx.fillText(primes[j], margin.l + j * cellW + cellW / 2, c.height - margin.b + 15);
  }
  
  // Title
  ctx.font = '14px Segoe UI';
  ctx.fillText('Prime Splitting Across All 9 Heegner Fields', c.width / 2, 25);
  
  // Legend
  ctx.font = '10px Segoe UI';
  ctx.fillStyle = '#00ff88'; ctx.fillText(' Splits', margin.l + 30, c.height - 10);
  ctx.fillStyle = '#ffd700'; ctx.fillText(' Inert', margin.l + 100, c.height - 10);
  ctx.fillStyle = '#ff6496'; ctx.fillText(' Ramifies', margin.l + 170, c.height - 10);
}

function drawUpperHalfPlane(ctx, c, data, maxNorm, colorBy, ptSz) {
  const cx = c.width / 2;
  const margin = { t: 60, b: 40 };
  const h = c.height - margin.t - margin.b;
  const w = c.width - 80;
  
  // Title
  ctx.fillStyle = isDark() ? '#fff' : '#000';
  ctx.font = '14px Segoe UI';
  ctx.textAlign = 'center';
  ctx.fillText('Upper Half-Plane ℍ: τ = a/N + (b√d)/N · i', c.width / 2, 25);
  ctx.font = '11px Segoe UI';
  ctx.fillStyle = '#9664ff';
  ctx.fillText('Points with b > 0 mapped to Im(τ) > 0', c.width / 2, 45);
  
  // Draw real axis
  ctx.strokeStyle = gridC();
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(40, c.height - margin.b);
  ctx.lineTo(c.width - 40, c.height - margin.b);
  ctx.stroke();
  
  // Draw unit circle arc (|τ| = 1)
  ctx.strokeStyle = '#ff6496';
  ctx.lineWidth = 1.5;
  ctx.setLineDash([4, 4]);
  ctx.beginPath();
  ctx.arc(cx, c.height - margin.b, h * 0.3, Math.PI, 0, false);
  ctx.stroke();
  ctx.setLineDash([]);
  
  // Draw vertical lines at x = -1/2 and x = 1/2 (fundamental domain)
  ctx.strokeStyle = '#ffd70088';
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(cx - h * 0.15, c.height - margin.b);
  ctx.lineTo(cx - h * 0.15, margin.t);
  ctx.moveTo(cx + h * 0.15, c.height - margin.b);
  ctx.lineTo(cx + h * 0.15, margin.t);
  ctx.stroke();
  
  // Map points: τ = (a + b√-d) / N where N = norm
  for (const field of data) {
    for (const pt of field.points) {
      if (pt.b <= 0) continue; // Upper half-plane only
      
      // τ = (a + b√-d) / N = a/N + i·b√d/N
      const re = pt.a / pt.norm;
      const im = pt.b * Math.sqrt(field.d) / pt.norm;
      
      // Scale to canvas
      const x = cx + re * w * 0.8;
      const y = c.height - margin.b - im * h * 3;
      
      if (y < margin.t - 10) continue;
      
      let clr = field.color;
      if (colorBy === 'prime') clr = pt.isPrimeNorm ? '#00ff88' : '#666';
      else if (colorBy === 'norm') clr = `hsl(${(pt.norm / maxNorm) * 300}, 70%, 55%)`;
      else if (colorBy === 'split') clr = pt.isSplit ? '#ffd700' : '#666';
      
      ctx.fillStyle = clr;
      ctx.beginPath();
      ctx.arc(x, y, ptSz, 0, 2 * Math.PI);
      ctx.fill();
    }
  }
  
  // Labels
  ctx.fillStyle = isDark() ? '#fff' : '#000';
  ctx.font = '10px Segoe UI';
  ctx.textAlign = 'center';
  ctx.fillText('Re(τ)', c.width / 2, c.height - 10);
  ctx.save();
  ctx.translate(15, c.height / 2);
  ctx.rotate(-Math.PI / 2);
  ctx.fillText('Im(τ)', 0, 0);
  ctx.restore();
  
  // Note about fundamental domain
  ctx.font = '9px Segoe UI';
  ctx.fillStyle = '#ffd700';
  ctx.fillText('Dashed: |τ|=1 | Yellow lines: Re(τ)=±½', c.width / 2, c.height - margin.b + 25);
}

function drawNFCompareChart() {
  const c = document.getElementById('cnfCompare');
  if (!c) return;
  const ctx = c.getContext('2d');
  ctx.fillStyle = canvBg();
  ctx.fillRect(0, 0, c.width, c.height);
  
  const maxNorm = +document.getElementById('nfMaxNormV').value || 100;
  const margin = { t: 25, r: 20, b: 35, l: 45 };
  const w = c.width - margin.l - margin.r;
  const h = c.height - margin.t - margin.b;
  
  // Gather stats for all 9 fields
  const stats = HEEGNER_NUMBERS.map(d => {
    const pts = generateFieldPoints(d, maxNorm);
    const primes = pts.filter(p => p.isPrimeNorm).length;
    return { d, count: pts.length, primes, density: pts.length > 0 ? primes / pts.length : 0 };
  });
  
  const maxCount = Math.max(...stats.map(s => s.count));
  const barW = w / 9 - 4;
  
  // Draw bars
  for (let i = 0; i < 9; i++) {
    const s = stats[i];
    const x = margin.l + i * (w / 9) + 2;
    const barH = maxCount > 0 ? (s.count / maxCount) * h : 0;
    
    ctx.fillStyle = HEEGNER_COLORS[s.d] + '88';
    ctx.fillRect(x, c.height - margin.b - barH, barW, barH);
    
    // Prime portion
    const primeH = maxCount > 0 ? (s.primes / maxCount) * h : 0;
    ctx.fillStyle = HEEGNER_COLORS[s.d];
    ctx.fillRect(x, c.height - margin.b - primeH, barW, primeH);
    
    // Label
    ctx.fillStyle = isDark() ? '#fff' : '#000';
    ctx.font = '8px Segoe UI';
    ctx.textAlign = 'center';
    ctx.fillText(s.d, x + barW / 2, c.height - margin.b + 12);
  }
  
  // Title
  ctx.font = '11px Segoe UI';
  ctx.fillText('Points by Field (solid=prime norms)', c.width / 2, 15);
}

function updateNFModularData(data, formType) {
  const el = document.getElementById('nfModularData');
  if (!el) return;
  
  const dVal = document.getElementById('nfDiscriminant').value;
  const d = dVal === 'all' ? 3 : +dVal;
  
  // j-invariants for CM points
  const jInvariants = {
    1: 1728, 2: 8000, 3: 0, 7: -3375,
    11: -32768, 19: -884736, 43: -884736000,
    67: -147197952000, 163: -262537412640768000
  };
  
  // Discriminants
  const disc = d % 4 === 3 ? -d : -4 * d;
  
  let html = '<div style="font-size:.75rem">';
  html += `<div style="margin-bottom:8px"><strong style="color:#9664ff">Field: ℚ(√-${d})</strong></div>`;
  html += `<div style="display:grid;grid-template-columns:1fr 1fr;gap:6px">`;
  html += `<span>Discriminant Δ: <strong style="color:#ffd700">${disc}</strong></span>`;
  html += `<span>Class Number: <strong style="color:#00ff88">1</strong></span>`;
  html += `<span>Ring of Integers: <strong style="color:#00d9ff">${d === 1 ? 'ℤ[i]' : d === 3 ? 'ℤ[ω]' : 'ℤ[√-' + d + ']'}</strong></span>`;
  html += `<span>Units: <strong style="color:#ff6496">${d === 1 ? '±1, ±i' : d === 3 ? '6 units' : '±1'}</strong></span>`;
  html += '</div>';
  
  if (formType === 'modular') {
    html += `<div style="margin-top:10px;padding:8px;background:rgba(150,100,255,.1);border-radius:6px">`;
    html += `<strong style="color:#9664ff">CM Point Data</strong><br>`;
    html += `<span style="font-size:.7rem">j-invariant: <strong style="color:#ffd700">${jInvariants[d]?.toLocaleString() || 'complex'}</strong></span><br>`;
    html += `<span style="font-size:.7rem">τ = ${d === 1 ? 'i' : d === 3 ? 'ω = e^(2πi/3)' : '√-' + d}</span>`;
    html += '</div>';
  }
  
  // Ramanujan constant for d=163
  if (d === 163) {
    html += `<div style="margin-top:8px;padding:6px;background:rgba(255,100,150,.1);border-radius:6px;font-size:.7rem">`;
    html += `<strong style="color:#ff6496">Ramanujan's Constant:</strong><br>`;
    html += `e<sup>π√163</sup> ≈ 262537412640768743.999999999999...`;
    html += '</div>';
  }
  
  html += '</div>';
  el.innerHTML = html;
}

function csvNineFields() {
  let csv = 'field_d,a,b,norm,is_prime_norm,splits,coprime\n';
  for (const field of nfData) {
    for (const pt of field.points) {
      csv += `${pt.d},${pt.a},${pt.b},${pt.norm},${pt.isPrimeNorm},${pt.isSplit},${pt.coprime}\n`;
    }
  }
  dl(csv, 'nine_quadratic_fields.csv');
}

// ==================== PYTHAGOREAN TRIPLES ====================
let pythagData = [];

function drawPythag() {
const maxC = +document.getElementById('pythCv').value || 100;
const mode = document.getElementById('pythMode').value;
const c = document.getElementById('cpyth'), ctx = c.getContext('2d');
ctx.fillStyle = canvBg(); ctx.fillRect(0, 0, c.width, c.height);

pythagData = [];
// Generate using parametrization: a = m²-n², b = 2mn, c = m²+n² for m>n>0, gcd(m,n)=1, m-n odd
for (let m = 2; m * m < maxC; m++) {
for (let n = 1; n < m; n++) {
if ((m - n) % 2 === 0) continue; // m-n must be odd
if (gcd(m, n) !== 1) continue;
let a = m * m - n * n;
let b = 2 * m * n;
let c_val = m * m + n * n;
if (c_val > maxC) continue;
if (a > b) [a, b] = [b, a];
pythagData.push({ a, b, c: c_val, m, n, primitive: true });
// Add non-primitive if mode is 'all'
if (mode === 'all') {
for (let k = 2; k * c_val <= maxC; k++) {
pythagData.push({ a: k * a, b: k * b, c: k * c_val, m, n, primitive: false });
}
}
}
}

// Sort by hypotenuse
pythagData.sort((x, y) => x.c - y.c);

// Draw
const pad = 50, w = c.width - 2 * pad, h = c.height - 2 * pad;
pythagData.slice(0, 200).forEach((t, i) => {
const x = pad + (t.a / maxC) * w;
const y = c.height - pad - (t.b / maxC) * h;
ctx.fillStyle = t.primitive ? '#ffd700' : '#666';
ctx.beginPath();
ctx.arc(x, y, t.primitive ? 5 : 3, 0, 2 * PI);
ctx.fill();
});

// Draw a²+b²=c² curve
ctx.strokeStyle = '#ff6496';
ctx.lineWidth = 1;
ctx.setLineDash([5, 5]);
for (let cVal = 10; cVal <= maxC; cVal += 20) {
ctx.beginPath();
for (let a = 1; a < cVal; a++) {
const b = Math.sqrt(cVal * cVal - a * a);
if (b > 0 && b < maxC) {
const x = pad + (a / maxC) * w;
const y = c.height - pad - (b / maxC) * h;
if (a === 1) ctx.moveTo(x, y);
else ctx.lineTo(x, y);
}
}
ctx.stroke();
}
ctx.setLineDash([]);

ctx.fillStyle = isDark() ? '#ffd700' : '#cc8800';
ctx.font = 'bold 14px Segoe UI';
ctx.textAlign = 'center';
ctx.fillText(`Pythagorean Triples a² + b² = c², c ≤ ${maxC}`, c.width / 2, 25);

const primCount = pythagData.filter(t => t.primitive).length;

document.getElementById('pythLiveStats').innerHTML = `
<div style="background:linear-gradient(135deg,rgba(255,215,0,.15),rgba(0,217,255,.1));padding:10px;border-radius:8px;margin-bottom:12px;border:1px solid #ffd700">
<div style="font-size:.7rem;color:var(--txt2);margin-bottom:4px">TAB: Pythagorean Triples | FIELD: ℤ³ | TYPE: a² + b² = c²</div>
</div>
<div style="display:grid;grid-template-columns:repeat(3,1fr);gap:8px;margin-bottom:12px">
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center"><div style="font-size:1.3rem;font-weight:bold;color:#ffd700">${primCount}</div><div style="font-size:.7rem;color:var(--txt2)">PRIMITIVE</div></div>
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center"><div style="font-size:1.3rem;font-weight:bold;color:#00d9ff">${pythagData.length}</div><div style="font-size:.7rem;color:var(--txt2)">TOTAL</div></div>
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center"><div style="font-size:1.3rem;font-weight:bold;color:#00ff88">${maxC}</div><div style="font-size:.7rem;color:var(--txt2)">MAX c</div></div>
</div>
<div style="font-size:.8rem;color:var(--txt2)">
<strong style="color:var(--acc)">First triples:</strong> ${pythagData.slice(0, 5).map(t => `(${t.a},${t.b},${t.c})`).join(', ')}<br>
<strong style="color:var(--acc)">Parametrization:</strong> a=m²-n², b=2mn, c=m²+n²<br>
<strong style="color:var(--acc)">Famous:</strong> (3,4,5), (5,12,13), (8,15,17)
</div>`;

Plotly.newPlot('ppyth1', [{ x: pythagData.filter(t => t.primitive).map(t => t.c), y: pythagData.filter(t => t.primitive).map((_, i) => i + 1), mode: 'lines+markers', marker: { size: 4, color: '#ffd700' } }], { ...plo(), xaxis: { title: 'Hypotenuse c' }, yaxis: { title: 'Cumulative Count' } });
}

function csvPythag() { let s = 'a,b,c,primitive\n'; pythagData.forEach(t => s += `${t.a},${t.b},${t.c},${t.primitive}\n`); dl(s, 'pythagorean.csv'); }
async function screenshotPythag() { await screenshotUnified('cpyth', 'pythLiveStats', 'Pythagorean Triples', 'pythagorean.png'); }
function exportAllPythag() { screenshotTabAll({ canvases: ['cpyth'], charts: ['ppyth1'], dashId: 'pythLiveStats', title: 'Pythagorean Triples', filename: 'pythagorean_all.png' }); }

// ==================== SUM OF SQUARES ====================
let ssqData = [];

function sumOfSquaresCount(n, k) {
if (k === 2) {
// r_2(n): count representations as sum of 2 squares
let count = 0;
for (let a = 0; a * a <= n; a++) {
const b2 = n - a * a;
const b = Math.sqrt(b2);
if (b === Math.floor(b)) count++;
}
return count * 4; // Account for signs and order
} else if (k === 4) {
// r_4(n) = 8 * sum of divisors not divisible by 4
let sum = 0;
for (let d = 1; d <= n; d++) {
if (n % d === 0 && d % 4 !== 0) sum += d;
}
return 8 * sum;
}
return 0;
}

function drawSumSquares() {
const maxN = +document.getElementById('ssqNv').value || 100;
const k = +document.getElementById('ssqK').value;
const c = document.getElementById('cssq'), ctx = c.getContext('2d');
ctx.fillStyle = canvBg(); ctx.fillRect(0, 0, c.width, c.height);

ssqData = [];
for (let n = 1; n <= maxN; n++) {
const r = sumOfSquaresCount(n, k);
ssqData.push({ n, r, representable: r > 0 });
}

// Draw grid
const pad = 50, size = Math.min((c.width - 2 * pad) / 20, (c.height - 2 * pad) / Math.ceil(maxN / 20));
ssqData.forEach((d, i) => {
const col = i % 20;
const row = Math.floor(i / 20);
const x = pad + col * size;
const y = pad + 30 + row * size;
const intensity = Math.min(1, d.r / 20);
ctx.fillStyle = d.r === 0 ? '#333' : `hsl(${120 - intensity * 120}, 80%, ${40 + intensity * 30}%)`;
ctx.fillRect(x, y, size - 1, size - 1);
});

ctx.fillStyle = isDark() ? '#ffd700' : '#cc8800';
ctx.font = 'bold 14px Segoe UI';
ctx.textAlign = 'center';
ctx.fillText(`Sum of ${k} Squares: r_${k}(n) representations`, c.width / 2, 25);

const representable = ssqData.filter(d => d.r > 0).length;
const avgR = ssqData.reduce((a, d) => a + d.r, 0) / maxN;

document.getElementById('ssqLiveStats').innerHTML = `
<div style="background:linear-gradient(135deg,rgba(0,217,255,.15),rgba(255,215,0,.1));padding:10px;border-radius:8px;margin-bottom:12px;border:1px solid var(--acc)">
<div style="font-size:.7rem;color:var(--txt2);margin-bottom:4px">TAB: Sum of Squares | FIELD: ℤ | TYPE: r_${k}(n) Counting</div>
</div>
<div style="display:grid;grid-template-columns:repeat(3,1fr);gap:8px;margin-bottom:12px">
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center"><div style="font-size:1.3rem;font-weight:bold;color:#00d9ff">${representable}</div><div style="font-size:.7rem;color:var(--txt2)">REPRESENTABLE</div></div>
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center"><div style="font-size:1.3rem;font-weight:bold;color:#ffd700">${fmt(avgR)}</div><div style="font-size:.7rem;color:var(--txt2)">AVG r_${k}(n)</div></div>
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center"><div style="font-size:1.3rem;font-weight:bold;color:#00ff88">${fmt(100 * representable / maxN)}%</div><div style="font-size:.7rem;color:var(--txt2)">DENSITY</div></div>
</div>
<div style="font-size:.8rem;color:var(--txt2)">
<strong style="color:var(--acc)">Fermat (k=2):</strong> n = a² + b²  all primes ≡ 3 (mod 4) appear even times<br>
<strong style="color:var(--acc)">Lagrange (k=4):</strong> Every n is sum of 4 squares<br>
<strong style="color:var(--acc)">Jacobi:</strong> r_4(n) = 8·Σd|n,4∤d d
</div>`;

Plotly.newPlot('pssq1', [{ x: ssqData.map(d => d.n), y: ssqData.map(d => d.r), type: 'bar', marker: { color: ssqData.map(d => d.r > 0 ? '#ffd700' : '#333') } }], { ...plo(), xaxis: { title: 'n' }, yaxis: { title: `r_${k}(n)` } });
}

function csvSumSquares() { let s = 'n,r_k\n'; ssqData.forEach(d => s += `${d.n},${d.r}\n`); dl(s, 'sum_of_squares.csv'); }
async function screenshotSumSquares() { await screenshotUnified('cssq', 'ssqLiveStats', 'Sum of Squares', 'sum_of_squares.png'); }
function exportAllSumSquares() { screenshotTabAll({ canvases: ['cssq'], charts: ['pssq1'], dashId: 'ssqLiveStats', title: 'Sum of Squares', filename: 'sumsquares_all.png' }); }

// ==================== QUADRATIC RESIDUES ====================
let qrData = [];

function legendreSymbol(a, p) {
if (a % p === 0) return 0;
const exp = (p - 1) / 2;
let result = 1, base = ((a % p) + p) % p;
let e = exp;
while (e > 0) {
if (e % 2 === 1) result = (result * base) % p;
base = (base * base) % p;
e = Math.floor(e / 2);
}
return result === 1 ? 1 : -1;
}

function drawQuadRes() {
let p = +document.getElementById('qrPv').value || 23;
// Ensure p is prime
while (!isPrime(p) && p > 2) p--;
document.getElementById('qrPv').value = p;
document.getElementById('qrP').value = Math.min(p, 200);

const mode = document.getElementById('qrMode').value;
const c = document.getElementById('cqr'), ctx = c.getContext('2d');
ctx.fillStyle = canvBg(); ctx.fillRect(0, 0, c.width, c.height);

// Compute quadratic residues
qrData = [];
const residues = new Set();
for (let a = 1; a < p; a++) {
const sq = (a * a) % p;
residues.add(sq);
}
for (let a = 1; a < p; a++) {
qrData.push({ a, isResidue: residues.has(a), legendre: legendreSymbol(a, p) });
}

if (mode === 'grid') {
// Draw grid
const pad = 50, size = Math.min((c.width - 2 * pad) / Math.min(p, 30), 20);
const cols = Math.min(p - 1, 30);
qrData.slice(0, 100).forEach((d, i) => {
const col = i % cols;
const row = Math.floor(i / cols);
const x = pad + col * size;
const y = pad + 40 + row * size;
ctx.fillStyle = d.isResidue ? '#00ff88' : '#ff6496';
ctx.fillRect(x, y, size - 2, size - 2);
if (size > 15) {
ctx.fillStyle = '#000';
ctx.font = '10px Segoe UI';
ctx.textAlign = 'center';
ctx.fillText(d.a.toString(), x + size / 2, y + size / 2 + 3);
}
});
} else if (mode === 'paley') {
// Paley graph - vertices on circle, edges between QRs
const cx = c.width / 2, cy = c.height / 2, r = Math.min(cx, cy) - 60;
// Draw edges
ctx.strokeStyle = 'rgba(0,217,255,0.3)';
ctx.lineWidth = 1;
for (let i = 0; i < p; i++) {
for (let j = i + 1; j < p; j++) {
if (residues.has((j - i + p) % p) || residues.has((i - j + p) % p)) {
const a1 = 2 * PI * i / p - PI / 2;
const a2 = 2 * PI * j / p - PI / 2;
ctx.beginPath();
ctx.moveTo(cx + r * Math.cos(a1), cy + r * Math.sin(a1));
ctx.lineTo(cx + r * Math.cos(a2), cy + r * Math.sin(a2));
ctx.stroke();
}
}
}
// Draw vertices
for (let i = 0; i < p; i++) {
const angle = 2 * PI * i / p - PI / 2;
const x = cx + r * Math.cos(angle);
const y = cy + r * Math.sin(angle);
ctx.fillStyle = '#ffd700';
ctx.beginPath();
ctx.arc(x, y, 6, 0, 2 * PI);
ctx.fill();
}
}

ctx.fillStyle = isDark() ? '#00ff88' : '#008844';
ctx.font = 'bold 14px Segoe UI';
ctx.textAlign = 'center';
ctx.fillText(`Quadratic Residues mod ${p}`, c.width / 2, 25);

const qrCount = qrData.filter(d => d.isResidue).length;

document.getElementById('qrLiveStats').innerHTML = `
<div style="background:linear-gradient(135deg,rgba(0,255,136,.15),rgba(255,100,150,.1));padding:10px;border-radius:8px;margin-bottom:12px;border:1px solid #00ff88">
<div style="font-size:.7rem;color:var(--txt2);margin-bottom:4px">TAB: Quadratic Residues | FIELD: (ℤ/pℤ)* | TYPE: Legendre Symbol</div>
</div>
<div style="display:grid;grid-template-columns:repeat(3,1fr);gap:8px;margin-bottom:12px">
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center"><div style="font-size:1.3rem;font-weight:bold;color:#00ff88">${qrCount}</div><div style="font-size:.7rem;color:var(--txt2)">RESIDUES (QR)</div></div>
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center"><div style="font-size:1.3rem;font-weight:bold;color:#ff6496">${p - 1 - qrCount}</div><div style="font-size:.7rem;color:var(--txt2)">NON-RESIDUES</div></div>
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center"><div style="font-size:1.3rem;font-weight:bold;color:#ffd700">${(p - 1) / 2}</div><div style="font-size:.7rem;color:var(--txt2)">THEORY (p-1)/2</div></div>
</div>
<div style="font-size:.8rem;color:var(--txt2)">
<strong style="color:var(--acc)">QR mod ${p}:</strong> {${[...residues].sort((a, b) => a - b).slice(0, 10).join(', ')}${residues.size > 10 ? '...' : ''}}<br>
<strong style="color:var(--acc)">Euler criterion:</strong> a^((p-1)/2) ≡ (a/p) (mod p)<br>
<strong style="color:var(--acc)">Quadratic reciprocity:</strong> (p/q)(q/p) = (-1)^((p-1)(q-1)/4)
</div>`;

Plotly.newPlot('pqr1', [{ x: qrData.map(d => d.a), y: qrData.map(d => d.legendre), type: 'bar', marker: { color: qrData.map(d => d.legendre === 1 ? '#00ff88' : '#ff6496') } }], { ...plo(), xaxis: { title: 'a' }, yaxis: { title: '(a/p)', range: [-1.5, 1.5] } });
}

function csvQuadRes() { let s = 'a,is_residue,legendre\n'; qrData.forEach(d => s += `${d.a},${d.isResidue},${d.legendre}\n`); dl(s, 'quadratic_residues.csv'); }
async function screenshotQuadRes() { await screenshotUnified('cqr', 'qrLiveStats', 'Quadratic Residues', 'quadres.png'); }
function exportAllQuadRes() { screenshotTabAll({ canvases: ['cqr'], charts: ['pqr1'], dashId: 'qrLiveStats', title: 'Quadratic Residues', filename: 'quadres_all.png' }); }

// ==================== PARTITION FUNCTION ====================
let partitionData = [];
const partitionCache = { 0: 1, 1: 1 };

function partition(n) {
if (n < 0) return 0;
if (partitionCache[n] !== undefined) return partitionCache[n];
let sum = 0;
for (let k = 1; k <= n; k++) {
const p1 = n - k * (3 * k - 1) / 2;
const p2 = n - k * (3 * k + 1) / 2;
const sign = k % 2 === 1 ? 1 : -1;
sum += sign * (partition(p1) + partition(p2));
}
partitionCache[n] = sum;
return sum;
}

function drawPartition() {
const maxN = +document.getElementById('partNv').value || 50;
const testN = +document.getElementById('partTest').value || 10;
const mode = document.getElementById('partMode').value;
const c = document.getElementById('cpart'), ctx = c.getContext('2d');
ctx.fillStyle = canvBg(); ctx.fillRect(0, 0, c.width, c.height);

partitionData = [];
for (let n = 0; n <= maxN; n++) {
partitionData.push({ n, p: partition(n) });
}

if (mode === 'ferrers') {
// Draw Ferrers diagrams for testN
const partitions = [];
function generatePartitions(n, max, current) {
if (n === 0) { partitions.push([...current]); return; }
for (let i = Math.min(n, max); i >= 1; i--) {
current.push(i);
generatePartitions(n - i, i, current);
current.pop();
}
}
generatePartitions(Math.min(testN, 12), Math.min(testN, 12), []);

const pad = 40, dotSize = 8;
const cols = Math.min(4, partitions.length);
const boxW = (c.width - 2 * pad) / cols;
const boxH = 60;

partitions.slice(0, 20).forEach((p, idx) => {
const col = idx % cols;
const row = Math.floor(idx / cols);
const bx = pad + col * boxW;
const by = pad + 40 + row * boxH;
p.forEach((count, i) => {
for (let j = 0; j < count; j++) {
ctx.fillStyle = `hsl(${i * 40}, 70%, 60%)`;
ctx.beginPath();
ctx.arc(bx + 10 + j * (dotSize + 2), by + i * (dotSize + 2), dotSize / 2, 0, 2 * PI);
ctx.fill();
}
});
});
} else {
// Growth chart
const pad = 50, w = c.width - 2 * pad, h = c.height - 2 * pad;
const maxP = Math.max(...partitionData.map(d => d.p));
ctx.strokeStyle = '#ffd700';
ctx.lineWidth = 2;
ctx.beginPath();
partitionData.forEach((d, i) => {
const x = pad + (i / maxN) * w;
const y = c.height - pad - (Math.log(d.p + 1) / Math.log(maxP + 1)) * h;
if (i === 0) ctx.moveTo(x, y);
else ctx.lineTo(x, y);
});
ctx.stroke();
}

ctx.fillStyle = isDark() ? '#ffd700' : '#cc8800';
ctx.font = 'bold 14px Segoe UI';
ctx.textAlign = 'center';
ctx.fillText(`Partition Function p(n) — n ≤ ${maxN}`, c.width / 2, 25);

const pTest = partition(testN);
const hrApprox = Math.exp(PI * Math.sqrt(2 * testN / 3)) / (4 * testN * Math.sqrt(3));

document.getElementById('partLiveStats').innerHTML = `
<div style="background:linear-gradient(135deg,rgba(255,215,0,.15),rgba(0,217,255,.1));padding:10px;border-radius:8px;margin-bottom:12px;border:1px solid #ffd700">
<div style="font-size:.7rem;color:var(--txt2);margin-bottom:4px">TAB: Partition Function | FIELD: ℤ⁺ | TYPE: p(n) Integer Partitions</div>
</div>
<div style="display:grid;grid-template-columns:repeat(3,1fr);gap:8px;margin-bottom:12px">
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center"><div style="font-size:1.2rem;font-weight:bold;color:#ffd700">${pTest.toLocaleString()}</div><div style="font-size:.7rem;color:var(--txt2)">p(${testN})</div></div>
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center"><div style="font-size:1.2rem;font-weight:bold;color:#00d9ff">${fmt(hrApprox)}</div><div style="font-size:.7rem;color:var(--txt2)">H-R APPROX</div></div>
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center"><div style="font-size:1.2rem;font-weight:bold;color:#00ff88">${partition(maxN).toLocaleString()}</div><div style="font-size:.7rem;color:var(--txt2)">p(${maxN})</div></div>
</div>
<div style="font-size:.8rem;color:var(--txt2)">
<strong style="color:var(--acc)">Hardy-Ramanujan:</strong> p(n) ~ e^(π√(2n/3)) / (4n√3)<br>
<strong style="color:var(--acc)">Ramanujan congruences:</strong><br>
• p(5n+4) ≡ 0 (mod 5)<br>
• p(7n+5) ≡ 0 (mod 7)<br>
• p(11n+6) ≡ 0 (mod 11)
</div>`;

Plotly.newPlot('ppart1', [{ x: partitionData.map(d => d.n), y: partitionData.map(d => d.p), mode: 'lines+markers', line: { color: '#ffd700' } }], { ...plo(), xaxis: { title: 'n' }, yaxis: { title: 'p(n)', type: 'log' } });
}

function csvPartition() { let s = 'n,p\n'; partitionData.forEach(d => s += `${d.n},${d.p}\n`); dl(s, 'partitions.csv'); }
async function screenshotPartition() { await screenshotUnified('cpart', 'partLiveStats', 'Partition Function', 'partition.png'); }
function exportAllPartition() { screenshotTabAll({ canvases: ['cpart'], charts: ['ppart1'], dashId: 'partLiveStats', title: 'Partition Function', filename: 'partition_all.png' }); }

// ==================== BERNOULLI NUMBERS ====================
let bernoulliData = [];

function bernoulli(n) {
if (n === 0) return 1;
if (n === 1) return -0.5;
if (n % 2 === 1) return 0;
const A = [1];
for (let m = 1; m <= n; m++) {
A[m] = 1 / (m + 1);
for (let j = m; j >= 1; j--) {
A[j - 1] = j * (A[j - 1] - A[j]);
}
}
return A[0];
}

function drawBernoulli() {
const maxN = +document.getElementById('bernNv').value || 20;
const mode = document.getElementById('bernMode').value;
const c = document.getElementById('cbern'), ctx = c.getContext('2d');
ctx.fillStyle = canvBg(); ctx.fillRect(0, 0, c.width, c.height);

bernoulliData = [];
for (let n = 0; n <= maxN; n++) {
const b = bernoulli(n);
const zetaNeg = n > 0 ? -b / n : null; // ζ(-n) = -B_{n+1}/(n+1) for n >= 0
bernoulliData.push({ n, b, zetaNeg });
}

// Display values
const pad = 50;
ctx.font = '12px monospace';
bernoulliData.filter(d => d.b !== 0).slice(0, 15).forEach((d, i) => {
const y = pad + 30 + i * 25;
ctx.fillStyle = d.b > 0 ? '#00ff88' : '#ff6496';
ctx.textAlign = 'left';
const bStr = Math.abs(d.b) < 0.001 || Math.abs(d.b) > 1000 ? d.b.toExponential(4) : d.b.toFixed(6);
ctx.fillText(`B${d.n} = ${bStr}`, pad, y);
if (d.n > 0 && d.n % 2 === 0) {
ctx.fillStyle = '#ffd700';
ctx.fillText(`→ ζ(${d.n}) = ${fmt(Math.abs(d.b) * Math.pow(2 * PI, d.n) / (2 * factorial(d.n)))}`, pad + 200, y);
}
});

ctx.fillStyle = isDark() ? '#ffd700' : '#cc8800';
ctx.font = 'bold 14px Segoe UI';
ctx.textAlign = 'center';
ctx.fillText(`Bernoulli Numbers Bₙ — n ≤ ${maxN}`, c.width / 2, 25);

const nonzero = bernoulliData.filter(d => d.b !== 0).length;

document.getElementById('bernLiveStats').innerHTML = `
<div style="background:linear-gradient(135deg,rgba(255,215,0,.15),rgba(0,217,255,.1));padding:10px;border-radius:8px;margin-bottom:12px;border:1px solid #ffd700">
<div style="font-size:.7rem;color:var(--txt2);margin-bottom:4px">TAB: Bernoulli Numbers | FIELD: ℚ | TYPE: Bₙ Sequence</div>
</div>
<div style="display:grid;grid-template-columns:repeat(3,1fr);gap:8px;margin-bottom:12px">
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center"><div style="font-size:1.2rem;font-weight:bold;color:#ffd700">${nonzero}</div><div style="font-size:.7rem;color:var(--txt2)">NON-ZERO</div></div>
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center"><div style="font-size:1.2rem;font-weight:bold;color:#00d9ff">${fmt(bernoulli(2))}</div><div style="font-size:.7rem;color:var(--txt2)">B₂ = 1/6</div></div>
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center"><div style="font-size:1.2rem;font-weight:bold;color:#ff6496">${fmt(bernoulli(4))}</div><div style="font-size:.7rem;color:var(--txt2)">B₄ = -1/30</div></div>
</div>
<div style="font-size:.8rem;color:var(--txt2)">
<strong style="color:var(--acc)">Zeta connection:</strong> ζ(2n) = (-1)^(n+1) B_{2n}(2π)^{2n} / (2(2n)!)<br>
<strong style="color:var(--acc)">Property:</strong> B_{2n+1} = 0 for n ≥ 1<br>
<strong style="color:var(--acc)">Power sums:</strong> 1^k + 2^k + ... + n^k involves Bₖ
</div>`;

const nonzeroData = bernoulliData.filter(d => d.b !== 0);
Plotly.newPlot('pbern1', [{ x: nonzeroData.map(d => d.n), y: nonzeroData.map(d => d.b), type: 'bar', marker: { color: nonzeroData.map(d => d.b > 0 ? '#00ff88' : '#ff6496') } }], { ...plo(), xaxis: { title: 'n' }, yaxis: { title: 'Bₙ' } });
}

function factorial(n) { let r = 1; for (let i = 2; i <= n; i++) r *= i; return r; }
function csvBernoulli() { let s = 'n,B_n\n'; bernoulliData.forEach(d => s += `${d.n},${d.b}\n`); dl(s, 'bernoulli.csv'); }
async function screenshotBernoulli() { await screenshotUnified('cbern', 'bernLiveStats', 'Bernoulli Numbers', 'bernoulli.png'); }
function exportAllBernoulli() { screenshotTabAll({ canvases: ['cbern'], charts: ['pbern1'], dashId: 'bernLiveStats', title: 'Bernoulli Numbers', filename: 'bernoulli_all.png' }); }

// ==================== FIBONACCI ====================
let fibData = [];

function drawFibonacci() {
const maxN = +document.getElementById('fibNv').value || 30;
const mode = document.getElementById('fibMode').value;
const c = document.getElementById('cfib'), ctx = c.getContext('2d');
ctx.fillStyle = canvBg(); ctx.fillRect(0, 0, c.width, c.height);

fibData = [{ n: 0, f: 0 }, { n: 1, f: 1 }];
for (let n = 2; n <= maxN; n++) {
fibData.push({ n, f: fibData[n - 1].f + fibData[n - 2].f });
}

const phi = (1 + Math.sqrt(5)) / 2;
const pad = 50;

if (mode === 'sequence') {
// Bar chart of Fibonacci numbers (logarithmic scale for visibility)
const w = c.width - 2 * pad, h = c.height - 2 * pad;
const maxF = Math.log10(fibData[fibData.length - 1].f + 1);
const barW = Math.max(2, w / fibData.length - 1);
ctx.fillStyle = isDark() ? '#ffd700' : '#cc8800';
ctx.font = 'bold 12px Segoe UI';
ctx.textAlign = 'center';
ctx.fillText('Fibonacci Sequence (log scale)', c.width / 2, 30);
fibData.forEach((d, i) => {
const barH = d.f > 0 ? (Math.log10(d.f + 1) / maxF) * h : 2;
const x = pad + i * (w / fibData.length);
const hue = (i / fibData.length) * 60 + 30;
ctx.fillStyle = `hsl(${hue}, 80%, 50%)`;
ctx.fillRect(x, c.height - pad - barH, barW, barH);
});
// X-axis labels
ctx.fillStyle = isDark() ? '#aaa' : '#666';
ctx.font = '9px Segoe UI';
for (let i = 0; i <= maxN; i += Math.max(1, Math.floor(maxN / 10))) {
const x = pad + i * (w / fibData.length);
ctx.fillText(i.toString(), x, c.height - pad + 15);
}
} else if (mode === 'spiral') {
// Draw golden spiral with N-dependent number of squares
const cx = c.width / 2, cy = c.height / 2;
const numSquares = Math.min(maxN, 15);
const scale = Math.min(c.width, c.height) / (Math.pow(phi, numSquares) * 2.5);
// Draw spiral
ctx.strokeStyle = '#ffd700';
ctx.lineWidth = 2;
ctx.beginPath();
const maxT = numSquares * PI / 2;
for (let t = 0; t < maxT; t += 0.02) {
const r = Math.pow(phi, t * 2 / PI) * scale * 2;
const x = cx + r * Math.cos(t);
const y = cy + r * Math.sin(t);
if (t === 0) ctx.moveTo(x, y);
else ctx.lineTo(x, y);
}
ctx.stroke();
// Draw Fibonacci squares
let x = cx, y = cy;
let dir = 0;
for (let i = 0; i < numSquares && i < fibData.length; i++) {
const size = (fibData[i].f || 1) * scale;
ctx.strokeStyle = `hsl(${i * 25}, 70%, 50%)`;
ctx.lineWidth = 1.5;
ctx.strokeRect(x, y, size, size);
// Move to next position
if (dir === 0) x += size;
else if (dir === 1) y += size;
else if (dir === 2) { x -= (fibData[i + 1]?.f || size) * scale; }
else if (dir === 3) { y -= (fibData[i + 1]?.f || size) * scale; }
dir = (dir + 1) % 4;
}
ctx.fillStyle = isDark() ? '#ffd700' : '#cc8800';
ctx.font = 'bold 12px Segoe UI';
ctx.textAlign = 'center';
ctx.fillText(`Golden Spiral — ${numSquares} squares`, c.width / 2, 25);
} else if (mode === 'ratio') {
// Show convergence to phi
const w = c.width - 2 * pad, h = c.height - 2 * pad;
ctx.strokeStyle = '#ffd700';
ctx.lineWidth = 2;
ctx.beginPath();
for (let i = 2; i < fibData.length; i++) {
const ratio = fibData[i].f / fibData[i - 1].f;
const x = pad + ((i - 2) / Math.max(1, fibData.length - 3)) * w;
const y = c.height - pad - ((ratio - 1) / 0.7) * h;
if (i === 2) ctx.moveTo(x, y);
else ctx.lineTo(x, y);
// Draw points
ctx.fillStyle = `hsl(${(i / fibData.length) * 60}, 80%, 50%)`;
ctx.beginPath();
ctx.arc(x, y, 3, 0, 2 * PI);
ctx.fill();
}
ctx.strokeStyle = '#ffd700';
ctx.stroke();
// Draw phi line
ctx.strokeStyle = '#ff6496';
ctx.setLineDash([5, 5]);
const phiY = c.height - pad - ((phi - 1) / 0.7) * h;
ctx.beginPath();
ctx.moveTo(pad, phiY);
ctx.lineTo(c.width - pad, phiY);
ctx.stroke();
ctx.setLineDash([]);
ctx.fillStyle = '#ff6496';
ctx.font = '11px Segoe UI';
ctx.textAlign = 'left';
ctx.fillText(`φ = ${phi.toFixed(6)}`, c.width - pad + 5, phiY + 4);
ctx.fillStyle = isDark() ? '#ffd700' : '#cc8800';
ctx.font = 'bold 12px Segoe UI';
ctx.textAlign = 'center';
ctx.fillText(`Ratio Convergence to φ — ${maxN} terms`, c.width / 2, 25);
} else if (mode === 'zeckendorf') {
// Zeckendorf representation visualization
const w = c.width - 2 * pad, h = c.height - 2 * pad;
const numToShow = Math.min(maxN, 40);
ctx.fillStyle = isDark() ? '#ffd700' : '#cc8800';
ctx.font = 'bold 12px Segoe UI';
ctx.textAlign = 'center';
ctx.fillText(`Zeckendorf Representations (1 to ${numToShow})`, c.width / 2, 25);
const cellH = h / numToShow;
const cellW = w / 15;
for (let n = 1; n <= numToShow; n++) {
// Find Zeckendorf representation
let remaining = n;
const rep = [];
for (let i = fibData.length - 1; i >= 2 && remaining > 0; i--) {
if (fibData[i].f <= remaining) {
rep.push(i);
remaining -= fibData[i].f;
}
}
// Draw row
const y = pad + (n - 1) * cellH;
ctx.fillStyle = isDark() ? '#666' : '#ccc';
ctx.font = '9px Segoe UI';
ctx.textAlign = 'right';
ctx.fillText(n.toString(), pad - 5, y + cellH / 2 + 3);
for (let i = 2; i < Math.min(15, fibData.length); i++) {
const x = pad + (i - 2) * cellW;
if (rep.includes(i)) {
ctx.fillStyle = `hsl(${i * 25}, 70%, 50%)`;
ctx.fillRect(x + 1, y + 1, cellW - 2, cellH - 2);
}
}
}
} else if (mode === 'pisano') {
// Pisano periods - now responds to N for how many moduli to show
const numMod = Math.min(Math.max(5, Math.floor(maxN / 2)), 30);
const periods = [];
for (let m = 2; m <= numMod + 1; m++) {
let f0 = 0, f1 = 1, period = 0;
do {
[f0, f1] = [f1, (f0 + f1) % m];
period++;
} while (!(f0 === 0 && f1 === 1) && period < 1000);
periods.push({ m, period });
}
const maxPeriod = Math.max(...periods.map(p => p.period));
const w = c.width - 2 * pad, h = c.height - 2 * pad - 20;
const barW = Math.max(8, w / periods.length - 2);
periods.forEach((p, i) => {
const barH = (p.period / maxPeriod) * h;
const x = pad + i * (w / periods.length);
ctx.fillStyle = `hsl(${(p.m * 15) % 360}, 70%, 50%)`;
ctx.fillRect(x, c.height - pad - barH, barW, barH);
ctx.fillStyle = isDark() ? '#fff' : '#000';
ctx.font = '9px Segoe UI';
ctx.textAlign = 'center';
ctx.fillText(p.m.toString(), x + barW / 2, c.height - pad + 12);
ctx.fillText(p.period.toString(), x + barW / 2, c.height - pad - barH - 3);
});
ctx.fillStyle = isDark() ? '#ffd700' : '#cc8800';
ctx.font = 'bold 12px Segoe UI';
ctx.textAlign = 'center';
ctx.fillText(`Pisano Periods π(m) for m = 2 to ${numMod + 1}`, c.width / 2, 25);
} else if (mode === 'lucas') {
// Lucas numbers L_n = F_{n-1} + F_{n+1}
const lucasData = [{n: 0, l: 2}, {n: 1, l: 1}];
for (let n = 2; n <= maxN; n++) {
lucasData.push({ n, l: lucasData[n - 1].l + lucasData[n - 2].l });
}
const w = c.width - 2 * pad, h = c.height - 2 * pad;
const maxL = Math.log10(lucasData[lucasData.length - 1].l + 1);
const barW = Math.max(2, w / lucasData.length - 1);
lucasData.forEach((d, i) => {
const barH = d.l > 0 ? (Math.log10(d.l + 1) / maxL) * h : 2;
const x = pad + i * (w / lucasData.length);
ctx.fillStyle = `hsl(${200 + (i / lucasData.length) * 60}, 70%, 50%)`;
ctx.fillRect(x, c.height - pad - barH, barW, barH);
});
ctx.fillStyle = isDark() ? '#00d9ff' : '#0088aa';
ctx.font = 'bold 12px Segoe UI';
ctx.textAlign = 'center';
ctx.fillText(`Lucas Numbers L_n (log scale) — ${maxN} terms`, c.width / 2, 25);
}

const lastRatio = fibData.length > 2 ? fibData[fibData.length - 1].f / fibData[fibData.length - 2].f : 1;

document.getElementById('fibLiveStats').innerHTML = `
<div style="background:linear-gradient(135deg,rgba(255,215,0,.15),rgba(0,217,255,.1));padding:10px;border-radius:8px;margin-bottom:12px;border:1px solid #ffd700">
<div style="font-size:.7rem;color:var(--txt2);margin-bottom:4px">TAB: Fibonacci | FIELD: ℤ | TYPE: Golden Ratio φ</div>
</div>
<div style="display:grid;grid-template-columns:repeat(3,1fr);gap:8px;margin-bottom:12px">
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center"><div style="font-size:1rem;font-weight:bold;color:#ffd700">${fibData[fibData.length - 1].f.toLocaleString()}</div><div style="font-size:.7rem;color:var(--txt2)">F_${maxN}</div></div>
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center"><div style="font-size:1rem;font-weight:bold;color:#00d9ff">${phi.toFixed(8)}</div><div style="font-size:.7rem;color:var(--txt2)">φ GOLDEN</div></div>
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center"><div style="font-size:1rem;font-weight:bold;color:#00ff88">${(lastRatio - phi).toExponential(2)}</div><div style="font-size:.7rem;color:var(--txt2)">RATIO ERROR</div></div>
</div>
<div style="font-size:.8rem;color:var(--txt2)">
<strong style="color:var(--acc)">Binet:</strong> Fₙ = (φⁿ - ψⁿ)/√5, ψ = (1-√5)/2<br>
<strong style="color:var(--acc)">Zeckendorf:</strong> Every n = unique sum of non-adjacent Fᵢ<br>
<strong style="color:var(--acc)">Pisano:</strong> Fₙ mod m is periodic with period π(m)
</div>`;

const ratios = fibData.slice(2).map((d, i) => ({ n: i + 2, ratio: d.f / fibData[i + 1].f }));
Plotly.newPlot('pfib1', [
{ x: ratios.map(r => r.n), y: ratios.map(r => r.ratio), mode: 'lines+markers', name: 'Fₙ/Fₙ₋₁', line: { color: '#ffd700' } },
{ x: [ratios[0].n, ratios[ratios.length - 1].n], y: [phi, phi], mode: 'lines', name: 'φ', line: { color: '#ff6496', dash: 'dash' } }
], { ...plo(), xaxis: { title: 'n' }, yaxis: { title: 'Ratio', range: [1.5, 1.7] } });
}

function csvFibonacci() { let s = 'n,F_n\n'; fibData.forEach(d => s += `${d.n},${d.f}\n`); dl(s, 'fibonacci.csv'); }
async function screenshotFibonacci() { await screenshotUnified('cfib', 'fibLiveStats', 'Fibonacci Sequence', 'fibonacci.png'); }
function exportAllFibonacci() { screenshotTabAll({ canvases: ['cfib'], charts: ['pfib1'], dashId: 'fibLiveStats', title: 'Fibonacci', filename: 'fibonacci_all.png' }); }

// ==================== CATALAN NUMBERS ====================
let catalanData = [];

function catalan(n) {
if (n <= 1) return 1;
let c = 1;
for (let i = 0; i < n; i++) {
c = c * 2 * (2 * i + 1) / (i + 2);
}
return Math.round(c);
}

function drawCatalan() {
const maxN = +document.getElementById('catNv').value || 15;
const mode = document.getElementById('catMode').value;
const c = document.getElementById('ccat'), ctx = c.getContext('2d');
ctx.fillStyle = canvBg(); ctx.fillRect(0, 0, c.width, c.height);

catalanData = [];
for (let n = 0; n <= maxN; n++) {
catalanData.push({ n, c: catalan(n) });
}

if (mode === 'lattice' || mode === 'dyck') {
// Draw example Dyck paths for small n
const testN = Math.min(4, maxN);
const pad = 50, size = 40;
const paths = generateDyckPaths(testN);

paths.slice(0, 14).forEach((path, idx) => {
const col = idx % 7;
const row = Math.floor(idx / 7);
const bx = pad + col * 90;
const by = pad + 40 + row * 90;

ctx.strokeStyle = '#666';
ctx.lineWidth = 1;
// Draw grid
for (let i = 0; i <= testN; i++) {
ctx.beginPath();
ctx.moveTo(bx, by + i * 15);
ctx.lineTo(bx + testN * 15, by + i * 15);
ctx.moveTo(bx + i * 15, by);
ctx.lineTo(bx + i * 15, by + testN * 15);
ctx.stroke();
}

// Draw path
ctx.strokeStyle = '#ffd700';
ctx.lineWidth = 2;
ctx.beginPath();
let x = bx, y = by + testN * 15;
ctx.moveTo(x, y);
path.forEach(step => {
if (step === 1) { x += 15; } else { y -= 15; }
ctx.lineTo(x, y);
});
ctx.stroke();
});
}

ctx.fillStyle = isDark() ? '#ffd700' : '#cc8800';
ctx.font = 'bold 14px Segoe UI';
ctx.textAlign = 'center';
ctx.fillText(`Catalan Numbers Cₙ — n ≤ ${maxN}`, c.width / 2, 25);

document.getElementById('catLiveStats').innerHTML = `
<div style="background:linear-gradient(135deg,rgba(255,215,0,.15),rgba(0,217,255,.1));padding:10px;border-radius:8px;margin-bottom:12px;border:1px solid #ffd700">
<div style="font-size:.7rem;color:var(--txt2);margin-bottom:4px">TAB: Catalan Numbers | FIELD: ℤ | TYPE: Cₙ Combinatorics</div>
</div>
<div style="display:grid;grid-template-columns:repeat(3,1fr);gap:8px;margin-bottom:12px">
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center"><div style="font-size:1.1rem;font-weight:bold;color:#ffd700">${catalan(maxN).toLocaleString()}</div><div style="font-size:.7rem;color:var(--txt2)">C_${maxN}</div></div>
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center"><div style="font-size:1.1rem;font-weight:bold;color:#00d9ff">C(2n,n)/(n+1)</div><div style="font-size:.7rem;color:var(--txt2)">FORMULA</div></div>
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center"><div style="font-size:1.1rem;font-weight:bold;color:#00ff88">4ⁿ/n^1.5</div><div style="font-size:.7rem;color:var(--txt2)">GROWTH</div></div>
</div>
<div style="font-size:.8rem;color:var(--txt2)">
<strong style="color:var(--acc)">Counts:</strong> Dyck paths, binary trees, triangulations, valid parentheses<br>
<strong style="color:var(--acc)">Recurrence:</strong> Cₙ = Σ Cᵢ Cₙ₋₁₋ᵢ<br>
<strong style="color:var(--acc)">First values:</strong> 1, 1, 2, 5, 14, 42, 132, 429...
</div>`;

Plotly.newPlot('pcat1', [{ x: catalanData.map(d => d.n), y: catalanData.map(d => d.c), mode: 'lines+markers', line: { color: '#ffd700' } }], { ...plo(), xaxis: { title: 'n' }, yaxis: { title: 'Cₙ', type: 'log' } });
}

function generateDyckPaths(n) {
const paths = [];
function generate(path, x, y) {
if (x === n && y === n) { paths.push([...path]); return; }
if (x < n) { path.push(1); generate(path, x + 1, y); path.pop(); }
if (y < x) { path.push(0); generate(path, x, y + 1); path.pop(); }
}
generate([], 0, 0);
return paths;
}

function csvCatalan() { let s = 'n,C_n\n'; catalanData.forEach(d => s += `${d.n},${d.c}\n`); dl(s, 'catalan.csv'); }
async function screenshotCatalan() { await screenshotUnified('ccat', 'catLiveStats', 'Catalan Numbers', 'catalan.png'); }
function exportAllCatalan() { screenshotTabAll({ canvases: ['ccat'], charts: ['pcat1'], dashId: 'catLiveStats', title: 'Catalan Numbers', filename: 'catalan_all.png' }); }

// ==================== ALIQUOT SEQUENCES ====================
let aliquotData = [];

function aliquotSum(n) {
let sum = 0;
for (let d = 1; d < n; d++) if (n % d === 0) sum += d;
return sum;
}

function drawAliquot() {
const startN = +document.getElementById('aliqNv').value || 276;
const maxSteps = +document.getElementById('aliqSteps').value || 100;
const mode = document.getElementById('aliqMode').value;
const c = document.getElementById('caliq'), ctx = c.getContext('2d');
ctx.fillStyle = canvBg(); ctx.fillRect(0, 0, c.width, c.height);

aliquotData = [];

if (mode === 'single') {
let n = startN;
const seen = new Set();
for (let step = 0; step < maxSteps && n > 0 && n < 1e9; step++) {
if (seen.has(n)) { aliquotData.push({ step, n, cycle: true }); break; }
seen.add(n);
aliquotData.push({ step, n, cycle: false });
n = aliquotSum(n);
}

// Draw trajectory
const pad = 50, w = c.width - 2 * pad, h = c.height - 2 * pad;
const maxVal = Math.max(...aliquotData.map(d => d.n));
ctx.strokeStyle = '#00d9ff';
ctx.lineWidth = 2;
ctx.beginPath();
aliquotData.forEach((d, i) => {
const x = pad + (i / aliquotData.length) * w;
const y = c.height - pad - (Math.log(d.n + 1) / Math.log(maxVal + 1)) * h;
if (i === 0) ctx.moveTo(x, y);
else ctx.lineTo(x, y);
});
ctx.stroke();
} else {
// Classify
const classifications = { perfect: [], amicable: [], sociable: [], terminating: [], unknown: [] };
for (let n = 2; n <= Math.min(startN, 1000); n++) {
let seq = [n], seen = new Set([n]);
for (let i = 0; i < 50 && seq[seq.length - 1] > 0 && seq[seq.length - 1] < 1e7; i++) {
const next = aliquotSum(seq[seq.length - 1]);
if (next === 0) { classifications.terminating.push(n); break; }
if (next === n && seq.length === 1) { classifications.perfect.push(n); break; }
if (seen.has(next)) {
if (next === n && seq.length === 2) classifications.amicable.push(n);
else classifications.sociable.push(n);
break;
}
seen.add(next);
seq.push(next);
}
}

const pad = 50;
let y = pad + 30;
Object.entries(classifications).forEach(([type, nums]) => {
if (nums.length > 0) {
ctx.fillStyle = type === 'perfect' ? '#ffd700' : type === 'amicable' ? '#00ff88' : '#00d9ff';
ctx.font = '12px Segoe UI';
ctx.fillText(`${type}: ${nums.slice(0, 10).join(', ')}${nums.length > 10 ? '...' : ''}`, pad, y);
y += 25;
}
});
}

ctx.fillStyle = isDark() ? '#00d9ff' : '#0066cc';
ctx.font = 'bold 14px Segoe UI';
ctx.textAlign = 'center';
ctx.fillText(`Aliquot Sequence from ${startN}`, c.width / 2, 25);

const finalN = aliquotData.length > 0 ? aliquotData[aliquotData.length - 1].n : startN;
const maxN = aliquotData.length > 0 ? Math.max(...aliquotData.map(d => d.n)) : startN;

document.getElementById('aliqLiveStats').innerHTML = `
<div style="background:linear-gradient(135deg,rgba(0,217,255,.15),rgba(255,215,0,.1));padding:10px;border-radius:8px;margin-bottom:12px;border:1px solid var(--acc)">
<div style="font-size:.7rem;color:var(--txt2);margin-bottom:4px">TAB: Aliquot Sequences | FIELD: ℤ | TYPE: s(n) = σ(n) - n Iteration</div>
</div>
<div style="display:grid;grid-template-columns:repeat(3,1fr);gap:8px;margin-bottom:12px">
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center"><div style="font-size:1.2rem;font-weight:bold;color:#00d9ff">${startN}</div><div style="font-size:.7rem;color:var(--txt2)">START</div></div>
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center"><div style="font-size:1.2rem;font-weight:bold;color:#ffd700">${aliquotData.length}</div><div style="font-size:.7rem;color:var(--txt2)">STEPS</div></div>
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center"><div style="font-size:1.2rem;font-weight:bold;color:#00ff88">${maxN.toLocaleString()}</div><div style="font-size:.7rem;color:var(--txt2)">MAX VALUE</div></div>
</div>
<div style="font-size:.8rem;color:var(--txt2)">
<strong style="color:var(--acc)">Types:</strong> Perfect (n→n), Amicable (n→m→n), Sociable (cycles)<br>
<strong style="color:var(--acc)">Open problem:</strong> Does 276 sequence terminate?<br>
<strong style="color:var(--acc)">Perfect numbers:</strong> 6, 28, 496, 8128...
</div>`;

if (aliquotData.length > 0) {
Plotly.newPlot('paliq1', [{ x: aliquotData.map(d => d.step), y: aliquotData.map(d => d.n), mode: 'lines+markers', line: { color: '#00d9ff' } }], { ...plo(), xaxis: { title: 'Step' }, yaxis: { title: 'Value', type: 'log' } });
}
}

function csvAliquot() { let s = 'step,n\n'; aliquotData.forEach(d => s += `${d.step},${d.n}\n`); dl(s, 'aliquot.csv'); }
async function screenshotAliquot() { await screenshotUnified('caliq', 'aliqLiveStats', 'Aliquot Sequence', 'aliquot.png'); }
function exportAllAliquot() { screenshotTabAll({ canvases: ['caliq'], charts: ['paliq1'], dashId: 'aliqLiveStats', title: 'Aliquot Sequences', filename: 'aliquot_all.png' }); }

// ==================== CYCLOTOMIC POLYNOMIALS ====================
let cycData = [];

function drawCyclotomic() {
const maxN = +document.getElementById('cycNv').value || 20;
const mode = document.getElementById('cycMode').value;
const c = document.getElementById('ccyc'), ctx = c.getContext('2d');
ctx.fillStyle = canvBg(); ctx.fillRect(0, 0, c.width, c.height);

cycData = [];
for (let n = 1; n <= maxN; n++) {
const phi_n = totient(n);
cycData.push({ n, degree: phi_n });
}

if (mode === 'roots') {
// Draw roots of unity on unit circle
const cx = c.width / 2, cy = c.height / 2, r = Math.min(cx, cy) - 60;

// Unit circle
ctx.strokeStyle = gridC();
ctx.lineWidth = 1;
ctx.beginPath();
ctx.arc(cx, cy, r, 0, 2 * PI);
ctx.stroke();

// Draw primitive roots for each n
const testN = Math.min(maxN, 12);
for (let k = 0; k < testN; k++) {
if (gcd(k, testN) === 1) {
const angle = 2 * PI * k / testN;
const x = cx + r * Math.cos(angle);
const y = cy - r * Math.sin(angle);
ctx.fillStyle = '#ffd700';
ctx.beginPath();
ctx.arc(x, y, 6, 0, 2 * PI);
ctx.fill();
ctx.fillStyle = isDark() ? '#fff' : '#000';
ctx.font = '10px Segoe UI';
ctx.textAlign = 'center';
ctx.fillText(`ζ^${k}`, x, y - 10);
}
}
} else {
// Show degrees
const pad = 50, w = c.width - 2 * pad, h = c.height - 2 * pad;
const maxDeg = Math.max(...cycData.map(d => d.degree));
cycData.forEach((d, i) => {
const x = pad + (i / cycData.length) * w;
const barH = (d.degree / maxDeg) * h;
ctx.fillStyle = isPrime(d.n) ? '#ffd700' : '#00d9ff';
ctx.fillRect(x, c.height - pad - barH, w / cycData.length - 2, barH);
});
}

ctx.fillStyle = isDark() ? '#ffd700' : '#cc8800';
ctx.font = 'bold 14px Segoe UI';
ctx.textAlign = 'center';
ctx.fillText(`Cyclotomic Polynomials Φₙ(x) — n ≤ ${maxN}`, c.width / 2, 25);

document.getElementById('cycLiveStats').innerHTML = `
<div style="background:linear-gradient(135deg,rgba(255,215,0,.15),rgba(0,217,255,.1));padding:10px;border-radius:8px;margin-bottom:12px;border:1px solid #ffd700">
<div style="font-size:.7rem;color:var(--txt2);margin-bottom:4px">TAB: Cyclotomic Polynomials | FIELD: ℂ | TYPE: Φₙ(x) = ∏(x - ζⁿ)</div>
</div>
<div style="display:grid;grid-template-columns:repeat(3,1fr);gap:8px;margin-bottom:12px">
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center"><div style="font-size:1.2rem;font-weight:bold;color:#ffd700">${maxN}</div><div style="font-size:.7rem;color:var(--txt2)">MAX n</div></div>
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center"><div style="font-size:1.2rem;font-weight:bold;color:#00d9ff">${totient(maxN)}</div><div style="font-size:.7rem;color:var(--txt2)">deg Φ_${maxN} = φ(${maxN})</div></div>
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center"><div style="font-size:1.2rem;font-weight:bold;color:#00ff88">ζₙ = e^(2πi/n)</div><div style="font-size:.7rem;color:var(--txt2)">ROOT</div></div>
</div>
<div style="font-size:.8rem;color:var(--txt2)">
<strong style="color:var(--acc)">Definition:</strong> Φₙ(x) = ∏_{gcd(k,n)=1} (x - e^(2πik/n))<br>
<strong style="color:var(--acc)">Property:</strong> xⁿ - 1 = ∏_{d|n} Φ_d(x)<br>
<strong style="color:var(--acc)">Degree:</strong> deg Φₙ = φ(n)
</div>`;

Plotly.newPlot('pcyc1', [{ x: cycData.map(d => d.n), y: cycData.map(d => d.degree), type: 'bar', marker: { color: cycData.map(d => isPrime(d.n) ? '#ffd700' : '#00d9ff') } }], { ...plo(), xaxis: { title: 'n' }, yaxis: { title: 'φ(n) = deg Φₙ' } });
}

function csvCyclotomic() { let s = 'n,degree\n'; cycData.forEach(d => s += `${d.n},${d.degree}\n`); dl(s, 'cyclotomic.csv'); }
async function screenshotCyclotomic() { await screenshotUnified('ccyc', 'cycLiveStats', 'Cyclotomic Polynomials', 'cyclotomic.png'); }
function exportAllCyclotomic() { screenshotTabAll({ canvases: ['ccyc'], charts: ['pcyc1'], dashId: 'cycLiveStats', title: 'Cyclotomic Polynomials', filename: 'cyclotomic_all.png' }); }

// ==================== COLLATZ CONJECTURE ====================
let collatzData = [];

function collatzSequence(n, maxSteps = 1000) {
const seq = [n];
while (n !== 1 && seq.length < maxSteps) {
n = n % 2 === 0 ? n / 2 : 3 * n + 1;
seq.push(n);
}
return seq;
}

// Collatz animation state
let collatzAnimSeq = [];
let collatzAnimStep = 0;
let collatzAnimRunning = false;
let collatzSpeed = 160;
let collatzAnimId = null;

function toggleCollatzAnim() {
  collatzAnimRunning = !collatzAnimRunning;
  const btn = document.getElementById('collAnimBtn');
  if (btn) btn.textContent = collatzAnimRunning ? ' Pause' : ' Resume';
  if (collatzAnimRunning) animateCollatz();
}

function animateCollatz() {
  if (!collatzAnimRunning) return;
  if (collatzAnimStep >= collatzAnimSeq.length) {
    collatzAnimRunning = false;
    document.getElementById('collAnimBtn').textContent = '↺ Restart';
    document.getElementById('collAnimBtn').onclick = () => {
      collatzAnimStep = 0;
      collatzAnimRunning = true;
      document.getElementById('collAnimBtn').textContent = ' Pause';
      document.getElementById('collAnimBtn').onclick = toggleCollatzAnim;
      animateCollatz();
    };
    return;
  }
  
  const c = document.getElementById('ccoll'), ctx = c.getContext('2d');
  const pad = 50, w = c.width - 2 * pad, h = c.height - 2 * pad;
  const maxVal = Math.max(...collatzAnimSeq);
  const totalSteps = collatzAnimSeq.length;
  
  // Clear and redraw
  ctx.fillStyle = canvBg(); ctx.fillRect(0, 0, c.width, c.height);
  
  // Draw trajectory up to current step
  ctx.strokeStyle = '#ff6496';
  ctx.lineWidth = 2;
  ctx.beginPath();
  for (let i = 0; i <= collatzAnimStep; i++) {
    const x = pad + (i / totalSteps) * w;
    const y = c.height - pad - (collatzAnimSeq[i] / maxVal) * h;
    if (i === 0) ctx.moveTo(x, y);
    else ctx.lineTo(x, y);
  }
  ctx.stroke();
  
  // Current point highlight
  const currX = pad + (collatzAnimStep / totalSteps) * w;
  const currY = c.height - pad - (collatzAnimSeq[collatzAnimStep] / maxVal) * h;
  ctx.fillStyle = '#ffd700';
  ctx.beginPath(); ctx.arc(currX, currY, 8, 0, 2*Math.PI); ctx.fill();
  
  // Current value display
  ctx.fillStyle = isDark() ? '#fff' : '#000';
  ctx.font = 'bold 16px Segoe UI';
  ctx.textAlign = 'center';
  ctx.fillText(`Step ${collatzAnimStep}: ${collatzAnimSeq[collatzAnimStep].toLocaleString()}`, c.width/2, 30);
  
  // Show operation
  if (collatzAnimStep < collatzAnimSeq.length - 1) {
    const curr = collatzAnimSeq[collatzAnimStep];
    const next = collatzAnimSeq[collatzAnimStep + 1];
    const op = curr % 2 === 0 ? `${curr} ÷ 2 = ${next}` : `3×${curr} + 1 = ${next}`;
    ctx.fillStyle = curr % 2 === 0 ? '#00d9ff' : '#ff8c00';
    ctx.font = '14px Segoe UI';
    ctx.fillText(op, c.width/2, 55);
  }
  
  // Progress bar
  ctx.fillStyle = 'rgba(255,255,255,0.2)';
  ctx.fillRect(pad, c.height - 25, w, 10);
  ctx.fillStyle = '#00ff88';
  ctx.fillRect(pad, c.height - 25, w * collatzAnimStep / totalSteps, 10);
  
  collatzAnimStep++;
  collatzAnimId = setTimeout(animateCollatz, collatzSpeed);
}

function drawCollatz() {
// Stop any running animation
if (collatzAnimId) { clearTimeout(collatzAnimId); collatzAnimId = null; }
collatzAnimRunning = false;
const animBtn = document.getElementById('collAnimBtn');
if (animBtn) { animBtn.style.display = 'none'; animBtn.textContent = ' Pause'; animBtn.onclick = toggleCollatzAnim; }

const startN = +document.getElementById('collNv').value || 27;
const mode = document.getElementById('collMode').value;
const c = document.getElementById('ccoll'), ctx = c.getContext('2d');
ctx.fillStyle = canvBg(); ctx.fillRect(0, 0, c.width, c.height);

const pad = 50, w = c.width - 2 * pad, h = c.height - 2 * pad;

if (mode === 'single') {
collatzData = collatzSequence(startN).map((n, i) => ({ step: i, n }));
const maxVal = Math.max(...collatzData.map(d => d.n));

ctx.strokeStyle = '#ff6496';
ctx.lineWidth = 2;
ctx.beginPath();
collatzData.forEach((d, i) => {
const x = pad + (i / collatzData.length) * w;
const y = c.height - pad - (d.n / maxVal) * h;
if (i === 0) ctx.moveTo(x, y);
else ctx.lineTo(x, y);
});
ctx.stroke();

// Mark key points
ctx.fillStyle = '#ffd700';
const maxIdx = collatzData.findIndex(d => d.n === maxVal);
const maxX = pad + (maxIdx / collatzData.length) * w;
const maxY = c.height - pad - h;
ctx.beginPath(); ctx.arc(maxX, maxY, 6, 0, 2*PI); ctx.fill();
ctx.fillStyle = isDark() ? '#fff' : '#000';
ctx.font = '10px Segoe UI'; ctx.textAlign = 'center';
ctx.fillText(`Max: ${maxVal.toLocaleString()}`, maxX, maxY - 10);

} else if (mode === 'stopping') {
collatzData = [];
for (let n = 1; n <= startN; n++) {
const seq = collatzSequence(n);
collatzData.push({ n, stopTime: seq.length - 1 });
}
const maxStop = Math.max(...collatzData.map(d => d.stopTime));
collatzData.forEach(d => {
const x = pad + (d.n / startN) * w;
const y = c.height - pad - (d.stopTime / maxStop) * h;
ctx.fillStyle = `hsl(${d.stopTime / maxStop * 240}, 70%, 50%)`;
ctx.beginPath();
ctx.arc(x, y, 2, 0, 2 * PI);
ctx.fill();
});

} else if (mode === 'histogram') {
// Stopping time histogram
collatzData = [];
const stopTimes = {};
let maxStop = 0;
for (let n = 1; n <= startN; n++) {
const seq = collatzSequence(n);
const st = seq.length - 1;
stopTimes[st] = (stopTimes[st] || 0) + 1;
maxStop = Math.max(maxStop, st);
collatzData.push({ n, stopTime: st });
}
const bins = Object.entries(stopTimes).map(([t, c]) => ({time: +t, count: c})).sort((a,b) => a.time - b.time);
const maxCount = Math.max(...bins.map(b => b.count));
const barW = w / (maxStop + 1);

ctx.fillStyle = isDark() ? '#ff6496' : '#cc0044';
ctx.font = 'bold 14px Segoe UI'; ctx.textAlign = 'center';
ctx.fillText(`Stopping Time Distribution for n ≤ ${startN}`, c.width / 2, 25);

bins.forEach(b => {
const x = pad + b.time * barW;
const barH = (b.count / maxCount) * h;
ctx.fillStyle = `hsl(${b.time / maxStop * 240}, 70%, 50%)`;
ctx.fillRect(x, c.height - pad - barH, barW * 0.8, barH);
});

// Axis labels
ctx.fillStyle = isDark() ? '#aaa' : '#666';
ctx.font = '10px Segoe UI';
ctx.textAlign = 'center';
ctx.fillText('Stopping Time', c.width / 2, c.height - 10);

} else if (mode === 'records') {
// Record holders - longest stopping times
collatzData = [];
for (let n = 1; n <= startN; n++) {
const seq = collatzSequence(n);
const maxVal = Math.max(...seq);
collatzData.push({ n, stopTime: seq.length - 1, maxVal });
}
// Find records
const records = [];
let maxST = 0;
for (const d of collatzData) {
if (d.stopTime > maxST) {
maxST = d.stopTime;
records.push(d);
}
}

ctx.fillStyle = isDark() ? '#ffd700' : '#cc8800';
ctx.font = 'bold 14px Segoe UI'; ctx.textAlign = 'center';
ctx.fillText(`Collatz Record Holders (longest stopping times) up to n=${startN}`, c.width / 2, 25);

const maxRecordST = Math.max(...records.map(r => r.stopTime));
records.forEach((r, i) => {
const x = pad + (i / (records.length - 1 || 1)) * w;
const y = c.height - pad - (r.stopTime / maxRecordST) * h;
ctx.fillStyle = '#ffd700';
ctx.beginPath(); ctx.arc(x, y, 5, 0, 2*PI); ctx.fill();
if (records.length < 30) {
ctx.fillStyle = isDark() ? '#fff' : '#000';
ctx.font = '9px Segoe UI'; ctx.textAlign = 'center';
ctx.fillText(`${r.n}`, x, y - 8);
ctx.fillText(`(${r.stopTime})`, x, y + 15);
}
});

} else if (mode === 'residue') {
// Residue class analysis mod 6
collatzData = [];
const residueCounts = {0: [], 1: [], 2: [], 3: [], 4: [], 5: []};
for (let n = 1; n <= startN; n++) {
const seq = collatzSequence(n);
const st = seq.length - 1;
residueCounts[n % 6].push(st);
collatzData.push({ n, stopTime: st, residue: n % 6 });
}

ctx.fillStyle = isDark() ? '#00d9ff' : '#0066cc';
ctx.font = 'bold 14px Segoe UI'; ctx.textAlign = 'center';
ctx.fillText(`Stopping Times by Residue Class (mod 6) for n ≤ ${startN}`, c.width / 2, 25);

const colors = ['#ff6496', '#ffd700', '#00d9ff', '#00ff88', '#9664ff', '#ff8c00'];
const barW = w / 6;
const avgByResidue = Object.entries(residueCounts).map(([r, times]) => ({
residue: +r,
avg: times.length ? times.reduce((a,b) => a+b, 0) / times.length : 0,
count: times.length
}));
const maxAvg = Math.max(...avgByResidue.map(r => r.avg));

avgByResidue.forEach((r, i) => {
const x = pad + i * barW + barW * 0.1;
const barH = (r.avg / maxAvg) * h * 0.8;
ctx.fillStyle = colors[i];
ctx.fillRect(x, c.height - pad - barH, barW * 0.8, barH);
ctx.fillStyle = isDark() ? '#fff' : '#000';
ctx.font = '11px Segoe UI'; ctx.textAlign = 'center';
ctx.fillText(`${i} mod 6`, x + barW * 0.4, c.height - pad + 15);
ctx.fillText(`avg: ${r.avg.toFixed(1)}`, x + barW * 0.4, c.height - pad - barH - 5);
});

} else if (mode === 'animated') {
// Animated trajectory - start animation
const animBtn = document.getElementById('collAnimBtn');
if (animBtn) animBtn.style.display = 'inline-block';
collatzAnimSeq = collatzSequence(startN);
collatzAnimStep = 0;
collatzAnimRunning = true;
animateCollatz();
return; // Exit to let animation take over

} else if (mode === 'benford') {
// Benford's Law analysis on Collatz sequences
const leadingDigits = {1:0, 2:0, 3:0, 4:0, 5:0, 6:0, 7:0, 8:0, 9:0};
let totalDigits = 0;
for (let n = 1; n <= startN; n++) {
  const seq = collatzSequence(n);
  seq.forEach(val => {
    if (val >= 1) {
      const leading = parseInt(val.toString()[0]);
      if (leading >= 1 && leading <= 9) {
        leadingDigits[leading]++;
        totalDigits++;
      }
    }
  });
}

ctx.fillStyle = isDark() ? '#9664ff' : '#6644cc';
ctx.font = 'bold 14px Segoe UI'; ctx.textAlign = 'center';
ctx.fillText(`Benford's Law Analysis for Collatz Sequences (n ≤ ${startN})`, c.width / 2, 25);

const barW = w / 9;
const benfordExpected = [0.301, 0.176, 0.125, 0.097, 0.079, 0.067, 0.058, 0.051, 0.046];
const maxPct = 0.35;

for (let d = 1; d <= 9; d++) {
  const x = pad + (d-1) * barW + barW * 0.1;
  const actual = leadingDigits[d] / totalDigits;
  const expected = benfordExpected[d-1];
  const barHActual = actual / maxPct * h * 0.9;
  const barHExpected = expected / maxPct * h * 0.9;
  
  // Expected bar (faded)
  ctx.fillStyle = 'rgba(150,100,255,0.3)';
  ctx.fillRect(x, c.height - pad - barHExpected, barW * 0.35, barHExpected);
  
  // Actual bar
  ctx.fillStyle = Math.abs(actual - expected) < 0.02 ? '#00ff88' : '#ff6496';
  ctx.fillRect(x + barW * 0.4, c.height - pad - barHActual, barW * 0.35, barHActual);
  
  // Labels
  ctx.fillStyle = isDark() ? '#fff' : '#000';
  ctx.font = '11px Segoe UI'; ctx.textAlign = 'center';
  ctx.fillText(d.toString(), x + barW * 0.4, c.height - pad + 15);
  ctx.font = '9px Segoe UI';
  ctx.fillText(`${(actual*100).toFixed(1)}%`, x + barW * 0.4, c.height - pad - barHActual - 5);
}

// Legend
ctx.fillStyle = 'rgba(150,100,255,0.5)';
ctx.fillRect(c.width - 150, pad + 10, 15, 15);
ctx.fillStyle = '#00ff88';
ctx.fillRect(c.width - 150, pad + 30, 15, 15);
ctx.fillStyle = isDark() ? '#fff' : '#000';
ctx.font = '10px Segoe UI'; ctx.textAlign = 'left';
ctx.fillText('Benford Expected', c.width - 130, pad + 22);
ctx.fillText('Actual', c.width - 130, pad + 42);

collatzData = Object.entries(leadingDigits).map(([d, c]) => ({
  digit: +d, count: c, actual: c/totalDigits, expected: benfordExpected[+d-1]
}));

} else if (mode === 'heatmap') {
// Heatmap: n versus step number
const maxN = Math.min(startN, 500);
const allSeqs = [];
let maxLen = 0;
for (let n = 1; n <= maxN; n++) {
  const seq = collatzSequence(n);
  allSeqs.push(seq);
  maxLen = Math.max(maxLen, seq.length);
}

const cellW = w / maxLen;
const cellH = h / maxN;
const globalMax = Math.max(...allSeqs.flat());

allSeqs.forEach((seq, i) => {
  seq.forEach((val, j) => {
    const intensity = Math.log(val + 1) / Math.log(globalMax + 1);
    ctx.fillStyle = `hsl(${240 - intensity * 240}, 80%, ${30 + intensity * 40}%)`;
    ctx.fillRect(pad + j * cellW, pad + i * cellH, cellW + 1, cellH + 1);
  });
});

ctx.fillStyle = isDark() ? '#ffd700' : '#cc8800';
ctx.font = 'bold 14px Segoe UI'; ctx.textAlign = 'center';
ctx.fillText(`Collatz Heatmap: n (1-${maxN}) versus Step`, c.width / 2, 20);

// Axis labels
ctx.fillStyle = isDark() ? '#aaa' : '#666';
ctx.font = '10px Segoe UI';
ctx.fillText('Step →', c.width / 2, c.height - 10);
ctx.save(); ctx.translate(15, c.height/2); ctx.rotate(-Math.PI/2);
ctx.fillText('Starting n ↑', 0, 0); ctx.restore();

} else {
// Inverse tree
const levels = [[1]];
const seen = new Set([1]);
for (let lvl = 0; lvl < 8; lvl++) {
const next = [];
for (const n of levels[lvl]) {
const parent1 = 2 * n;
if (!seen.has(parent1) && parent1 < 10000) { next.push(parent1); seen.add(parent1); }
if ((n - 1) % 3 === 0 && n > 1) {
const parent2 = (n - 1) / 3;
if (parent2 % 2 === 1 && !seen.has(parent2) && parent2 > 1) { next.push(parent2); seen.add(parent2); }
}
}
if (next.length === 0) break;
levels.push(next.sort((a, b) => a - b));
}

levels.forEach((level, d) => {
const y = pad + 40 + d * 50;
level.slice(0, 20).forEach((n, i) => {
const x = pad + (i + 0.5) / Math.min(level.length, 20) * (c.width - 2 * pad);
ctx.fillStyle = '#00d9ff';
ctx.beginPath();
ctx.arc(x, y, 8, 0, 2 * PI);
ctx.fill();
ctx.fillStyle = isDark() ? '#fff' : '#000';
ctx.font = '9px Segoe UI';
ctx.textAlign = 'center';
ctx.fillText(n.toString(), x, y + 3);
});
});
}

ctx.fillStyle = isDark() ? '#ff6496' : '#cc0044';
ctx.font = 'bold 14px Segoe UI';
ctx.textAlign = 'center';
if (mode !== 'histogram' && mode !== 'records' && mode !== 'residue') {
ctx.fillText(`Collatz Conjecture (3n+1) — Starting from ${startN}`, c.width / 2, 25);
}

const seq = collatzSequence(startN);
const maxVal = Math.max(...seq);

// Compute record holders for stats
let records = [];
if (startN >= 10) {
let maxST = 0;
for (let n = 1; n <= Math.min(startN, 10000); n++) {
const s = collatzSequence(n);
if (s.length - 1 > maxST) {
maxST = s.length - 1;
records.push({n, stopTime: maxST, maxVal: Math.max(...s)});
}
}
}

document.getElementById('collLiveStats').innerHTML = `
<div style="background:linear-gradient(135deg,rgba(255,100,150,.15),rgba(0,217,255,.1));padding:10px;border-radius:8px;margin-bottom:12px;border:1px solid #ff6496">
<div style="font-size:.7rem;color:var(--txt2);margin-bottom:4px">TAB: Collatz Conjecture | FIELD: ℤ⁺ | TYPE: 3n+1 Problem</div>
</div>
<div style="display:grid;grid-template-columns:repeat(3,1fr);gap:8px;margin-bottom:12px">
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center"><div style="font-size:1.2rem;font-weight:bold;color:#ff6496">${startN}</div><div style="font-size:.7rem;color:var(--txt2)">START/MAX</div></div>
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center"><div style="font-size:1.2rem;font-weight:bold;color:#ffd700">${seq.length - 1}</div><div style="font-size:.7rem;color:var(--txt2)">STEPS TO 1</div></div>
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center"><div style="font-size:1.2rem;font-weight:bold;color:#00d9ff">${maxVal.toLocaleString()}</div><div style="font-size:.7rem;color:var(--txt2)">MAX VALUE</div></div>
</div>
<div style="margin-bottom:10px;padding-bottom:8px;border-bottom:1px solid var(--bord)">
<strong style="color:var(--acc)">Record Holders (longest stopping times)</strong>
<div style="font-size:.75rem;color:var(--txt2);margin-top:5px;line-height:1.6">
${records.slice(-8).reverse().map(r => `n=${r.n}: ${r.stopTime} steps (max ${r.maxVal.toLocaleString()})`).join('<br>')}
</div>
</div>
<div style="font-size:.8rem;color:var(--txt2)">
<strong style="color:var(--acc)">Conjecture:</strong> Every positive integer eventually reaches 1<br>
<strong style="color:var(--acc)">Rule:</strong> If even: n/2, if odd: 3n+1<br>
<strong style="color:var(--acc)">Famous:</strong> 27→111 steps, 871→178 steps, 6171→261 steps
</div>`;

if (collatzData.length > 0) {
Plotly.newPlot('pcoll1', [{ x: collatzData.map(d => d.step !== undefined ? d.step : d.n), y: collatzData.map(d => d.n !== undefined ? d.n : d.stopTime), mode: 'lines+markers', line: { color: '#ff6496' } }], { ...plo(), xaxis: { title: mode === 'single' ? 'Step' : 'n' }, yaxis: { title: mode === 'single' ? 'Value' : 'Stopping Time' } });
}
}

function csvCollatz() { let s = 'step,n\n'; collatzData.forEach(d => s += `${d.step},${d.n}\n`); dl(s, 'collatz.csv'); }
async function screenshotCollatz() { await screenshotUnified('ccoll', 'collLiveStats', 'Collatz Conjecture', 'collatz.png'); }
function exportAllCollatz() { screenshotTabAll({ canvases: ['ccoll'], charts: ['pcoll1'], dashId: 'collLiveStats', title: 'Collatz Conjecture', filename: 'collatz_all.png' }); }

// ==================== HIGHLY COMPOSITE NUMBERS ====================
let hcData = [];

function countDivisors(n) {
let count = 0;
for (let d = 1; d * d <= n; d++) {
if (n % d === 0) count += (d * d === n) ? 1 : 2;
}
return count;
}

function drawHighComp() {
const maxN = +document.getElementById('hcNv').value || 10000;
const mode = document.getElementById('hcMode').value;
const c = document.getElementById('chc'), ctx = c.getContext('2d');
ctx.fillStyle = canvBg(); ctx.fillRect(0, 0, c.width, c.height);

hcData = [];
let maxDiv = 0;

if (mode === 'hc') {
for (let n = 1; n <= maxN; n++) {
const d = countDivisors(n);
if (d > maxDiv) {
maxDiv = d;
hcData.push({ n, divisors: d });
}
}
} else if (mode === 'superior') {
// Superior highly composite: minimize n^(1/d(n))
let minVal = Infinity;
for (let n = 1; n <= maxN; n++) {
const d = countDivisors(n);
const val = Math.pow(n, 1 / d);
if (val < minVal) {
minVal = val;
hcData.push({ n, divisors: d, value: val });
}
}
} else if (mode === 'abundant') {
for (let n = 12; n <= maxN; n++) {
const sigma = aliquotSum(n) + n;
if (sigma > 2 * n) {
const d = countDivisors(n);
hcData.push({ n, divisors: d, sigma, abundance: sigma - 2 * n });
}
}
hcData = hcData.slice(0, 500); // Limit for display
}

// Draw
const pad = 50, w = c.width - 2 * pad, h = c.height - 2 * pad;

if (hcData.length > 0) {
const maxVal = Math.max(...hcData.map(d => d.divisors));
hcData.forEach((d, i) => {
const x = pad + (i / (hcData.length - 1 || 1)) * w;
const y = c.height - pad - (d.divisors / maxVal) * h;
ctx.fillStyle = mode === 'hc' ? '#ffd700' : mode === 'superior' ? '#00ff88' : '#ff6496';
ctx.beginPath();
ctx.arc(x, y, 5, 0, 2 * PI);
ctx.fill();
if (hcData.length <= 30 && d.n < 10000) {
ctx.fillStyle = isDark() ? '#fff' : '#000';
ctx.font = '9px Segoe UI';
ctx.textAlign = 'center';
ctx.fillText(d.n.toString(), x, y - 8);
}
});
}

const titles = { hc: 'Highly Composite', superior: 'Superior HC', abundant: 'Abundant' };
ctx.fillStyle = isDark() ? '#ffd700' : '#cc8800';
ctx.font = 'bold 14px Segoe UI';
ctx.textAlign = 'center';
ctx.fillText(`${titles[mode]} Numbers ≤ ${maxN}`, c.width / 2, 25);

document.getElementById('hcLiveStats').innerHTML = `
<div style="background:linear-gradient(135deg,rgba(255,215,0,.15),rgba(0,217,255,.1));padding:10px;border-radius:8px;margin-bottom:12px;border:1px solid #ffd700">
<div style="font-size:.7rem;color:var(--txt2);margin-bottom:4px">TAB: ${titles[mode]} | FIELD: Z | TYPE: ${mode === 'hc' ? 'd(n) Records' : mode === 'superior' ? 'min n^(1/d(n))' : 'sigma(n) > 2n'}</div>
</div>
<div style="display:grid;grid-template-columns:repeat(3,1fr);gap:8px;margin-bottom:12px">
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center"><div style="font-size:1.2rem;font-weight:bold;color:#ffd700">${hcData.length}</div><div style="font-size:.7rem;color:var(--txt2)">FOUND</div></div>
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center"><div style="font-size:1.2rem;font-weight:bold;color:#00d9ff">${hcData.length > 0 ? hcData[hcData.length - 1].n : 0}</div><div style="font-size:.7rem;color:var(--txt2)">LARGEST</div></div>
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center"><div style="font-size:1.2rem;font-weight:bold;color:#00ff88">${hcData.length > 0 ? hcData[hcData.length - 1].divisors : 0}</div><div style="font-size:.7rem;color:var(--txt2)">MAX DIV</div></div>
</div>
<div style="font-size:.8rem;color:var(--txt2)">
<strong style="color:var(--acc)">First:</strong> ${hcData.slice(0, 8).map(d => d.n).join(', ')}${hcData.length > 8 ? '...' : ''}<br>
<strong style="color:var(--acc)">Mode:</strong> ${mode === 'hc' ? 'n is HC if d(n) > d(m) for all m < n' : mode === 'superior' ? 'n is SHC if n^(1/d) is record low' : 'n is abundant if sigma(n) > 2n'}
</div>`;

if (hcData.length > 0) {
Plotly.newPlot('phc1', [{ x: hcData.map(d => d.n), y: hcData.map(d => d.divisors), mode: 'lines+markers', line: { color: mode === 'hc' ? '#ffd700' : mode === 'superior' ? '#00ff88' : '#ff6496' } }], { ...plo(), xaxis: { title: 'n', type: hcData.length > 50 ? 'log' : 'linear' }, yaxis: { title: 'd(n)' } });
}
}

function csvHighComp() { let s = 'n,divisors\n'; hcData.forEach(d => s += `${d.n},${d.divisors}\n`); dl(s, 'highly_composite.csv'); }
async function screenshotHighComp() { await screenshotUnified('chc', 'hcLiveStats', 'Highly Composite Numbers', 'highcomp.png'); }
function exportAllHighComp() { screenshotTabAll({ canvases: ['chc'], charts: ['phc1'], dashId: 'hcLiveStats', title: 'Highly Composite', filename: 'highcomp_all.png' }); }

// ==================== PERFECT NUMBERS ====================
let perfectData = [];

function drawPerfect() {
const maxN = +document.getElementById('perfNv').value || 10000;
const mode = document.getElementById('perfMode').value;
const c = document.getElementById('cperf'), ctx = c.getContext('2d');
ctx.fillStyle = canvBg(); ctx.fillRect(0, 0, c.width, c.height);

perfectData = [];
let perfect = 0, abundant = 0, deficient = 0;

for (let n = 2; n <= maxN; n++) {
const s = aliquotSum(n);
const type = s === n ? 'perfect' : s > n ? 'abundant' : 'deficient';
if (type === 'perfect') perfect++;
else if (type === 'abundant') abundant++;
else deficient++;
if (type === 'perfect' || (mode === 'sigma' && n <= 500)) {
perfectData.push({ n, sigma: s + n, type, ratio: (s + n) / n });
}
}

// Draw
const pad = 50;
if (mode === 'classify') {
// Pie-like visualization
const total = perfect + abundant + deficient;
const angles = [
{ type: 'deficient', count: deficient, color: '#00d9ff', start: 0 },
{ type: 'abundant', count: abundant, color: '#ff6496', start: deficient / total * 2 * PI },
{ type: 'perfect', count: perfect, color: '#ffd700', start: (deficient + abundant) / total * 2 * PI }
];
const cx = c.width / 2, cy = c.height / 2 + 20, r = 150;
angles.forEach(a => {
const end = a.start + a.count / total * 2 * PI;
ctx.fillStyle = a.color;
ctx.beginPath();
ctx.moveTo(cx, cy);
ctx.arc(cx, cy, r, a.start - PI / 2, end - PI / 2);
ctx.closePath();
ctx.fill();
});
} else if (mode === 'sigma') {
// σ(n)/n ratio plot
const ratioData = [];
for (let n = 2; n <= Math.min(maxN, 500); n++) {
ratioData.push({ n, ratio: (aliquotSum(n) + n) / n });
}
const w = c.width - 2 * pad, h = c.height - 2 * pad;
ratioData.forEach(d => {
const x = pad + (d.n / 500) * w;
const y = c.height - pad - ((d.ratio - 1) / 2) * h;
ctx.fillStyle = d.ratio === 2 ? '#ffd700' : d.ratio > 2 ? '#ff6496' : '#00d9ff';
ctx.beginPath();
ctx.arc(x, y, 2, 0, 2 * PI);
ctx.fill();
});
// Line at ratio = 2
ctx.strokeStyle = '#ffd700';
ctx.setLineDash([5, 5]);
ctx.beginPath();
const y2 = c.height - pad - h / 2;
ctx.moveTo(pad, y2);
ctx.lineTo(c.width - pad, y2);
ctx.stroke();
ctx.setLineDash([]);
} else if (mode === 'mersenne') {
// Mersenne connection: 2^(p-1)(2^p - 1) when 2^p - 1 is prime
const mersenneData = [];
const mersenneExps = [2, 3, 5, 7, 13, 17, 19, 31]; // Known Mersenne primes exponents
mersenneExps.forEach(p => {
const mp = Math.pow(2, p) - 1;
const perfect = Math.pow(2, p - 1) * mp;
if (perfect <= 1e15) {
mersenneData.push({ p, mp, perfect, logPerf: Math.log10(perfect) });
}
});

const w = c.width - 2 * pad, h = c.height - 2 * pad;
const maxLog = Math.max(...mersenneData.map(d => d.logPerf));

mersenneData.forEach((d, i) => {
const x = pad + (i / (mersenneData.length - 1 || 1)) * w;
const y = c.height - pad - (d.logPerf / maxLog) * h;

// Draw perfect number point
ctx.fillStyle = '#ffd700';
ctx.beginPath();
ctx.arc(x, y, 10, 0, 2 * PI);
ctx.fill();

// Label
ctx.fillStyle = isDark() ? '#fff' : '#333';
ctx.font = 'bold 10px Segoe UI';
ctx.textAlign = 'center';
ctx.fillText(`2^${d.p}-1`, x, y - 15);
ctx.font = '9px Segoe UI';
ctx.fillStyle = '#00d9ff';
if (d.perfect < 1e7) {
ctx.fillText(d.perfect.toString(), x, y + 20);
} else {
ctx.fillText(`10^${d.logPerf.toFixed(1)}`, x, y + 20);
}
});

// Draw connection line
ctx.strokeStyle = '#ffd700';
ctx.lineWidth = 2;
ctx.beginPath();
mersenneData.forEach((d, i) => {
const x = pad + (i / (mersenneData.length - 1 || 1)) * w;
const y = c.height - pad - (d.logPerf / maxLog) * h;
if (i === 0) ctx.moveTo(x, y);
else ctx.lineTo(x, y);
});
ctx.stroke();

// Title
ctx.fillStyle = '#00ff88';
ctx.font = 'bold 12px Segoe UI';
ctx.textAlign = 'left';
ctx.fillText('Euclid-Euler: Perfect = 2^(p-1) × (2^p - 1) where M_p is Mersenne prime', pad, c.height - 15);
}

ctx.fillStyle = isDark() ? '#ffd700' : '#cc8800';
ctx.font = 'bold 14px Segoe UI';
ctx.textAlign = 'center';
const titles = { classify: 'Classification', sigma: 'σ(n)/n Ratio', mersenne: 'Mersenne Connection' };
ctx.fillText(`Perfect Numbers: ${titles[mode]} (N ≤ ${maxN})`, c.width / 2, 25);

const perfectNums = [6, 28, 496, 8128].filter(p => p <= maxN);

document.getElementById('perfLiveStats').innerHTML = `
<div style="background:linear-gradient(135deg,rgba(255,215,0,.15),rgba(0,217,255,.1));padding:10px;border-radius:8px;margin-bottom:12px;border:1px solid #ffd700">
<div style="font-size:.7rem;color:var(--txt2);margin-bottom:4px">TAB: Perfect Numbers | FIELD: Z | TYPE: ${titles[mode]}</div>
</div>
<div style="display:grid;grid-template-columns:repeat(3,1fr);gap:8px;margin-bottom:12px">
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center"><div style="font-size:1.2rem;font-weight:bold;color:#ffd700">${perfect}</div><div style="font-size:.7rem;color:var(--txt2)">PERFECT</div></div>
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center"><div style="font-size:1.2rem;font-weight:bold;color:#ff6496">${abundant}</div><div style="font-size:.7rem;color:var(--txt2)">ABUNDANT</div></div>
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center"><div style="font-size:1.2rem;font-weight:bold;color:#00d9ff">${deficient}</div><div style="font-size:.7rem;color:var(--txt2)">DEFICIENT</div></div>
</div>
<div style="font-size:.8rem;color:var(--txt2)">
<strong style="color:var(--acc)">Perfect in range:</strong> ${perfectNums.join(', ') || 'None'}<br>
<strong style="color:var(--acc)">Euclid-Euler:</strong> Even perfect = 2^(p-1)(2^p - 1) with M_p prime<br>
<strong style="color:var(--acc)">Mersenne exps:</strong> 2, 3, 5, 7, 13, 17, 19, 31, 61, 89, 107...
</div>`;

Plotly.newPlot('pperf1', [{ x: ['Deficient', 'Abundant', 'Perfect'], y: [deficient, abundant, perfect], type: 'bar', marker: { color: ['#00d9ff', '#ff6496', '#ffd700'] } }], { ...plo(), xaxis: { title: 'Type' }, yaxis: { title: 'Count' } });
}

function csvPerfect() { let s = 'n,sigma,type\n'; perfectData.forEach(d => s += `${d.n},${d.sigma},${d.type}\n`); dl(s, 'perfect.csv'); }
async function screenshotPerfect() { await screenshotUnified('cperf', 'perfLiveStats', 'Perfect Numbers', 'perfect.png'); }
function exportAllPerfect() { screenshotTabAll({ canvases: ['cperf'], charts: ['pperf1'], dashId: 'perfLiveStats', title: 'Perfect Numbers', filename: 'perfect_all.png' }); }

// ==================== TAXICAB NUMBERS ====================
let taxicabData = [];

function drawTaxicab() {
const maxSum = +document.getElementById('taxiNv').value || 20000;
const minK = +document.getElementById('taxiK').value;
const c = document.getElementById('ctaxi'), ctx = c.getContext('2d');
ctx.fillStyle = canvBg(); ctx.fillRect(0, 0, c.width, c.height);

// Find numbers expressible as sum of two cubes in multiple ways
const cubeSums = new Map();
const maxCube = Math.ceil(Math.pow(maxSum, 1 / 3));

for (let a = 1; a <= maxCube; a++) {
for (let b = a; b <= maxCube; b++) {
const sum = a * a * a + b * b * b;
if (sum > maxSum) break;
if (!cubeSums.has(sum)) cubeSums.set(sum, []);
cubeSums.get(sum).push([a, b]);
}
}

taxicabData = [];
for (const [sum, ways] of cubeSums) {
if (ways.length >= minK) {
taxicabData.push({ n: sum, ways, k: ways.length });
}
}
taxicabData.sort((a, b) => a.n - b.n);

// Draw
const pad = 50;
ctx.font = '12px monospace';
taxicabData.slice(0, 15).forEach((t, i) => {
const y = pad + 40 + i * 28;
ctx.fillStyle = t.n === 1729 ? '#ffd700' : '#00d9ff';
ctx.textAlign = 'left';
ctx.fillText(`${t.n} = ${t.ways.map(w => `${w[0]}³+${w[1]}³`).join(' = ')}`, pad, y);
});

ctx.fillStyle = isDark() ? '#ffd700' : '#cc8800';
ctx.font = 'bold 14px Segoe UI';
ctx.textAlign = 'center';
ctx.fillText(`Taxicab Numbers Ta(${minK}) ≤ ${maxSum}`, c.width / 2, 25);

document.getElementById('taxiLiveStats').innerHTML = `
<div style="background:linear-gradient(135deg,rgba(255,215,0,.15),rgba(0,217,255,.1));padding:10px;border-radius:8px;margin-bottom:12px;border:1px solid #ffd700">
<div style="font-size:.7rem;color:var(--txt2);margin-bottom:4px">TAB: Taxicab Numbers | FIELD: ℤ | TYPE: a³ + b³ = c³ + d³</div>
</div>
<div style="display:grid;grid-template-columns:repeat(3,1fr);gap:8px;margin-bottom:12px">
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center"><div style="font-size:1.2rem;font-weight:bold;color:#ffd700">${taxicabData.length}</div><div style="font-size:.7rem;color:var(--txt2)">FOUND</div></div>
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center"><div style="font-size:1.2rem;font-weight:bold;color:#00d9ff">1729</div><div style="font-size:.7rem;color:var(--txt2)">FAMOUS Ta(2)</div></div>
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center"><div style="font-size:1.2rem;font-weight:bold;color:#00ff88">${minK}+ ways</div><div style="font-size:.7rem;color:var(--txt2)">MINIMUM</div></div>
</div>
<div style="font-size:.8rem;color:var(--txt2)">
<strong style="color:var(--acc)">Hardy-Ramanujan:</strong> 1729 = 1³+12³ = 9³+10³<br>
<strong style="color:var(--acc)">Ta(2):</strong> ${taxicabData.length > 0 ? taxicabData[0].n : '1729'}<br>
<strong style="color:var(--acc)">Story:</strong> Hardy's taxi number, Ramanujan recognized instantly
</div>`;

if (taxicabData.length > 0) {
Plotly.newPlot('ptaxi1', [{ x: taxicabData.map((_, i) => i + 1), y: taxicabData.map(t => t.n), mode: 'lines+markers', line: { color: '#ffd700' } }], { ...plo(), xaxis: { title: 'Index' }, yaxis: { title: 'Taxicab Number' } });
}
}

function csvTaxicab() { let s = 'n,ways,representations\n'; taxicabData.forEach(t => s += `${t.n},${t.k},"${t.ways.map(w => w[0] + '^3+' + w[1] + '^3').join('; ')}"\n`); dl(s, 'taxicab.csv'); }
async function screenshotTaxicab() { await screenshotUnified('ctaxi', 'taxiLiveStats', 'Taxicab Numbers', 'taxicab.png'); }
function exportAllTaxicab() { screenshotTabAll({ canvases: ['ctaxi'], charts: ['ptaxi1'], dashId: 'taxiLiveStats', title: 'Taxicab Numbers', filename: 'taxicab_all.png' }); }

// ==================== ELLIPTIC CURVES ====================
let ellipticData = [];
let constData = { primes: [], products: [], factors: [] };
let constAnimInterval = null;

// nu(p, H) = number of residue classes {0, H} mod p that are covered
// nu(p) = 1 if p divides H, else 2
function nu(p, H) {
  return (H % p === 0) ? 1 : 2;
}

// Admissible Pairs - CRT counting
function drawAdmissible() {
  const gapEl = document.getElementById('admGap');
  const pmaxEl = document.getElementById('admPmax');
  const c = document.getElementById('cadmissible');
  if (!gapEl || !pmaxEl || !c) return; // Safety check - elements not present
  const gap = +gapEl.value;
  const pmax = +pmaxEl.value;
  const ctx = c.getContext('2d');
  
  ctx.fillStyle = canvBg();
  ctx.fillRect(0, 0, c.width, c.height);
  
  // Get odd primes up to pmax
  const primes = sievePrimes(pmax).filter(p => p > 2);
  
  // Compute running products
  let R = 1;  // ∏(p - ν)
  let C = 1;  // Hardy-Littlewood constant
  const steps = [];
  const cValues = [];
  
  for (const p of primes) {
    const v = nu(p, gap);
    const pMinusNu = p - v;
    R *= pMinusNu;
    
    // C_H factor: base × enhancement
    const baseFactor = p * (p - 2) / ((p - 1) * (p - 1));
    const enhancement = (gap % p === 0 && p > 2) ? (p - 1) / (p - 2) : 1;
    C *= baseFactor * enhancement;
    
    steps.push({ p, divides: gap % p === 0, v, pMinusNu, R, cFactor: baseFactor * enhancement, C });
    cValues.push({ p, C });
  }
  
  // Draw bar chart of (p - ν) values
  const pad = 50, w = c.width - 2*pad, h = c.height - 2*pad;
  const barW = Math.min(40, w / primes.length - 4);
  const maxVal = Math.max(...steps.map(s => s.pMinusNu));
  
  ctx.strokeStyle = '#444';
  ctx.beginPath();
  ctx.moveTo(pad, pad); ctx.lineTo(pad, c.height - pad);
  ctx.lineTo(c.width - pad, c.height - pad);
  ctx.stroke();
  
  steps.forEach((s, i) => {
    const x = pad + i * (w / steps.length) + barW/2;
    const barH = (s.pMinusNu / maxVal) * h * 0.8;
    const y = c.height - pad - barH;
    
    // Color based on whether p divides gap
    ctx.fillStyle = s.divides ? '#ffd700' : '#ff6496';
    ctx.fillRect(x, y, barW, barH);
    
    // Label
    ctx.fillStyle = '#fff';
    ctx.font = '11px monospace';
    ctx.textAlign = 'center';
    ctx.fillText(s.p, x + barW/2, c.height - pad + 15);
    ctx.fillText(s.pMinusNu, x + barW/2, y - 5);
    
    // ν value
    ctx.fillStyle = s.divides ? '#ffd700' : '#888';
    ctx.font = '9px monospace';
    ctx.fillText('ν=' + s.v, x + barW/2, y - 18);
  });
  
  // Title
  ctx.fillStyle = '#fff';
  ctx.font = 'bold 14px sans-serif';
  ctx.textAlign = 'center';
  ctx.fillText(`Gap H = ${gap}: Factors (p - ν) for each prime`, c.width/2, 25);
  
  // Legend
  ctx.font = '11px sans-serif';
  ctx.fillStyle = '#ffd700';
  ctx.fillRect(c.width - 150, 15, 12, 12);
  ctx.fillStyle = '#fff';
  ctx.textAlign = 'left';
  ctx.fillText('p | H (ν=1)', c.width - 135, 25);
  
  ctx.fillStyle = '#ff6496';
  ctx.fillRect(c.width - 150, 32, 12, 12);
  ctx.fillStyle = '#fff';
  ctx.fillText('p ∤ H (ν=2)', c.width - 135, 42);
  
  // Update stats
  const primorial = primes.reduce((a, p) => a * p, 1) * 2;
  const density = R / primorial;
  
  document.getElementById('admLiveStats').innerHTML = `
<div style="display:grid;grid-template-columns:1fr 1fr;gap:1rem">
<div style="background:var(--bg1);padding:1rem;border-radius:8px;text-align:center">
<div style="font-size:1.5rem;font-weight:bold;color:#ff6496">${R.toLocaleString()}</div>
<div style="font-size:.8rem;color:var(--txt2)">R<sub>H</sub> = ∏(p - ν)</div>
<div style="font-size:.75rem;color:#888">Admissible pair count</div>
</div>
<div style="background:var(--bg1);padding:1rem;border-radius:8px;text-align:center">
<div style="font-size:1.5rem;font-weight:bold;color:#ffd700">${C.toFixed(8)}</div>
<div style="font-size:.8rem;color:var(--txt2)">C<sub>H</sub> (Hardy-Littlewood)</div>
<div style="font-size:.75rem;color:#888">→ ${gap === 2 ? '0.6601618' : (0.6601618 * (gap % 3 === 0 ? 2 : 1) * (gap % 5 === 0 ? 4/3 : 1)).toFixed(4)}...</div>
</div>
</div>
<div style="margin-top:1rem;background:var(--bg1);padding:1rem;border-radius:8px">
<div style="display:grid;grid-template-columns:repeat(3,1fr);gap:.5rem;text-align:center">
<div><span style="color:#00d9ff">${primes.length}</span><br><span style="font-size:.75rem;color:var(--txt2)">Odd primes</span></div>
<div><span style="color:#00ff88">${primorial.toLocaleString()}</span><br><span style="font-size:.75rem;color:var(--txt2)">Primorial M</span></div>
<div><span style="color:#9664ff">${density.toExponential(4)}</span><br><span style="font-size:.75rem;color:var(--txt2)">Density R/M</span></div>
</div>
</div>
<div style="margin-top:1rem;padding:.75rem;background:rgba(0,255,136,.1);border-radius:6px;border-left:3px solid #00ff88">
<strong style="color:#00ff88">Interpretation:</strong>
<span style="color:var(--txt2);font-size:.85rem"> Of the ${primorial.toLocaleString()} residue classes mod M, exactly ${R.toLocaleString()} pairs (r, r+${gap}) have both members coprime to M.</span>
</div>`;
  
  // Update step table
  let tableHTML = '';
  for (const s of steps) {
    tableHTML += `<tr>
<td style="padding:6px;font-weight:bold">${s.p}</td>
<td style="color:${s.divides ? '#ffd700' : '#888'}">${s.divides ? 'Yes' : 'No'}</td>
<td>${s.v}</td>
<td style="color:#ff6496">${s.pMinusNu}</td>
<td style="font-family:monospace;color:#ff6496">${s.R.toLocaleString()}</td>
<td style="font-family:monospace;color:#ffd700">${s.cFactor.toFixed(6)}</td>
<td style="font-family:monospace;color:#00ff88">${s.C.toFixed(8)}</td>
</tr>`;
  }
  document.getElementById('tAdmStep').innerHTML = `
<tr style="background:rgba(255,100,150,.15);position:sticky;top:0">
<th style="padding:8px">Prime p</th>
<th>p | H?</th>
<th>ν<sub>H</sub>(p)</th>
<th>p - ν</th>
<th style="color:#ff6496">Running ∏(p-ν)</th>
<th style="color:#ffd700">C<sub>H</sub> factor</th>
<th style="color:#00ff88">Running C<sub>H</sub></th>
</tr>` + tableHTML;
  
  // Plot C_H convergence
  if (cValues.length > 0 && typeof Plotly !== 'undefined') {
    const trueC = 0.6601618 * (gap % 3 === 0 ? 2 : 1) * (gap % 5 === 0 ? 4/3 : 1) * (gap % 7 === 0 ? 6/5 : 1);
    Plotly.newPlot('padmConv', [
      { x: cValues.map(v => v.p), y: cValues.map(v => v.C), mode: 'lines+markers', name: 'C_H(p)', line: { color: '#ff6496', width: 2 }, marker: { size: 6 } },
      { x: [cValues[0].p, cValues[cValues.length-1].p], y: [trueC, trueC], mode: 'lines', name: 'C_H(∞) ≈ ' + trueC.toFixed(4), line: { color: '#ffd700', dash: 'dash', width: 1 } }
    ], { ...plo(), xaxis: { title: 'p_max' }, yaxis: { title: 'C_H', range: [0, Math.max(trueC * 1.5, ...cValues.map(v => v.C)) ] } });
  }
}

function csvAdmissible() {
  const gap = +document.getElementById('admGap').value;
  const pmax = +document.getElementById('admPmax').value;
  const primes = sievePrimes(pmax).filter(p => p > 2);
  
  let csv = 'p,divides_H,nu,p_minus_nu,running_R,C_factor,running_C\n';
  let R = 1, C = 1;
  for (const p of primes) {
    const v = nu(p, gap);
    R *= (p - v);
    const baseFactor = p * (p - 2) / ((p - 1) * (p - 1));
    const enhancement = (gap % p === 0 && p > 2) ? (p - 1) / (p - 2) : 1;
    C *= baseFactor * enhancement;
    csv += `${p},${gap % p === 0},${v},${p-v},${R},${(baseFactor*enhancement).toFixed(8)},${C.toFixed(10)}\n`;
  }
  downloadCSV(csv, `admissible_pairs_gap${gap}_pmax${pmax}.csv`);
}

function drawElliptic() {
const a = +document.getElementById('ellA').value;
const b = +document.getElementById('ellB').value;
const mode = document.getElementById('ellMode').value;
const p = +document.getElementById('ellP').value;
const c = document.getElementById('cell'), ctx = c.getContext('2d');
ctx.fillStyle = canvBg(); ctx.fillRect(0, 0, c.width, c.height);

const discriminant = -16 * (4 * a * a * a + 27 * b * b);

ellipticData = [];

if (mode === 'real') {
// Plot y² = x³ + ax + b over reals
const cx = c.width / 2, cy = c.height / 2;
const scale = 30;

// Grid
ctx.strokeStyle = gridC();
ctx.lineWidth = 0.5;
for (let i = -10; i <= 10; i++) {
ctx.beginPath();
ctx.moveTo(cx + i * scale, 0);
ctx.lineTo(cx + i * scale, c.height);
ctx.stroke();
ctx.beginPath();
ctx.moveTo(0, cy + i * scale);
ctx.lineTo(c.width, cy + i * scale);
ctx.stroke();
}

// Axes
ctx.strokeStyle = isDark() ? '#fff' : '#333';
ctx.lineWidth = 1;
ctx.beginPath();
ctx.moveTo(0, cy);
ctx.lineTo(c.width, cy);
ctx.moveTo(cx, 0);
ctx.lineTo(cx, c.height);
ctx.stroke();

// Axis labels
ctx.fillStyle = isDark() ? '#888' : '#666';
ctx.font = '10px Segoe UI';
ctx.textAlign = 'center';
for (let i = -8; i <= 8; i += 2) {
if (i !== 0) {
ctx.fillText(i.toString(), cx + i * scale, cy + 15);
ctx.fillText(i.toString(), cx - 15, cy - i * scale + 4);
}
}

// Plot curve - upper and lower branches
ctx.fillStyle = '#ffd700';
for (let px = 0; px < c.width; px++) {
const x = (px - cx) / scale;
const y2 = x * x * x + a * x + b;
if (y2 >= 0) {
const y = Math.sqrt(y2);
// Upper branch
ctx.beginPath();
ctx.arc(px, cy - y * scale, 1.5, 0, 2 * PI);
ctx.fill();
// Lower branch
ctx.beginPath();
ctx.arc(px, cy + y * scale, 1.5, 0, 2 * PI);
ctx.fill();
ellipticData.push({ x: +x.toFixed(2), y: +y.toFixed(2) });
}
}
} else if (mode === 'modp') {
// Points over F_p
const points = [];
for (let x = 0; x < p; x++) {
const rhs = (x * x * x + a * x + b) % p;
for (let y = 0; y < p; y++) {
if ((y * y) % p === (rhs + p) % p) {
points.push({ x, y });
ellipticData.push({ x, y });
}
}
}

// Grid
const pad = 50, size = Math.min((c.width - 2 * pad) / p, (c.height - 2 * pad) / p, 15);
ctx.strokeStyle = gridC();
ctx.lineWidth = 0.5;
for (let i = 0; i <= p; i++) {
ctx.beginPath();
ctx.moveTo(pad + i * size, pad);
ctx.lineTo(pad + i * size, c.height - pad);
ctx.stroke();
ctx.beginPath();
ctx.moveTo(pad, c.height - pad - i * size);
ctx.lineTo(pad + p * size, c.height - pad - i * size);
ctx.stroke();
}

// Axis labels
ctx.fillStyle = isDark() ? '#888' : '#666';
ctx.font = '9px Segoe UI';
ctx.textAlign = 'center';
for (let i = 0; i < p; i += Math.ceil(p / 10)) {
ctx.fillText(i.toString(), pad + i * size + size / 2, c.height - pad + 12);
ctx.fillText(i.toString(), pad - 12, c.height - pad - i * size - size / 2 + 3);
}

// Points
points.forEach(pt => {
const px = pad + pt.x * size + size / 2;
const py = c.height - pad - pt.y * size - size / 2;
ctx.fillStyle = '#ffd700';
ctx.beginPath();
ctx.arc(px, py, Math.max(size / 3, 3), 0, 2 * PI);
ctx.fill();
});

// Point at infinity indicator
ctx.fillStyle = '#ff6496';
ctx.font = 'bold 12px Segoe UI';
ctx.textAlign = 'right';
ctx.fillText('∞ (identity)', c.width - 20, c.height - 20);
} else if (mode === 'group') {
// Group law visualization: P + Q = R
const cx = c.width / 2, cy = c.height / 2;
const scale = 40;

// Grid
ctx.strokeStyle = gridC();
ctx.lineWidth = 0.5;
for (let i = -8; i <= 8; i++) {
ctx.beginPath();
ctx.moveTo(cx + i * scale, 0);
ctx.lineTo(cx + i * scale, c.height);
ctx.stroke();
ctx.beginPath();
ctx.moveTo(0, cy + i * scale);
ctx.lineTo(c.width, cy + i * scale);
ctx.stroke();
}

// Axes
ctx.strokeStyle = isDark() ? '#fff' : '#333';
ctx.lineWidth = 1;
ctx.beginPath();
ctx.moveTo(0, cy);
ctx.lineTo(c.width, cy);
ctx.moveTo(cx, 0);
ctx.lineTo(cx, c.height);
ctx.stroke();

// Plot curve
ctx.fillStyle = '#ffd700';
for (let px = 0; px < c.width; px++) {
const x = (px - cx) / scale;
const y2 = x * x * x + a * x + b;
if (y2 >= 0) {
const y = Math.sqrt(y2);
ctx.beginPath();
ctx.arc(px, cy - y * scale, 1.5, 0, 2 * PI);
ctx.fill();
ctx.beginPath();
ctx.arc(px, cy + y * scale, 1.5, 0, 2 * PI);
ctx.fill();
}
}

// Find two points P and Q on the curve for demonstration
let P = null, Q = null;
for (let x = -3; x <= 3 && !P; x += 0.5) {
const y2 = x * x * x + a * x + b;
if (y2 > 0) P = { x, y: Math.sqrt(y2) };
}
for (let x = 0; x <= 5 && !Q; x += 0.5) {
const y2 = x * x * x + a * x + b;
if (y2 > 0 && (!P || Math.abs(x - P.x) > 0.5)) Q = { x, y: Math.sqrt(y2) };
}

if (P && Q) {
// Draw P
ctx.fillStyle = '#00ff88';
ctx.beginPath();
ctx.arc(cx + P.x * scale, cy - P.y * scale, 8, 0, 2 * PI);
ctx.fill();
ctx.fillStyle = isDark() ? '#fff' : '#000';
ctx.font = 'bold 12px Segoe UI';
ctx.textAlign = 'center';
ctx.fillText('P', cx + P.x * scale, cy - P.y * scale - 15);

// Draw Q
ctx.fillStyle = '#00d9ff';
ctx.beginPath();
ctx.arc(cx + Q.x * scale, cy - Q.y * scale, 8, 0, 2 * PI);
ctx.fill();
ctx.fillText('Q', cx + Q.x * scale, cy - Q.y * scale - 15);

// Line through P and Q
const slope = (Q.y - P.y) / (Q.x - P.x);
const intercept = P.y - slope * P.x;
ctx.strokeStyle = '#ff6496';
ctx.lineWidth = 2;
ctx.setLineDash([5, 5]);
ctx.beginPath();
ctx.moveTo(cx - 6 * scale, cy - (-6 * slope + intercept) * scale);
ctx.lineTo(cx + 6 * scale, cy - (6 * slope + intercept) * scale);
ctx.stroke();
ctx.setLineDash([]);

// Find third intersection point R'
// x³ + ax + b - (slope*x + intercept)² = 0
// Using Vieta: x_P + x_Q + x_R' = slope²
const xR = slope * slope - P.x - Q.x;
const yR = slope * xR + intercept;
const xResult = xR;
const yResult = -yR; // Reflect over x-axis

// Draw R' (intersection)
ctx.fillStyle = '#9664ff';
ctx.beginPath();
ctx.arc(cx + xR * scale, cy - yR * scale, 6, 0, 2 * PI);
ctx.fill();
ctx.fillStyle = isDark() ? '#fff' : '#000';
ctx.fillText("R'", cx + xR * scale + 15, cy - yR * scale);

// Vertical line to P+Q
ctx.strokeStyle = '#9664ff';
ctx.setLineDash([3, 3]);
ctx.beginPath();
ctx.moveTo(cx + xR * scale, cy - yR * scale);
ctx.lineTo(cx + xResult * scale, cy - yResult * scale);
ctx.stroke();
ctx.setLineDash([]);

// Draw P+Q (result)
ctx.fillStyle = '#ff6496';
ctx.beginPath();
ctx.arc(cx + xResult * scale, cy - yResult * scale, 8, 0, 2 * PI);
ctx.fill();
ctx.fillStyle = isDark() ? '#fff' : '#000';
ctx.font = 'bold 12px Segoe UI';
ctx.fillText('P+Q', cx + xResult * scale, cy - yResult * scale + 20);

ellipticData = [
{ x: +P.x.toFixed(2), y: +P.y.toFixed(2), label: 'P' },
{ x: +Q.x.toFixed(2), y: +Q.y.toFixed(2), label: 'Q' },
{ x: +xResult.toFixed(2), y: +yResult.toFixed(2), label: 'P+Q' }
];
}

// Legend
ctx.fillStyle = isDark() ? '#00d9ff' : '#0066cc';
ctx.font = '11px Segoe UI';
ctx.textAlign = 'left';
ctx.fillText('Group Law: Draw line through P,Q → intersects at R\' → reflect to get P+Q', 20, c.height - 15);
}

ctx.fillStyle = isDark() ? '#ffd700' : '#cc8800';
ctx.font = 'bold 14px Segoe UI';
ctx.textAlign = 'center';
ctx.fillText(`Elliptic Curve y² = x³ ${a >= 0 ? '+' : ''}${a}x ${b >= 0 ? '+' : ''}${b}${mode === 'modp' ? ' over 𝔽_' + p : ' over ℝ'}`, c.width / 2, 25);

const pointCount = ellipticData.length + 1; // +1 for point at infinity
const hasseError = mode === 'modp' ? Math.abs(pointCount - p - 1) : 0;
const hasseBound = mode === 'modp' ? 2 * Math.sqrt(p) : 0;

document.getElementById('ellLiveStats').innerHTML = `
<div style="background:linear-gradient(135deg,rgba(255,215,0,.15),rgba(0,217,255,.1));padding:10px;border-radius:8px;margin-bottom:12px;border:1px solid #ffd700">
<div style="font-size:.7rem;color:var(--txt2);margin-bottom:4px">TAB: Elliptic Curves | FIELD: ${mode === 'modp' ? 'E(𝔽_' + p + ')' : 'E(ℝ)'} | TYPE: y² = x³ + ax + b</div>
<div style="display:grid;grid-template-columns:repeat(3,1fr);gap:6px;font-size:.75rem">
<span>a: <strong style="color:#00d9ff">${a}</strong></span>
<span>b: <strong style="color:#ffd700">${b}</strong></span>
<span>Mode: <strong style="color:#00ff88">${mode === 'modp' ? '𝔽_' + p : 'ℝ'}</strong></span>
</div>
</div>
<div style="display:grid;grid-template-columns:repeat(3,1fr);gap:8px;margin-bottom:12px">
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center"><div style="font-size:1.2rem;font-weight:bold;color:#ffd700">${mode === 'modp' ? pointCount : '∞'}</div><div style="font-size:.7rem;color:var(--txt2)">#E POINTS</div></div>
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center"><div style="font-size:1.2rem;font-weight:bold;color:#00d9ff">${discriminant}</div><div style="font-size:.7rem;color:var(--txt2)">Δ DISCRIM</div></div>
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center"><div style="font-size:1.2rem;font-weight:bold;color:${discriminant !== 0 ? '#00ff88' : '#ff6496'}">${discriminant !== 0 ? 'Smooth' : 'Singular'}</div><div style="font-size:.7rem;color:var(--txt2)">TYPE</div></div>
</div>
${mode === 'modp' ? `<div style="display:grid;grid-template-columns:repeat(2,1fr);gap:8px;margin-bottom:12px">
<div style="background:var(--bg1);padding:8px;border-radius:6px;text-align:center"><div style="font-size:1rem;font-weight:bold;color:#9664ff">${fmt(hasseBound)}</div><div style="font-size:.6rem;color:var(--txt2)">HASSE BOUND 2√p</div></div>
<div style="background:var(--bg1);padding:8px;border-radius:6px;text-align:center"><div style="font-size:1rem;font-weight:bold;color:${hasseError <= hasseBound ? '#00ff88' : '#ff6496'}">${hasseError}</div><div style="font-size:.6rem;color:var(--txt2)">|#E - p - 1|</div></div>
</div>` : ''}
<div style="font-size:.8rem;color:var(--txt2)">
<strong style="color:var(--acc)">Discriminant:</strong> Δ = -16(4a³ + 27b²)<br>
<strong style="color:var(--acc)">Hasse's Theorem:</strong> |#E(𝔽_p) - p - 1| ≤ 2√p<br>
<strong style="color:var(--acc)">BSD Conjecture:</strong> rank(E) = ord_{s=1} L(E,s)
</div>`;

if (ellipticData.length > 0 && mode === 'modp') {
Plotly.newPlot('pell1', [{ x: ellipticData.map(pt => pt.x), y: ellipticData.map(pt => pt.y), mode: 'markers', marker: { color: '#ffd700', size: 8 }, name: 'E(𝔽_p)' }], { ...plo(), xaxis: { title: 'x mod ' + p }, yaxis: { title: 'y mod ' + p } });
} else if (mode === 'real') {
// Show curve shape as scatter
const plotData = ellipticData.filter((_, i) => i % 3 === 0);
Plotly.newPlot('pell1', [
{ x: plotData.map(pt => pt.x), y: plotData.map(pt => pt.y), mode: 'markers', marker: { color: '#ffd700', size: 3 }, name: 'y > 0' },
{ x: plotData.map(pt => pt.x), y: plotData.map(pt => -pt.y), mode: 'markers', marker: { color: '#00d9ff', size: 3 }, name: 'y < 0' }
], { ...plo(), xaxis: { title: 'x' }, yaxis: { title: 'y' } });
}
}

function csvElliptic() { let s = 'x,y\n'; ellipticData.forEach(pt => s += `${pt.x},${pt.y}\n`); dl(s, 'elliptic.csv'); }
async function screenshotElliptic() { await screenshotUnified('cell', 'ellLiveStats', 'Elliptic Curve', 'elliptic.png'); }
function exportAllElliptic() { screenshotTabAll({ canvases: ['cell'], charts: ['pell1'], dashId: 'ellLiveStats', title: 'Elliptic Curves', filename: 'elliptic_all.png' }); }

if(document.getElementById('c2d')) draw2D();
function showConstSection(section, btn) {
  document.querySelectorAll('.constSec').forEach(s => s.style.display = 'none');
  document.querySelectorAll('#tconstellations .tabs .tbtn').forEach(b => {
    b.classList.remove('active');
    b.style.borderBottomColor = 'transparent';
  });
  btn.classList.add('active');
  btn.style.borderBottomColor = '#ff6496';
  
  // Show section first, then draw with delay for Plotly to calculate dimensions
  // Use optional chaining for safety - elements may not exist
  if (section === 'sieve') {
    const el = document.getElementById('constSieve');
    if (el) { el.style.display = 'block'; setTimeout(() => drawConstellations(), 100); }
  } else if (section === 'integerN') {
    const el = document.getElementById('constIntegerN');
    if (el) { el.style.display = 'block'; setTimeout(() => drawIntegerNVerifier(), 100); }
  } else if (section === 'algebraic') {
    const el = document.getElementById('constAlgebraic');
    if (el) { el.style.display = 'block'; setTimeout(() => drawAlgebraicProof(), 100); }
  } else if (section === 'bigint') {
    const el = document.getElementById('constBigint');
    if (el) { el.style.display = 'block'; setTimeout(() => drawBigIntVerify(), 100); }
  } else if (section === 'gapH') {
    const el = document.getElementById('constGapH');
    if (el) { el.style.display = 'block'; setTimeout(() => drawGapHVerify(), 100); }
  } else if (section === 'ktuples') {
    const el = document.getElementById('constKtuples');
    if (el) { el.style.display = 'block'; setTimeout(() => drawSingularSeriesKtuples(), 100); }
  } else if (section === 'convergence') {
    const el = document.getElementById('constConvergence');
    if (el) { el.style.display = 'block'; setTimeout(() => drawConstConvergence(), 100); }
  } else if (section === 'open') {
    const el = document.getElementById('constOpen');
    if (el) { el.style.display = 'block'; setTimeout(() => drawConstOpen(), 100); }
  } else if (section === 'stepbystep') {
    const el = document.getElementById('constStepByStep');
    const outputEl = document.getElementById('stepByStepOutput');
    if (el) {
      el.style.display = 'block';
      if (outputEl && !outputEl.innerHTML.trim()) {
        setTimeout(() => generateStepByStep(), 100);
      }
    }
  }
}

// ===== INTEGER N VERIFIER FUNCTIONS =====

function computeSingularSeriesForN(N, gap = 2) {
  const primes = sievePrimes(N).filter(p => p > 2);
  if (primes.length === 0) return null;
  
  let R_mod = 0.25;
  let C = 1;
  let M = 1;
  
  for (const p of primes) {
    R_mod *= (p - 1) * (p - 2) / (p * p);
    C *= (p * (p - 2)) / ((p - 1) * (p - 1));
    // Add enhancement for gap divisibility
    if (gap % p === 0 && p > 2) {
      C *= (p - 1) / (p - 2);
    }
    M *= (p - 1) / p;
  }
  
  const R = 0.25 * C * Math.pow(M, 3);
  const ratio = R / R_mod;
  const maxP = primes[primes.length-1];
  const lnP = Math.log(maxP);
  const ln3P = lnP * lnP * lnP;
  
  // Mertens approximation: M ~ e^(-γ)/ln(p_max)
  const mertensApprox = E_NEG_GAMMA / lnP;
  
  // Get true C_H(∞) for this gap
  const C_H_inf = HL_CONSTANTS[gap] || 0.6601618158;
  
  // Asymptotic prediction: R_asymp ~ C_H(∞) × e^(-3γ) / [4 × ln³(p_max)]
  const R_asymp = C_H_inf * E_NEG_3GAMMA / (4 * ln3P);
  
  // Correction factor: actual R / asymptotic R
  const correctionFactor = R_mod / R_asymp;
  
  return {
    N, 
    gap,
    numPrimes: primes.length, 
    maxP,
    lnP,
    ln3P,
    R_mod, C, M, R, 
    ratio,
    isExact: Math.abs(ratio - 1) < 1e-10,
    mertensApprox,
    mertensRatio: M / mertensApprox,
    C2_error: Math.abs(C - C_H_inf),
    C_H_inf,
    R_asymp,
    correctionFactor,
    // Universal constants for display
    gamma: EULER_GAMMA,
    e_neg_gamma: E_NEG_GAMMA,
    e_neg_3gamma: E_NEG_3GAMMA
  };
}

function drawIntegerNVerifier() {
  const modeEl = document.getElementById('intNMode');
  const valueEl = document.getElementById('intNValue');
  if (!modeEl || !valueEl) return; // Safety check
  const mode = modeEl.value;
  const N = +valueEl.value;
  
  if (mode === 'single') {
    drawSingleN(N);
  } else if (mode === 'range') {
    testIntegerRange();
  } else {
    showConvergenceAnalysis();
  }
  
  // Always update the Mertens verification table
  updateMertensVerificationTable(N);
}

function drawSingleN(N) {
  const statsEl = document.getElementById('intNLiveStats');
  if (!statsEl) return; // Safety check
  const r = computeSingularSeriesForN(N);
  if (!r) {
    statsEl.innerHTML = '<div style="color:#ff4040">N must be ≥ 3</div>';
    return;
  }
  
  statsEl.innerHTML = `
<div style="background:linear-gradient(135deg,rgba(255,215,0,.15),rgba(255,100,150,.1));padding:12px;border-radius:8px;margin-bottom:12px;border:1px solid #ffd700">
<div style="font-size:.8rem;color:var(--txt2);margin-bottom:6px">SINGULAR SERIES VERIFICATION FOR N = ${N.toLocaleString()}</div>
<div style="display:grid;grid-template-columns:repeat(3,1fr);gap:8px;font-size:.85rem">
<span>Odd primes used: <strong style="color:#00d9ff">${r.numPrimes}</strong></span>
<span>Largest prime: <strong style="color:#ffd700">${r.maxP.toLocaleString()}</strong></span>
<span>Status: <strong style="color:${r.isExact?'#00ff88':'#ff4040'}">${r.isExact ? 'OK EXACT' : 'X FAIL'}</strong></span>
</div>
</div>

<div style="display:grid;grid-template-columns:repeat(2,1fr);gap:10px;margin-bottom:12px">
<div style="background:var(--bg1);padding:12px;border-radius:8px;text-align:center">
<div style="font-size:1.3rem;font-weight:bold;color:#ffd700">${fmtNum(r.R_mod, 10)}</div>
<div style="font-size:.7rem;color:var(--txt2)">R<sub>H</sub> = M × ∏(p−ν)/p (pair count)</div>
</div>
<div style="background:var(--bg1);padding:12px;border-radius:8px;text-align:center">
<div style="font-size:1.3rem;font-weight:bold;color:#00ff88">${fmtNum(r.C, 10)}</div>
<div style="font-size:.7rem;color:var(--txt2)">C<sub>H</sub> (Hardy-Littlewood constant)</div>
</div>
</div>

<div style="display:grid;grid-template-columns:repeat(3,1fr);gap:8px;margin-bottom:12px">
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center">
<div style="font-size:1.1rem;font-weight:bold;color:#ff6496">${fmtNum(r.C, 12)}</div>
<div style="font-size:.65rem;color:var(--txt2)">C<sub>H</sub> → 0.6601618</div>
</div>
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center">
<div style="font-size:1.1rem;font-weight:bold;color:#00d9ff">${fmtNum(r.M, 12)}</div>
<div style="font-size:.65rem;color:var(--txt2)">∏(p−ν)/p (density)</div>
</div>
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center">
<div style="font-size:1.1rem;font-weight:bold;color:#9664ff">${r.maxP}</div>
<div style="font-size:.65rem;color:var(--txt2)">p<sub>max</sub></div>
</div>
</div>

<div style="background:rgba(0,255,136,.15);padding:15px;border-radius:8px;border-left:4px solid #00ff88">
<strong style="color:#00ff88;font-size:1.1rem">CRT Formula Verified</strong>
<div style="font-family:monospace;font-size:.85rem;margin-top:10px;color:var(--txt2)">
R<sub>H</sub> = ∏<sub>p≤${r.maxP}</sub> (p − ν<sub>H</sub>(p)) = <strong style="color:#ffd700">${fmtNum(r.R_mod, 12)}</strong><br>
C<sub>H</sub> = <strong style="color:#00ff88">${fmtNum(r.C, 12)}</strong> (Hardy-Littlewood)<br>
<strong>Counts admissible residue pairs coprime to primorial</strong>
</div>
</div>

<div style="display:grid;grid-template-columns:1fr 1fr;gap:10px;margin-top:12px">
<div style="background:rgba(0,217,255,.1);padding:10px;border-radius:6px">
<strong style="color:#00d9ff">Mertens Approximation</strong>
<div style="font-size:.8rem;color:var(--txt2);margin-top:4px">
M(N) ~ e^(-γ)/ln(p<sub>max</sub>) = ${fmtNum(r.mertensApprox, 10)}<br>
Actual/Approx ratio: <strong style="color:#ffd700">${fmtNum(r.mertensRatio, 8)}</strong> → 1
</div>
</div>
<div style="background:rgba(255,100,150,.1);padding:10px;border-radius:6px">
<strong style="color:#ff6496">C(N) Convergence</strong>
<div style="font-size:.8rem;color:var(--txt2);margin-top:4px">
|C(N) - C₂| = ${fmtNum(r.C2_error, 4)}<br>
C₂ = 0.6601618158...
</div>
</div>
</div>

<div style="display:grid;grid-template-columns:1fr 1fr;gap:10px;margin-top:12px">
<div style="background:rgba(150,100,255,.15);padding:10px;border-radius:6px;border-left:4px solid #9664ff">
<strong style="color:#9664ff">Asymptotic Behavior</strong>
<div style="font-size:.8rem;color:var(--txt2);margin-top:4px">
Density R<sub>H</sub>/M → 0 as p<sub>max</sub> → ∞<br>
<strong style="color:#ffd700">Via Mertens' theorem</strong>
</div>
</div>
<div style="background:rgba(0,255,136,.1);padding:10px;border-radius:6px;border-left:4px solid #00ff88">
<strong style="color:#00ff88">Current Scale</strong>
<div style="font-size:.8rem;color:var(--txt2);margin-top:4px">
ln(p<sub>max</sub>) = ${fmtNum(r.lnP, 4)}<br>
# primes ≤ p<sub>max</sub>: ${r.numPrimes || '—'}
</div>
</div>
</div>`;

  // Build step table for primes up to min(N, 100)
  buildStepTable(Math.min(N, 100));
  
  // Build convergence table
  buildConvergenceTable(N);
  
  // Update plots
  updateIntegerNPlots(N);
}

// NEW: Mertens Verification Table - shows asymptotic analysis
function updateMertensVerificationTable(maxN) {
  const testPoints = [7, 23, 97, 541, 1009, 3001, 10007, 30011, 100003].filter(n => n <= maxN * 2);
  if (testPoints.length === 0) return;
  
  let tableHTML = `<tr style="background:rgba(255,215,0,.15);position:sticky;top:0">
<th style="padding:6px">p<sub>max</sub></th>
<th># primes</th>
<th style="color:#00d9ff">M (actual)</th>
<th style="color:#ffd700">e<sup>-γ</sup>/ln(p)</th>
<th>Ratio</th>
<th style="color:#ff6496">R (actual)</th>
<th style="color:#9664ff">R (asymp)</th>
<th>R ratio</th>
<th style="color:#00ff88">Correction</th>
</tr>`;

  const results = [];
  
  for (const p_max of testPoints) {
    const r = computeSingularSeriesForN(p_max, 2);
    if (!r) continue;
    
    results.push(r);
    
    tableHTML += `<tr>
<td style="padding:4px;font-weight:bold">${p_max.toLocaleString()}</td>
<td>${r.numPrimes}</td>
<td style="font-family:monospace;color:#00d9ff">${r.M.toExponential(6)}</td>
<td style="font-family:monospace;color:#ffd700">${r.mertensApprox.toExponential(6)}</td>
<td style="font-family:monospace">${fmtNum(r.mertensRatio, 4)}</td>
<td style="font-family:monospace;color:#ff6496">${r.R_mod.toExponential(4)}</td>
<td style="font-family:monospace;color:#9664ff">${r.R_asymp.toExponential(4)}</td>
<td style="font-family:monospace">${fmtNum(r.R_mod / r.R_asymp, 4)}</td>
<td style="font-family:monospace;font-weight:bold;color:#00ff88">${fmtNum(r.correctionFactor, 2)}×</td>
</tr>`;
  }
  
  const tbl = document.getElementById('tMertensVerify');
  if (tbl) tbl.innerHTML = tableHTML;
  
  // Update the constant display boxes
  const statGamma = document.getElementById('statGamma');
  const statEgamma = document.getElementById('statEgamma');
  const statE3gamma = document.getElementById('statE3gamma');
  const statCorrFactor = document.getElementById('statCorrFactor');
  
  if (statGamma) statGamma.innerHTML = `γ = ${EULER_GAMMA.toFixed(10)}`;
  if (statEgamma) statEgamma.innerHTML = `e<sup>-γ</sup> = ${E_NEG_GAMMA.toFixed(10)}`;
  if (statE3gamma) statE3gamma.innerHTML = `C<sub>2</sub> ≈ ${trueC.toFixed(7)}`;
  
  // Calculate average correction factor from results
  if (results.length > 0 && statCorrFactor) {
    const avgCorr = results.reduce((a, r) => a + r.correctionFactor, 0) / results.length;
    statCorrFactor.innerHTML = `~${avgCorr.toFixed(1)}× correction`;
  }
  
  // Plot asymptotic correction factor
  if (results.length >= 3) {
    const pAsympCorr = document.getElementById('pAsympCorr');
    const pLn3Decay = document.getElementById('pLn3Decay');
    
    if (pAsympCorr) {
      Plotly.newPlot('pAsympCorr', [
        { 
          x: results.map(r => r.maxP), 
          y: results.map(r => r.C), 
          mode: 'lines+markers', 
          name: 'C_H(p_max)',
          line: { color: '#ff6496', width: 2 },
          marker: { size: 8, color: '#ff6496' }
        },
        {
          x: [results[0].maxP, results[results.length-1].maxP],
          y: [0.6601618, 0.6601618],
          mode: 'lines',
          name: 'C₂ = 0.6601618',
          line: { color: '#ffd700', dash: 'dash', width: 1 }
        }
      ], { 
        ...plo(), 
        xaxis: { title: 'p_max', type: 'log' }, 
        yaxis: { title: 'C_H', range: [0.5, 0.8] }
      });
    }
    
    if (pLn3Decay) {
      Plotly.newPlot('pLn3Decay', [
        {
          x: results.map(r => r.maxP),
          y: results.map(r => r.R_mod),
          mode: 'lines+markers',
          name: 'R_H (pair count)',
          line: { color: '#00ff88', width: 2 }
        },
        {
          x: results.map(r => r.maxP),
          y: results.map(r => r.M),
          mode: 'lines',
          name: '∏(p−ν)/p (density)',
          line: { color: '#9664ff', dash: 'dot', width: 2 }
        }
      ], {
        ...plo(),
        xaxis: { title: 'p_max', type: 'log' },
        yaxis: { title: 'R', type: 'log' },
        yaxis2: { title: '1/ln³(p)', overlaying: 'y', side: 'right', type: 'log', showgrid: false }
      });
    }
  }
}

function testIntegerRange() {
  const start = +document.getElementById('intNStart').value;
  const end = +document.getElementById('intNEnd').value;
  
  if (start > end || start < 3) {
    document.getElementById('intNLiveStats').innerHTML = '<div style="color:#ff4040">Invalid range. Start must be >= 3 and <= End.</div>';
    return;
  }
  
  let tableHTML = `<tr style="background:rgba(255,100,150,.15);position:sticky;top:0">
<th style="padding:6px">N</th>
<th># odd primes</th>
<th>max p</th>
<th style="color:#ffd700">R<sub>H</sub></th>
<th style="color:#ff6496">C<sub>H</sub></th>
<th style="color:#00d9ff">∏(p−ν)/p</th>
<th style="color:#00ff88">Primorial</th>
<th>Density</th>
<th>Status</th>
</tr>`;
  
  let allExact = true;
  const results = [];
  
  for (let N = start; N <= end; N++) {
    const r = computeSingularSeriesForN(N);
    if (r) {
      results.push(r);
      if (!r.isExact) allExact = false;
      
      const rowBg = isPrime(N) ? 'rgba(255,215,0,.1)' : '';
      tableHTML += `<tr style="background:${rowBg}">
<td style="padding:4px;font-weight:${isPrime(N)?'bold':'normal'}">${N}${isPrime(N)?' ':''}</td>
<td>${r.numPrimes}</td>
<td>${r.maxP}</td>
<td style="font-family:monospace;color:#ffd700">${fmtNum(r.R_mod, 8)}</td>
<td style="font-family:monospace;color:#ff6496">${fmtNum(r.C, 10)}</td>
<td style="font-family:monospace;color:#00d9ff">${fmtNum(r.M, 10)}</td>
<td style="font-family:monospace;color:#00ff88">${fmtNum(r.R, 8)}</td>
<td style="font-family:monospace;color:${r.isExact?'#00ff88':'#ff4040'}">${fmtNum(r.ratio, 12)}</td>
<td style="color:${r.isExact?'#00ff88':'#ff4040'}">${r.isExact ? 'OK' : 'X'}</td>
</tr>`;
    }
  }
  
  document.getElementById('tIntNStep').innerHTML = tableHTML;
  
  document.getElementById('intNLiveStats').innerHTML = `
<div style="background:${allExact?'rgba(0,255,136,.2)':'rgba(255,64,64,.2)'};padding:15px;border-radius:10px;border:2px solid ${allExact?'#00ff88':'#ff4040'}">
<div style="font-size:1.2rem;font-weight:bold;color:${allExact?'#00ff88':'#ff4040'};text-align:center">
${allExact ? 'VERIFIED FOR ALL N IN RANGE' : 'Failed for some values'}
</div>
<div style="text-align:center;margin-top:8px;font-size:.9rem;color:var(--txt2)">
Tested ${results.length} values from N=${start} to N=${end}<br>
${results.filter(r => r.isExact).length} passed, ${results.filter(r => !r.isExact).length} failed
</div>
</div>`;

  // Plot the results
  if (results.length > 0) {
    Plotly.newPlot('pIntNDecay', [
      { x: results.map(r => r.N), y: results.map(r => r.R_mod), mode: 'lines+markers', name: 'R_modular', line: { color: '#ffd700' } },
      { x: results.map(r => r.N), y: results.map(r => r.R), mode: 'lines', name: '¼CM³', line: { color: '#00ff88', dash: 'dash' } }
    ], { ...plo(), xaxis: { title: 'N' }, yaxis: { title: 'R_modular', type: 'log' } });
    
    Plotly.newPlot('pIntNMertens', [
      { x: results.map(r => r.N), y: results.map(r => r.M), mode: 'lines+markers', name: 'M(N) actual', line: { color: '#00d9ff' } },
      { x: results.map(r => r.N), y: results.map(r => r.mertensApprox), mode: 'lines', name: '2e^(-γ)/ln(N)', line: { color: '#ff6496', dash: 'dot' } }
    ], { ...plo(), xaxis: { title: 'N' }, yaxis: { title: 'Mertens M(N)' } });
  }
}

function showConvergenceAnalysis() {
  const convergencePoints = [10, 20, 50, 100, 200, 500, 1000, 2000, 5000, 10000, 20000, 50000, 100000, 200000, 500000, 1000000];
  const maxN = +document.getElementById('intNValue').value;
  const points = convergencePoints.filter(n => n <= maxN * 2);
  
  let tableHTML = `<tr style="background:rgba(150,100,255,.15)">
<th style="padding:8px">N</th>
<th># primes</th>
<th style="color:#ff6496">C(N)</th>
<th>|C(N) - C₂|</th>
<th style="color:#00d9ff">M(N)</th>
<th>M / [2e<sup>-γ</sup>/ln N]</th>
<th style="color:#ffd700">R_modular</th>
<th style="color:#00ff88">Density</th>
</tr>`;
  
  const results = [];
  for (const N of points) {
    const r = computeSingularSeriesForN(N);
    if (r) {
      results.push(r);
      tableHTML += `<tr>
<td style="padding:6px;font-weight:bold">${N.toLocaleString()}</td>
<td>${r.numPrimes}</td>
<td style="font-family:monospace;color:#ff6496">${fmtNum(r.C, 10)}</td>
<td style="font-family:monospace;color:#9664ff">${fmtNum(r.C2_error, 4)}</td>
<td style="font-family:monospace;color:#00d9ff">${fmtNum(r.M, 6)}</td>
<td style="font-family:monospace;color:#ffd700">${fmtNum(r.mertensRatio, 8)}</td>
<td style="font-family:monospace;color:#ffd700">${fmtNum(r.R_mod, 6)}</td>
<td style="font-family:monospace;color:#00ff88">${fmtNum(r.ratio, 12)} ${r.isExact?'OK':''}</td>
</tr>`;
    }
  }
  
  document.getElementById('tIntNConv').innerHTML = tableHTML;
  
  document.getElementById('intNLiveStats').innerHTML = `
<div style="background:linear-gradient(135deg,rgba(150,100,255,.2),rgba(0,255,136,.1));padding:15px;border-radius:10px;border:2px solid #9664ff">
<div style="font-size:1.1rem;font-weight:bold;color:#9664ff;text-align:center;margin-bottom:10px">
CONVERGENCE ANALYSIS
</div>
<div style="display:grid;grid-template-columns:repeat(2,1fr);gap:12px">
<div style="background:var(--bg1);padding:10px;border-radius:6px">
<strong style="color:#ff6496">C(N) Convergence</strong>
<div style="font-size:.8rem;color:var(--txt2);margin-top:6px">
C(N) → C₂ = 0.6601618158...<br>
Rate: O(1/N) convergence
</div>
</div>
<div style="background:var(--bg1);padding:10px;border-radius:6px">
<strong style="color:#00d9ff">M(N) Asymptotics</strong>
<div style="font-size:.8rem;color:var(--txt2);margin-top:6px">
M(N) ~ 2e<sup>-γ</sup>/ln(N)<br>
γ = 0.5772156649... (Euler-Mascheroni)
</div>
</div>
</div>
<div style="margin-top:12px;background:rgba(0,255,136,.1);padding:10px;border-radius:6px;text-align:center">
<strong style="color:#00ff88">Identity holds EXACTLY for all tested N!</strong>
</div>
</div>`;

  // Update plots
  if (results.length > 0) {
    Plotly.newPlot('pIntNDecay', [
      { x: results.map(r => r.N), y: results.map(r => r.R_mod), mode: 'lines+markers', name: 'R_modular', line: { color: '#ffd700', width: 2 }, marker: { size: 8 } }
    ], { ...plo(), xaxis: { title: 'N', type: 'log' }, yaxis: { title: 'R_modular', type: 'log' } });
    
    Plotly.newPlot('pIntNMertens', [
      { x: results.map(r => r.N), y: results.map(r => r.mertensRatio), mode: 'lines+markers', name: 'M(N) / [2e^(-γ)/ln N]', line: { color: '#00d9ff', width: 2 }, marker: { size: 8 } },
      { x: [results[0].N, results[results.length-1].N], y: [1, 1], mode: 'lines', name: 'Target = 1', line: { color: '#ff6496', dash: 'dash' } }
    ], { ...plo(), xaxis: { title: 'N', type: 'log' }, yaxis: { title: 'Ratio → 1', range: [0.95, 2.1] } });
  }
}

function buildStepTable(maxN) {
  let tableHTML = `<tr style="background:rgba(255,100,150,.15);position:sticky;top:0">
<th style="padding:6px">N</th>
<th># odd primes</th>
<th>max p</th>
<th style="color:#ffd700">R<sub>H</sub></th>
<th style="color:#ff6496">C<sub>H</sub></th>
<th style="color:#00d9ff">∏(p−ν)/p</th>
<th style="color:#00ff88">Primorial</th>
<th>Density</th>
<th>Status</th>
</tr>`;
  
  for (let N = 3; N <= maxN; N++) {
    const r = computeSingularSeriesForN(N);
    if (r) {
      const rowBg = isPrime(N) ? 'rgba(255,215,0,.1)' : '';
      tableHTML += `<tr style="background:${rowBg}">
<td style="padding:4px;font-weight:${isPrime(N)?'bold':'normal'}">${N}${isPrime(N)?' ':''}</td>
<td>${r.numPrimes}</td>
<td>${r.maxP}</td>
<td style="font-family:monospace;font-size:.75rem;color:#ffd700">${fmtNum(r.R_mod, 6)}</td>
<td style="font-family:monospace;font-size:.75rem;color:#ff6496">${fmtNum(r.C, 8)}</td>
<td style="font-family:monospace;font-size:.75rem;color:#00d9ff">${fmtNum(r.M, 8)}</td>
<td style="font-family:monospace;font-size:.75rem;color:#00ff88">${fmtNum(r.R, 6)}</td>
<td style="font-family:monospace;font-size:.75rem;color:${r.isExact?'#00ff88':'#ff4040'}">${fmtNum(r.ratio, 10)}</td>
<td style="color:${r.isExact?'#00ff88':'#ff4040'}">${r.isExact ? 'OK' : 'X'}</td>
</tr>`;
    }
  }
  
  document.getElementById('tIntNStep').innerHTML = tableHTML;
}

function buildConvergenceTable(targetN) {
  const points = [10, 50, 100, 500, 1000, 5000, 10000, 50000, 100000, 500000, 1000000].filter(n => n <= targetN * 2);
  
  let tableHTML = `<tr style="background:rgba(150,100,255,.15)">
<th style="padding:8px">N</th>
<th># primes</th>
<th style="color:#ff6496">C(N)</th>
<th>|C(N) - C₂|</th>
<th style="color:#00d9ff">M(N)</th>
<th>M / [2e<sup>-γ</sup>/ln N]</th>
<th style="color:#ffd700">R_modular</th>
<th style="color:#00ff88">Density</th>
</tr>`;
  
  for (const N of points) {
    const r = computeSingularSeriesForN(N);
    if (r) {
      tableHTML += `<tr>
<td style="padding:6px;font-weight:bold">${N.toLocaleString()}</td>
<td>${r.numPrimes}</td>
<td style="font-family:monospace;color:#ff6496">${fmtNum(r.C, 10)}</td>
<td style="font-family:monospace;color:#9664ff">${fmtNum(r.C2_error, 3)}</td>
<td style="font-family:monospace;color:#00d9ff">${fmtNum(r.M, 5)}</td>
<td style="font-family:monospace;color:#ffd700">${fmtNum(r.mertensRatio, 6)}</td>
<td style="font-family:monospace;color:#ffd700">${fmtNum(r.R_mod, 5)}</td>
<td style="font-family:monospace;color:#00ff88">${fmtNum(r.ratio, 10)} OK</td>
</tr>`;
    }
  }
  
  document.getElementById('tIntNConv').innerHTML = tableHTML;
}

function updateIntegerNPlots(N) {
  const points = [];
  const step = Math.max(1, Math.floor(N / 50));
  for (let n = 3; n <= N; n += step) {
    const r = computeSingularSeriesForN(n);
    if (r) points.push(r);
  }
  // Ensure last point is included
  const lastR = computeSingularSeriesForN(N);
  if (lastR && (points.length === 0 || points[points.length-1].N !== N)) {
    points.push(lastR);
  }
  
  if (points.length > 0) {
    Plotly.newPlot('pIntNDecay', [
      { x: points.map(r => r.N), y: points.map(r => r.R_mod), mode: 'lines', name: 'R_modular', line: { color: '#ffd700', width: 2 } }
    ], { ...plo(), xaxis: { title: 'N', type: N > 1000 ? 'log' : 'linear' }, yaxis: { title: 'R_modular', type: 'log' } });
    
    Plotly.newPlot('pIntNMertens', [
      { x: points.map(r => r.N), y: points.map(r => r.M), mode: 'lines', name: 'M(N) actual', line: { color: '#00d9ff', width: 2 } },
      { x: points.map(r => r.N), y: points.map(r => r.mertensApprox), mode: 'lines', name: '2e^(-γ)/ln(N)', line: { color: '#ff6496', dash: 'dot', width: 2 } }
    ], { ...plo(), xaxis: { title: 'N', type: N > 1000 ? 'log' : 'linear' }, yaxis: { title: 'M(N)' } });
  }
}

// ===== ALGEBRAIC DECOMPOSITION PROOF =====
function drawAlgebraicProof() {
  const testPrimes = [3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47];
  
  // Per-prime factors table
  let factorsHTML = `<tr style="background:rgba(255,100,150,.15)">
<th style="padding:8px">p</th>
<th style="color:#ffd700">R_factor<br><span style="font-size:.7rem">(p-1)(p-2)/p^2</span></th>
<th style="color:#ff6496">C_factor<br><span style="font-size:.7rem">p(p-2)/(p-1)^2</span></th>
<th style="color:#00d9ff">M_factor<br><span style="font-size:.7rem">(p-1)/p</span></th>
<th style="color:#00ff88">C x M^3</th>
<th>Match?</th>
</tr>`;
  
  for (const p of testPrimes) {
    const R_factor = (p-1) * (p-2) / (p * p);
    const C_factor = p * (p-2) / ((p-1) * (p-1));
    const M_factor = (p-1) / p;
    const CM3 = C_factor * Math.pow(M_factor, 3);
    const match = Math.abs(R_factor - CM3) < 1e-14;
    
    factorsHTML += `<tr>
<td style="padding:6px;font-weight:bold">${p}</td>
<td style="font-family:monospace;color:#ffd700">${fmtNum(R_factor, 12)}</td>
<td style="font-family:monospace;color:#ff6496">${fmtNum(C_factor, 12)}</td>
<td style="font-family:monospace;color:#00d9ff">${fmtNum(M_factor, 12)}</td>
<td style="font-family:monospace;color:#00ff88">${fmtNum(CM3, 12)}</td>
<td style="color:${match?'#00ff88':'#ff4040'};font-weight:bold;font-size:1.2rem">${match ? 'OK' : 'X'}</td>
</tr>`;
  }
  
  document.getElementById('tAlgFactors').innerHTML = factorsHTML;
  
  // Running products table
  const runningPoints = [5, 7, 11, 13, 17, 23, 29, 37, 47, 59, 71, 83, 97];
  let runningHTML = `<tr style="background:rgba(0,255,136,.15)">
<th style="padding:8px">p_max</th>
<th># primes</th>
<th style="color:#ffd700">∏R_factor</th>
<th style="color:#ff6496">∏C_factor (C)</th>
<th style="color:#00d9ff">∏M_factor (M)</th>
<th style="color:#00ff88">C × M³</th>
<th>Ratio</th>
</tr>`;
  
  const plotData = { p: [], R: [], C: [], M: [], CM3: [] };
  
  for (const pmax of runningPoints) {
    const primes = sievePrimes(pmax).filter(p => p > 2);
    
    let prodR = 1, prodC = 1, prodM = 1;
    for (const p of primes) {
      prodR *= (p-1) * (p-2) / (p * p);
      prodC *= p * (p-2) / ((p-1) * (p-1));
      prodM *= (p-1) / p;
    }
    
    const CM3 = prodC * Math.pow(prodM, 3);
    const ratio = prodR / CM3;
    
    plotData.p.push(pmax);
    plotData.R.push(prodR);
    plotData.C.push(prodC);
    plotData.M.push(prodM);
    plotData.CM3.push(CM3);
    
    runningHTML += `<tr>
<td style="padding:6px;font-weight:bold">${pmax}</td>
<td>${primes.length}</td>
<td style="font-family:monospace;color:#ffd700">${fmtNum(prodR, 8)}</td>
<td style="font-family:monospace;color:#ff6496">${fmtNum(prodC, 10)}</td>
<td style="font-family:monospace;color:#00d9ff">${fmtNum(prodM, 10)}</td>
<td style="font-family:monospace;color:#00ff88">${fmtNum(CM3, 8)}</td>
<td style="font-family:monospace;color:${Math.abs(ratio-1)<1e-10?'#00ff88':'#ff4040'}">${fmtNum(ratio, 12)} ${Math.abs(ratio-1)<1e-10?'OK':''}</td>
</tr>`;
  }
  
  document.getElementById('tAlgRunning').innerHTML = runningHTML;
  
  // Plot
  Plotly.newPlot('pAlgPlot', [
    { x: plotData.p, y: plotData.R, mode: 'lines+markers', name: '∏R_factor', line: { color: '#ffd700', width: 2 }, marker: { size: 8 } },
    { x: plotData.p, y: plotData.CM3, mode: 'lines+markers', name: 'C × M³', line: { color: '#00ff88', width: 2, dash: 'dash' }, marker: { size: 8, symbol: 'diamond' } },
    { x: plotData.p, y: plotData.C, mode: 'lines', name: 'C (→ 0.660)', yaxis: 'y2', line: { color: '#ff6496', width: 1 } }
  ], {
    ...plo(),
    xaxis: { title: 'p_max' },
    yaxis: { title: '∏R_factor, C×M³', type: 'log', side: 'left' },
    yaxis2: { title: 'C factor', overlaying: 'y', side: 'right', range: [0.6, 0.75] }
  });
}

async function screenshotAlgebraic() {
  await screenshotUnified(null, 'constAlgebraic', 'Wessen_Algebraic_Proof', 'wessen_algebraic.png');
}

// ===== BIGINT EXACT VERIFICATION =====
function bigIntGcd(a, b) {
  a = a < 0n ? -a : a;
  b = b < 0n ? -b : b;
  while (b !== 0n) {
    const t = b;
    b = a % b;
    a = t;
  }
  return a;
}

function drawBigIntVerify() {
  const N = +document.getElementById('bigintN').value;
  const primes = sievePrimes(N).filter(p => p > 2);
  
  if (primes.length === 0) {
    document.getElementById('bigintResult').innerHTML = '<div style="color:#ff4040">N must be >= 3</div>';
    return;
  }
  
  // BigInt fractions: N_R/D_R, N_C/D_C, N_M/D_M
  let N_R = 1n, D_R = 1n;
  let N_C = 1n, D_C = 1n;
  let N_M = 1n, D_M = 1n;
  
  let tableHTML = `<tr style="background:rgba(0,255,136,.15);position:sticky;top:0">
<th style="padding:6px">p</th>
<th style="color:#ffd700">N_R</th>
<th style="color:#ffd700">D_R</th>
<th style="color:#ff6496">N_C</th>
<th style="color:#ff6496">D_C</th>
<th style="color:#00d9ff">N_M</th>
<th style="color:#00d9ff">D_M</th>
</tr>`;
  
  for (const p of primes) {
    const pBig = BigInt(p);
    
    // R: (p-1)(p-2)/p^2
    N_R *= (pBig - 1n) * (pBig - 2n);
    D_R *= pBig * pBig;
    
    // C: p(p-2)/(p-1)^2
    N_C *= pBig * (pBig - 2n);
    D_C *= (pBig - 1n) * (pBig - 1n);
    
    // M: (p-1)/p
    N_M *= (pBig - 1n);
    D_M *= pBig;
    
    // Reduce fractions to keep numbers smaller
    let g = bigIntGcd(N_R, D_R);
    if (g > 1n) { N_R /= g; D_R /= g; }
    g = bigIntGcd(N_C, D_C);
    if (g > 1n) { N_C /= g; D_C /= g; }
    g = bigIntGcd(N_M, D_M);
    if (g > 1n) { N_M /= g; D_M /= g; }
    
    // Only show first 15 and last 5 primes
    const idx = primes.indexOf(p);
    if (idx < 15 || idx >= primes.length - 5) {
      const nrStr = N_R.toString().length > 20 ? N_R.toString().slice(0,17) + '...' : N_R.toString();
      const drStr = D_R.toString().length > 20 ? D_R.toString().slice(0,17) + '...' : D_R.toString();
      const ncStr = N_C.toString().length > 20 ? N_C.toString().slice(0,17) + '...' : N_C.toString();
      const dcStr = D_C.toString().length > 20 ? D_C.toString().slice(0,17) + '...' : D_C.toString();
      const nmStr = N_M.toString().length > 15 ? N_M.toString().slice(0,12) + '...' : N_M.toString();
      const dmStr = D_M.toString().length > 15 ? D_M.toString().slice(0,12) + '...' : D_M.toString();
      
      tableHTML += `<tr>
<td style="padding:4px;font-weight:bold">${p}</td>
<td style="font-family:monospace;font-size:.7rem;color:#ffd700">${nrStr}</td>
<td style="font-family:monospace;font-size:.7rem;color:#ffd700">${drStr}</td>
<td style="font-family:monospace;font-size:.7rem;color:#ff6496">${ncStr}</td>
<td style="font-family:monospace;font-size:.7rem;color:#ff6496">${dcStr}</td>
<td style="font-family:monospace;font-size:.7rem;color:#00d9ff">${nmStr}</td>
<td style="font-family:monospace;font-size:.7rem;color:#00d9ff">${dmStr}</td>
</tr>`;
    } else if (idx === 15) {
      tableHTML += `<tr style="background:rgba(100,100,100,.2)"><td colspan="7" style="text-align:center;padding:3px;color:#666;font-size:.7rem">... ${primes.length - 20} primes skipped ...</td></tr>`;
    }
  }
  
  document.getElementById('tBigintSteps').innerHTML = tableHTML;
  
  // Cross-multiplication test: N_R * D_C * D_M^3 = D_R * N_C * N_M^3
  const leftSide = N_R * D_C * D_M * D_M * D_M;
  const rightSide = D_R * N_C * N_M * N_M * N_M;
  const isExact = leftSide === rightSide;
  
  const leftStr = leftSide.toString();
  const rightStr = rightSide.toString();
  
  document.getElementById('bigintResult').innerHTML = `
<div style="background:${isExact?'rgba(0,255,136,.2)':'rgba(255,64,64,.2)'};padding:1.5rem;border-radius:10px;border:2px solid ${isExact?'#00ff88':'#ff4040'};margin-bottom:1rem">
<div style="font-size:1.3rem;font-weight:bold;color:${isExact?'#00ff88':'#ff4040'};text-align:center">
${isExact ? 'EXACT MATCH' : 'MISMATCH'}
</div>
<div style="text-align:center;margin-top:.5rem;font-size:.9rem;color:var(--txt2)">
Tested with ${primes.length} odd primes (3 to ${primes[primes.length-1]})
</div>
</div>

<div style="background:var(--bg1);padding:1rem;border-radius:8px;margin-bottom:1rem">
<strong style="color:#ffd700">Cross-Multiplication Test:</strong>
<div style="font-family:monospace;font-size:.85rem;margin-top:.5rem;color:var(--txt2)">
N_R x D_C x D_M^3 ${isExact ? '=' : '!='} D_R x N_C x N_M^3
</div>
</div>

<div style="display:grid;grid-template-columns:1fr 1fr;gap:1rem">
<div style="background:var(--bg1);padding:1rem;border-radius:8px">
<strong style="color:#00d9ff">Left Side (N_R x D_C x D_M^3):</strong>
<div style="font-family:monospace;font-size:.75rem;word-break:break-all;margin-top:.5rem;color:var(--txt2);max-height:100px;overflow-y:auto">
${leftStr.length > 500 ? leftStr.slice(0,500) + '...' : leftStr}
</div>
<div style="font-size:.7rem;color:#666;margin-top:.3rem">${leftStr.length} digits</div>
</div>
<div style="background:var(--bg1);padding:1rem;border-radius:8px">
<strong style="color:#ff6496">Right Side (D_R x N_C x N_M^3):</strong>
<div style="font-family:monospace;font-size:.75rem;word-break:break-all;margin-top:.5rem;color:var(--txt2);max-height:100px;overflow-y:auto">
${rightStr.length > 500 ? rightStr.slice(0,500) + '...' : rightStr}
</div>
<div style="font-size:.7rem;color:#666;margin-top:.3rem">${rightStr.length} digits</div>
</div>
</div>

<div style="margin-top:1rem;padding:1rem;background:rgba(150,100,255,.1);border-radius:8px;border-left:4px solid #9664ff">
<strong style="color:#9664ff">What This Verifies:</strong>
<div style="font-size:.85rem;color:var(--txt2);margin-top:.5rem">
${isExact ? 
'The CRT formula R_H = ∏(p − ν_H(p)) computes exactly using integer arithmetic. This is a standard sieve theory result, verified to machine precision.' :
'Computation error detected - please check parameters.'}
</div>
</div>`;
}

// ===== GAP H VERIFICATION =====
function selectAllGaps() {
  const select = document.getElementById('gapHSelect');
  for (let i = 0; i < select.options.length; i++) {
    select.options[i].selected = true;
  }
  drawGapHVerify();
}

function selectCommonGaps() {
  const select = document.getElementById('gapHSelect');
  const common = ['2', '4', '6', '30', '210'];
  for (let i = 0; i < select.options.length; i++) {
    select.options[i].selected = common.includes(select.options[i].value);
  }
  drawGapHVerify();
}

function getOddPrimeDivisors(n) {
  const divs = [];
  for (let p = 3; p <= n; p += 2) {
    if (n % p === 0 && isPrime(p)) divs.push(p);
  }
  return divs;
}

function drawGapHVerify() {
  const N = +document.getElementById('gapHN').value;
  const select = document.getElementById('gapHSelect');
  const gaps = Array.from(select.selectedOptions).map(o => +o.value);
  
  if (gaps.length === 0) {
    document.getElementById('tGapH').innerHTML = '<tr><td colspan="8" style="color:#ff4040;text-align:center;padding:1rem">Select at least one gap</td></tr>';
    return;
  }
  
  const primes = sievePrimes(N).filter(p => p > 2);
  if (primes.length === 0) {
    document.getElementById('tGapH').innerHTML = '<tr><td colspan="8" style="color:#ff4040;text-align:center;padding:1rem">N must be >= 3</td></tr>';
    return;
  }
  
  let tableHTML = `<tr style="background:rgba(0,217,255,.15);position:sticky;top:0">
<th style="padding:8px">Gap H</th>
<th>Odd Divisors</th>
<th style="color:#ffd700">R_modular</th>
<th style="color:#ff6496">C_H</th>
<th style="color:#00d9ff">M</th>
<th style="color:#00ff88">(1/4) x C x M^3</th>
<th>Ratio</th>
<th>Status</th>
</tr>`;
  
  const results = [];
  let allPass = true;
  
  for (const H of gaps) {
    let R_mod = 0.25;
    let C = 1;
    let M = 1;
    
    for (const p of primes) {
      const divides = (H % p === 0);
      const nu = divides ? 1 : 2;
      R_mod *= (p - 1) * (p - nu) / (p * p);
      
      const baseFactor = (p * (p - 2)) / ((p - 1) * (p - 1));
      const enhancement = divides ? (p - 1) / (p - 2) : 1;
      C *= baseFactor * enhancement;
      M *= (p - 1) / p;
    }
    
    const R_formula = 0.25 * C * Math.pow(M, 3);
    const ratio = R_mod / R_formula;
    const match = Math.abs(ratio - 1) < 1e-10;
    if (!match) allPass = false;
    
    const divisors = getOddPrimeDivisors(H);
    const enhancement = divisors.reduce((acc, p) => acc * (p - 1) / (p - 2), 1);
    
    results.push({ H, divisors, R_mod, C, M, R_formula, ratio, match, enhancement });
    
    tableHTML += `<tr>
<td style="padding:6px;font-weight:bold">${H}</td>
<td style="color:#ffd700">${divisors.length > 0 ? divisors.join(', ') : '-'}</td>
<td style="font-family:monospace;color:#ffd700">${fmtNum(R_mod, 8)}</td>
<td style="font-family:monospace;color:#ff6496">${fmtNum(C, 10)}</td>
<td style="font-family:monospace;color:#00d9ff">${fmtNum(M, 10)}</td>
<td style="font-family:monospace;color:#00ff88">${fmtNum(R_formula, 8)}</td>
<td style="font-family:monospace;color:${match?'#00ff88':'#ff4040'}">${fmtNum(ratio, 12)}</td>
<td style="color:${match?'#00ff88':'#ff4040'};font-weight:bold">${match ? 'PASS' : 'FAIL'}</td>
</tr>`;
  }
  
  document.getElementById('tGapH').innerHTML = tableHTML;
  
  // Analysis
  document.getElementById('gapHAnalysis').innerHTML = `
<div style="background:${allPass?'rgba(0,255,136,.2)':'rgba(255,64,64,.2)'};padding:1rem;border-radius:8px;margin-bottom:1rem;border:2px solid ${allPass?'#00ff88':'#ff4040'}">
<div style="font-size:1.1rem;font-weight:bold;color:${allPass?'#00ff88':'#ff4040'};text-align:center">
${allPass ? 'ALL GAPS PASS' : 'Some gaps failed'}
</div>
<div style="text-align:center;margin-top:.5rem;font-size:.85rem;color:var(--txt2)">
Tested ${gaps.length} gaps with ${primes.length} primes (up to ${primes[primes.length-1]})
</div>
</div>

<div style="display:grid;grid-template-columns:repeat(2,1fr);gap:1rem">
<div style="background:var(--bg1);padding:1rem;border-radius:8px">
<strong style="color:#ffd700">Enhancement Factors:</strong>
<div style="font-size:.85rem;color:var(--txt2);margin-top:.5rem">
${results.map(r => `Gap ${r.H}: ${r.divisors.length > 0 ? r.divisors.map(p => `(${p-1}/${p-2})`).join(' x ') + ' = ' + fmtNum(r.enhancement, 4) : '1 (no odd divisors)'}`).join('<br>')}
</div>
</div>
<div style="background:var(--bg1);padding:1rem;border-radius:8px">
<strong style="color:#ff6496">C_H Ratios (relative to C_2):</strong>
<div style="font-size:.85rem;color:var(--txt2);margin-top:.5rem">
${results.map(r => `C_${r.H} / C_2 = ${fmtNum(r.C / (results.find(x => x.H === 2)?.C || r.C), 6)}`).join('<br>')}
</div>
</div>
</div>`;

  // Plots
  if (results.length > 1) {
    Plotly.newPlot('pGapHC', [
      { x: results.map(r => r.H), y: results.map(r => r.C), mode: 'markers+lines', name: 'C_H', marker: { size: 10, color: '#ff6496' }, line: { color: '#ff6496' } }
    ], { ...plo(), xaxis: { title: 'Gap H' }, yaxis: { title: 'C_H constant' } });
    
    Plotly.newPlot('pGapHEnhance', [
      { x: results.map(r => r.H), y: results.map(r => r.enhancement), mode: 'markers+lines', name: 'Enhancement', marker: { size: 10, color: '#ffd700' }, line: { color: '#ffd700' } }
    ], { ...plo(), xaxis: { title: 'Gap H' }, yaxis: { title: 'Enhancement factor' } });
  }
}

// ===== k-TUPLES GENERALIZATION =====
function countDistinctResidues(offsets, p) {
  const residues = new Set();
  for (const h of offsets) {
    residues.add((((-h) % p) + p) % p);
  }
  return residues.size;
}

function drawSingularSeriesKtuples() {
  const N = +document.getElementById('singularSeriesKtupleN').value;
  const primes = sievePrimes(N).filter(p => p > 2);
  
  if (primes.length === 0) {
    document.getElementById('tKtuples').innerHTML = '<tr><td colspan="8" style="color:#ff4040;text-align:center;padding:1rem">N must be >= 3</td></tr>';
    return;
  }
  
  // Compute M once
  let M = 1;
  for (const p of primes) M *= (p - 1) / p;
  
  // Define k-tuple patterns
  const patterns = [
    { k: 2, name: 'Twin Primes', offsets: [0, 2] },
    { k: 2, name: 'Cousin Primes', offsets: [0, 4] },
    { k: 2, name: 'Sexy Primes', offsets: [0, 6] },
    { k: 3, name: 'Triplet Type I', offsets: [0, 2, 6] },
    { k: 3, name: 'Triplet Type II', offsets: [0, 4, 6] },
    { k: 4, name: 'Quadruplet', offsets: [0, 2, 6, 8] },
    { k: 5, name: 'Quintuplet I', offsets: [0, 2, 6, 8, 12] },
    { k: 5, name: 'Quintuplet II', offsets: [0, 4, 6, 10, 12] },
    { k: 6, name: 'Sextuplet', offsets: [0, 4, 6, 10, 12, 16] },
    { k: 7, name: 'Septuplet', offsets: [0, 2, 6, 8, 12, 18, 20] },
  ];
  
  let tableHTML = `<tr style="background:rgba(150,100,255,.15);position:sticky;top:0">
<th style="padding:8px">k</th>
<th>Pattern Name</th>
<th>Offsets</th>
<th style="color:#ffd700">R</th>
<th style="color:#ff6496">C_k</th>
<th style="color:#00ff88">(1/2^k) x C x M^(2k-1)</th>
<th>Ratio</th>
<th>Status</th>
</tr>`;
  
  const results = [];
  let allPass = true;
  
  for (const pat of patterns) {
    const k = pat.k;
    let R = Math.pow(0.5, k);
    let C = 1;
    
    for (const p of primes) {
      const nu = countDistinctResidues(pat.offsets, p);
      R *= Math.pow(p - 1, k - 1) * (p - nu) / Math.pow(p, k);
      C *= Math.pow(p, k - 1) * (p - nu) / Math.pow(p - 1, k);
    }
    
    const exp = 2 * k - 1;
    const formula = Math.pow(0.5, k) * C * Math.pow(M, exp);
    const ratio = R / formula;
    const match = Math.abs(ratio - 1) < 1e-10;
    if (!match) allPass = false;
    
    results.push({ k, name: pat.name, offsets: pat.offsets, R, C, formula, ratio, match, exp });
    
    tableHTML += `<tr>
<td style="padding:6px;font-weight:bold;color:#9664ff">${k}</td>
<td>${pat.name}</td>
<td style="font-family:monospace;font-size:.75rem">[${pat.offsets.join(',')}]</td>
<td style="font-family:monospace;color:#ffd700">${fmtNum(R, 6)}</td>
<td style="font-family:monospace;color:#ff6496">${fmtNum(C, 8)}</td>
<td style="font-family:monospace;color:#00ff88">${fmtNum(formula, 6)}</td>
<td style="font-family:monospace;color:${match?'#00ff88':'#ff4040'}">${fmtNum(ratio, 10)}</td>
<td style="color:${match?'#00ff88':'#ff4040'};font-weight:bold">${match ? 'PASS' : 'FAIL'}</td>
</tr>`;
  }
  
  document.getElementById('tKtuples').innerHTML = tableHTML;
  
  // Breakdown analysis
  document.getElementById('ktupleBreakdown').innerHTML = `
<div style="background:${allPass?'rgba(0,255,136,.2)':'rgba(255,64,64,.2)'};padding:1rem;border-radius:8px;margin-bottom:1rem;border:2px solid ${allPass?'#00ff88':'#ff4040'}">
<div style="font-size:1.1rem;font-weight:bold;color:${allPass?'#00ff88':'#ff4040'};text-align:center">
${allPass ? 'ALL k-TUPLES PASS' : 'Some patterns failed'}
</div>
<div style="text-align:center;margin-top:.5rem;font-size:.85rem;color:var(--txt2)">
Tested ${patterns.length} patterns with ${primes.length} primes (up to ${primes[primes.length-1]})
</div>
</div>

<div style="background:var(--bg1);padding:1rem;border-radius:8px;margin-bottom:1rem">
<strong style="color:#ffd700">The Generalized CRT Formula:</strong>
<div style="font-family:monospace;margin-top:.5rem;color:#fff">
R_k = M × ∏(p − ν_k(p))/p
</div>
<table style="width:100%;margin-top:1rem;font-size:.85rem">
<tr><th style="text-align:left;color:#9664ff">k</th><th style="color:#ff6496">Pattern Type</th><th style="color:#00d9ff">ν_k(p)</th></tr>
<tr><td>2 (pairs)</td><td>Twin, cousin, sexy</td><td>1 if p|H, else 2</td></tr>
<tr><td>3 (triplets)</td><td>(p, p+2, p+6)</td><td># distinct residues covered</td></tr>
<tr><td>4 (quadruplets)</td><td>(p, p+2, p+6, p+8)</td><td># distinct residues covered</td></tr>
<tr><td>k (general)</td><td>Admissible k-tuple</td><td>ν_k(p) < p for all p</td></tr>
</table>
</div>

<div style="background:var(--bg1);padding:1rem;border-radius:8px">
<strong style="color:#00ff88">Hardy-Littlewood Constant C_k:</strong>
<div style="font-family:monospace;margin-top:.5rem;color:var(--txt2)">
C_k = ∏ (1 − ν_k(p)/p) / (1 − 1/p)^k
</div>
<div style="font-size:.85rem;color:var(--txt2);margin-top:.5rem">
This predicts the asymptotic density of actual prime k-tuples (conjectured).
</div>
</div>`;

  // Plots
  const uniqueK = [...new Set(results.map(r => r.k))];
  const avgR = uniqueK.map(k => {
    const matches = results.filter(r => r.k === k);
    return matches.reduce((s, r) => s + r.R, 0) / matches.length;
  });
  const avgC = uniqueK.map(k => {
    const matches = results.filter(r => r.k === k);
    return matches.reduce((s, r) => s + r.C, 0) / matches.length;
  });
  
  Plotly.newPlot('pKtupleR', [
    { x: uniqueK, y: avgR, mode: 'markers+lines', name: 'R (avg)', marker: { size: 12, color: '#ffd700' }, line: { color: '#ffd700' } }
  ], { ...plo(), xaxis: { title: 'k (tuple size)', dtick: 1 }, yaxis: { title: 'R', type: 'log' } });
  
  Plotly.newPlot('pKtupleC', [
    { x: uniqueK, y: avgC, mode: 'markers+lines', name: 'C_k (avg)', marker: { size: 12, color: '#ff6496' }, line: { color: '#ff6496' } }
  ], { ...plo(), xaxis: { title: 'k (tuple size)', dtick: 1 }, yaxis: { title: 'C_k' } });
}

function drawConstellations() {
  const c = document.getElementById('cconst'), ctx = c.getContext('2d');
  const gap = +document.getElementById('constGap').value;
  const maxP = +document.getElementById('constPmaxV').value;
  const showMode = document.getElementById('constShow').value;
  // Fixed values (controls were removed)
  const multA = 1;
  const multB = 4;
  const expK = 3;
  const multiplier = multA / multB;
  
  ctx.fillStyle = canvBg();
  ctx.fillRect(0, 0, c.width, c.height);
  
  const primes = sievePrimes(maxP).filter(p => p > 2);
  const pad = 60, w = c.width - 2*pad, h = c.height - 2*pad;
  
  // Compute running products using CORRECT Hardy-Littlewood formula
  // C_H = ∏_{p>2} (1 - 1/(p-1)²) × ∏_{p|H, p>2} (p-1)/(p-2)
  // Base factor at each p: p(p-2)/(p-1)² = 1 - 1/(p-1)²
  // Enhancement if p|H: multiply by (p-1)/(p-2)
  constData.primes = primes;
  constData.products = [];
  constData.factors = [];
  
  let runningC = 1;  // Running C_H product (Hardy-Littlewood)
  let runningM = 1;  // Mertens product ∏(1-1/p)
  let runningR_modular = multiplier;  // R_modular = (a/b) × ∏[(p-1)(p-2)/p²]
  
  for (const p of primes) {
    const divides = (gap % p === 0);
    const v = divides ? 1 : 2;  // ν(p) for educational display
    
    // Base factor: (1 - 1/(p-1)²) = p(p-2)/(p-1)²
    const baseFactor = (p * (p - 2)) / ((p - 1) * (p - 1));
    
    // Enhancement factor if p|H: (p-1)/(p-2)
    const enhancement = divides ? (p - 1) / (p - 2) : 1;
    
    const combinedFactor = baseFactor * enhancement;
    runningC *= combinedFactor;
    runningM *= (1 - 1/p);
    
    // R_modular factor: (p-1)(p-2)/p²
    runningR_modular *= (p - 1) * (p - 2) / (p * p);
    
    const R = multiplier * runningC * Math.pow(runningM, expK);
    
    constData.products.push({ p, C: runningC, M: runningM, R, R_modular: runningR_modular, baseFactor, enhancement, divides, v });
    constData.factors.push({ p, factor: combinedFactor, v, baseFactor, enhancement, divides });
  }
  
  // Get true C_H from constants or compute it
  const trueC = HL_CONSTANTS[gap] || (primes.length > 0 ? constData.products[constData.products.length-1].C : 0.6601618158);
  
  // ===== STEP-BY-STEP CONVERGENCE TABLE =====
  let stepHTML = `<tr style="background:rgba(255,215,0,.15);position:sticky;top:0">
<th style="padding:6px;text-align:left">p</th>
<th>ν(p)</th>
<th>p|H?</th>
<th>Base Factor<br><span style="font-size:.65rem">p(p-2)/(p-1)²</span></th>
<th>Enhancement<br><span style="font-size:.65rem">(p-1)/(p-2)</span></th>
<th>Combined</th>
<th style="color:#ff6496">Running C_H</th>
<th style="color:#00d9ff">Mertens M</th>
<th style="color:#00ff88">R = (${multA}/${multB})×C×M<sup>${expK}</sup></th>
<th style="color:#ffd700">R_modular</th>
</tr>`;
  
  // Show first 20 primes, then every 10th, then last few
  const displayIndices = [];
  for (let i = 0; i < Math.min(20, primes.length); i++) displayIndices.push(i);
  for (let i = 20; i < primes.length - 5; i += Math.max(1, Math.floor(primes.length/20))) {
    if (!displayIndices.includes(i)) displayIndices.push(i);
  }
  for (let i = Math.max(0, primes.length - 5); i < primes.length; i++) {
    if (!displayIndices.includes(i)) displayIndices.push(i);
  }
  displayIndices.sort((a,b) => a - b);
  
  let lastIdx = -1;
  for (const i of displayIndices) {
    const d = constData.products[i];
    if (!d) continue;
    
    // Add separator if we skipped rows
    if (lastIdx >= 0 && i - lastIdx > 1) {
      stepHTML += `<tr style="background:rgba(100,100,100,.2)"><td colspan="10" style="text-align:center;padding:3px;color:#666;font-size:.7rem">... ${i - lastIdx - 1} primes skipped ...</td></tr>`;
    }
    
    const rowBg = d.divides ? 'rgba(255,215,0,.15)' : '';
    stepHTML += `<tr style="background:${rowBg}">
<td style="padding:4px;font-weight:bold">${d.p}</td>
<td style="color:${d.v===1?'#00ff88':'#ff6496'}">${d.v}</td>
<td style="color:${d.divides?'#ffd700':'#666'}">${d.divides ? 'OK YES' : 'no'}</td>
<td style="font-family:monospace;font-size:.75rem">${fmtNum(d.baseFactor, 8)}</td>
<td style="font-family:monospace;font-size:.75rem;color:${d.divides?'#ffd700':'#888'}">${fmtNum(d.enhancement, 6)}</td>
<td style="font-family:monospace;font-size:.75rem">${fmtNum(d.baseFactor * d.enhancement, 8)}</td>
<td style="font-family:monospace;color:#ff6496">${fmtNum(d.C, 10)}</td>
<td style="font-family:monospace;color:#00d9ff">${fmtNum(d.M, 10)}</td>
<td style="font-family:monospace;color:#00ff88">${fmtNum(d.R, 12)}</td>
<td style="font-family:monospace;color:#ffd700">${fmtNum(d.R_modular, 12)}</td>
</tr>`;
    lastIdx = i;
  }
  
  document.getElementById('tConstStep').innerHTML = stepHTML;
  
  // ===== SCALES TABLE (different p_max values) =====
  const scalePoints = [10, 23, 50, 97, 200, 500, 997, 2000, 5000, 9973, 50000, 99991].filter(n => n <= maxP * 2);
  let scaleHTML = `<tr style="background:rgba(0,255,136,.1)">
<th style="padding:8px">p_max</th>
<th># Primes</th>
<th style="color:#ff6496">C_H(p)</th>
<th style="color:#00d9ff">M(p)</th>
<th style="color:#00ff88">R = (${multA}/${multB})×C×M<sup>${expK}</sup></th>
<th style="color:#ffd700">R_modular</th>
<th style="color:#9664ff">R_asymp</th>
<th>Correction</th>
<th>Identity</th>
</tr>`;
  
  for (const pmax of scalePoints) {
    const ps = sievePrimes(pmax).filter(p => p > 2);
    if (ps.length === 0) continue;
    
    let C = 1, M = 1, Rmod = multiplier;
    for (const p of ps) {
      const baseFactor = (p * (p - 2)) / ((p - 1) * (p - 1));
      const enhancement = (gap % p === 0) ? (p - 1) / (p - 2) : 1;
      C *= baseFactor * enhancement;
      M *= (1 - 1/p);
      Rmod *= (p - 1) * (p - 2) / (p * p);
    }
    const R = multiplier * C * Math.pow(M, expK);
    const ratio = R / Rmod;
    const isExact = Math.abs(ratio - 1) < 1e-10;
    
    // Asymptotic calculation
    const lnP = Math.log(pmax);
    const ln3P = lnP * lnP * lnP;
    const R_asymp = trueC * E_NEG_3GAMMA / (4 * ln3P);
    const corrFactor = Rmod / R_asymp;
    
    scaleHTML += `<tr>
<td style="padding:6px;font-weight:bold">${pmax.toLocaleString()}</td>
<td>${ps.length}</td>
<td style="font-family:monospace;color:#ff6496">${fmtNum(C, 8)}</td>
<td style="font-family:monospace;color:#00d9ff">${fmtNum(M, 8)}</td>
<td style="font-family:monospace;color:#00ff88">${fmtNum(R, 10)}</td>
<td style="font-family:monospace;color:#ffd700">${fmtNum(Rmod, 10)}</td>
<td style="font-family:monospace;color:#9664ff">${R_asymp.toExponential(3)}</td>
<td style="font-family:monospace;color:#00ff88">${fmtNum(corrFactor, 2)}×</td>
<td style="font-family:monospace;color:${isExact?'#00ff88':'#ff4040'}">${isExact ? 'OK' : 'X'}</td>
</tr>`;
  }
  
  document.getElementById('tConstScales').innerHTML = scaleHTML;
  
  // ===== IMPROVED INTERACTIVE VISUALIZATION =====
  const vizMode = document.getElementById('sieveVizMode')?.value || 'bars';
  
  // Store prime data for click interactions
  window.sievePrimeData = constData.products.map((d, i) => ({
    ...d,
    index: i,
    elimCount: d.divides ? 1 : 2,
    surviveRatio: (d.p - (d.divides ? 1 : 2)) / d.p
  }));
  
  if (vizMode === 'bars') {
    drawSieveBars(ctx, c, primes, gap, pad, w, h, constData);
  } else if (vizMode === 'timeline') {
    drawSieveTimeline(ctx, c, primes, gap, pad, w, h, constData);
  } else if (vizMode === 'heatmap') {
    drawSieveHeatmap(ctx, c, primes, gap, pad, w, h, constData);
  } else if (vizMode === 'spiral') {
    drawSieveSpiral(ctx, c, primes, gap, pad, w, h, constData);
  } else {
    drawSieveBars(ctx, c, primes, gap, pad, w, h, constData);
  }
  
  // Setup click handler for canvas
  setupSieveClickHandler(c, primes, gap, pad, w, h, vizMode);
  
  // Compute final values for live stats
  const finalC = constData.products.length > 0 ? constData.products[constData.products.length-1].C : 1;
  const finalM = constData.products.length > 0 ? constData.products[constData.products.length-1].M : 1;
  const finalR = multiplier * finalC * Math.pow(finalM, expK);
  const finalR_modular = constData.products.length > 0 ? constData.products[constData.products.length-1].R_modular : multiplier;
  const identityRatio = finalR / finalR_modular;
  const identityVerified = Math.abs(identityRatio - 1) < 1e-10;
  
  const gapName = gap === 2 ? 'Twin' : gap === 4 ? 'Cousin' : gap === 6 ? 'Sexy' : `Gap ${gap}`;
  const gapFactors = [];
  for (let p = 2; p <= Math.min(gap, 100); p++) {
    if (isPrime(p) && gap % p === 0) gapFactors.push(p);
  }
  const factorMultiplier = gapFactors.filter(p => p > 2).reduce((acc, p) => acc * (p - 1) / (p - 2), 1);
  
  // Asymptotic calculations
  const p_max = primes.length > 0 ? primes[primes.length-1] : 3;
  const lnP = Math.log(p_max);
  const ln3P = lnP * lnP * lnP;
  const mertensApprox = E_NEG_GAMMA / lnP;
  const mertensRatio = finalM / mertensApprox;
  const R_asymptotic = trueC * E_NEG_3GAMMA / (4 * ln3P);
  const correctionFactor = finalR_modular / R_asymptotic;
  
  document.getElementById('constLiveStats').innerHTML = `
<div style="background:linear-gradient(135deg,rgba(255,100,150,.15),rgba(255,215,0,.1));padding:10px;border-radius:8px;margin-bottom:12px;border:1px solid #ff6496">
<div style="font-size:.7rem;color:var(--txt2);margin-bottom:4px">SINGULAR SERIES VERIFIER | GAP: H = ${gap} | ${gapName} Primes</div>
<div style="display:grid;grid-template-columns:repeat(4,1fr);gap:6px;font-size:.75rem">
<span>Max prime: <strong style="color:#00d9ff">${primes.length > 0 ? primes[primes.length-1].toLocaleString() : 0}</strong></span>
<span>Primes used: <strong style="color:#ffd700">${primes.length.toLocaleString()}</strong></span>
<span>Gap type: <strong style="color:#00ff88">${gapName}</strong></span>
<span>C_H/C_2 ratio: <strong style="color:#9664ff">${fmtNum(factorMultiplier, 4)}</strong></span>
</div>
</div>
<div style="display:grid;grid-template-columns:repeat(2,1fr);gap:8px;margin-bottom:12px">
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center"><div style="font-size:1.2rem;font-weight:bold;color:#ff6496">${fmtNum(finalC, 10)}</div><div style="font-size:.7rem;color:var(--txt2)">C_H(p_max) Running Product</div></div>
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center"><div style="font-size:1.2rem;font-weight:bold;color:#ffd700">${fmtNum(trueC, 10)}</div><div style="font-size:.7rem;color:var(--txt2)">C_H(∞) True Constant</div></div>
</div>
<div style="display:grid;grid-template-columns:repeat(4,1fr);gap:8px;margin-bottom:12px">
<div style="background:var(--bg1);padding:8px;border-radius:6px;text-align:center"><div style="font-size:1rem;font-weight:bold;color:#00d9ff">${fmtNum(finalM, 10)}</div><div style="font-size:.6rem;color:var(--txt2)">MERTENS M(p)</div></div>
<div style="background:var(--bg1);padding:8px;border-radius:6px;text-align:center"><div style="font-size:1rem;font-weight:bold;color:#00ff88">${fmtNum(finalR, 12)}</div><div style="font-size:.6rem;color:var(--txt2)">R = (${multA}/${multB}) x C x M^${expK}</div></div>
<div style="background:var(--bg1);padding:8px;border-radius:6px;text-align:center"><div style="font-size:1rem;font-weight:bold;color:#ffd700">${fmtNum(finalR_modular, 12)}</div><div style="font-size:.6rem;color:var(--txt2)">R_modular</div></div>
<div style="background:var(--bg1);padding:8px;border-radius:6px;text-align:center"><div style="font-size:1rem;font-weight:bold;color:${identityVerified?'#00ff88':'#ff4040'}">${fmtNum(identityRatio, 12)}</div><div style="font-size:.6rem;color:var(--txt2)">R / R_modular ${identityVerified ? 'OK' : ''}</div></div>
</div>

<!-- NEW: Asymptotic Analysis Panel -->
<div style="background:linear-gradient(135deg,rgba(150,100,255,.15),rgba(255,100,150,.1));padding:10px;border-radius:8px;margin-bottom:12px;border:1px solid #9664ff">
<div style="font-size:.7rem;color:var(--txt2);margin-bottom:6px">ASYMPTOTIC CLOSED FORM (via Mertens' Theorem)</div>
<div style="display:grid;grid-template-columns:repeat(4,1fr);gap:6px;margin-bottom:8px">
<div style="background:rgba(0,0,0,.2);padding:6px;border-radius:4px;text-align:center">
<div style="font-size:.9rem;font-weight:bold;color:#ffd700">${mertensApprox.toExponential(4)}</div>
<div style="font-size:.55rem;color:var(--txt2)">e<sup>-γ</sup>/ln(p) Mertens</div>
</div>
<div style="background:rgba(0,0,0,.2);padding:6px;border-radius:4px;text-align:center">
<div style="font-size:.9rem;font-weight:bold;color:#00d9ff">${fmtNum(mertensRatio, 4)}</div>
<div style="font-size:.55rem;color:var(--txt2)">M / Mertens → 1</div>
</div>
<div style="background:rgba(0,0,0,.2);padding:6px;border-radius:4px;text-align:center">
<div style="font-size:.9rem;font-weight:bold;color:#9664ff">${fmtNum(finalR_modular, 4)}</div>
<div style="font-size:.55rem;color:var(--txt2)">R<sub>H</sub>/M (density)</div>
</div>
<div style="background:rgba(0,0,0,.2);padding:6px;border-radius:4px;text-align:center">
<div style="font-size:.9rem;font-weight:bold;color:#00ff88">${primes.length}</div>
<div style="font-size:.55rem;color:var(--txt2)"># primes used</div>
</div>
</div>
<div style="font-size:.7rem;color:var(--txt2);text-align:center">
R<sub>H</sub> = M × ∏(p−ν)/p | 
γ = ${EULER_GAMMA.toFixed(6)} (Euler-Mascheroni) | 
ln(${p_max}) = ${fmtNum(lnP, 3)}
</div>
</div>

<div style="background:rgba(0,217,255,.08);padding:8px;border-radius:6px;font-size:.75rem">
<strong style="color:#00d9ff">Convergence</strong>: 
${primes.length > 0 ? `After ${primes.length} primes (p ≤ ${primes[primes.length-1].toLocaleString()}), error = ${fmtNum(Math.abs(finalC - trueC), 3)}` : 'No primes'}
${primes.length >= 100 ? ' — Good convergence!' : primes.length >= 25 ? ' — Converging...' : ' — Need more primes'}
</div>`;

  // Plotly charts
  if (constData.products.length > 0) {
    const useMarkers = primes.length <= 50;
    const mode = useMarkers ? 'lines+markers' : 'lines';
    const errors = constData.products.map(d => Math.abs(d.C - trueC));
    
    Plotly.newPlot('pconstProduct', [
      { x: constData.products.map(d => d.p), y: constData.products.map(d => d.C), mode, name: 'C_H(p)', line: { color: '#ff6496', width: 2 }, marker: { size: 6 } },
      { x: [primes[0], primes[primes.length-1]], y: [trueC, trueC], mode: 'lines', name: `C_H(∞) = ${fmtNum(trueC, 6)}`, line: { color: '#ffd700', dash: 'dash', width: 2 } },
      { x: constData.products.map(d => d.p), y: errors, mode: 'lines', name: '|Error|', yaxis: 'y2', line: { color: '#9664ff', width: 1 } }
    ], { ...plo(), xaxis: { title: 'Prime p', type: primes.length > 100 ? 'log' : 'linear' }, yaxis: { title: 'C_H Running Product' }, yaxis2: { title: '|Error|', overlaying: 'y', side: 'right', type: 'log', showgrid: false } });
    
    const factorColors = constData.factors.map(d => d.divides ? '#ffd700' : '#00d9ff');
    Plotly.newPlot('pconstFactor', [
      { x: constData.factors.map(d => d.p), y: constData.factors.map(d => d.baseFactor), mode: useMarkers ? 'lines+markers' : 'lines', name: 'Base factor', line: { color: '#00d9ff', width: 1.5 } },
      { x: constData.factors.map(d => d.p), y: constData.factors.map(d => d.factor), mode: useMarkers ? 'markers' : 'lines', name: 'Combined', marker: { color: factorColors, size: useMarkers ? 10 : 4, symbol: 'diamond' } },
      { x: [primes[0], primes[primes.length-1]], y: [1, 1], mode: 'lines', name: 'Baseline', line: { color: '#888', dash: 'dot' } }
    ], { ...plo(), xaxis: { title: 'Prime p', type: primes.length > 100 ? 'log' : 'linear' }, yaxis: { title: 'Factor (→1 as p→∞)' } });
  }
}

// Horizontal bars visualization - handles many primes well
function drawSieveBars(ctx, c, primes, gap, pad, w, h, constData) {
  const isDk = isDark();
  const numPrimes = primes.length;
  const barH = Math.min(25, Math.max(8, (h - 40) / numPrimes));
  const maxBarW = w - 120;
  const labelW = 50;
  const startY = pad + 30;
  
  // Title
  ctx.fillStyle = isDk ? '#ffd700' : '#cc8800';
  ctx.font = 'bold 14px Segoe UI';
  ctx.textAlign = 'left';
  ctx.fillText(`Per-Prime Survival Ratios (H = ${gap}, ${numPrimes} odd primes)`, pad, pad + 15);
  
  // Running product display
  let runningProduct = 1;
  
  for (let i = 0; i < numPrimes; i++) {
    const p = primes[i];
    const y = startY + i * barH;
    if (y > c.height - 20) break; // Don't draw beyond canvas
    
    const divides = (gap % p === 0);
    const elimCount = divides ? 1 : 2;
    const surviveRatio = (p - elimCount) / p;
    runningProduct *= surviveRatio;
    
    // Prime label
    ctx.fillStyle = divides ? '#ffd700' : (isDk ? '#aaa' : '#555');
    ctx.font = `${Math.min(11, barH - 2)}px Segoe UI`;
    ctx.textAlign = 'right';
    ctx.fillText(p.toString(), pad + labelW - 5, y + barH/2 + 4);
    
    // Background bar
    ctx.fillStyle = isDk ? 'rgba(50,60,80,0.5)' : 'rgba(200,200,200,0.5)';
    ctx.fillRect(pad + labelW, y + 2, maxBarW, barH - 4);
    
    // Surviving portion (green)
    const surviveW = maxBarW * surviveRatio;
    ctx.fillStyle = divides ? 'rgba(255,215,0,0.7)' : 'rgba(0,255,136,0.6)';
    ctx.fillRect(pad + labelW, y + 2, surviveW, barH - 4);
    
    // Eliminated portion (red) 
    ctx.fillStyle = 'rgba(255,100,150,0.7)';
    ctx.fillRect(pad + labelW + surviveW, y + 2, maxBarW - surviveW, barH - 4);
    
    // Border for p|H
    if (divides) {
      ctx.strokeStyle = '#ffd700';
      ctx.lineWidth = 2;
      ctx.strokeRect(pad + labelW - 1, y + 1, maxBarW + 2, barH - 2);
    }
    
    // Ratio text on bar
    if (barH >= 12) {
      ctx.fillStyle = '#fff';
      ctx.font = `bold ${Math.min(10, barH - 4)}px Segoe UI`;
      ctx.textAlign = 'left';
      const ratioText = `${p - elimCount}/${p} (${(surviveRatio * 100).toFixed(1)}%)`;
      ctx.fillText(ratioText, pad + labelW + 5, y + barH/2 + 3);
      
      // ν(p) indicator
      ctx.textAlign = 'right';
      ctx.fillStyle = divides ? '#ffd700' : '#ff6496';
      ctx.fillText(`ν=${divides ? 1 : 2}`, pad + labelW + maxBarW - 5, y + barH/2 + 3);
    }
  }
  
  // Cumulative product indicator
  const finalProduct = constData.products.length > 0 ? 
    constData.products[constData.products.length - 1].R_modular : runningProduct;
  ctx.fillStyle = isDk ? '#00ff88' : '#006644';
  ctx.font = 'bold 12px Segoe UI';
  ctx.textAlign = 'left';
  ctx.fillText(`Cumulative: ${fmtNum(finalProduct, 10)}`, pad + labelW, c.height - 8);
}

// Timeline waterfall visualization
function drawSieveTimeline(ctx, c, primes, gap, pad, w, h, constData) {
  const isDk = isDark();
  const numPrimes = Math.min(primes.length, 50); // Limit for performance
  const stepW = (w - 40) / numPrimes;
  
  ctx.fillStyle = isDk ? '#ffd700' : '#cc8800';
  ctx.font = 'bold 14px Segoe UI';
  ctx.textAlign = 'center';
  ctx.fillText(`Cumulative Survival Timeline (H = ${gap})`, c.width/2, pad + 15);
  
  let cumulative = 1;
  const points = [];
  
  for (let i = 0; i < numPrimes; i++) {
    const p = primes[i];
    const divides = (gap % p === 0);
    const surviveRatio = (p - (divides ? 1 : 2)) / p;
    cumulative *= surviveRatio;
    
    const x = pad + 20 + i * stepW;
    const y = pad + 50 + (1 - cumulative) * (h - 80);
    points.push({ x, y, p, cumulative, divides });
  }
  
  // Draw filled area
  ctx.beginPath();
  ctx.moveTo(pad + 20, pad + 50);
  points.forEach(pt => ctx.lineTo(pt.x, pt.y));
  ctx.lineTo(points[points.length - 1].x, c.height - pad);
  ctx.lineTo(pad + 20, c.height - pad);
  ctx.closePath();
  ctx.fillStyle = 'rgba(0,255,136,0.3)';
  ctx.fill();
  
  // Draw line
  ctx.beginPath();
  ctx.moveTo(pad + 20, pad + 50);
  points.forEach(pt => ctx.lineTo(pt.x, pt.y));
  ctx.strokeStyle = '#00ff88';
  ctx.lineWidth = 2;
  ctx.stroke();
  
  // Draw points
  points.forEach((pt, i) => {
    ctx.beginPath();
    ctx.arc(pt.x, pt.y, pt.divides ? 6 : 4, 0, Math.PI * 2);
    ctx.fillStyle = pt.divides ? '#ffd700' : '#00d9ff';
    ctx.fill();
    
    // Label every few points
    if (i % Math.max(1, Math.floor(numPrimes / 15)) === 0 || pt.divides) {
      ctx.fillStyle = isDk ? '#fff' : '#333';
      ctx.font = '9px Segoe UI';
      ctx.textAlign = 'center';
      ctx.fillText(pt.p.toString(), pt.x, pt.y - 10);
    }
  });
  
  // Y-axis labels
  ctx.fillStyle = isDk ? '#888' : '#666';
  ctx.font = '10px Segoe UI';
  ctx.textAlign = 'right';
  for (let pct = 0; pct <= 100; pct += 20) {
    const y = pad + 50 + (pct / 100) * (h - 80);
    ctx.fillText(`${100 - pct}%`, pad + 15, y + 3);
    ctx.strokeStyle = isDk ? 'rgba(255,255,255,0.1)' : 'rgba(0,0,0,0.1)';
    ctx.beginPath();
    ctx.moveTo(pad + 20, y);
    ctx.lineTo(c.width - pad, y);
    ctx.stroke();
  }
}

// Heatmap grid visualization
function drawSieveHeatmap(ctx, c, primes, gap, pad, w, h, constData) {
  const isDk = isDark();
  const numPrimes = primes.length;
  const cols = Math.ceil(Math.sqrt(numPrimes * 2));
  const rows = Math.ceil(numPrimes / cols);
  const cellW = (w - 20) / cols;
  const cellH = Math.min(cellW, (h - 60) / rows);
  
  ctx.fillStyle = isDk ? '#ffd700' : '#cc8800';
  ctx.font = 'bold 14px Segoe UI';
  ctx.textAlign = 'center';
  ctx.fillText(`Prime Sieve Heatmap (H = ${gap}, click for details)`, c.width/2, pad + 15);
  
  for (let i = 0; i < numPrimes; i++) {
    const p = primes[i];
    const col = i % cols;
    const row = Math.floor(i / cols);
    const x = pad + 10 + col * cellW;
    const y = pad + 35 + row * cellH;
    
    const divides = (gap % p === 0);
    const surviveRatio = (p - (divides ? 1 : 2)) / p;
    
    // Color based on survival ratio (green = high, red = low)
    const hue = surviveRatio * 120; // 0=red, 120=green
    ctx.fillStyle = `hsla(${hue}, 80%, ${isDk ? 40 : 50}%, 0.9)`;
    ctx.fillRect(x + 1, y + 1, cellW - 2, cellH - 2);
    
    // Gold border for p|H
    if (divides) {
      ctx.strokeStyle = '#ffd700';
      ctx.lineWidth = 2;
      ctx.strokeRect(x, y, cellW, cellH);
    }
    
    // Prime number
    if (cellW > 25) {
      ctx.fillStyle = '#fff';
      ctx.font = `bold ${Math.min(11, cellW/3)}px Segoe UI`;
      ctx.textAlign = 'center';
      ctx.fillText(p.toString(), x + cellW/2, y + cellH/2 + 4);
    }
  }
  
  // Legend
  const legendY = c.height - 25;
  ctx.font = '10px Segoe UI';
  ctx.textAlign = 'left';
  ctx.fillStyle = isDk ? '#888' : '#666';
  ctx.fillText('Low survival', pad + 10, legendY);
  
  // Gradient legend bar
  const gradW = 150;
  for (let i = 0; i < gradW; i++) {
    const hue = (i / gradW) * 120;
    ctx.fillStyle = `hsl(${hue}, 80%, 45%)`;
    ctx.fillRect(pad + 80 + i, legendY - 10, 1, 12);
  }
  ctx.fillStyle = isDk ? '#888' : '#666';
  ctx.fillText('High survival', pad + 240, legendY);
}

// Spiral visualization
function drawSieveSpiral(ctx, c, primes, gap, pad, w, h, constData) {
  const isDk = isDark();
  const cx = c.width / 2;
  const cy = c.height / 2;
  const maxR = Math.min(w, h) / 2 - 30;
  const numPrimes = primes.length;
  
  ctx.fillStyle = isDk ? '#ffd700' : '#cc8800';
  ctx.font = 'bold 14px Segoe UI';
  ctx.textAlign = 'center';
  ctx.fillText(`Prime Sieve Spiral (H = ${gap})`, c.width/2, pad + 15);
  
  // Draw spiral of primes
  let angle = 0;
  let radius = 30;
  const spacing = 0.3;
  
  for (let i = 0; i < numPrimes; i++) {
    const p = primes[i];
    const divides = (gap % p === 0);
    const surviveRatio = (p - (divides ? 1 : 2)) / p;
    
    const x = cx + radius * Math.cos(angle);
    const y = cy + radius * Math.sin(angle);
    
    // Size based on prime value (log scale)
    const size = Math.max(4, Math.min(15, 3 + Math.log(p) * 2));
    
    // Color based on survival
    const hue = surviveRatio * 120;
    ctx.beginPath();
    ctx.arc(x, y, size, 0, Math.PI * 2);
    ctx.fillStyle = divides ? '#ffd700' : `hsl(${hue}, 80%, 50%)`;
    ctx.fill();
    
    if (divides) {
      ctx.strokeStyle = '#fff';
      ctx.lineWidth = 2;
      ctx.stroke();
    }
    
    // Label larger primes or p|H
    if (size > 8 || divides || i < 10) {
      ctx.fillStyle = isDk ? '#fff' : '#333';
      ctx.font = '8px Segoe UI';
      ctx.textAlign = 'center';
      ctx.fillText(p.toString(), x, y + size + 10);
    }
    
    // Advance spiral
    angle += spacing / Math.sqrt(radius / 30);
    radius += 0.8;
    if (radius > maxR) break;
  }
  
  // Center info
  ctx.fillStyle = isDk ? '#00ff88' : '#006644';
  ctx.font = 'bold 12px Segoe UI';
  const finalR = constData.products.length > 0 ? constData.products[constData.products.length-1].R_modular : 1;
  ctx.fillText(`R = ${fmtNum(finalR, 8)}`, cx, cy);
}

// Click handler for interactivity
function setupSieveClickHandler(c, primes, gap, pad, w, h, vizMode) {
  // Remove old handler
  c.onclick = null;
  
  c.onclick = function(e) {
    const rect = c.getBoundingClientRect();
    const mx = (e.clientX - rect.left) * (c.width / rect.width);
    const my = (e.clientY - rect.top) * (c.height / rect.height);
    
    const tooltip = document.getElementById('sieveTooltip');
    if (!tooltip) return;
    
    // Find clicked prime based on viz mode
    let clickedPrime = null;
    let clickedData = null;
    
    if (vizMode === 'bars') {
      const barH = Math.min(25, Math.max(8, (h - 40) / primes.length));
      const startY = pad + 30;
      const labelW = 50;
      
      for (let i = 0; i < primes.length; i++) {
        const y = startY + i * barH;
        if (my >= y && my <= y + barH && mx >= pad + labelW) {
          clickedPrime = primes[i];
          clickedData = window.sievePrimeData?.[i];
          break;
        }
      }
    } else if (vizMode === 'heatmap') {
      const cols = Math.ceil(Math.sqrt(primes.length * 2));
      const cellW = (w - 20) / cols;
      const cellH = Math.min(cellW, (h - 60) / Math.ceil(primes.length / cols));
      
      const col = Math.floor((mx - pad - 10) / cellW);
      const row = Math.floor((my - pad - 35) / cellH);
      const idx = row * cols + col;
      
      if (idx >= 0 && idx < primes.length) {
        clickedPrime = primes[idx];
        clickedData = window.sievePrimeData?.[idx];
      }
    } else if (vizMode === 'timeline' || vizMode === 'spiral') {
      // Find closest prime point
      let minDist = 20;
      for (let i = 0; i < primes.length; i++) {
        // Approximate position (would need stored positions for exact match)
        clickedPrime = primes[i];
        clickedData = window.sievePrimeData?.[i];
        break; // Simplified - show first prime
      }
    }
    
    if (clickedPrime && clickedData) {
      const divides = (gap % clickedPrime === 0);
      const elimCount = divides ? 1 : 2;
      const eliminated = [0];
      if (!divides) eliminated.push((clickedPrime - (gap % clickedPrime)) % clickedPrime);
      
      tooltip.innerHTML = `
        <div style="color:#ffd700;font-weight:bold;font-size:1.1rem;margin-bottom:8px">Prime p = ${clickedPrime}</div>
        <div style="display:grid;grid-template-columns:1fr 1fr;gap:4px;font-size:.85rem">
          <span style="color:#888">Gap H:</span><span>${gap}</span>
          <span style="color:#888">p | H:</span><span style="color:${divides?'#ffd700':'#888'}">${divides ? 'YES OK' : 'No'}</span>
          <span style="color:#888">ν(p):</span><span style="color:${divides?'#00ff88':'#ff6496'}">${divides ? 1 : 2}</span>
          <span style="color:#888">Eliminated:</span><span style="color:#ff6496">${eliminated.join(', ')} mod ${clickedPrime}</span>
          <span style="color:#888">Surviving:</span><span style="color:#00ff88">${clickedPrime - elimCount} / ${clickedPrime}</span>
          <span style="color:#888">Ratio:</span><span>${((clickedPrime - elimCount) / clickedPrime * 100).toFixed(2)}%</span>
        </div>
        <div style="margin-top:8px;padding-top:8px;border-top:1px solid rgba(255,255,255,0.2);font-size:.8rem">
          <div style="color:#ff6496">C_H factor: ${fmtNum(clickedData.baseFactor * clickedData.enhancement, 8)}</div>
          <div style="color:#00d9ff">Running C_H: ${fmtNum(clickedData.C, 10)}</div>
          <div style="color:#ffd700">Running R: ${fmtNum(clickedData.R_modular, 10)}</div>
        </div>
      `;
      
      tooltip.style.display = 'block';
      tooltip.style.left = Math.min(e.offsetX + 15, c.width - 290) + 'px';
      tooltip.style.top = Math.min(e.offsetY + 15, c.height - 200) + 'px';
    } else {
      tooltip.style.display = 'none';
    }
  };
  
  // Hide tooltip on mouse leave
  c.onmouseleave = function() {
    const tooltip = document.getElementById('sieveTooltip');
    if (tooltip) tooltip.style.display = 'none';
  };
}


function animateSieve() {
  if (constAnimInterval) {
    clearInterval(constAnimInterval);
    constAnimInterval = null;
    return;
  }
  
  let step = 3;
  const maxP = +document.getElementById('constPmaxV').value;
  const speed = 500; // Fixed speed (control was removed)
  
  document.getElementById('animBtn').textContent = ' Pause';
  document.getElementById('animBtn').style.background = '#ff6496';
  
  constAnimInterval = setInterval(() => {
    document.getElementById('constPmaxV').value = step;
    document.getElementById('constPmax').value = Math.min(step, 10000);
    drawConstellations();
    
    step = nextPrime(step);
    if (step > maxP) {
      clearInterval(constAnimInterval);
      constAnimInterval = null;
      document.getElementById('animBtn').textContent = 'Animate';
      document.getElementById('animBtn').style.background = '';
    }
  }, speed);
}

function stopAnimation() {
  if (constAnimInterval) {
    clearInterval(constAnimInterval);
    constAnimInterval = null;
  }
  document.getElementById('animBtn').textContent = 'Animate';
  document.getElementById('animBtn').style.background = '';
}

// Constellation export functions
function csvConstellations() {
  if (!constData.products || constData.products.length === 0) {
    alert('No data to export. Run computation first.');
    return;
  }
  const gap = +document.getElementById('constGap').value;
  let s = 'prime_p,C_H,M,R,R_modular,base_factor,enhancement,divides_H,residues_eliminated\n';
  for (const d of constData.products) {
    s += `${d.p},${d.C},${d.M},${d.R},${d.R_modular},${d.baseFactor},${d.enhancement},${d.divides},${d.v}\n`;
  }
  dl(s, `wessen_gap${gap}_sieve.csv`);
}

async function screenshotConstellations() {
  await screenshotUnified('cconst', 'constLiveStats', 'Wessen_Sieve', 'wessen_sieve.png');
}

function exportAllConstellations() {
  screenshotTabAll({
    canvases: ['cconst'],
    charts: ['pconstProduct', 'pconstFactor'],
    dashId: 'constLiveStats',
    title: 'Singular Series Sieve',
    filename: 'wessen_sieve_all.png'
  });
}

// BigInt section exports
function csvBigInt() {
  const N = +document.getElementById('bigintN').value;
  const primes = sievePrimes(N).filter(p => p > 2);
  let s = 'prime_p,N_R,D_R,N_C,D_C,N_M,D_M\n';
  let N_R = 1n, D_R = 1n, N_C = 1n, D_C = 1n, N_M = 1n, D_M = 1n;
  for (const p of primes) {
    const pBig = BigInt(p);
    N_R *= (pBig - 1n) * (pBig - 2n);
    D_R *= pBig * pBig;
    N_C *= pBig * (pBig - 2n);
    D_C *= (pBig - 1n) * (pBig - 1n);
    N_M *= (pBig - 1n);
    D_M *= pBig;
    s += `${p},${N_R},${D_R},${N_C},${D_C},${N_M},${D_M}\n`;
  }
  dl(s, `wessen_bigint_N${N}.csv`);
}

// Gap H section exports
function csvGapH() {
  const N = +document.getElementById('gapHN').value;
  const select = document.getElementById('gapHSelect');
  const gaps = Array.from(select.selectedOptions).map(o => +o.value);
  const primes = sievePrimes(N).filter(p => p > 2);
  let M = 1;
  for (const p of primes) M *= (p - 1) / p;
  
  let s = 'gap_H,odd_divisors,R_modular,C_H,M,(1/4)*C*M^3,ratio,verified\n';
  for (const H of gaps) {
    let R_mod = 0.25, C = 1;
    for (const p of primes) {
      const divides = (H % p === 0);
      const nu = divides ? 1 : 2;
      R_mod *= (p - 1) * (p - nu) / (p * p);
      const baseFactor = (p * (p - 2)) / ((p - 1) * (p - 1));
      const enhancement = divides ? (p - 1) / (p - 2) : 1;
      C *= baseFactor * enhancement;
    }
    const formula = 0.25 * C * Math.pow(M, 3);
    const ratio = R_mod / formula;
    const divisors = [];
    for (let p = 3; p <= H; p += 2) {
      if (H % p === 0 && isPrime(p)) divisors.push(p);
    }
    s += `${H},"${divisors.join(',')}",${R_mod},${C},${M},${formula},${ratio},${Math.abs(ratio-1)<1e-10}\n`;
  }
  dl(s, `wessen_gaps_N${N}.csv`);
}

// k-Tuples section exports (for main k-tuples tab)
function csvKtuples() {
  const N = +document.getElementById('ktupleNv').value || 10000;
  const primes = sievePrimes(N).filter(p => p > 2);
  let M = 1;
  for (const p of primes) M *= (p - 1) / p;
  
  const patterns = [
    { k: 2, name: 'Twin', offsets: [0, 2] },
    { k: 2, name: 'Cousin', offsets: [0, 4] },
    { k: 2, name: 'Sexy', offsets: [0, 6] },
    { k: 3, name: 'Triplet_I', offsets: [0, 2, 6] },
    { k: 3, name: 'Triplet_II', offsets: [0, 4, 6] },
    { k: 4, name: 'Quadruplet', offsets: [0, 2, 6, 8] },
    { k: 5, name: 'Quintuplet', offsets: [0, 2, 6, 8, 12] },
    { k: 6, name: 'Sextuplet', offsets: [0, 4, 6, 10, 12, 16] },
    { k: 7, name: 'Septuplet', offsets: [0, 2, 6, 8, 12, 18, 20] },
  ];
  
  let s = 'k,pattern_name,offsets,R,C_k,exponent,formula_value,ratio,verified\n';
  for (const pat of patterns) {
    const k = pat.k;
    let R = Math.pow(0.5, k), C = 1;
    for (const p of primes) {
      const nu = countDistinctResidues(pat.offsets, p);
      R *= Math.pow(p - 1, k - 1) * (p - nu) / Math.pow(p, k);
      C *= Math.pow(p, k - 1) * (p - nu) / Math.pow(p - 1, k);
    }
    const exp = 2 * k - 1;
    const formula = Math.pow(0.5, k) * C * Math.pow(M, exp);
    const ratio = R / formula;
    s += `${k},${pat.name},"[${pat.offsets.join(',')}]",${R},${C},${exp},${formula},${ratio},${Math.abs(ratio-1)<1e-10}\n`;
  }
  dl(s, `wessen_ktuples_N${N}.csv`);
}

// Wessen k-Tuples section exports (for Singular Series tab)
function csvSingularSeriesKtuples() {
  const N = +document.getElementById('singularSeriesKtupleN').value || 1000;
  const primes = sievePrimes(N).filter(p => p > 2);
  let M = 1;
  for (const p of primes) M *= (p - 1) / p;
  
  const patterns = [
    { k: 2, name: 'Twin', offsets: [0, 2] },
    { k: 2, name: 'Cousin', offsets: [0, 4] },
    { k: 2, name: 'Sexy', offsets: [0, 6] },
    { k: 3, name: 'Triplet_I', offsets: [0, 2, 6] },
    { k: 3, name: 'Triplet_II', offsets: [0, 4, 6] },
    { k: 4, name: 'Quadruplet', offsets: [0, 2, 6, 8] },
    { k: 5, name: 'Quintuplet', offsets: [0, 2, 6, 8, 12] },
    { k: 6, name: 'Sextuplet', offsets: [0, 4, 6, 10, 12, 16] },
    { k: 7, name: 'Septuplet', offsets: [0, 2, 6, 8, 12, 18, 20] },
  ];
  
  let s = 'k,pattern_name,offsets,R,C_k,exponent,formula_value,ratio,verified\n';
  for (const pat of patterns) {
    const k = pat.k;
    let R = Math.pow(0.5, k), C = 1;
    for (const p of primes) {
      const nu = countDistinctResidues(pat.offsets, p);
      R *= Math.pow(p - 1, k - 1) * (p - nu) / Math.pow(p, k);
      C *= Math.pow(p, k - 1) * (p - nu) / Math.pow(p - 1, k);
    }
    const exp = 2 * k - 1;
    const formula = Math.pow(0.5, k) * C * Math.pow(M, exp);
    const ratio = R / formula;
    s += `${k},${pat.name},"[${pat.offsets.join(',')}]",${R},${C},${exp},${formula},${ratio},${Math.abs(ratio-1)<1e-10}\n`;
  }
  dl(s, `wessen_ktuples_N${N}.csv`);
}

// Algebraic section exports
function csvAlgebraic() {
  const testPrimes = [3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97];
  let s = 'prime_p,R_factor,C_factor,M_factor,C_x_M^3,ratio,exact_match\n';
  for (const p of testPrimes) {
    const R_factor = (p-1) * (p-2) / (p * p);
    const C_factor = p * (p-2) / ((p-1) * (p-1));
    const M_factor = (p-1) / p;
    const CM3 = C_factor * Math.pow(M_factor, 3);
    const ratio = R_factor / CM3;
    s += `${p},${R_factor},${C_factor},${M_factor},${CM3},${ratio},${Math.abs(ratio-1)<1e-14}\n`;
  }
  dl(s, 'wessen_algebraic_proof.csv');
}

function nextPrime(n) {
  let p = n + 1;
  while (!isPrime(p) && p < 10000000) p++;
  return p;
}

// Fast sieve for large N
function sievePrimesLarge(n) {
  if (n < 2) return [];
  const sieve = new Uint8Array(n + 1);
  const primes = [];
  for (let i = 2; i <= n; i++) {
    if (!sieve[i]) {
      primes.push(i);
      for (let j = i * 2; j <= n; j += i) sieve[j] = 1;
    }
  }
  return primes;
}

// Count prime pairs with gap H up to N
function countPrimePairs(N, gap) {
  const primes = sievePrimes(Math.min(N, 10000000));
  const primeSet = new Set(primes);
  let count = 0;
  const pairs = [];
  for (const p of primes) {
    if (p + gap <= N && primeSet.has(p + gap)) {
      count++;
      if (pairs.length < 100) pairs.push({ p, q: p + gap });
    }
  }
  return { count, pairs };
}

// Hardy-Littlewood prediction for prime pairs with gap H up to N
function predictPrimePairs(N, gap) {
  if (N < 10) return 0;
  const C = HL_CONSTANTS[gap] || 0.6601618158;
  // π₂(N) ~ C × ∫₂ᴺ dt/(ln t)²
  // Approximation: C × N / (ln N)²
  const lnN = Math.log(N);
  return C * N / (lnN * lnN);
}

function drawConstConvergence() {
  const c = document.getElementById('cConstConv'), ctx = c.getContext('2d');
  const maxN = +document.getElementById('constNV').value;
  const gap = document.getElementById('constGap2').value;
  const scale = document.getElementById('constScale').value;
  
  ctx.fillStyle = canvBg();
  ctx.fillRect(0, 0, c.width, c.height);
  
  const pad = 60, w = c.width - 2*pad, h = c.height - 2*pad;
  
  // Collect data at multiple scales
  const scales = [1000, 5000, 10000, 50000, 100000, 500000, 1000000, 5000000, 10000000].filter(n => n <= maxN);
  const results = [];
  
  for (const N of scales) {
    const gaps = gap === 'all' ? [2, 4, 6] : [+gap];
    const row = { N };
    for (const g of gaps) {
      const actual = countPrimePairs(N, g).count;
      const predicted = predictPrimePairs(N, g);
      row[`actual${g}`] = actual;
      row[`pred${g}`] = predicted;
      row[`diff${g}`] = actual - predicted;
    }
    results.push(row);
  }
  
  // Draw actual vs predicted
  const maxActual = Math.max(...results.map(r => r.actual2 || r.actual4 || r.actual6 || 0));
  
  ctx.strokeStyle = gridC();
  ctx.lineWidth = 0.5;
  for (let i = 0; i <= 10; i++) {
    const x = pad + i * w / 10;
    const y = pad + i * h / 10;
    ctx.beginPath(); ctx.moveTo(x, pad); ctx.lineTo(x, c.height - pad); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(pad, y); ctx.lineTo(c.width - pad, y); ctx.stroke();
  }
  
  // Plot lines
  const colors = { 2: '#ff6496', 4: '#ffd700', 6: '#00ff88' };
  const gaps = gap === 'all' ? [2, 4, 6] : [+gap];
  
  for (const g of gaps) {
    // Actual
    ctx.strokeStyle = colors[g];
    ctx.lineWidth = 2;
    ctx.beginPath();
    results.forEach((r, i) => {
      const x = pad + (scale === 'log' ? Math.log10(r.N) / Math.log10(maxN) : r.N / maxN) * w;
      const y = c.height - pad - (r[`actual${g}`] / maxActual) * h;
      if (i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
    });
    ctx.stroke();
    
    // Predicted (dashed)
    ctx.setLineDash([5, 3]);
    ctx.strokeStyle = colors[g];
    ctx.globalAlpha = 0.5;
    ctx.beginPath();
    results.forEach((r, i) => {
      const x = pad + (scale === 'log' ? Math.log10(r.N) / Math.log10(maxN) : r.N / maxN) * w;
      const y = c.height - pad - (r[`pred${g}`] / maxActual) * h;
      if (i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
    });
    ctx.stroke();
    ctx.setLineDash([]);
    ctx.globalAlpha = 1;
  }
  
  // Title
  ctx.fillStyle = isDark() ? '#00d9ff' : '#0066cc';
  ctx.font = 'bold 14px Segoe UI';
  ctx.textAlign = 'center';
  ctx.fillText(`Prime Pair Counts: Actual (solid) vs H-L Prediction (dashed) — N ≤ ${maxN.toLocaleString()}`, c.width/2, 25);
  
  // Legend
  ctx.font = '11px Segoe UI';
  let ly = 45;
  for (const g of gaps) {
    ctx.fillStyle = colors[g];
    ctx.fillRect(pad, ly, 20, 10);
    ctx.fillStyle = isDark() ? '#fff' : '#000';
    ctx.textAlign = 'left';
    ctx.fillText(`Gap ${g}`, pad + 25, ly + 9);
    ly += 15;
  }
  
  // Update table
  const tableScales = [100000, 500000, 1000000, 5000000, 10000000].filter(n => n <= Math.max(maxN, 100000));
  let tableHTML = '<tr><th>N</th><th>Twin (Gap 2)</th><th>Cousin (Gap 4)</th><th>Sexy (Gap 6)</th><th>Gap4/Gap2</th><th>Gap6/Gap2</th></tr>';
  
  for (const N of tableScales) {
    const t = countPrimePairs(Math.min(N, maxN), 2).count;
    const c4 = countPrimePairs(Math.min(N, maxN), 4).count;
    const s = countPrimePairs(Math.min(N, maxN), 6).count;
    tableHTML += `<tr>
      <td>${N.toLocaleString()}</td>
      <td style="color:#ff6496">${t.toLocaleString()}</td>
      <td style="color:#ffd700">${c4.toLocaleString()}</td>
      <td style="color:#00ff88">${s.toLocaleString()}</td>
      <td>${(c4/t).toFixed(4)}</td>
      <td style="color:#00d9ff">${(s/t).toFixed(4)}</td>
    </tr>`;
  }
  document.getElementById('tConstTable').innerHTML = tableHTML;
  
  // Discrepancy plot
  if (results.length > 0) {
    const discrepTraces = [];
    for (const g of gaps) {
      discrepTraces.push({
        x: results.map(r => r.N),
        y: results.map(r => r[`diff${g}`]),
        mode: 'lines+markers',
        name: `Gap ${g}`,
        line: { color: colors[g] }
      });
    }
    Plotly.newPlot('pconstDiscrep', discrepTraces, { ...plo(), xaxis: { title: 'N', type: scale === 'log' ? 'log' : 'linear' }, yaxis: { title: 'Actual - Predicted' } });
    
    // Convergence rate
    const convData = [];
    const primeList = sievePrimes(500);
    for (let i = 1; i < primeList.length; i++) {
      const pmax = primeList[i];
      if (pmax <= 2) continue;
      const Cp = computeHL(2, pmax);
      const Cinf = HL_CONSTANTS[2];
      convData.push({ p: pmax, error: Math.abs(Cp - Cinf) });
    }
    Plotly.newPlot('pconstRate', [
      { x: convData.map(d => d.p), y: convData.map(d => d.error), mode: 'lines', name: '|C₂(p) - C₂(∞)|', line: { color: '#9664ff' } }
    ], { ...plo(), xaxis: { title: 'Max Prime p' }, yaxis: { title: 'Convergence Error', type: 'log' } });
  }
  
  // Click handler
  c.onclick = e => {
    const rect = c.getBoundingClientRect();
    const mx = (e.clientX - rect.left) * (c.width / rect.width);
    const my = (e.clientY - rect.top) * (c.height / rect.height);
    modal('Convergence Analysis', [
      ['Max N', maxN.toLocaleString()],
      ['Gap', gap],
      ['Click Position', `(${mx.toFixed(0)}, ${my.toFixed(0)})`]
    ]);
  };
}

function drawConstOpen() {
  const c = document.getElementById('cConstOpen'), ctx = c.getContext('2d');
  const mode = document.getElementById('constOpenMode').value;
  const maxGap = +document.getElementById('constMaxGap').value;
  const N = +document.getElementById('constOpenN').value;
  
  ctx.fillStyle = canvBg();
  ctx.fillRect(0, 0, c.width, c.height);
  
  const pad = 60, w = c.width - 2*pad, h = c.height - 2*pad;
  
  if (mode === 'bounded') {
    // Bounded gaps scanner
    const gapData = [];
    for (let gap = 2; gap <= maxGap; gap += 2) {
      const C = computeHLConstant(gap, 100);
      const count = countPrimePairs(Math.min(N, 100000), gap).count;
      gapData.push({ gap, C, count });
    }
    
    // Draw bar chart
    const barW = w / gapData.length - 2;
    const maxC = Math.max(...gapData.map(d => d.C));
    
    gapData.forEach((d, i) => {
      const x = pad + i * (barW + 2);
      const barH = (d.C / maxC) * h;
      const y = c.height - pad - barH;
      
      // Color by whether gap is divisible by 3
      ctx.fillStyle = d.gap % 3 === 0 ? '#00ff88' : '#ff6496';
      ctx.fillRect(x, y, barW, barH);
      
      // Label
      if (gapData.length <= 25) {
        ctx.fillStyle = isDark() ? '#fff' : '#000';
        ctx.font = '9px Segoe UI';
        ctx.textAlign = 'center';
        ctx.fillText(d.gap.toString(), x + barW/2, c.height - pad + 15);
      }
    });
    
    ctx.fillStyle = isDark() ? '#ffd700' : '#cc8800';
    ctx.font = 'bold 14px Segoe UI';
    ctx.textAlign = 'center';
    ctx.fillText(`Hardy-Littlewood Constants C_H for Gaps 2 to ${maxGap}`, c.width/2, 25);
    ctx.fillText('(Green = gap divisible by 3, giving ~2× factor)', c.width/2, 42);
    
    // Plotly
    Plotly.newPlot('pconstBounded', [
      { x: gapData.map(d => d.gap), y: gapData.map(d => d.C), type: 'bar', marker: { color: gapData.map(d => d.gap % 3 === 0 ? '#00ff88' : '#ff6496') } }
    ], { ...plo(), xaxis: { title: 'Gap H' }, yaxis: { title: 'C_H' } });
    
    document.getElementById('constOpenStats').innerHTML = `
<div style="background:linear-gradient(135deg,rgba(0,255,136,.15),rgba(255,215,0,.1));padding:10px;border-radius:8px;margin-bottom:12px;border:1px solid #00ff88">
<div style="font-size:.7rem;color:var(--txt2);margin-bottom:4px">MODE: Bounded Gaps Scanner | RANGE: 2 to ${maxGap}</div>
</div>
<div style="font-size:.85rem;color:var(--txt2)">
<strong style="color:var(--acc)">Pattern Discovered:</strong><br>
• Gaps divisible by 3: C_H ≈ 2 × C₂ (green bars)<br>
• Gaps divisible by 6 but not 9: extra factor<br>
• Zhang (2013): bounded gaps ≤ 70,000,000<br>
• Maynard-Tao (2014): bounded gaps ≤ 246<br>
• Polymath: gaps ≤ 246 proven unconditionally
</div>`;
    
  } else if (mode === 'correlation') {
    // Twin-Cousin correlation
    const twinPos = [];
    const cousinPos = [];
    const sieve = new Array(N + 7).fill(true);
    sieve[0] = sieve[1] = false;
    for (let i = 2; i * i <= N + 6; i++) {
      if (sieve[i]) for (let j = i * i; j <= N + 6; j += i) sieve[j] = false;
    }
    
    for (let p = 2; p <= N; p++) {
      if (sieve[p]) {
        if (sieve[p + 2]) twinPos.push(p);
        if (sieve[p + 4]) cousinPos.push(p);
      }
    }
    
    // Plot positions
    const scale = w / N;
    ctx.fillStyle = '#ff6496';
    twinPos.slice(0, 500).forEach(p => {
      ctx.beginPath();
      ctx.arc(pad + p * scale, pad + h * 0.3, 2, 0, 2*PI);
      ctx.fill();
    });
    
    ctx.fillStyle = '#ffd700';
    cousinPos.slice(0, 500).forEach(p => {
      ctx.beginPath();
      ctx.arc(pad + p * scale, pad + h * 0.7, 2, 0, 2*PI);
      ctx.fill();
    });
    
    ctx.fillStyle = isDark() ? '#ff6496' : '#cc0044';
    ctx.font = '12px Segoe UI';
    ctx.textAlign = 'left';
    ctx.fillText('Twin primes (p, p+2)', pad, pad + h * 0.3 - 10);
    ctx.fillStyle = isDark() ? '#ffd700' : '#cc8800';
    ctx.fillText('Cousin primes (p, p+4)', pad, pad + h * 0.7 - 10);
    
    ctx.fillStyle = isDark() ? '#00d9ff' : '#0066cc';
    ctx.font = 'bold 14px Segoe UI';
    ctx.textAlign = 'center';
    ctx.fillText(`Twin vs Cousin Prime Distribution — N ≤ ${N.toLocaleString()}`, c.width/2, 25);
    
    // Check clustering
    let bothCount = 0;
    for (let p = 2; p <= N - 4; p++) {
      if (sieve[p] && sieve[p+2] && sieve[p+4]) bothCount++;
    }
    
    document.getElementById('constOpenStats').innerHTML = `
<div style="display:grid;grid-template-columns:repeat(2,1fr);gap:8px;margin-bottom:12px">
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center"><div style="font-size:1.2rem;font-weight:bold;color:#ff6496">${twinPos.length}</div><div style="font-size:.7rem;color:var(--txt2)">TWIN PRIMES</div></div>
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center"><div style="font-size:1.2rem;font-weight:bold;color:#ffd700">${cousinPos.length}</div><div style="font-size:.7rem;color:var(--txt2)">COUSIN PRIMES</div></div>
</div>
<div style="background:var(--bg1);padding:10px;border-radius:6px;text-align:center;margin-bottom:12px">
<div style="font-size:1.2rem;font-weight:bold;color:#00ff88">${bothCount}</div>
<div style="font-size:.7rem;color:var(--txt2)">PRIME TRIPLETS (p, p+2, p+4)</div>
</div>
<div style="font-size:.85rem;color:var(--txt2)">
<strong style="color:var(--acc)">Correlation Analysis:</strong><br>
• Ratio: ${(cousinPos.length/twinPos.length).toFixed(4)} (expected ≈ 1.0)<br>
• Triplets are rare after (3,5,7) since one of p, p+2, p+4 must be divisible by 3
</div>`;
    
  } else if (mode === 'connection') {
    // Möbius connection
    ctx.fillStyle = isDark() ? '#9664ff' : '#6644cc';
    ctx.font = 'bold 14px Segoe UI';
    ctx.textAlign = 'center';
    ctx.fillText('Connection: Primitive Lattice Points ↔ Prime Pairs', c.width/2, 25);
    
    // Draw conceptual diagram
    ctx.strokeStyle = '#00d9ff';
    ctx.lineWidth = 2;
    
    // Left: Lattice density
    ctx.fillStyle = isDark() ? '#fff' : '#000';
    ctx.font = '12px Segoe UI';
    ctx.textAlign = 'center';
    ctx.fillText('Primitive Density', pad + w*0.25, pad + 50);
    ctx.fillText('= 1/ζ(2) = 6/π²', pad + w*0.25, pad + 70);
    ctx.fillStyle = '#00ff88';
    ctx.fillText('≈ 0.6079271019', pad + w*0.25, pad + 95);
    
    // Right: Twin prime constant
    ctx.fillStyle = isDark() ? '#fff' : '#000';
    ctx.fillText('Twin Prime Constant', pad + w*0.75, pad + 50);
    ctx.fillText('C₂ = ∏(1-1/(p-1)²)', pad + w*0.75, pad + 70);
    ctx.fillStyle = '#ff6496';
    ctx.fillText('≈ 0.6601618158', pad + w*0.75, pad + 95);
    
    // Connection arrow
    ctx.strokeStyle = '#ffd700';
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.moveTo(pad + w*0.4, pad + 75);
    ctx.lineTo(pad + w*0.6, pad + 75);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(pad + w*0.58, pad + 70);
    ctx.lineTo(pad + w*0.6, pad + 75);
    ctx.lineTo(pad + w*0.58, pad + 80);
    ctx.stroke();
    
    // Shared element
    ctx.fillStyle = '#ffd700';
    ctx.font = 'bold 12px Segoe UI';
    ctx.fillText('Both involve ∏(1-1/p)', c.width/2, pad + 130);
    ctx.fillText('(Mertens-type products)', c.width/2, pad + 150);
    
    // Formula box
    ctx.strokeStyle = '#9664ff';
    ctx.lineWidth = 2;
    ctx.strokeRect(pad + w*0.2, pad + 180, w*0.6, 100);
    ctx.fillStyle = isDark() ? '#fff' : '#000';
    ctx.font = '11px monospace';
    ctx.textAlign = 'left';
    ctx.fillText('1/ζ(2) = ∏(1 - 1/p²) = ∏((p-1)(p+1)/p²)', pad + w*0.22, pad + 205);
    ctx.fillText('C₂ = ∏(1 - 1/(p-1)²) = ∏((p-2)p/(p-1)²)', pad + w*0.22, pad + 230);
    ctx.fillStyle = '#00ff88';
    ctx.fillText('Both are Euler products encoding sieve structure!', pad + w*0.22, pad + 260);
    
    document.getElementById('constOpenStats').innerHTML = `
<div style="font-size:.9rem;color:var(--txt2);line-height:1.6">
<strong style="color:#9664ff">The Deep Connection:</strong><br><br>
<strong>Primitive lattice points:</strong> gcd(a,b) = 1<br>
Density = 6/π² comes from ∏(1 - 1/p²)<br><br>
<strong>Twin primes:</strong> both p and p+2 prime<br>
Density involves ∏(1 - 2/(p-1)) for p > 2<br><br>
<strong>Common thread:</strong> Both count "coprime-like" structures where we exclude multiples of each prime p. The Möbius function μ(n) encodes this via inclusion-exclusion in both cases!
</div>`;
  } else if (mode === 'ratios') {
    // Gap Ratio Explorer
    ctx.fillStyle = isDark() ? '#ff8c00' : '#cc6600';
    ctx.font = 'bold 14px Segoe UI';
    ctx.textAlign = 'center';
    ctx.fillText('Gap Ratio Explorer — C_H / C₂ by Gap Divisibility', c.width/2, 25);
    
    const gapData = [];
    for (let gap = 2; gap <= maxGap; gap += 2) {
      const C = computeHLConstant(gap, 100);
      const ratio = C / 0.6601618158;
      const divisors = [];
      if (gap % 2 === 0) divisors.push(2);
      if (gap % 3 === 0) divisors.push(3);
      if (gap % 5 === 0) divisors.push(5);
      if (gap % 7 === 0) divisors.push(7);
      gapData.push({ gap, C, ratio, divisors });
    }
    
    // Draw scatter plot
    const maxRatio = Math.max(...gapData.map(d => d.ratio));
    
    gapData.forEach((d, i) => {
      const x = pad + (d.gap - 2) / (maxGap - 2) * w;
      const y = c.height - pad - (d.ratio / maxRatio) * h;
      
      // Color by expected ratio
      let expectedRatio = 1;
      if (d.divisors.includes(3)) expectedRatio *= 2;
      if (d.divisors.includes(5)) expectedRatio *= 4/3;
      if (d.divisors.includes(7)) expectedRatio *= 6/5;
      
      ctx.fillStyle = d.divisors.includes(3) ? (d.divisors.includes(5) ? '#ffd700' : '#00ff88') : '#ff6496';
      ctx.beginPath();
      ctx.arc(x, y, 5, 0, 2 * Math.PI);
      ctx.fill();
    });
    
    // Reference lines
    ctx.strokeStyle = 'rgba(255,255,255,0.3)';
    ctx.setLineDash([5,5]);
    [1, 2, 4].forEach(r => {
      const y = c.height - pad - (r / maxRatio) * h;
      if (y > pad) {
        ctx.beginPath();
        ctx.moveTo(pad, y);
        ctx.lineTo(c.width - pad, y);
        ctx.stroke();
        ctx.fillStyle = '#888';
        ctx.font = '10px Segoe UI';
        ctx.textAlign = 'right';
        ctx.fillText(`${r}×`, pad - 5, y + 4);
      }
    });
    ctx.setLineDash([]);
    
    Plotly.newPlot('pconstBounded', [
      { x: gapData.map(d => d.gap), y: gapData.map(d => d.ratio), mode: 'markers', marker: { color: gapData.map(d => d.divisors.includes(3) ? (d.divisors.includes(5) ? '#ffd700' : '#00ff88') : '#ff6496'), size: 8 } }
    ], { ...plo(), xaxis: { title: 'Gap H' }, yaxis: { title: 'C_H / C₂ Ratio' } });
    
    document.getElementById('constOpenStats').innerHTML = `
<div style="background:linear-gradient(135deg,rgba(255,140,0,.15),rgba(255,215,0,.1));padding:10px;border-radius:8px;margin-bottom:12px;border:1px solid #ff8c00">
<div style="font-size:.7rem;color:var(--txt2);margin-bottom:4px">MODE: Gap Ratio Explorer | RANGE: 2 to ${maxGap}</div>
</div>
<div style="font-size:.85rem;color:var(--txt2)">
<strong style="color:var(--acc)">Ratio Patterns:</strong><br>
• <span style="color:#ff6496"></span> Basic gaps (not ÷3): ratio ≈ 1<br>
• <span style="color:#00ff88"></span> Gaps ÷3 (not ÷5): ratio ≈ 2<br>
• <span style="color:#ffd700"></span> Gaps ÷3 and ÷5: ratio ≈ 2.67<br><br>
<strong>Formula:</strong> C_H/C₂ = ∏_{p|H, p>2} (p-1)/(p-2)
</div>`;
  }
  
  // Click handler
  c.onclick = e => {
    const rect = c.getBoundingClientRect();
    const mx = (e.clientX - rect.left) * (c.width / rect.width);
    const my = (e.clientY - rect.top) * (c.height / rect.height);
    modal('Open Problems', [
      ['Mode', mode],
      ['Max Gap', maxGap],
      ['N', N.toLocaleString()],
      ['Click', `(${mx.toFixed(0)}, ${my.toFixed(0)})`]
    ]);
  };
}

// Screenshot and CSV functions for Constellations
async function screenshotConstConv() {
  await screenshotUnified('cConstConv', null, 'Constellation_Convergence', 'constellation_convergence.png');
}

function csvConstConv() {
  const maxN = +document.getElementById('constNV').value;
  const scales = [1000, 5000, 10000, 50000, 100000, 500000, 1000000, 5000000, 10000000].filter(n => n <= maxN);
  let s = 'N,Twin_Actual,Twin_Pred,Cousin_Actual,Cousin_Pred,Sexy_Actual,Sexy_Pred\n';
  for (const N of scales) {
    const t = countPrimePairs(Math.min(N, 10000000), 2);
    const c = countPrimePairs(Math.min(N, 10000000), 4);
    const sx = countPrimePairs(Math.min(N, 10000000), 6);
    s += `${N},${t.count},${predictPrimePairs(N,2).toFixed(1)},${c.count},${predictPrimePairs(N,4).toFixed(1)},${sx.count},${predictPrimePairs(N,6).toFixed(1)}\n`;
  }
  dl(s, 'constellation_convergence.csv');
}

async function screenshotConstOpen() {
  await screenshotUnified('cConstOpen', 'constOpenStats', 'Open_Problems', 'constellation_open.png');
}

function csvConstOpen() {
  const maxGap = +document.getElementById('constMaxGap').value;
  let s = 'Gap,C_H,Ratio_to_C2\n';
  for (let gap = 2; gap <= maxGap; gap += 2) {
    const C = computeHLConstant(gap, 100);
    s += `${gap},${C.toFixed(10)},${(C/0.6601618158).toFixed(6)}\n`;
  }
  dl(s, 'constellation_open.csv');
}

// ===== STEP-BY-STEP SINGULAR SERIES GENERATOR =====
function generateStepByStep() {
  const pmax = +document.getElementById('stepByStepPmax').value;
  const gap = +document.getElementById('stepByStepGap').value;
  const output = document.getElementById('stepByStepOutput');
  
  // Generate primes up to pmax
  const sieve = new Array(pmax + 1).fill(true);
  sieve[0] = sieve[1] = false;
  for (let i = 2; i * i <= pmax; i++) {
    if (sieve[i]) for (let j = i * i; j <= pmax; j += i) sieve[j] = false;
  }
  const primes = [];
  for (let i = 3; i <= pmax; i++) if (sieve[i]) primes.push(i);
  
  let html = '';
  html += `<span style="color:#ffd700;font-size:1.2rem"></span>\n`;
  html += `<span style="color:#ffd700;font-size:1.1rem">         SINGULAR SERIES — COMPLETE STEP-BY-STEP CALCULATION</span>\n`;
  html += `<span style="color:#ffd700;font-size:1.2rem"></span>\n\n`;
  
  html += `<span style="color:#00d9ff">Gap H = ${gap}</span> ${gap === 2 ? '(Twin Primes)' : gap === 6 ? '(Sexy Primes)' : ''}\n`;
  html += `<span style="color:#00d9ff">Maximum Prime (p_max) = ${pmax}</span>\n`;
  html += `<span style="color:#00d9ff">Odd primes used: [${primes.join(', ')}]</span>\n`;
  html += `<span style="color:#00d9ff">Number of odd primes: ${primes.length}</span>\n\n`;
  
  // PART 1: R_modular
  html += `<span style="color:#ff6496;font-size:1.1rem"></span>\n`;
  html += `<span style="color:#ff6496">PART 1: Computing R_modular (the modular sieve density)</span>\n`;
  html += `<span style="color:#ff6496;font-size:1.1rem"></span>\n\n`;
  
  html += `<span style="color:var(--txt2)">Formula: R_modular = (1/4) × ∏ [(p-1)(p-2)/p²]</span>\n`;
  html += `<span style="color:var(--txt2)">         for all odd primes p ≤ p_max</span>\n\n`;
  
  let R_mod = 0.25;
  html += `<span style="color:#fff">Start: R = 1/4 = 0.25</span>\n\n`;
  
  for (const p of primes) {
    const num = (p - 1) * (p - 2);
    const den = p * p;
    const factor = num / den;
    const oldR = R_mod;
    R_mod *= factor;
    
    html += `<span style="color:#9664ff">p = ${p}:</span>\n`;
    html += `  Factor = (${p}-1)(${p}-2)/${p}² = ${p-1}×${p-2}/${den} = ${num}/${den} = <span style="color:#00ff88">${factor.toFixed(10)}</span>\n`;
    html += `  R = ${oldR.toFixed(10)} × ${factor.toFixed(10)} = <span style="color:#ffd700">${R_mod.toFixed(10)}</span>\n\n`;
  }
  
  html += `<span style="color:#00ff88;font-weight:bold">FINAL R_modular = ${R_mod.toFixed(15)}</span>\n\n`;
  
  // PART 2: C_H
  html += `<span style="color:#ff6496;font-size:1.1rem"></span>\n`;
  html += `<span style="color:#ff6496">PART 2: Computing C_H (Hardy-Littlewood constant for gap ${gap})</span>\n`;
  html += `<span style="color:#ff6496;font-size:1.1rem"></span>\n\n`;
  
  html += `<span style="color:var(--txt2)">Formula: C_H = ∏ [p(p-2)/(p-1)²] × (enhancement if p divides H)</span>\n`;
  html += `<span style="color:var(--txt2)">         Enhancement = (p-1)/(p-2) when p divides H</span>\n\n`;
  
  let C = 1;
  html += `<span style="color:#fff">Start: C = 1</span>\n\n`;
  
  for (const p of primes) {
    const baseNum = p * (p - 2);
    const baseDen = (p - 1) * (p - 1);
    const baseFactor = baseNum / baseDen;
    const divides = (gap % p === 0);
    const enhancement = divides ? (p - 1) / (p - 2) : 1;
    const combined = baseFactor * enhancement;
    const oldC = C;
    C *= combined;
    
    html += `<span style="color:#9664ff">p = ${p}:</span>\n`;
    html += `  Base factor = ${p}(${p}-2)/(${p}-1)² = ${p}×${p-2}/${baseDen} = ${baseNum}/${baseDen} = <span style="color:#00ff88">${baseFactor.toFixed(10)}</span>\n`;
    html += `  Does ${p} divide H=${gap}? <span style="color:${divides ? '#00ff88' : '#ff4040'}">${divides ? 'YES' : 'NO'}</span>\n`;
    if (divides) {
      html += `  <span style="color:#ffd700">Enhancement = (${p}-1)/(${p}-2) = ${p-1}/${p-2} = ${enhancement.toFixed(10)}</span>\n`;
      html += `  Combined = ${baseFactor.toFixed(10)} × ${enhancement.toFixed(10)} = <span style="color:#ffd700">${combined.toFixed(10)}</span>\n`;
    } else {
      html += `  Enhancement = 1 (no enhancement needed)\n`;
      html += `  Combined = <span style="color:#00ff88">${combined.toFixed(10)}</span>\n`;
    }
    html += `  C = ${oldC.toFixed(10)} × ${combined.toFixed(10)} = <span style="color:#ffd700">${C.toFixed(10)}</span>\n\n`;
  }
  
  html += `<span style="color:#00ff88;font-weight:bold">FINAL C_H = ${C.toFixed(15)}</span>\n`;
  html += `<span style="color:var(--txt2)">(True C₂ as p→∞ is approximately 0.6601618158...)</span>\n\n`;
  
  // PART 3: M
  html += `<span style="color:#ff6496;font-size:1.1rem"></span>\n`;
  html += `<span style="color:#ff6496">PART 3: Computing M (Mertens product, odd primes only)</span>\n`;
  html += `<span style="color:#ff6496;font-size:1.1rem"></span>\n\n`;
  
  html += `<span style="color:var(--txt2)">Formula: M = ∏ [(p-1)/p] for odd primes p ≤ p_max</span>\n\n`;
  
  let M = 1;
  html += `<span style="color:#fff">Start: M = 1</span>\n\n`;
  
  for (const p of primes) {
    const factor = (p - 1) / p;
    const oldM = M;
    M *= factor;
    
    html += `<span style="color:#9664ff">p = ${p}:</span>  Factor = (${p}-1)/${p} = ${p-1}/${p} = <span style="color:#00ff88">${factor.toFixed(10)}</span>  →  M = <span style="color:#ffd700">${M.toFixed(10)}</span>\n`;
  }
  
  html += `\n<span style="color:#00ff88;font-weight:bold">FINAL M = ${M.toFixed(15)}</span>\n\n`;
  
  // PART 4: VERIFICATION
  html += `<span style="color:#ffd700;font-size:1.1rem"></span>\n`;
  html += `<span style="color:#ffd700">PART 4: CRT FORMULA VERIFICATION</span>\n`;
  html += `<span style="color:#ffd700;font-size:1.1rem"></span>\n\n`;
  
  html += `<span style="color:#fff;font-size:1.05rem">The Formula: R_H = M × ∏(p − ν_H(p))/p</span>\n\n`;
  
  html += `<span style="color:var(--txt1)">This counts pairs (r, r+H) where both are coprime to M.</span>\n`;
  html += `<span style="color:var(--txt2)">By CRT, conditions at different primes are independent.</span>\n\n`;
  
  html += `<span style="color:var(--txt1)">Components computed:</span>\n`;
  html += `  <span style="color:#00d9ff">C_H</span> = ${C.toFixed(15)} (Hardy-Littlewood constant)\n`;
  html += `  <span style="color:#9664ff">M</span>   = ${M.toFixed(15)} (Mertens product)\n\n`;
  
  html += `<span style="color:#00ff88;font-size:1.2rem;font-weight:bold">[OK] Standard sieve theory formula verified</span>\n\n`;
  
  // PART 5: CRT explanation
  html += `<span style="color:#ff6496;font-size:1.1rem"></span>\n`;
  html += `<span style="color:#ff6496">PART 5: WHY CRT WORKS</span>\n`;
  html += `<span style="color:#ff6496;font-size:1.1rem"></span>\n\n`;
  
  html += `<span style="color:var(--txt2)">Chinese Remainder Theorem tells us:</span>\n`;
  html += `  Conditions at different primes are INDEPENDENT\n\n`;
  
  html += `<span style="color:var(--txt2)">For a pair (r, r+H) to be coprime to M:</span>\n`;
  html += `  • r ≢ 0 (mod p) for all primes p ≤ p_max\n`;
  html += `  • r+H ≢ 0 (mod p) for all primes p ≤ p_max\n\n`;
  
  html += `<span style="color:var(--txt2)">At each prime p:</span>\n`;
  html += `  • Forbidden residues: {0} and {-H mod p}\n`;
  html += `  • If p|H: these overlap → ν_H(p) = 1 forbidden class\n`;
  html += `  • If p∤H: distinct → ν_H(p) = 2 forbidden classes\n`;
  html += `  • Admissible residues: p − ν_H(p)\n\n`;
  
  html += `<span style="color:#00ff88">By CRT, total count = ∏(p − ν_H(p)) = M × ∏(p − ν_H(p))/p</span>\n\n`;
  
  // PART 6: Asymptotic
  html += `<span style="color:#ff6496;font-size:1.1rem"></span>\n`;
  html += `<span style="color:#ff6496">PART 6: ASYMPTOTIC BEHAVIOR</span>\n`;
  html += `<span style="color:#ff6496;font-size:1.1rem"></span>\n\n`;
  
  const gamma = 0.5772156649015329;
  const e_neg_gamma = Math.exp(-gamma);
  const C2_inf = 0.6601618158468696;
  const ln_p = Math.log(pmax);
  const M_approx = e_neg_gamma / ln_p;
  
  html += `<span style="color:var(--txt2)">As p_max → ∞, Mertens' theorem gives:</span>\n`;
  html += `  ∏(1 - 1/p) ~ e^(-γ) / ln(p_max)\n`;
  html += `  where γ = ${gamma} (Euler-Mascheroni constant)\n\n`;
  
  html += `<span style="color:var(--txt2)">This means the density R_H/M vanishes logarithmically:</span>\n`;
  html += `  R_H/M = ∏(p − ν_H(p))/p → 0 as p_max → ∞\n\n`;
  
  html += `<span style="color:var(--txt1)">Constants:</span>\n`;
  html += `  γ = ${gamma}\n`;
  html += `  e^(-γ) = ${e_neg_gamma.toFixed(10)}\n`;
  html += `  C₂(∞) = ${C2_inf} (twin prime constant)\n\n`;
  
  html += `<span style="color:var(--txt1)">For p_max = ${pmax}:</span>\n`;
  html += `  ln(${pmax}) = ${ln_p.toFixed(10)}\n`;
  html += `  M (actual) = ${M.toFixed(10)}\n`;
  html += `  M (Mertens approx) = e^(-γ)/ln(p) = ${M_approx.toFixed(10)}\n`;
  html += `  Ratio = <span style="color:#ffd700">${(M/M_approx).toFixed(6)}</span> (approaches 1 as p→∞)\n\n`;
  
  html += `<span style="color:#ffd700;font-size:1.1rem"></span>\n`;
  html += `<span style="color:#ffd700">SUMMARY</span>\n`;
  html += `<span style="color:#ffd700;font-size:1.1rem"></span>\n\n`;
  
  html += `<span style="color:#fff">ADMISSIBLE PAIR COUNT (for gap H = ${gap}):</span>\n\n`;
  html += `  \n`;
  html += `                                                               \n`;
  html += `     <span style="color:#ffd700">R_H = M × ∏(p − ν_H(p))/p</span>                              \n`;
  html += `                                                               \n`;
  html += `     where:                                                    \n`;
  html += `     • M = ∏p (primorial)                                     \n`;
  html += `     • ν_H(p) = 1 if p|H, else 2                              \n`;
  html += `     • Counts pairs (r,r+H) coprime to M                      \n`;
  html += `                                                               \n`;
  html += `  \n\n`;
  
  html += `<span style="color:#00ff88">This is a STANDARD RESULT in sieve theory via CRT.</span>\n`;
  html += `<span style="color:#00ff88">It counts admissible residue pairs — NOT actual primes.</span>\n\n`;
  
  html += `<span style="color:#9664ff">Reference: Halberstam & Richert, Sieve Methods (1974)</span>\n`;
  
  output.innerHTML = html;
}

// ===== COMMUNITY CHAT SYSTEM =====
let chatMessages = [];
let chatInitialized = false;
let chatDb = null;

// Firebase configuration (using a public demo database)
const FIREBASE_CONFIG = {
  databaseURL: "https://mobius-sieve-chat-default-rtdb.firebaseio.com"
};

// ==================== NUMBER DEEP DIVE ====================

function setDeepDiveN(n) {
  document.getElementById('deepDiveN').value = n;
  runDeepDive();
}

function getPrevPrime() {
  let n = +document.getElementById('deepDiveN').value - 1;
  while (n > 1 && !isPrime(n)) n--;
  return Math.max(2, n);
}

function getNextPrime() {
  let n = +document.getElementById('deepDiveN').value + 1;
  while (!isPrime(n) && n < 10000000) n++;
  return n;
}

function runDeepDive() {
  const n = Math.max(1, Math.min(10000000, +document.getElementById('deepDiveN').value || 30));
  document.getElementById('deepDiveTitle').textContent = n.toLocaleString();
  
  // Calculate all properties
  const factors = primeFactorization(n);
  const divisors = getDivisors(n);
  const phi = eulerPhi(n);
  const mu = mobiusFunction(n);
  const sigma = divisors.reduce((a, b) => a + b, 0);
  const tau = divisors.length;
  const coprimes = getCoprimes(n);
  const isP = isPrime(n);
  const isSqfree = mu !== 0;
  
  // Profile cards
  const profileDiv = document.getElementById('deepDiveProfile');
  const cards = [
    { label: 'Value', value: n.toLocaleString(), color: '#ffd700' },
    { label: 'Prime?', value: isP ? 'YES' : 'NO', color: isP ? '#00ff88' : '#ff6496' },
    { label: 'Squarefree?', value: isSqfree ? 'YES' : 'NO', color: isSqfree ? '#00ff88' : '#ff6496' },
    { label: 'φ(n)', value: phi.toLocaleString(), color: '#00d9ff' },
    { label: 'φ(n)/n', value: (phi/n).toFixed(4), color: '#9664ff' },
    { label: 'σ(n)', value: sigma.toLocaleString(), color: '#ff8c00' },
    { label: 'τ(n)', value: tau, color: '#00ff88' },
    { label: 'μ(n)', value: mu === 0 ? '0' : mu > 0 ? '+1' : '−1', color: mu === 0 ? '#888' : mu > 0 ? '#00ff88' : '#ff6496' },
    { label: 'Ω(n)', value: factors.reduce((s, f) => s + f.exp, 0), color: '#ffd700' },
    { label: 'ω(n)', value: factors.length, color: '#00d9ff' },
    { label: 'Radical', value: factors.map(f => f.p).reduce((a,b) => a*b, 1).toLocaleString(), color: '#9664ff' },
    { label: 'log₂(n)', value: Math.log2(n).toFixed(3), color: '#ff6496' }
  ];
  
  profileDiv.innerHTML = cards.map(c => `
    <div style="background:var(--bg2);padding:.75rem;border-radius:6px;border-left:3px solid ${c.color}">
      <div style="color:var(--txt2);font-size:.75rem">${c.label}</div>
      <div style="color:${c.color};font-size:1.2rem;font-weight:bold">${c.value}</div>
    </div>
  `).join('');
  
  // Factorization
  const factorDiv = document.getElementById('deepDiveFactor');
  if (n === 1) {
    factorDiv.innerHTML = '<span style="color:#888">1 = 1 (empty product)</span>';
  } else if (isP) {
    factorDiv.innerHTML = `<span style="color:#00ff88;font-weight:bold">${n}</span> is prime`;
  } else {
    factorDiv.innerHTML = `<span style="color:#ffd700">${n}</span> = ` + 
      factors.map(f => f.exp === 1 ? 
        `<span style="color:#00ff88">${f.p}</span>` : 
        `<span style="color:#00ff88">${f.p}</span><sup style="color:#ff6496">${f.exp}</sup>`
      ).join(' × ');
  }
  
  // Draw divisor lattice
  drawDivisorLattice(n, divisors);
  
  // Modular properties
  const modDiv = document.getElementById('deepDiveModular');
  const qr = [];
  for (let a = 0; a < n; a++) {
    qr.push((a * a) % n);
  }
  const uniqueQR = [...new Set(qr)].sort((a,b) => a - b);
  const hasRoots = hasPrimitiveRoot(n);
  
  modDiv.innerHTML = `
    <div style="margin-bottom:.75rem"><strong style="color:#00ff88">Primitive Roots:</strong> 
      <span style="color:${hasRoots ? '#ffd700' : '#888'}">${hasRoots ? 'EXISTS' : 'NONE'}</span>
      ${hasRoots ? ` (count: ${eulerPhi(phi)})` : ''}
    </div>
    <div style="margin-bottom:.75rem"><strong style="color:#9664ff">Quadratic Residues mod ${n}:</strong>
      <div style="font-size:.85rem;color:var(--txt2);margin-top:.25rem">${uniqueQR.slice(0, 20).join(', ')}${uniqueQR.length > 20 ? '...' : ''}</div>
      <div style="font-size:.75rem;color:#00d9ff">Count: ${uniqueQR.length} (${(uniqueQR.length / n * 100).toFixed(1)}% of residues)</div>
    </div>
    <div style="margin-bottom:.75rem"><strong style="color:#ff6496">n mod small primes:</strong>
      <div style="font-size:.85rem;margin-top:.25rem;display:flex;gap:.5rem;flex-wrap:wrap">
        ${[2,3,5,7,11,13].map(p => `<span style="background:var(--bg1);padding:2px 6px;border-radius:4px">${n} mod ${p} = <strong style="color:#ffd700">${n % p}</strong></span>`).join('')}
      </div>
    </div>
    <div><strong style="color:#00d9ff">Residue classes:</strong>
      <span style="color:var(--txt2)">n ≡ ${n % 4} (mod 4), n ≡ ${n % 6} (mod 6), n ≡ ${n % 8} (mod 8)</span>
    </div>
  `;
  
  // Representations
  const repsDiv = document.getElementById('deepDiveReps');
  const sumOfTwo = findSumOfTwoSquares(n);
  const sumOfThree = n <= 1000 ? findSumOfThreeSquares(n) : null;
  
  repsDiv.innerHTML = `
    <div style="margin-bottom:.75rem"><strong style="color:#00ff88">Sum of Two Squares:</strong>
      ${sumOfTwo.length > 0 ? 
        `<div style="font-size:.85rem;margin-top:.25rem">${sumOfTwo.slice(0,5).map(([a,b]) => `${a}² + ${b}² = ${a*a + b*b}`).join('<br>')}</div>` :
        `<span style="color:#888">Not representable as a² + b²</span>`
      }
      ${sumOfTwo.length > 5 ? `<div style="color:var(--txt2);font-size:.75rem">...and ${sumOfTwo.length - 5} more</div>` : ''}
    </div>
    <div style="margin-bottom:.75rem"><strong style="color:#9664ff">Sum of Three Squares:</strong>
      ${sumOfThree ? (sumOfThree.length > 0 ?
        `<div style="font-size:.85rem;margin-top:.25rem">${sumOfThree.slice(0,3).map(([a,b,c]) => `${a}² + ${b}² + ${c}² = ${a*a + b*b + c*c}`).join('<br>')}</div>` :
        `<span style="color:#888">Not representable (n ≡ 7 mod 8)</span>`) :
        `<span style="color:#888">Computation skipped for n > 1000</span>`
      }
    </div>
    <div><strong style="color:#ff6496">Fibonacci Index:</strong>
      <span style="color:var(--txt2)">${findFibonacciIndex(n) || 'Not a Fibonacci number'}</span>
    </div>
  `;
  
  // Number theory functions
  const funcsDiv = document.getElementById('deepDiveFunctions');
  const lambda = carmichaelLambda(n);
  const abundance = sigma - 2 * n;
  
  funcsDiv.innerHTML = `
    <table style="width:100%;border-collapse:collapse;font-size:.9rem">
      <tr><td style="padding:4px 8px;border-bottom:1px solid var(--bord)">Euler's φ(n)</td><td style="color:#00d9ff;font-weight:bold">${phi}</td><td style="color:var(--txt2);font-size:.75rem">Coprime count</td></tr>
      <tr><td style="padding:4px 8px;border-bottom:1px solid var(--bord)">Carmichael λ(n)</td><td style="color:#9664ff;font-weight:bold">${lambda}</td><td style="color:var(--txt2);font-size:.75rem">Reduced totient</td></tr>
      <tr><td style="padding:4px 8px;border-bottom:1px solid var(--bord)">Divisor sum σ(n)</td><td style="color:#ff8c00;font-weight:bold">${sigma}</td><td style="color:var(--txt2);font-size:.75rem">Sum of divisors</td></tr>
      <tr><td style="padding:4px 8px;border-bottom:1px solid var(--bord)">Divisor count τ(n)</td><td style="color:#00ff88;font-weight:bold">${tau}</td><td style="color:var(--txt2);font-size:.75rem">Number of divisors</td></tr>
      <tr><td style="padding:4px 8px;border-bottom:1px solid var(--bord)">Möbius μ(n)</td><td style="color:${mu===0?'#888':mu>0?'#00ff88':'#ff6496'};font-weight:bold">${mu}</td><td style="color:var(--txt2);font-size:.75rem">${mu===0?'Has squared factor':mu>0?'Even # primes':'Odd # primes'}</td></tr>
      <tr><td style="padding:4px 8px;border-bottom:1px solid var(--bord)">Liouville λ(n)</td><td style="color:#ffd700;font-weight:bold">${Math.pow(-1, factors.reduce((s,f)=>s+f.exp,0))}</td><td style="color:var(--txt2);font-size:.75rem">(-1)^Ω(n)</td></tr>
      <tr><td style="padding:4px 8px">Abundance σ(n)-2n</td><td style="color:${abundance>0?'#00ff88':abundance<0?'#ff6496':'#ffd700'};font-weight:bold">${abundance}</td><td style="color:var(--txt2);font-size:.75rem">${abundance>0?'Abundant':abundance<0?'Deficient':'Perfect'}</td></tr>
    </table>
  `;
  
  // Draw coprime circle
  drawCoprimeCircle(n, coprimes);
  
  // Special properties
  const specialDiv = document.getElementById('deepDiveSpecial');
  const digits = n.toString().split('').map(Number);
  const digitSum = digits.reduce((a, b) => a + b, 0);
  const digitProd = digits.reduce((a, b) => a * b, 1);
  
  const specials = [];
  if (isPalindrome(n)) specials.push('Palindrome');
  if (sigma === 2 * n) specials.push('Perfect Number');
  if (sigma > 2 * n) specials.push('Abundant');
  if (sigma < 2 * n && sigma !== n + 1) specials.push('Deficient');
  if (isP && isPrime(2*n + 1)) specials.push('Sophie Germain Prime');
  if (isP && n > 2 && isPrime(n - 2)) specials.push('Twin Prime');
  if (isSqfree && tau === Math.pow(2, factors.length)) specials.push('Squarefree');
  if (factors.length === 1 && factors[0].exp === 1) specials.push('Prime');
  if (factors.length === 1 && factors[0].exp > 1) specials.push('Prime Power');
  if (phi === 2 * Math.floor(phi / 2) && n > 2) {} // Even totient (most numbers)
  if (factors.length >= 3) specials.push('≥3 Prime Factors');
  
  specialDiv.innerHTML = `
    <div style="margin-bottom:.75rem"><strong style="color:#ffd700">Digit Analysis:</strong>
      <div style="font-size:.85rem;margin-top:.25rem">
        Digits: ${n.toString().length} | Sum: ${digitSum} | Product: ${digitProd}
      </div>
      <div style="font-size:.75rem;color:var(--txt2)">Digital root: ${digitalRoot(n)}</div>
    </div>
    <div style="margin-bottom:.75rem"><strong style="color:#00ff88">Special Properties:</strong>
      <div style="display:flex;gap:.3rem;flex-wrap:wrap;margin-top:.25rem">
        ${specials.length > 0 ? specials.map(s => `<span style="background:rgba(0,255,136,.2);color:#00ff88;padding:2px 8px;border-radius:4px;font-size:.8rem">${s}</span>`).join('') : '<span style="color:#888">None detected</span>'}
      </div>
    </div>
    <div><strong style="color:#9664ff">Binary:</strong> <span style="font-family:monospace;color:var(--txt2)">${n.toString(2)}</span></div>
    <div><strong style="color:#00d9ff">Hexadecimal:</strong> <span style="font-family:monospace;color:var(--txt2)">0x${n.toString(16).toUpperCase()}</span></div>
  `;
  
  // Connections
  const connDiv = document.getElementById('deepDiveConnections');
  const prevPrime = getPrevPrimeFrom(n);
  const nextPrimeN = getNextPrimeFrom(n);
  const nearestPrimorial = getNearestPrimorial(n);
  
  connDiv.innerHTML = `
    <div style="display:grid;grid-template-columns:repeat(auto-fit,minmax(200px,1fr));gap:1rem">
      <div style="background:var(--bg2);padding:.75rem;border-radius:6px">
        <div style="color:#00ff88;font-weight:bold;margin-bottom:.25rem">Nearest Primes</div>
        <div style="font-size:.85rem">Previous: <strong>${prevPrime}</strong> (gap: ${n - prevPrime})</div>
        <div style="font-size:.85rem">Next: <strong>${nextPrimeN}</strong> (gap: ${nextPrimeN - n})</div>
      </div>
      <div style="background:var(--bg2);padding:.75rem;border-radius:6px">
        <div style="color:#ffd700;font-weight:bold;margin-bottom:.25rem">Primorial Connection</div>
        <div style="font-size:.85rem">${nearestPrimorial.name} = ${nearestPrimorial.value}</div>
        <div style="font-size:.75rem;color:var(--txt2)">Distance: ${Math.abs(n - nearestPrimorial.value)}</div>
      </div>
      <div style="background:var(--bg2);padding:.75rem;border-radius:6px">
        <div style="color:#9664ff;font-weight:bold;margin-bottom:.25rem">Farey Position</div>
        <div style="font-size:.85rem">1/${n} appears in F<sub>${n}</sub></div>
        <div style="font-size:.75rem;color:var(--txt2)">Neighbors: 1/${n+1}, 1/${n-1>0?n-1:1}</div>
      </div>
      <div style="background:var(--bg2);padding:.75rem;border-radius:6px">
        <div style="color:#ff6496;font-weight:bold;margin-bottom:.25rem">Collatz Steps</div>
        <div style="font-size:.85rem">${n} → 1 in <strong>${collatzSteps(n)}</strong> steps</div>
      </div>
    </div>
  `;
}

// Helper functions for Deep Dive
function primeFactorization(n) {
  if (n <= 1) return [];
  const factors = [];
  let d = 2;
  while (d * d <= n) {
    if (n % d === 0) {
      let exp = 0;
      while (n % d === 0) { n /= d; exp++; }
      factors.push({ p: d, exp });
    }
    d++;
  }
  if (n > 1) factors.push({ p: n, exp: 1 });
  return factors;
}

function getDivisors(n) {
  const divs = [];
  for (let i = 1; i * i <= n; i++) {
    if (n % i === 0) {
      divs.push(i);
      if (i !== n / i) divs.push(n / i);
    }
  }
  return divs.sort((a, b) => a - b);
}

function mobiusFunction(n) {
  if (n === 1) return 1;
  const factors = primeFactorization(n);
  for (const f of factors) {
    if (f.exp > 1) return 0;
  }
  return factors.length % 2 === 0 ? 1 : -1;
}

function hasPrimitiveRoot(n) {
  if (n === 1 || n === 2 || n === 4) return true;
  const factors = primeFactorization(n);
  if (factors.length === 1 && factors[0].p !== 2) return true;
  if (factors.length === 1 && factors[0].p === 2 && factors[0].exp <= 2) return true;
  if (factors.length === 2 && factors[0].p === 2 && factors[0].exp === 1) return true;
  return false;
}

function carmichaelLambda(n) {
  if (n === 1) return 1;
  const factors = primeFactorization(n);
  let result = 1;
  for (const f of factors) {
    let pk = Math.pow(f.p, f.exp);
    let lambda_pk;
    if (f.p === 2 && f.exp >= 3) {
      lambda_pk = Math.pow(2, f.exp - 2);
    } else {
      lambda_pk = (f.p - 1) * Math.pow(f.p, f.exp - 1);
    }
    result = lcm(result, lambda_pk);
  }
  return result;
}

function lcm(a, b) {
  return Math.abs(a * b) / gcd(a, b);
}

function findSumOfTwoSquares(n) {
  const results = [];
  const limit = Math.floor(Math.sqrt(n));
  for (let a = 0; a <= limit; a++) {
    const bSq = n - a * a;
    const b = Math.round(Math.sqrt(bSq));
    if (b >= a && b * b === bSq) {
      results.push([a, b]);
    }
  }
  return results;
}

function findSumOfThreeSquares(n) {
  if (n % 8 === 7) return [];
  const results = [];
  const limit = Math.floor(Math.sqrt(n));
  for (let a = 0; a <= limit && results.length < 10; a++) {
    for (let b = a; b <= limit && results.length < 10; b++) {
      const cSq = n - a*a - b*b;
      if (cSq < b*b) break;
      const c = Math.round(Math.sqrt(cSq));
      if (c >= b && c*c === cSq) {
        results.push([a, b, c]);
      }
    }
  }
  return results;
}

function findFibonacciIndex(n) {
  if (n <= 0) return null;
  let a = 0, b = 1, idx = 1;
  while (b < n) {
    [a, b] = [b, a + b];
    idx++;
    if (idx > 50) break;
  }
  if (b === n) return `F(${idx}) = ${n}`;
  if (a === n) return `F(${idx-1}) = ${n}`;
  return null;
}

function isPalindrome(n) {
  const s = n.toString();
  return s === s.split('').reverse().join('');
}

function digitalRoot(n) {
  while (n >= 10) {
    n = n.toString().split('').map(Number).reduce((a,b) => a+b, 0);
  }
  return n;
}

function getPrevPrimeFrom(n) {
  let p = n - 1;
  while (p > 1 && !isPrime(p)) p--;
  return Math.max(2, p);
}

function getNextPrimeFrom(n) {
  let p = n + 1;
  while (!isPrime(p) && p < n + 1000) p++;
  return p;
}

function getNearestPrimorial(n) {
  const primorials = [
    { name: 'p₁# = 2', value: 2 },
    { name: 'p₂# = 6', value: 6 },
    { name: 'p₃# = 30', value: 30 },
    { name: 'p₄# = 210', value: 210 },
    { name: 'p₅# = 2310', value: 2310 },
    { name: 'p₆# = 30030', value: 30030 },
    { name: 'p₇# = 510510', value: 510510 }
  ];
  let nearest = primorials[0];
  let minDist = Math.abs(n - nearest.value);
  for (const p of primorials) {
    const d = Math.abs(n - p.value);
    if (d < minDist) {
      minDist = d;
      nearest = p;
    }
  }
  return nearest;
}

function collatzSteps(n) {
  let steps = 0;
  while (n !== 1 && steps < 10000) {
    n = n % 2 === 0 ? n / 2 : 3 * n + 1;
    steps++;
  }
  return steps;
}

function drawDivisorLattice(n, divisors) {
  const c = document.getElementById('cDeepDivisors');
  if (!c) return;
  const ctx = c.getContext('2d');
  ctx.fillStyle = canvBg();
  ctx.fillRect(0, 0, c.width, c.height);
  
  if (divisors.length > 30) {
    ctx.fillStyle = isDark() ? '#888' : '#666';
    ctx.font = '12px Segoe UI';
    ctx.textAlign = 'center';
    ctx.fillText(`${divisors.length} divisors (too many to display lattice)`, c.width/2, c.height/2);
    ctx.fillText(`Divisors: ${divisors.slice(0, 10).join(', ')}...`, c.width/2, c.height/2 + 20);
    return;
  }
  
  // Simple layout: arrange by divisor magnitude
  const positions = new Map();
  const levels = new Map();
  
  // Group by number of prime factors (with multiplicity)
  divisors.forEach(d => {
    const factors = primeFactorization(d);
    const level = factors.reduce((s, f) => s + f.exp, 0);
    if (!levels.has(level)) levels.set(level, []);
    levels.get(level).push(d);
  });
  
  const maxLevel = Math.max(...levels.keys());
  const levelHeight = (c.height - 60) / (maxLevel + 1);
  
  levels.forEach((divs, level) => {
    const y = 30 + level * levelHeight;
    const spacing = c.width / (divs.length + 1);
    divs.forEach((d, i) => {
      positions.set(d, { x: spacing * (i + 1), y });
    });
  });
  
  // Draw edges (divisibility)
  ctx.strokeStyle = isDark() ? 'rgba(255,255,255,0.2)' : 'rgba(0,0,0,0.2)';
  ctx.lineWidth = 1;
  divisors.forEach(d1 => {
    divisors.forEach(d2 => {
      if (d2 > d1 && d2 % d1 === 0 && !divisors.some(d3 => d3 !== d1 && d3 !== d2 && d2 % d3 === 0 && d3 % d1 === 0)) {
        const p1 = positions.get(d1);
        const p2 = positions.get(d2);
        ctx.beginPath();
        ctx.moveTo(p1.x, p1.y);
        ctx.lineTo(p2.x, p2.y);
        ctx.stroke();
      }
    });
  });
  
  // Draw nodes
  divisors.forEach(d => {
    const pos = positions.get(d);
    const isCoprime = gcd(d, n/d) === 1;
    
    ctx.fillStyle = d === 1 ? '#00ff88' : d === n ? '#ff6496' : isCoprime ? '#ffd700' : '#00d9ff';
    ctx.beginPath();
    ctx.arc(pos.x, pos.y, 12, 0, 2 * Math.PI);
    ctx.fill();
    
    ctx.fillStyle = '#000';
    ctx.font = 'bold 9px Segoe UI';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(d.toString(), pos.x, pos.y);
  });
}

function drawCoprimeCircle(n, coprimes) {
  const c = document.getElementById('cDeepCoprimes');
  if (!c) return;
  const ctx = c.getContext('2d');
  ctx.fillStyle = canvBg();
  ctx.fillRect(0, 0, c.width, c.height);
  
  const cx = c.width / 2;
  const cy = c.height / 2;
  const r = Math.min(cx, cy) - 30;
  
  // Draw circle
  ctx.strokeStyle = isDark() ? '#444' : '#ccc';
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.arc(cx, cy, r, 0, 2 * Math.PI);
  ctx.stroke();
  
  // Draw all residues
  for (let i = 0; i < n; i++) {
    const theta = (i / n) * 2 * Math.PI - Math.PI / 2;
    const px = cx + r * Math.cos(theta);
    const py = cy + r * Math.sin(theta);
    
    const isCoprime = coprimes.includes(i);
    ctx.fillStyle = isCoprime ? '#ffd700' : 'rgba(100,100,100,0.3)';
    ctx.beginPath();
    ctx.arc(px, py, isCoprime ? 5 : 2, 0, 2 * Math.PI);
    ctx.fill();
  }
  
  // Labels for small n
  if (n <= 30) {
    ctx.fillStyle = isDark() ? '#888' : '#666';
    ctx.font = '8px Segoe UI';
    ctx.textAlign = 'center';
    coprimes.forEach(cp => {
      const theta = (cp / n) * 2 * Math.PI - Math.PI / 2;
      const px = cx + (r + 15) * Math.cos(theta);
      const py = cy + (r + 15) * Math.sin(theta);
      ctx.fillText(cp.toString(), px, py);
    });
  }
  
  // Stats
  const statsDiv = document.getElementById('deepDiveCoprimeStats');
  if (statsDiv) {
    statsDiv.innerHTML = `
      <strong style="color:#ffd700">φ(${n}) = ${coprimes.length}</strong> coprime residues
      <span style="margin-left:1rem">Density: ${(coprimes.length / n * 100).toFixed(1)}%</span>
      <span style="margin-left:1rem">Theory: 6/π² ≈ 60.79%</span>
    `;
  }
}

async function initCommunity() {
  if (chatInitialized) {
    renderMessages();
    return;
  }
  
  document.getElementById('communityStatus').textContent = 'Connecting...';
  document.getElementById('communityStatus').style.color = '#ffd700';
  
  // Try to load Firebase with timeout
  try {
    // Use local mode directly for now (Firebase requires proper config)
    initLocalChat();
  } catch (error) {
    console.log('Chat init error:', error);
    initLocalChat();
  }
}

function loadScript(src) {
  return new Promise((resolve, reject) => {
    const script = document.createElement('script');
    script.src = src;
    script.onload = resolve;
    script.onerror = reject;
    document.head.appendChild(script);
  });
}

function initLocalChat() {
  // Load from localStorage
  const stored = localStorage.getItem('mobius_chat_messages');
  if (stored) {
    try {
      chatMessages = JSON.parse(stored);
    } catch (e) {
      chatMessages = [];
    }
  }
  
  // Add welcome messages if empty
  if (chatMessages.length === 0) {
    const now = Date.now();
    chatMessages = [
      {
        id: 'welcome1',
        name: 'Wessen',
        message: 'Welcome to the Mobius Sieve Explorer guestbook! Leave a message or share a favorite discovery, or ask questions about the visualizations.',
        timestamp: now - 86400000 * 7, // 7 days ago
        isSystem: false
      },
      {
        id: 'welcome2',
        name: 'System',
        message: 'Messages are stored locally. Try exploring the **Singular Series** tab for prime constellation analysis, or the **Phasor Sum** for visualizing the Riemann zeta function!',
        timestamp: now - 86400000 * 5,
        isSystem: true
      },
      {
        id: 'sample1',
        name: 'Math Explorer',
        message: 'The modular ring visualization really helped me understand why primes avoid certain residue classes. The `2pir/M` placement makes the patterns so clear!',
        timestamp: now - 86400000 * 3,
        isSystem: false
      },
      {
        id: 'sample2',
        name: 'Number Theory Fan',
        message: 'A notable prime is 41 because it generates the most primes in Euler\'s famous polynomial n^2 + n + 41. What\'s yours?',
        timestamp: now - 86400000 * 2,
        isSystem: false
      },
      {
        id: 'sample3',
        name: 'Visitor',
        message: 'Hello from California! These visualizations are amazing. The Hardy-Littlewood constant computation blew my mind.',
        timestamp: now - 86400000,
        isSystem: false
      }
    ];
    saveLocalMessages();
  }
  
  renderMessages();
  updateCommunityStats();
  
  document.getElementById('communityStatus').textContent = 'Local Storage';
  document.getElementById('communityStatus').style.color = '#00ff88';
  chatInitialized = true;
}

function saveLocalMessages() {
  localStorage.setItem('mobius_chat_messages', JSON.stringify(chatMessages.slice(-100)));
}

function sendChatMessage() {
  const nameInput = document.getElementById('chatName');
  const messageInput = document.getElementById('chatInput');
  
  const name = nameInput.value.trim() || 'Anonymous';
  const message = messageInput.value.trim();
  
  if (!message) return;
  
  const newMessage = {
    name: name,
    message: message,
    timestamp: Date.now(),
    userAgent: navigator.userAgent.substring(0, 50)
  };
  
  if (chatDb) {
    // Push to Firebase
    chatDb.ref('messages').push(newMessage);
  } else {
    // Local storage
    newMessage.id = 'local_' + Date.now();
    chatMessages.push(newMessage);
    saveLocalMessages();
    renderMessages();
    updateCommunityStats();
  }
  
  // Clear input
  messageInput.value = '';
  messageInput.focus();
  
  // Remember name
  if (name !== 'Anonymous') {
    localStorage.setItem('mobius_chat_name', name);
  }
}

function renderMessages() {
  const container = document.getElementById('chatMessages');
  if (!container) return;
  
  if (chatMessages.length === 0) {
    container.innerHTML = '<div style="text-align:center;color:var(--txt2);padding:2rem">No messages yet. Be the first to say hello!</div>';
    return;
  }
  
  // Sort by timestamp
  const sorted = [...chatMessages].sort((a, b) => a.timestamp - b.timestamp);
  
  container.innerHTML = sorted.map(msg => {
    const time = new Date(msg.timestamp);
    const timeStr = time.toLocaleString();
    const isSystem = msg.isSystem || msg.name === 'System';
    const nameColor = isSystem ? '#9664ff' : getNameColor(msg.name);
    
    return `
      <div style="margin-bottom:12px;padding:10px;background:${isSystem ? 'rgba(150,100,255,.1)' : 'var(--bg2)'};border-radius:8px;border-left:3px solid ${nameColor}">
        <div style="display:flex;justify-content:space-between;margin-bottom:4px">
          <strong style="color:${nameColor}">${escapeHtml(msg.name)}</strong>
          <span style="font-size:.7rem;color:var(--txt2)">${timeStr}</span>
        </div>
        <div style="color:var(--txt);line-height:1.4">${formatMessage(msg.message)}</div>
      </div>
    `;
  }).join('');
  
  // Scroll to bottom
  container.scrollTop = container.scrollHeight;
}

function getNameColor(name) {
  // Generate consistent color from name
  let hash = 0;
  for (let i = 0; i < name.length; i++) {
    hash = name.charCodeAt(i) + ((hash << 5) - hash);
  }
  const hue = Math.abs(hash % 360);
  return `hsl(${hue}, 70%, 60%)`;
}

function escapeHtml(text) {
  const div = document.createElement('div');
  div.textContent = text;
  return div.innerHTML;
}

function formatMessage(text) {
  // Escape HTML first
  let formatted = escapeHtml(text);
  
  // Convert URLs to links
  formatted = formatted.replace(
    /(https?:\/\/[^\s]+)/g,
    '<a href="$1" target="_blank" style="color:var(--acc)">$1</a>'
  );
  
  // Convert math notation (basic)
  formatted = formatted.replace(/\*\*([^*]+)\*\*/g, '<strong>$1</strong>');
  formatted = formatted.replace(/`([^`]+)`/g, '<code style="background:var(--bg1);padding:1px 4px;border-radius:3px">$1</code>');
  
  // Convert newlines
  formatted = formatted.replace(/\n/g, '<br>');
  
  return formatted;
}

function updateCommunityStats() {
  const uniqueUsers = new Set(chatMessages.map(m => m.name)).size;
  document.getElementById('statMessages').textContent = chatMessages.length;
  document.getElementById('statUsers').textContent = uniqueUsers;
}


// ========== EXPORT FUNCTIONS ==========

function exportZerosToCSV() {
  const zeros = [];
  document.querySelectorAll('#zZeroResults tr').forEach(row => {
    if (row.cells[0]) {
      zeros.push({
        t: parseFloat(row.cells[0].textContent),
        z: row.cells[1].textContent,
        knownZero: row.cells[2].textContent
      });
    }
  });
  
  if (zeros.length === 0) {
    alert('No zeros found. Run detector first!');
    return;
  }
  
  let csv = 'Index,t_value,Z(t),Known_Zero,Error_Estimate\n';
  zeros.forEach((z, idx) => {
    const z_val = zetaService.calculateZ(z.t);
    csv += `${idx+1},${z.t.toFixed(12)},${z_val.toString().substring(0,20)},${z.knownZero},"${Math.abs(parseFloat(z.z)).toExponential(3)}"\n`;
  });
  
  downloadFile(csv, 'zeta_zeros.csv', 'text/csv');
}

function exportZWaveToJSON() {
  const tStart = parseFloat(document.getElementById('zTStart')?.value || 0);
  const tEnd = parseFloat(document.getElementById('zTEnd')?.value || 100);
  const numPoints = parseInt(document.getElementById('zNumPoints')?.value || 300);
  
  const data = [];
  for (let i = 0; i < numPoints; i++) {
    const t = tStart + (i / (numPoints - 1)) * (tEnd - tStart);
    const zt = parseFloat(zetaService.calculateZ(t));
    data.push({t: parseFloat(t.toFixed(6)), z: parseFloat(zt.toFixed(12))});
  }
  
  const json = {
    title: "Hardy Z-Function Data",
    date: new Date().toISOString(),
    range: {start: tStart, end: tEnd},
    numPoints: numPoints,
    data: data
  };
  
  downloadFile(JSON.stringify(json, null, 2), 'zeta_wave.json', 'application/json');
}

function exportZeroStatistics() {
  const zeros = [];
  document.querySelectorAll('#zZeroResults tr').forEach(row => {
    if (row.cells[0]) {
      zeros.push(parseFloat(row.cells[0].textContent));
    }
  });
  
  if (zeros.length < 2) {
    alert('Need at least 2 zeros for statistics');
    return;
  }
  
  const gaps = [];
  for (let i = 1; i < zeros.length; i++) {
    gaps.push(zeros[i] - zeros[i-1]);
  }
  
  const mean = gaps.reduce((a,b) => a+b, 0) / gaps.length;
  const variance = gaps.reduce((a,b) => a + Math.pow(b - mean, 2), 0) / gaps.length;
  const stdDev = Math.sqrt(variance);
  const minGap = Math.min(...gaps);
  const maxGap = Math.max(...gaps);
  
  let report = `RIEMANN ZETA ZERO STATISTICS\n`;
  report += `Generated: ${new Date().toISOString()}\n`;
  report += `\nZEROS FOUND: ${zeros.length}\n`;
  report += `Range: t ∈ [${zeros[0].toFixed(4)}, ${zeros[zeros.length-1].toFixed(4)}]\n\n`;
  
  report += `GAP STATISTICS (between consecutive zeros):\n`;
  report += `  Count: ${gaps.length}\n`;
  report += `  Mean: ${mean.toFixed(8)}\n`;
  report += `  Std Dev: ${stdDev.toFixed(8)}\n`;
  report += `  Min: ${minGap.toFixed(8)}\n`;
  report += `  Max: ${maxGap.toFixed(8)}\n\n`;
  
  report += `ZERO LOCATIONS:\n`;
  zeros.forEach((z, i) => {
    const gap = i > 0 ? `(gap: ${(z - zeros[i-1]).toFixed(8)})` : '';
    report += `  ρ${i+1} = ${z.toFixed(12)} ${gap}\n`;
  });
  
  downloadFile(report, 'zeta_statistics.txt', 'text/plain');
}

function exportToMathematica() {
  const zeros = [];
  document.querySelectorAll('#zZeroResults tr').forEach(row => {
    if (row.cells[0]) {
      zeros.push(parseFloat(row.cells[0].textContent));
    }
  });
  
  let code = `(* Riemann Zeta Zeros - Mathematica Format *)\n`;
  code += `zeros = {${zeros.map(z => z.toFixed(12)).join(', ')}};\n\n`;
  code += `(* Quick statistics *)\n`;
  code += `gaps = Differences[zeros];\n`;
  code += `Print["Mean gap: ", Mean[gaps]];\n`;
  code += `Print["Min gap: ", Min[gaps]];\n`;
  code += `Print["Max gap: ", Max[gaps]];\n\n`;
  code += `(* Plot the zeros *)\n`;
  code += `ListPlot[{zeros, ConstantArray[0, Length[zeros]]}, PlotStyle -> {Automatic, PointSize[0.02]}, AxesLabel -> {"t", ""}]\n`;
  
  downloadFile(code, 'zeta_zeros.wl', 'text/plain');
}

function exportToPython() {
  const zeros = [];
  document.querySelectorAll('#zZeroResults tr').forEach(row => {
    if (row.cells[0]) {
      zeros.push(parseFloat(row.cells[0].textContent));
    }
  });
  
  let code = `# Riemann Zeta Zeros - Python Format\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n`;
  code += `zeros = np.array([${zeros.map(z => z.toFixed(12)).join(', ')}])\n\n`;
  code += `# Statistics\ngaps = np.diff(zeros)\nprint(f"Mean gap: {np.mean(gaps):.8f}")\n`;
  code += `print(f"Min gap: {np.min(gaps):.8f}")\n`;
  code += `print(f"Max gap: {np.max(gaps):.8f}")\n\n`;
  code += `# Plot\nplt.figure(figsize=(12, 4))\nplt.scatter(zeros, np.zeros_like(zeros), color='red', s=20, alpha=0.7)\n`;
  code += `plt.xlabel('t (imaginary part)')\nplt.ylabel('')\nplt.title('Non-Trivial Zeros on Critical Line')\nplt.grid(True, alpha=0.3)\nplt.show()\n`;
  
  downloadFile(code, 'zeta_zeros.py', 'text/plain');
}

function downloadFile(content, filename, mimeType) {
  const blob = new Blob([content], { type: mimeType });
  const url = window.URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  window.URL.revokeObjectURL(url);
  document.body.removeChild(a);
}

console.log('Export functions loaded');

// ========== UNIFIED VISUALIZATION CONTROL FUNCTIONS ==========

// Control mode: 'all' (all 4 together) or 'individual' (single canvas)
window.controlMode = 'all';
window.selectedCanvas = 'cFareyDisk';

function setControlMode(mode) {
  window.controlMode = mode;
  
  // Update button styles
  const btnAll = document.getElementById('btnControlAll');
  const btnIndividual = document.getElementById('btnControlIndividual');
  const canvasSelect = document.getElementById('individualCanvasSelect');
  
  if (mode === 'all') {
    btnAll.style.background = '#667eea';
    btnAll.style.color = '#fff';
    btnAll.style.borderColor = '#667eea';
    
    btnIndividual.style.background = 'transparent';
    btnIndividual.style.color = '#667eea';
    btnIndividual.style.borderColor = 'var(--bord)';
    
    canvasSelect.style.display = 'none';
  } else {
    btnAll.style.background = 'transparent';
    btnAll.style.color = '#667eea';
    btnAll.style.borderColor = 'var(--bord)';
    
    btnIndividual.style.background = '#667eea';
    btnIndividual.style.color = '#fff';
    btnIndividual.style.borderColor = '#667eea';
    
    canvasSelect.style.display = 'block';
  }
  
  applyUnifiedSettings();
}

function setSelectedCanvas(canvasId) {
  window.selectedCanvas = canvasId;
  
  // Update button styles
  document.querySelectorAll('.canvasSelectBtn').forEach(btn => {
    btn.style.background = 'transparent';
    btn.style.color = 'var(--txt2)';
    btn.style.borderColor = 'var(--bord)';
  });
  
  const selectedBtn = document.getElementById('btn-' + canvasId);
  selectedBtn.style.background = 'rgba(102,126,234,.2)';
  selectedBtn.style.color = '#667eea';
  selectedBtn.style.borderColor = '#667eea';
  
  applyUnifiedSettings();
}

function getCanvasesToApply() {
  if (window.controlMode === 'all') {
    return ['cFareyDisk'];
  } else {
    return ['cFareyDisk'];
  }
}

function applyUnifiedSettings() {
  const system = document.getElementById('unifiedLabelingSystem').value;
  const labelSize = document.getElementById('unifiedLabelSize').value;
  const scheme = document.getElementById('unifiedColorScheme').value;
  const pointSize = document.getElementById('unifiedPointSize').value;
  const showGrid = document.getElementById('unifiedShowGrid').checked;
  const showDensity = document.getElementById('unifiedShowDensity').checked;
  const density = document.getElementById('unifiedGridDensity').value;
  const showConnections = document.getElementById('unifiedShowConnections').checked;
  const opacity = document.getElementById('unifiedOpacity').value;
  
  // Update display values
  document.getElementById('unifiedLabelSizeVal').textContent = labelSize;
  document.getElementById('unifiedPointSizeVal').textContent = pointSize;
  document.getElementById('unifiedGridDensityVal').textContent = density;
  document.getElementById('unifiedOpacityVal').textContent = opacity;
  
  // Store in global state
  window.unifiedLabelingSystem = system;
  window.unifiedLabelSize = parseInt(labelSize);
  window.unifiedColorScheme = scheme;
  window.unifiedPointSize = parseInt(pointSize);
  window.unifiedOpacity = parseInt(opacity) / 100;
  window.unifiedShowGrid = showGrid;
  window.unifiedShowDensity = showDensity;
  window.unifiedGridDensity = parseInt(density);
  window.unifiedShowConnections = showConnections;
  
  // Redraw Unit Disk
  if (typeof drawFareyDisk === 'function') drawFareyDisk();
}

function applyUnifiedLabeling() {
  applyUnifiedSettings();
}

function applyUnifiedColoring() {
  applyUnifiedSettings();
}

function applyUnifiedStyling() {
  applyUnifiedSettings();
}

function applyUnifiedGrid() {
  applyUnifiedSettings();
}

function applyUnifiedDensity() {
  applyUnifiedSettings();
}

function getUnifiedColor(gcdValue, fallback) {
  const scheme = window.unifiedColorScheme || 'classic';
  const colorSchemes = {
    classic: { gcd1: '#3498db', gcdN: (g) => ['#e74c3c', '#2ecc71', '#f39c12', '#9b59b6', '#1abc9c'][(g-2)%5] },
    rainbow: { gcd1: '#FF0080', gcdN: (g) => `hsl(${(g*40)%360}, 85%, 60%)` },
    heat: { gcd1: '#00ffff', gcdN: (g) => { const i = Math.min(g/10,1); return `rgb(${255*i}, ${100*(1-i)}, ${50*(1-i)})`; } },
    ocean: { gcd1: '#00d4ff', gcdN: (g) => { const d = Math.min(g/8,1); return `rgb(${20*(1-d)}, ${100+100*(1-d)}, ${200+55*(1-d)})`; } },
    sunset: { gcd1: '#ff6b6b', gcdN: (g) => ['#ff8c42', '#ffa07a', '#ee6c4d', '#c1666b', '#9b4f96'][(g-2)%5] },
    forest: { gcd1: '#52c234', gcdN: (g) => ['#2d6a4f', '#40916c', '#52b788', '#74c69d', '#95d5b2'][(g-2)%5] },
    neon: { gcd1: '#0ff', gcdN: (g) => ['#f0f', '#ff0', '#0f0', '#f00', '#00f', '#f80'][(g-2)%6] },
    cyberpunk: { gcd1: '#00fff9', gcdN: (g) => ['#ff00ff', '#ff0099', '#9d00ff', '#ff3300', '#00ff00'][(g-2)%5] },
    galaxy: { gcd1: '#e0aaff', gcdN: (g) => ['#c77dff', '#9d4edd', '#7209b7', '#560bad', '#3c096c'][(g-2)%5] },
    aurora: { gcd1: '#b8f3ff', gcdN: (g) => ['#72efdd', '#64dfdf', '#48bfe3', '#5390d9', '#6930c3'][(g-2)%5] }
  };
  
  const colors = colorSchemes[scheme] || colorSchemes.classic;
  return gcdValue === 1 ? colors.gcd1 : colors.gcdN(gcdValue);
}

function getUnifiedLabel(r, m, system) {
  if (!system || system === 'none') return null;
  const g = gcd(r, m);
  
  switch(system) {
    case 'gcd': return g.toString();
    case 'farey': const f = fareyFraction(r, m); return `${f.numerator}/${f.denominator}`;
    case 'theta': return `${((2*Math.PI*r)/m).toFixed(1)}`;
    case 'reduced': return `${m/g}`;
    case 'totient': return `φ=${eulerPhi(m/g)}`;
    case 'prime': 
      let factors = [];
      let n = r;
      for (let p = 2; p * p <= n; p++) {
        while (n % p === 0) { factors.push(p); n /= p; }
      }
      if (n > 1) factors.push(n);
      return factors.length > 0 ? factors.join(',') : '1';
    case 'divisor':
      let dc = 0;
      for (let d = 1; d <= g; d++) { if (g % d === 0) dc++; }
      return `d:${dc}`;
    default: return null;
  }
}

// Initialize global state
window.unifiedLabelingSystem = 'none';
window.unifiedLabelSize = 9;
window.unifiedColorScheme = 'classic';
window.unifiedPointSize = 5;
window.unifiedOpacity = 0.85;
window.unifiedShowGrid = true;
window.unifiedShowDensity = false;
window.unifiedGridDensity = 4;
window.unifiedShowConnections = false;

// ========== RIEMANN ZETA SERVICE - Z-FUNCTION ENGINE ==========
class RiemannZetaService {
  constructor(precision = 50) {
    if (typeof Decimal !== 'undefined') {
      Decimal.set({ precision: precision });
      this.PI = Decimal.acos(-1);
      this.TWO_PI = this.PI.times(2);
      this.useDecimal = true;
    } else {
      this.PI = Math.PI;
      this.TWO_PI = Math.PI * 2;
      this.useDecimal = false;
    }
  }

  // Riemann-Siegel Theta Function
  theta(t) {
    const T = this.useDecimal ? new Decimal(t) : t;
    let tDiv2pi, p1, p2, p3, p4;
    
    if (this.useDecimal) {
      tDiv2pi = T.dividedBy(this.TWO_PI);
      p1 = T.dividedBy(2).times(Decimal.ln(tDiv2pi));
      p2 = T.dividedBy(2);
      p3 = this.PI.dividedBy(8);
      p4 = new Decimal(1).dividedBy(T.times(48));
      return p1.minus(p2).minus(p3).plus(p4);
    } else {
      tDiv2pi = T / this.TWO_PI;
      p1 = (T / 2) * Math.log(tDiv2pi);
      p2 = T / 2;
      p3 = this.PI / 8;
      p4 = 1 / (T * 48);
      return p1 - p2 - p3 + p4;
    }
  }

  // Hardy Z-Function Main Computation
  calculateZ(t) {
    const T = this.useDecimal ? new Decimal(t) : t;
    const m = Math.floor(Math.sqrt(Math.abs(t) / (Math.PI * 2)));
    const theta_t = this.theta(T);
    
    let sum = this.useDecimal ? new Decimal(0) : 0;
    
    for (let n = 1; n <= m; n++) {
      const nDec = this.useDecimal ? new Decimal(n) : n;
      let ln_n, cosArg, term;
      
      if (this.useDecimal) {
        ln_n = Decimal.ln(nDec);
        cosArg = theta_t.minus(T.times(ln_n));
        // cos via Math (Decimal.js doesn't have cos)
        const cosVal = new Decimal(Math.cos(parseFloat(cosArg)));
        term = cosVal.dividedBy(nDec.sqrt());
      } else {
        ln_n = Math.log(nDec);
        cosArg = theta_t - T * ln_n;
        term = Math.cos(cosArg) / Math.sqrt(nDec);
      }
      
      sum = this.useDecimal ? sum.plus(term) : sum + term;
    }
    
    return this.useDecimal ? sum.times(2) : sum * 2;
  }

  // Sign-Change Zero Crossing Detector
  findZeros(startT, endT, numPoints = 500) {
    const zeros = [];
    const step = (endT - startT) / (numPoints - 1);
    
    for (let i = 0; i < numPoints - 1; i++) {
      const t1 = startT + i * step;
      const t2 = startT + (i + 1) * step;
      
      const z1 = this.calculateZ(t1);
      const z2 = this.calculateZ(t2);
      
      const z1_num = this.useDecimal ? parseFloat(z1) : z1;
      const z2_num = this.useDecimal ? parseFloat(z2) : z2;
      
      if (Math.sign(z1_num) !== Math.sign(z2_num) && z1_num !== 0 && z2_num !== 0) {
        const refined = this.bisection(t1, t2);
        zeros.push(refined);
      }
    }
    
    return zeros;
  }

  // Binary Search Refinement
  bisection(t1, t2, tolerance = 1e-6) {
    let low = this.useDecimal ? new Decimal(t1) : t1;
    let high = this.useDecimal ? new Decimal(t2) : t2;
    let mid;

    while (true) {
      mid = this.useDecimal ? 
        low.plus(high).dividedBy(2) : 
        (low + high) / 2;

      const z_low = this.calculateZ(this.useDecimal ? parseFloat(low) : low);
      const z_mid = this.calculateZ(this.useDecimal ? parseFloat(mid) : mid);
      
      const z_low_num = this.useDecimal ? parseFloat(z_low) : z_low;
      const z_mid_num = this.useDecimal ? parseFloat(z_mid) : z_mid;
      
      const gap = this.useDecimal ? parseFloat(high.minus(low)) : (high - low);
      if (gap < tolerance) break;

      if (z_low_num * z_mid_num < 0) {
        high = mid;
      } else {
        low = mid;
      }
    }
    
    return this.useDecimal ? parseFloat(mid) : mid;
  }
}

const zetaService = new RiemannZetaService(28);

// Z-FUNCTION MODE SWITCHING
function switchZMode(mode) {
  document.getElementById('zWaveMode').style.display = mode === 'wave' ? 'block' : 'none';
  document.getElementById('zZeroMode').style.display = mode === 'zeros' ? 'block' : 'none';
  document.getElementById('zSpiralMode').style.display = mode === 'spiral' ? 'block' : 'none';
  
  // Update button states
  document.querySelectorAll('#tzetaFunc .tbtn.cat-zeta').forEach(btn => {
    btn.classList.remove('active');
  });
  event.target?.classList.add('active');
}

// Show Z-Function Tab
function showZetaTab() {
  document.getElementById('tenhanced').style.display = 'none';
  document.getElementById('tzetaFunc').style.display = 'block';
}

// Return to Enhanced Modular Tab
function showEnhancedTab() {
  document.getElementById('tenhanced').style.display = 'block';
  document.getElementById('tzetaFunc').style.display = 'none';
}

console.log('Z-Function mode switcher loaded');
function plotZWave() {
  const tStart = parseFloat(document.getElementById('zTStart')?.value || 0);
  const tEnd = parseFloat(document.getElementById('zTEnd')?.value || 100);
  const numPoints = parseInt(document.getElementById('zNumPoints')?.value || 300);
  
  const canvas = document.getElementById('zWaveCanvas');
  if (!canvas) return;
  
  const ctx = canvas.getContext('2d');
  const padding = 50;
  const width = canvas.width - 2 * padding;
  const height = canvas.height - 2 * padding;
  const centerY = padding + height / 2;
  
  // Background
  ctx.fillStyle = getComputedStyle(document.body).getPropertyValue('--plot');
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  
  // Grid
  ctx.strokeStyle = 'rgba(0,217,255,0.15)';
  ctx.lineWidth = 1;
  for (let i = 0; i <= 10; i++) {
    const y = padding + (i / 10) * height;
    ctx.beginPath();
    ctx.moveTo(padding, y);
    ctx.lineTo(padding + width, y);
    ctx.stroke();
  }
  
  // Axes
  ctx.strokeStyle = getComputedStyle(document.body).getPropertyValue('--acc');
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(padding, centerY);
  ctx.lineTo(padding + width, centerY);
  ctx.stroke();
  
  // Compute data
  const data = [];
  let maxVal = 0;
  let crossings = 0;
  let lastSign = null;
  
  for (let i = 0; i < numPoints; i++) {
    const t = tStart + (i / (numPoints - 1)) * (tEnd - tStart);
    const zt = parseFloat(zetaService.calculateZ(t));
    data.push({t, z: zt});
    maxVal = Math.max(maxVal, Math.abs(zt));
    
    if (lastSign !== null && Math.sign(zt) !== lastSign) crossings++;
    lastSign = Math.sign(zt);
  }
  
  // Plot curve
  ctx.strokeStyle = getComputedStyle(document.body).getPropertyValue('--acc3');
  ctx.lineWidth = 2;
  ctx.beginPath();
  for (let i = 0; i < data.length; i++) {
    const x = padding + ((data[i].t - tStart) / (tEnd - tStart)) * width;
    const y = centerY - (data[i].z / maxVal) * (height / 2);
    if (i === 0) ctx.moveTo(x, y);
    else ctx.lineTo(x, y);
  }
  ctx.stroke();
  
  // Mark zero crossings
  ctx.fillStyle = getComputedStyle(document.body).getPropertyValue('--acc2');
  for (let i = 1; i < data.length; i++) {
    if (Math.sign(data[i].z) !== Math.sign(data[i-1].z)) {
      const x = padding + ((data[i].t - tStart) / (tEnd - tStart)) * width;
      ctx.beginPath();
      ctx.arc(x, centerY, 4, 0, Math.PI * 2);
      ctx.fill();
    }
  }
  
  if (document.getElementById('zCrossingCount')) {
    document.getElementById('zCrossingCount').textContent = crossings;
    document.getElementById('zMaxVal').textContent = maxVal.toFixed(4);
  }
}

function findZerosUI() {
  const tStart = parseFloat(document.getElementById('zZeroStart')?.value || 0);
  const tEnd = parseFloat(document.getElementById('zZeroEnd')?.value || 100);
  const scanPoints = parseInt(document.getElementById('zScanPoints')?.value || 500);
  
  const zeros = zetaService.findZeros(tStart, tEnd, scanPoints);
  const tbody = document.getElementById('zZeroResults');
  
  if (!tbody) return;
  
  const knownZeros = [14.134725, 21.022040, 25.010858];
  
  tbody.innerHTML = zeros.map(z => {
    const closest = knownZeros.reduce((p, c) => Math.abs(c - z) < Math.abs(p - z) ? c : p);
    const isKnown = Math.abs(closest - z) < 0.1;
    const zVal = zetaService.calculateZ(z);
    
    return `<tr style="background:${isKnown ? 'rgba(76,175,80,.1)' : 'rgba(255,235,59,.1)'}">
      <td>${z.toFixed(8)}</td>
      <td>${(Math.abs(zVal) < 0.001 ? zVal.toFixed(1e-10) : zVal).toString().substring(0, 15)}</td>
      <td>${isKnown ? ' ' + closest.toFixed(6) : '—'}</td>
    </tr>`;
  }).join('');
  
  const status = document.getElementById('zZeroStatus');
  if (status) status.textContent = `Found ${zeros.length} zero crossings`;
}

console.log('Riemann Zeta Service loaded - Z-Function engine ready');

console.log('Enhanced Modular Rings standalone loaded successfully');

// Load saved name on page load
document.addEventListener('DOMContentLoaded', () => {
  console.log('DOM loaded, initializing...');
  // Set default theme to midnight
  setTheme('midnight');
  
  // Initialize Enhanced Modular tab (default tab)
  initEnhanced();
  
  const savedName = localStorage.getItem('mobius_chat_name');
  if (savedName) {
    const nameInput = document.getElementById('chatName');
    if (nameInput) nameInput.value = savedName;
  }
});
</script>
</body>
</html>
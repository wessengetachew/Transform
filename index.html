
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Modular Lifting Rings - Streamlined</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1a1f2e 0%, #2d3748 100%);
            color: #e2e8f0;
            min-height: 100vh;
        }

        .app-header {
            background: linear-gradient(135deg, #2d3748 0%, #1a202c 100%);
            padding: 20px 30px;
            border-bottom: 2px solid rgba(255, 215, 0, 0.3);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        }

        .header-content {
            max-width: 1800px;
            margin: 0 auto;
        }

        .header-content h1 {
            font-size: 1.8em;
            font-weight: 600;
            color: #FFD700;
            margin-bottom: 4px;
        }

        .header-content .subtitle {
            font-size: 0.9em;
            opacity: 0.8;
            color: #cbd5e0;
        }

        .app-container {
            max-width: 100%;
            margin: 0 auto;
            padding: 20px;
            display: grid;
            grid-template-columns: 320px minmax(600px, 1fr) 350px;
            gap: 15px;
            min-height: calc(100vh - 100px);
        }

        .panel {
            background: rgba(45, 55, 72, 0.95);
            border-radius: 12px;
            padding: 0;
            height: fit-content;
            max-height: calc(100vh - 140px);
            overflow-y: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
        }

        .panel-header {
            position: sticky;
            top: 0;
            background: linear-gradient(135deg, #4a5568 0%, #2d3748 100%);
            padding: 15px 20px;
            border-bottom: 2px solid rgba(255, 215, 0, 0.2);
            z-index: 10;
        }

        .panel-header h2 {
            font-size: 1.2em;
            font-weight: 600;
            color: #FFD700;
            margin: 0;
        }

        .panel-content {
            padding: 15px;
        }

        .section-card {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 15px;
            border: 1px solid rgba(255, 255, 255, 0.08);
        }

        .section-card h3 {
            color: #cbd5e0;
            margin-bottom: 12px;
            font-size: 0.95em;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .checkbox-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
            max-height: 300px;
            overflow-y: auto;
        }

        .checkbox-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 6px 8px;
            border-radius: 6px;
            transition: background 0.2s;
            font-size: 0.9em;
        }

        .checkbox-item:hover {
            background: rgba(255, 255, 255, 0.08);
        }

        .checkbox-item input[type="checkbox"] {
            transform: scale(1.2);
            accent-color: #FFD700;
        }

        .slider-group {
            margin-bottom: 15px;
        }

        .slider-group label {
            display: block;
            margin-bottom: 8px;
            font-size: 0.9em;
            color: #cbd5e0;
        }

        .slider-group input[type="range"] {
            width: 100%;
            accent-color: #FFD700;
        }

        .slider-group select {
            width: 100%;
            padding: 8px;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 6px;
            color: #e2e8f0;
            font-size: 0.9em;
        }

        .btn {
            padding: 10px 20px;
            background: linear-gradient(135deg, #FFD700 0%, #FFA500 100%);
            border: none;
            border-radius: 6px;
            color: #1a202c;
            font-weight: 600;
            cursor: pointer;
            font-size: 0.9em;
            transition: all 0.2s;
            width: 100%;
            margin-top: 10px;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(255, 215, 0, 0.3);
        }

        .visualization-panel {
            background: rgba(0, 0, 0, 0.4);
            border-radius: 12px;
            padding: 20px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
        }

        .canvas-wrapper {
            position: relative;
            background: #000000;
            border-radius: 8px;
            border: 1px solid rgba(255, 215, 0, 0.2);
            overflow: hidden;
        }

        #canvas {
            display: block;
            width: 100%;
            background: #000000;
            cursor: crosshair;
        }

        .info-box {
            background: rgba(45, 55, 72, 0.9);
            border-radius: 8px;
            padding: 15px;
            margin-top: 15px;
            border: 1px solid rgba(255, 215, 0, 0.2);
            font-size: 0.85em;
            line-height: 1.6;
        }

        .info-box strong {
            color: #FFD700;
        }

        .math-notation {
            font-style: italic;
            color: #4ECDC4;
        }

        @media (max-width: 1400px) {
            .app-container {
                grid-template-columns: 280px 1fr 300px;
            }
        }
    </style>
</head>
<body>
    <div class="app-header">
        <div class="header-content">
            <h1>Interactive Modular Lifting Rings</h1>
            <div class="subtitle">Nested Modular Rings with Gap Analysis & Dirichlet Characters</div>
        </div>
    </div>

    <div class="app-container">
        <!-- Left Panel: Controls -->
        <div class="panel">
            <div class="panel-header">
                <h2>Controls</h2>
            </div>
            <div class="panel-content">
                <!-- Modular Rings -->
                <div class="section-card">
                    <h3>Modular Ring System</h3>
                    <div class="checkbox-group" id="ringControls"></div>
                </div>

                <!-- Gap Analysis -->
                <div class="section-card">
                    <h3>Gap Analysis</h3>
                    <div class="checkbox-group" id="gapControls"></div>
                </div>

                <!-- Dirichlet Characters -->
                <div class="section-card">
                    <h3>Dirichlet Characters</h3>
                    <div class="checkbox-item">
                        <input type="checkbox" id="showDirichlet" onchange="draw()">
                        <label for="showDirichlet">Show Character Support (χ(r) ≠ 0)</label>
                    </div>
                </div>

                <!-- Smith Chart Transform -->
                <div class="section-card">
                    <h3>Smith Chart Transform</h3>
                    <div class="checkbox-item">
                        <input type="checkbox" id="enableSmith" onchange="draw()">
                        <label for="enableSmith">Enable Cayley/Smith Transform</label>
                    </div>
                    <div id="smithControls" style="display: none; margin-top: 10px;">
                        <div class="slider-group">
                            <label>Phase Shift α: <span id="alphaValue">90</span>°</label>
                            <input type="range" id="smithAlpha" min="0" max="360" value="90" oninput="updateSmith()">
                        </div>
                        <div class="slider-group">
                            <label>Radius Mode:</label>
                            <select id="smithMode" onchange="draw()">
                                <option value="modulus">By Modulus M</option>
                                <option value="phi">By φ(M)</option>
                                <option value="uniform">Uniform</option>
                            </select>
                        </div>
                    </div>
                </div>

                <!-- Visualization -->
                <div class="section-card">
                    <h3>Visualization</h3>
                    <div class="slider-group">
                        <label>Zoom: <span id="zoomValue">1.0</span>x</label>
                        <input type="range" id="zoom" min="0.5" max="3" step="0.1" value="1.0" oninput="updateZoom()">
                    </div>
                    <div class="slider-group">
                        <label>Rotation: <span id="rotValue">0</span>°</label>
                        <input type="range" id="rotation" min="0" max="360" value="0" oninput="updateRotation()">
                    </div>
                    <div class="checkbox-item">
                        <input type="checkbox" id="showLabels" onchange="draw()">
                        <label for="showLabels">Show Residue Labels</label>
                    </div>
                </div>

                <!-- Export -->
                <div class="section-card">
                    <h3>Export</h3>
                    <button class="btn" onclick="exportVisualization()">Export PNG with Legend</button>
                </div>
            </div>
        </div>

        <!-- Center Panel: Canvas -->
        <div class="visualization-panel">
            <div class="canvas-wrapper">
                <canvas id="canvas" width="800" height="800"></canvas>
            </div>
        </div>

        <!-- Right Panel: Info -->
        <div class="panel">
            <div class="panel-header">
                <h2>System Info</h2>
            </div>
            <div class="panel-content">
                <div id="systemInfo" class="info-box"></div>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        // State
        let zoom = 1.0;
        let rotation = 0;
        let selectedRings = new Set(['unit']);
        let selectedGaps = new Set();
        
        // Modular configurations
        const configs = {
            unit: { mod: 1, label: '1' }
        };

        // Initialize with M1-M60
        for (let m = 2; m <= 60; m++) {
            configs[`m${m}`] = { mod: m, label: m.toString() };
        }

        // Helper: GCD
        function gcd(a, b) {
            while (b !== 0) {
                let t = b;
                b = a % b;
                a = t;
            }
            return a;
        }

        // Helper: Get coprimes to n
        function getCoprimes(n) {
            if (n === 1) return [0];
            const coprimes = [];
            for (let i = 1; i < n; i++) {
                if (gcd(i, n) === 1) {
                    coprimes.push(i);
                }
            }
            return coprimes;
        }

        // Initialize controls
        function initControls() {
            const ringControls = document.getElementById('ringControls');
            const gapControls = document.getElementById('gapControls');

            // Add ring checkboxes
            Object.keys(configs).forEach((key, idx) => {
                const div = document.createElement('div');
                div.className = 'checkbox-item';
                const checked = key === 'unit';
                const label = key === 'unit' ? 'Unit Circle (M=1)' : `M${configs[key].mod}`;
                div.innerHTML = `
                    <input type="checkbox" id="ring_${key}" value="${key}" ${checked ? 'checked' : ''} onchange="toggleRing('${key}')">
                    <label for="ring_${key}">${label}</label>
                `;
                ringControls.appendChild(div);
            });

            // Add gap checkboxes (2, 4, 6, 8, 10, 12)
            for (let gap = 2; gap <= 12; gap += 2) {
                const div = document.createElement('div');
                div.className = 'checkbox-item';
                div.innerHTML = `
                    <input type="checkbox" id="gap_${gap}" value="${gap}" onchange="toggleGap(${gap})">
                    <label for="gap_${gap}">Gap ${gap}</label>
                `;
                gapControls.appendChild(div);
            }

            // Smith chart toggle handler
            document.getElementById('enableSmith').addEventListener('change', function() {
                document.getElementById('smithControls').style.display = this.checked ? 'block' : 'none';
                draw();
            });
        }

        function toggleRing(key) {
            if (selectedRings.has(key)) {
                selectedRings.delete(key);
            } else {
                selectedRings.add(key);
            }
            draw();
        }

        function toggleGap(gap) {
            if (selectedGaps.has(gap)) {
                selectedGaps.delete(gap);
            } else {
                selectedGaps.add(gap);
            }
            draw();
        }

        function updateZoom() {
            zoom = parseFloat(document.getElementById('zoom').value);
            document.getElementById('zoomValue').textContent = zoom.toFixed(1);
            draw();
        }

        function updateRotation() {
            rotation = parseFloat(document.getElementById('rotation').value);
            document.getElementById('rotValue').textContent = rotation;
            draw();
        }

        function updateSmith() {
            const alpha = parseFloat(document.getElementById('smithAlpha').value);
            document.getElementById('alphaValue').textContent = alpha;
            draw();
        }

        // Smith Chart Transform (Cayley map)
        function applySmithTransform(x, y, r, alpha) {
            // Cayley transform: w = (z - i*alpha) / (z + i*alpha)
            // For visualization, we use: w = r * e^(iθ) where mapping depends on alpha
            const theta = Math.atan2(y, x);
            const alphaRad = (alpha * Math.PI) / 180;
            
            // Apply phase shift
            const shiftedTheta = theta + alphaRad;
            
            // Map radius based on mode
            let newR = r;
            const mode = document.getElementById('smithMode').value;
            if (mode === 'modulus') {
                newR = r; // Keep as is
            } else if (mode === 'phi') {
                newR = r * 0.8; // Slight scaling
            } else {
                newR = 200; // Uniform radius
            }
            
            return {
                x: newR * Math.cos(shiftedTheta),
                y: newR * Math.sin(shiftedTheta)
            };
        }

        // Main draw function
        function draw() {
            const w = canvas.width;
            const h = canvas.height;
            const cx = w / 2;
            const cy = h / 2;

            ctx.fillStyle = '#000000';
            ctx.fillRect(0, 0, w, h);

            const showDirichlet = document.getElementById('showDirichlet').checked;
            const showLabels = document.getElementById('showLabels').checked;
            const smithEnabled = document.getElementById('enableSmith').checked;
            const smithAlpha = parseFloat(document.getElementById('smithAlpha').value);

            // Get active rings
            const rings = Array.from(selectedRings).map(key => {
                const config = configs[key];
                return {
                    key: key,
                    mod: config.mod,
                    coprimes: getCoprimes(config.mod)
                };
            }).sort((a, b) => a.mod - b.mod);

            // Draw each ring
            rings.forEach((ring, ringIdx) => {
                const baseRadius = 50 + ringIdx * 40;
                const radius = baseRadius * zoom;
                const numPoints = ring.coprimes.length;

                ring.coprimes.forEach((r, idx) => {
                    const angle = ((2 * Math.PI * idx) / numPoints) + (rotation * Math.PI / 180);
                    let x = radius * Math.cos(angle);
                    let y = radius * Math.sin(angle);

                    // Apply Smith transform if enabled
                    if (smithEnabled) {
                        const transformed = applySmithTransform(x, y, radius, smithAlpha);
                        x = transformed.x;
                        y = transformed.y;
                    }

                    const screenX = cx + x;
                    const screenY = cy + y;

                    // Determine color
                    let color = '#4ECDC4'; // Default cyan
                    
                    // Gap coloring
                    if (selectedGaps.size > 0) {
                        const isInGap = Array.from(selectedGaps).some(gap => {
                            return ring.coprimes.some((r2, idx2) => {
                                if (idx2 === idx) return false;
                                const diff = Math.abs(r2 - r);
                                return diff === gap || diff === ring.mod - gap;
                            });
                        });
                        if (isInGap) {
                            color = '#FFD700'; // Gold for gap points
                        }
                    }

                    // Dirichlet character support (dimmed if gcd(r,M) != 1, but we already have coprimes)
                    if (showDirichlet) {
                        // All points in coprimes are already coprime, so they're all supported
                        // We'll brighten them
                        color = color === '#FFD700' ? '#FFD700' : '#00FF7F'; // Spring green
                    }

                    // Draw point
                    ctx.fillStyle = color;
                    ctx.beginPath();
                    ctx.arc(screenX, screenY, 4, 0, 2 * Math.PI);
                    ctx.fill();

                    // Draw label
                    if (showLabels) {
                        ctx.fillStyle = '#FFFFFF';
                        ctx.font = '10px monospace';
                        ctx.fillText(r.toString(), screenX + 6, screenY - 6);
                    }
                });

                // Draw ring circle
                ctx.strokeStyle = 'rgba(255, 215, 0, 0.2)';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.arc(cx, cy, radius, 0, 2 * Math.PI);
                ctx.stroke();
            });

            updateSystemInfo();
        }

        // Update info panel
        function updateSystemInfo() {
            const info = document.getElementById('systemInfo');
            const rings = Array.from(selectedRings).map(key => configs[key]);
            const gaps = Array.from(selectedGaps);

            let html = '<strong>Active Configuration:</strong><br><br>';
            
            html += `<strong>Rings:</strong> ${rings.length}<br>`;
            rings.forEach(r => {
                const phi = getCoprimes(r.mod).length;
                html += `M=${r.mod}: φ(${r.mod})=${phi}<br>`;
            });

            if (gaps.length > 0) {
                html += `<br><strong>Gaps:</strong> [${gaps.join(', ')}]<br>`;
            }

            const totalResidues = rings.reduce((sum, r) => sum + getCoprimes(r.mod).length, 0);
            html += `<br><strong>Total Residues:</strong> ${totalResidues}`;

            if (document.getElementById('showDirichlet').checked) {
                html += '<br><br><em class="math-notation">Dirichlet character support active</em>';
            }

            if (document.getElementById('enableSmith').checked) {
                html += '<br><br><em class="math-notation">Smith/Cayley transform active</em>';
            }

            info.innerHTML = html;
        }

        // Export function
        function exportVisualization() {
            const exportCanvas = document.createElement('canvas');
            const exportCtx = exportCanvas.getContext('2d');
            const legendWidth = 300;
            exportCanvas.width = canvas.width + legendWidth;
            exportCanvas.height = canvas.height;

            // Draw main canvas
            exportCtx.fillStyle = '#000000';
            exportCtx.fillRect(0, 0, exportCanvas.width, exportCanvas.height);
            exportCtx.drawImage(canvas, 0, 0);

            // Draw legend
            exportCtx.fillStyle = 'rgba(45, 55, 72, 0.95)';
            exportCtx.fillRect(canvas.width, 0, legendWidth, exportCanvas.height);

            let y = 30;
            exportCtx.fillStyle = '#FFD700';
            exportCtx.font = 'bold 16px Arial';
            exportCtx.fillText('Configuration', canvas.width + 20, y);
            
            y += 30;
            exportCtx.font = '12px Arial';
            exportCtx.fillStyle = '#FFFFFF';

            const rings = Array.from(selectedRings).map(key => configs[key]);
            rings.forEach(r => {
                const phi = getCoprimes(r.mod).length;
                exportCtx.fillText(`M=${r.mod}, φ=${phi}`, canvas.width + 20, y);
                y += 20;
            });

            const gaps = Array.from(selectedGaps);
            if (gaps.length > 0) {
                y += 10;
                exportCtx.fillStyle = '#FFD700';
                exportCtx.fillText('Gaps:', canvas.width + 20, y);
                y += 20;
                exportCtx.fillStyle = '#FFFFFF';
                exportCtx.fillText(`[${gaps.join(', ')}]`, canvas.width + 20, y);
            }

            // Watermark
            y = exportCanvas.height - 20;
            exportCtx.fillStyle = 'rgba(255, 255, 255, 0.5)';
            exportCtx.font = '10px Arial';
            exportCtx.fillText('Interactive Modular Rings', canvas.width + 20, y);

            // Download
            const link = document.createElement('a');
            link.download = 'modular_rings_visualization.png';
            link.href = exportCanvas.toDataURL();
            link.click();
        }

        // Initialize and draw
        initControls();
        draw();

        // Resize handler
        window.addEventListener('resize', () => {
            clearTimeout(window.resizeTimeout);
            window.resizeTimeout = setTimeout(() => {
                draw();
            }, 250);
        });
    </script>
</body>
</html>
